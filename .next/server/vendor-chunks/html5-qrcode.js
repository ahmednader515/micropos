/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/html5-qrcode";
exports.ids = ["vendor-chunks/html5-qrcode"];
exports.modules = {

/***/ "(ssr)/./node_modules/html5-qrcode/esm/camera/core-impl.js":
/*!***********************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/camera/core-impl.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraImpl: () => (/* binding */ CameraImpl)\n/* harmony export */ });\nvar __extends = undefined && undefined.__extends || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar AbstractCameraCapability = function() {\n    function AbstractCameraCapability(name, track) {\n        this.name = name;\n        this.track = track;\n    }\n    AbstractCameraCapability.prototype.isSupported = function() {\n        if (!this.track.getCapabilities) {\n            return false;\n        }\n        return this.name in this.track.getCapabilities();\n    };\n    AbstractCameraCapability.prototype.apply = function(value) {\n        var constraint = {};\n        constraint[this.name] = value;\n        var constraints = {\n            advanced: [\n                constraint\n            ]\n        };\n        return this.track.applyConstraints(constraints);\n    };\n    AbstractCameraCapability.prototype.value = function() {\n        var settings = this.track.getSettings();\n        if (this.name in settings) {\n            var settingValue = settings[this.name];\n            return settingValue;\n        }\n        return null;\n    };\n    return AbstractCameraCapability;\n}();\nvar AbstractRangeCameraCapability = function(_super) {\n    __extends(AbstractRangeCameraCapability, _super);\n    function AbstractRangeCameraCapability(name, track) {\n        return _super.call(this, name, track) || this;\n    }\n    AbstractRangeCameraCapability.prototype.min = function() {\n        return this.getCapabilities().min;\n    };\n    AbstractRangeCameraCapability.prototype.max = function() {\n        return this.getCapabilities().max;\n    };\n    AbstractRangeCameraCapability.prototype.step = function() {\n        return this.getCapabilities().step;\n    };\n    AbstractRangeCameraCapability.prototype.apply = function(value) {\n        var constraint = {};\n        constraint[this.name] = value;\n        var constraints = {\n            advanced: [\n                constraint\n            ]\n        };\n        return this.track.applyConstraints(constraints);\n    };\n    AbstractRangeCameraCapability.prototype.getCapabilities = function() {\n        this.failIfNotSupported();\n        var capabilities = this.track.getCapabilities();\n        var capability = capabilities[this.name];\n        return {\n            min: capability.min,\n            max: capability.max,\n            step: capability.step\n        };\n    };\n    AbstractRangeCameraCapability.prototype.failIfNotSupported = function() {\n        if (!this.isSupported()) {\n            throw new Error(\"\".concat(this.name, \" capability not supported\"));\n        }\n    };\n    return AbstractRangeCameraCapability;\n}(AbstractCameraCapability);\nvar ZoomFeatureImpl = function(_super) {\n    __extends(ZoomFeatureImpl, _super);\n    function ZoomFeatureImpl(track) {\n        return _super.call(this, \"zoom\", track) || this;\n    }\n    return ZoomFeatureImpl;\n}(AbstractRangeCameraCapability);\nvar TorchFeatureImpl = function(_super) {\n    __extends(TorchFeatureImpl, _super);\n    function TorchFeatureImpl(track) {\n        return _super.call(this, \"torch\", track) || this;\n    }\n    return TorchFeatureImpl;\n}(AbstractCameraCapability);\nvar CameraCapabilitiesImpl = function() {\n    function CameraCapabilitiesImpl(track) {\n        this.track = track;\n    }\n    CameraCapabilitiesImpl.prototype.zoomFeature = function() {\n        return new ZoomFeatureImpl(this.track);\n    };\n    CameraCapabilitiesImpl.prototype.torchFeature = function() {\n        return new TorchFeatureImpl(this.track);\n    };\n    return CameraCapabilitiesImpl;\n}();\nvar RenderedCameraImpl = function() {\n    function RenderedCameraImpl(parentElement, mediaStream, callbacks) {\n        this.isClosed = false;\n        this.parentElement = parentElement;\n        this.mediaStream = mediaStream;\n        this.callbacks = callbacks;\n        this.surface = this.createVideoElement(this.parentElement.clientWidth);\n        parentElement.append(this.surface);\n    }\n    RenderedCameraImpl.prototype.createVideoElement = function(width) {\n        var videoElement = document.createElement(\"video\");\n        videoElement.style.width = \"\".concat(width, \"px\");\n        videoElement.style.display = \"block\";\n        videoElement.muted = true;\n        videoElement.setAttribute(\"muted\", \"true\");\n        videoElement.playsInline = true;\n        return videoElement;\n    };\n    RenderedCameraImpl.prototype.setupSurface = function() {\n        var _this = this;\n        this.surface.onabort = function() {\n            throw \"RenderedCameraImpl video surface onabort() called\";\n        };\n        this.surface.onerror = function() {\n            throw \"RenderedCameraImpl video surface onerror() called\";\n        };\n        var onVideoStart = function() {\n            var videoWidth = _this.surface.clientWidth;\n            var videoHeight = _this.surface.clientHeight;\n            _this.callbacks.onRenderSurfaceReady(videoWidth, videoHeight);\n            _this.surface.removeEventListener(\"playing\", onVideoStart);\n        };\n        this.surface.addEventListener(\"playing\", onVideoStart);\n        this.surface.srcObject = this.mediaStream;\n        this.surface.play();\n    };\n    RenderedCameraImpl.create = function(parentElement, mediaStream, options, callbacks) {\n        return __awaiter(this, void 0, void 0, function() {\n            var renderedCamera, aspectRatioConstraint;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        renderedCamera = new RenderedCameraImpl(parentElement, mediaStream, callbacks);\n                        if (!options.aspectRatio) return [\n                            3,\n                            2\n                        ];\n                        aspectRatioConstraint = {\n                            aspectRatio: options.aspectRatio\n                        };\n                        return [\n                            4,\n                            renderedCamera.getFirstTrackOrFail().applyConstraints(aspectRatioConstraint)\n                        ];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        renderedCamera.setupSurface();\n                        return [\n                            2,\n                            renderedCamera\n                        ];\n                }\n            });\n        });\n    };\n    RenderedCameraImpl.prototype.failIfClosed = function() {\n        if (this.isClosed) {\n            throw \"The RenderedCamera has already been closed.\";\n        }\n    };\n    RenderedCameraImpl.prototype.getFirstTrackOrFail = function() {\n        this.failIfClosed();\n        if (this.mediaStream.getVideoTracks().length === 0) {\n            throw \"No video tracks found\";\n        }\n        return this.mediaStream.getVideoTracks()[0];\n    };\n    RenderedCameraImpl.prototype.pause = function() {\n        this.failIfClosed();\n        this.surface.pause();\n    };\n    RenderedCameraImpl.prototype.resume = function(onResumeCallback) {\n        this.failIfClosed();\n        var $this = this;\n        var onVideoResume = function() {\n            setTimeout(onResumeCallback, 200);\n            $this.surface.removeEventListener(\"playing\", onVideoResume);\n        };\n        this.surface.addEventListener(\"playing\", onVideoResume);\n        this.surface.play();\n    };\n    RenderedCameraImpl.prototype.isPaused = function() {\n        this.failIfClosed();\n        return this.surface.paused;\n    };\n    RenderedCameraImpl.prototype.getSurface = function() {\n        this.failIfClosed();\n        return this.surface;\n    };\n    RenderedCameraImpl.prototype.getRunningTrackCapabilities = function() {\n        return this.getFirstTrackOrFail().getCapabilities();\n    };\n    RenderedCameraImpl.prototype.getRunningTrackSettings = function() {\n        return this.getFirstTrackOrFail().getSettings();\n    };\n    RenderedCameraImpl.prototype.applyVideoConstraints = function(constraints) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                if (\"aspectRatio\" in constraints) {\n                    throw \"Changing 'aspectRatio' in run-time is not yet supported.\";\n                }\n                return [\n                    2,\n                    this.getFirstTrackOrFail().applyConstraints(constraints)\n                ];\n            });\n        });\n    };\n    RenderedCameraImpl.prototype.close = function() {\n        if (this.isClosed) {\n            return Promise.resolve();\n        }\n        var $this = this;\n        return new Promise(function(resolve, _) {\n            var tracks = $this.mediaStream.getVideoTracks();\n            var tracksToClose = tracks.length;\n            var tracksClosed = 0;\n            $this.mediaStream.getVideoTracks().forEach(function(videoTrack) {\n                $this.mediaStream.removeTrack(videoTrack);\n                videoTrack.stop();\n                ++tracksClosed;\n                if (tracksClosed >= tracksToClose) {\n                    $this.isClosed = true;\n                    $this.parentElement.removeChild($this.surface);\n                    resolve();\n                }\n            });\n        });\n    };\n    RenderedCameraImpl.prototype.getCapabilities = function() {\n        return new CameraCapabilitiesImpl(this.getFirstTrackOrFail());\n    };\n    return RenderedCameraImpl;\n}();\nvar CameraImpl = function() {\n    function CameraImpl(mediaStream) {\n        this.mediaStream = mediaStream;\n    }\n    CameraImpl.prototype.render = function(parentElement, options, callbacks) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                return [\n                    2,\n                    RenderedCameraImpl.create(parentElement, this.mediaStream, options, callbacks)\n                ];\n            });\n        });\n    };\n    CameraImpl.create = function(videoConstraints) {\n        return __awaiter(this, void 0, void 0, function() {\n            var constraints, mediaStream;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        if (!navigator.mediaDevices) {\n                            throw \"navigator.mediaDevices not supported\";\n                        }\n                        constraints = {\n                            audio: false,\n                            video: videoConstraints\n                        };\n                        return [\n                            4,\n                            navigator.mediaDevices.getUserMedia(constraints)\n                        ];\n                    case 1:\n                        mediaStream = _a.sent();\n                        return [\n                            2,\n                            new CameraImpl(mediaStream)\n                        ];\n                }\n            });\n        });\n    };\n    return CameraImpl;\n}();\n //# sourceMappingURL=core-impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jYW1lcmEvY29yZS1pbXBsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSztJQUN4QyxJQUFJQyxnQkFBZ0IsU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO1FBQzlCRixnQkFBZ0JHLE9BQU9DLGNBQWMsSUFDaEM7WUFBRUMsV0FBVyxFQUFFO1FBQUMsY0FBYUMsU0FBUyxTQUFVTCxDQUFDLEVBQUVDLENBQUM7WUFBSUQsRUFBRUksU0FBUyxHQUFHSDtRQUFHLEtBQzFFLFNBQVVELENBQUMsRUFBRUMsQ0FBQztZQUFJLElBQUssSUFBSUssS0FBS0wsRUFBRyxJQUFJQyxPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUFJTixDQUFDLENBQUNNLEVBQUUsR0FBR0wsQ0FBQyxDQUFDSyxFQUFFO1FBQUU7UUFDcEcsT0FBT1AsY0FBY0MsR0FBR0M7SUFDNUI7SUFDQSxPQUFPLFNBQVVELENBQUMsRUFBRUMsQ0FBQztRQUNqQixJQUFJLE9BQU9BLE1BQU0sY0FBY0EsTUFBTSxNQUNqQyxNQUFNLElBQUlTLFVBQVUseUJBQXlCQyxPQUFPVixLQUFLO1FBQzdERixjQUFjQyxHQUFHQztRQUNqQixTQUFTVztZQUFPLElBQUksQ0FBQ0MsV0FBVyxHQUFHYjtRQUFHO1FBQ3RDQSxFQUFFTyxTQUFTLEdBQUdOLE1BQU0sT0FBT0MsT0FBT1ksTUFBTSxDQUFDYixLQUFNVyxDQUFBQSxHQUFHTCxTQUFTLEdBQUdOLEVBQUVNLFNBQVMsRUFBRSxJQUFJSyxJQUFHO0lBQ3RGO0FBQ0o7QUFDQSxJQUFJRyxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFB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RTVCLFNBQVM7UUFDckUsT0FBT3BFLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBT21CLFlBQVksSUFBSSxFQUFFLFNBQVVnRixFQUFFO2dCQUNqQyxPQUFPO29CQUFDO29CQUFHbEMsbUJBQW1CbEUsTUFBTSxDQUFDbUUsZUFBZSxJQUFJLENBQUNDLFdBQVcsRUFBRTZCLFNBQVM1QjtpQkFBVztZQUM5RjtRQUNKO0lBQ0o7SUFDQXlELFdBQVc5SCxNQUFNLEdBQUcsU0FBVWdJLGdCQUFnQjtRQUMxQyxPQUFPL0gsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJNkMsYUFBYXNCO1lBQ2pCLE9BQU9oRCxZQUFZLElBQUksRUFBRSxTQUFVZ0YsRUFBRTtnQkFDakMsT0FBUUEsR0FBRzdFLEtBQUs7b0JBQ1osS0FBSzt3QkFDRCxJQUFJLENBQUMwRyxVQUFVQyxZQUFZLEVBQUU7NEJBQ3pCLE1BQU07d0JBQ1Y7d0JBQ0FwRixjQUFjOzRCQUNWcUYsT0FBTzs0QkFDUEMsT0FBT0o7d0JBQ1g7d0JBQ0EsT0FBTzs0QkFBQzs0QkFBR0MsVUFBVUMsWUFBWSxDQUFDRyxZQUFZLENBQUN2Rjt5QkFBYTtvQkFDaEUsS0FBSzt3QkFDRHNCLGNBQWNnQyxHQUFHNUUsSUFBSTt3QkFDckIsT0FBTzs0QkFBQzs0QkFBRyxJQUFJc0csV0FBVzFEO3lCQUFhO2dCQUMvQztZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU8wRDtBQUNYO0FBQ3NCLENBQ3RCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL21pY3JvcG9zLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY2FtZXJhL2NvcmUtaW1wbC5qcz9hMTVhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgQWJzdHJhY3RDYW1lcmFDYXBhYmlsaXR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdENhbWVyYUNhcGFiaWxpdHkobmFtZSwgdHJhY2spIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50cmFjayA9IHRyYWNrO1xuICAgIH1cbiAgICBBYnN0cmFjdENhbWVyYUNhcGFiaWxpdHkucHJvdG90eXBlLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMudHJhY2suZ2V0Q2FwYWJpbGl0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSBpbiB0aGlzLnRyYWNrLmdldENhcGFiaWxpdGllcygpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYW1lcmFDYXBhYmlsaXR5LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgY29uc3RyYWludCA9IHt9O1xuICAgICAgICBjb25zdHJhaW50W3RoaXMubmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0geyBhZHZhbmNlZDogW2NvbnN0cmFpbnRdIH07XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrLmFwcGx5Q29uc3RyYWludHMoY29uc3RyYWludHMpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYW1lcmFDYXBhYmlsaXR5LnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy50cmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICBpZiAodGhpcy5uYW1lIGluIHNldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgc2V0dGluZ1ZhbHVlID0gc2V0dGluZ3NbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5nVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RDYW1lcmFDYXBhYmlsaXR5O1xufSgpKTtcbnZhciBBYnN0cmFjdFJhbmdlQ2FtZXJhQ2FwYWJpbGl0eSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFic3RyYWN0UmFuZ2VDYW1lcmFDYXBhYmlsaXR5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0UmFuZ2VDYW1lcmFDYXBhYmlsaXR5KG5hbWUsIHRyYWNrKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCB0cmFjaykgfHwgdGhpcztcbiAgICB9XG4gICAgQWJzdHJhY3RSYW5nZUNhbWVyYUNhcGFiaWxpdHkucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FwYWJpbGl0aWVzKCkubWluO1xuICAgIH07XG4gICAgQWJzdHJhY3RSYW5nZUNhbWVyYUNhcGFiaWxpdHkucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FwYWJpbGl0aWVzKCkubWF4O1xuICAgIH07XG4gICAgQWJzdHJhY3RSYW5nZUNhbWVyYUNhcGFiaWxpdHkucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENhcGFiaWxpdGllcygpLnN0ZXA7XG4gICAgfTtcbiAgICBBYnN0cmFjdFJhbmdlQ2FtZXJhQ2FwYWJpbGl0eS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSB7fTtcbiAgICAgICAgY29uc3RyYWludFt0aGlzLm5hbWVdID0gdmFsdWU7XG4gICAgICAgIHZhciBjb25zdHJhaW50cyA9IHsgYWR2YW5jZWQ6IFtjb25zdHJhaW50XSB9O1xuICAgICAgICByZXR1cm4gdGhpcy50cmFjay5hcHBseUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKTtcbiAgICB9O1xuICAgIEFic3RyYWN0UmFuZ2VDYW1lcmFDYXBhYmlsaXR5LnByb3RvdHlwZS5nZXRDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmFpbElmTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIHZhciBjYXBhYmlsaXRpZXMgPSB0aGlzLnRyYWNrLmdldENhcGFiaWxpdGllcygpO1xuICAgICAgICB2YXIgY2FwYWJpbGl0eSA9IGNhcGFiaWxpdGllc1t0aGlzLm5hbWVdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluOiBjYXBhYmlsaXR5Lm1pbixcbiAgICAgICAgICAgIG1heDogY2FwYWJpbGl0eS5tYXgsXG4gICAgICAgICAgICBzdGVwOiBjYXBhYmlsaXR5LnN0ZXAsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBYnN0cmFjdFJhbmdlQ2FtZXJhQ2FwYWJpbGl0eS5wcm90b3R5cGUuZmFpbElmTm90U3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCIgY2FwYWJpbGl0eSBub3Qgc3VwcG9ydGVkXCIpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0UmFuZ2VDYW1lcmFDYXBhYmlsaXR5O1xufShBYnN0cmFjdENhbWVyYUNhcGFiaWxpdHkpKTtcbnZhciBab29tRmVhdHVyZUltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab29tRmVhdHVyZUltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9vbUZlYXR1cmVJbXBsKHRyYWNrKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcInpvb21cIiwgdHJhY2spIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBab29tRmVhdHVyZUltcGw7XG59KEFic3RyYWN0UmFuZ2VDYW1lcmFDYXBhYmlsaXR5KSk7XG52YXIgVG9yY2hGZWF0dXJlSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRvcmNoRmVhdHVyZUltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVG9yY2hGZWF0dXJlSW1wbCh0cmFjaykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJ0b3JjaFwiLCB0cmFjaykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRvcmNoRmVhdHVyZUltcGw7XG59KEFic3RyYWN0Q2FtZXJhQ2FwYWJpbGl0eSkpO1xudmFyIENhbWVyYUNhcGFiaWxpdGllc0ltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbWVyYUNhcGFiaWxpdGllc0ltcGwodHJhY2spIHtcbiAgICAgICAgdGhpcy50cmFjayA9IHRyYWNrO1xuICAgIH1cbiAgICBDYW1lcmFDYXBhYmlsaXRpZXNJbXBsLnByb3RvdHlwZS56b29tRmVhdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab29tRmVhdHVyZUltcGwodGhpcy50cmFjayk7XG4gICAgfTtcbiAgICBDYW1lcmFDYXBhYmlsaXRpZXNJbXBsLnByb3RvdHlwZS50b3JjaEZlYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9yY2hGZWF0dXJlSW1wbCh0aGlzLnRyYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBDYW1lcmFDYXBhYmlsaXRpZXNJbXBsO1xufSgpKTtcbnZhciBSZW5kZXJlZENhbWVyYUltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVkQ2FtZXJhSW1wbChwYXJlbnRFbGVtZW50LCBtZWRpYVN0cmVhbSwgY2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5tZWRpYVN0cmVhbSA9IG1lZGlhU3RyZWFtO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICAgICAgdGhpcy5zdXJmYWNlID0gdGhpcy5jcmVhdGVWaWRlb0VsZW1lbnQodGhpcy5wYXJlbnRFbGVtZW50LmNsaWVudFdpZHRoKTtcbiAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmQodGhpcy5zdXJmYWNlKTtcbiAgICB9XG4gICAgUmVuZGVyZWRDYW1lcmFJbXBsLnByb3RvdHlwZS5jcmVhdGVWaWRlb0VsZW1lbnQgPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgICAgdmFyIHZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcbiAgICAgICAgdmlkZW9FbGVtZW50LnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIik7XG4gICAgICAgIHZpZGVvRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB2aWRlb0VsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKFwibXV0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICB2aWRlb0VsZW1lbnQucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmlkZW9FbGVtZW50O1xuICAgIH07XG4gICAgUmVuZGVyZWRDYW1lcmFJbXBsLnByb3RvdHlwZS5zZXR1cFN1cmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3VyZmFjZS5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgXCJSZW5kZXJlZENhbWVyYUltcGwgdmlkZW8gc3VyZmFjZSBvbmFib3J0KCkgY2FsbGVkXCI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3VyZmFjZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgXCJSZW5kZXJlZENhbWVyYUltcGwgdmlkZW8gc3VyZmFjZSBvbmVycm9yKCkgY2FsbGVkXCI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvblZpZGVvU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmlkZW9XaWR0aCA9IF90aGlzLnN1cmZhY2UuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICB2YXIgdmlkZW9IZWlnaHQgPSBfdGhpcy5zdXJmYWNlLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIF90aGlzLmNhbGxiYWNrcy5vblJlbmRlclN1cmZhY2VSZWFkeSh2aWRlb1dpZHRoLCB2aWRlb0hlaWdodCk7XG4gICAgICAgICAgICBfdGhpcy5zdXJmYWNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwbGF5aW5nXCIsIG9uVmlkZW9TdGFydCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3VyZmFjZS5hZGRFdmVudExpc3RlbmVyKFwicGxheWluZ1wiLCBvblZpZGVvU3RhcnQpO1xuICAgICAgICB0aGlzLnN1cmZhY2Uuc3JjT2JqZWN0ID0gdGhpcy5tZWRpYVN0cmVhbTtcbiAgICAgICAgdGhpcy5zdXJmYWNlLnBsYXkoKTtcbiAgICB9O1xuICAgIFJlbmRlcmVkQ2FtZXJhSW1wbC5jcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgbWVkaWFTdHJlYW0sIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRDYW1lcmEsIGFzcGVjdFJhdGlvQ29uc3RyYWludDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkQ2FtZXJhID0gbmV3IFJlbmRlcmVkQ2FtZXJhSW1wbChwYXJlbnRFbGVtZW50LCBtZWRpYVN0cmVhbSwgY2FsbGJhY2tzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5hc3BlY3RSYXRpbykgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvQ29uc3RyYWludCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbzogb3B0aW9ucy5hc3BlY3RSYXRpb1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgcmVuZGVyZWRDYW1lcmEuZ2V0Rmlyc3RUcmFja09yRmFpbCgpLmFwcGx5Q29uc3RyYWludHMoYXNwZWN0UmF0aW9Db25zdHJhaW50KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRDYW1lcmEuc2V0dXBTdXJmYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlbmRlcmVkQ2FtZXJhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmZhaWxJZkNsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IFwiVGhlIFJlbmRlcmVkQ2FtZXJhIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmdldEZpcnN0VHJhY2tPckZhaWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmFpbElmQ2xvc2VkKCk7XG4gICAgICAgIGlmICh0aGlzLm1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBcIk5vIHZpZGVvIHRyYWNrcyBmb3VuZFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZhaWxJZkNsb3NlZCgpO1xuICAgICAgICB0aGlzLnN1cmZhY2UucGF1c2UoKTtcbiAgICB9O1xuICAgIFJlbmRlcmVkQ2FtZXJhSW1wbC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKG9uUmVzdW1lQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5mYWlsSWZDbG9zZWQoKTtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9uVmlkZW9SZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KG9uUmVzdW1lQ2FsbGJhY2ssIDIwMCk7XG4gICAgICAgICAgICAkdGhpcy5zdXJmYWNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwbGF5aW5nXCIsIG9uVmlkZW9SZXN1bWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1cmZhY2UuYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlpbmdcIiwgb25WaWRlb1Jlc3VtZSk7XG4gICAgICAgIHRoaXMuc3VyZmFjZS5wbGF5KCk7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZhaWxJZkNsb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdXJmYWNlLnBhdXNlZDtcbiAgICB9O1xuICAgIFJlbmRlcmVkQ2FtZXJhSW1wbC5wcm90b3R5cGUuZ2V0U3VyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mYWlsSWZDbG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VyZmFjZTtcbiAgICB9O1xuICAgIFJlbmRlcmVkQ2FtZXJhSW1wbC5wcm90b3R5cGUuZ2V0UnVubmluZ1RyYWNrQ2FwYWJpbGl0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaXJzdFRyYWNrT3JGYWlsKCkuZ2V0Q2FwYWJpbGl0aWVzKCk7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmdldFJ1bm5pbmdUcmFja1NldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaXJzdFRyYWNrT3JGYWlsKCkuZ2V0U2V0dGluZ3MoKTtcbiAgICB9O1xuICAgIFJlbmRlcmVkQ2FtZXJhSW1wbC5wcm90b3R5cGUuYXBwbHlWaWRlb0NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJhc3BlY3RSYXRpb1wiIGluIGNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiQ2hhbmdpbmcgJ2FzcGVjdFJhdGlvJyBpbiBydW4tdGltZSBpcyBub3QgeWV0IHN1cHBvcnRlZC5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmdldEZpcnN0VHJhY2tPckZhaWwoKS5hcHBseUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgXykge1xuICAgICAgICAgICAgdmFyIHRyYWNrcyA9ICR0aGlzLm1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgICAgICB2YXIgdHJhY2tzVG9DbG9zZSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgdHJhY2tzQ2xvc2VkID0gMDtcbiAgICAgICAgICAgICR0aGlzLm1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodmlkZW9UcmFjaykge1xuICAgICAgICAgICAgICAgICR0aGlzLm1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKHZpZGVvVHJhY2spO1xuICAgICAgICAgICAgICAgIHZpZGVvVHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgICsrdHJhY2tzQ2xvc2VkO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja3NDbG9zZWQgPj0gdHJhY2tzVG9DbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoJHRoaXMuc3VyZmFjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmdldENhcGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYW1lcmFDYXBhYmlsaXRpZXNJbXBsKHRoaXMuZ2V0Rmlyc3RUcmFja09yRmFpbCgpKTtcbiAgICB9O1xuICAgIHJldHVybiBSZW5kZXJlZENhbWVyYUltcGw7XG59KCkpO1xudmFyIENhbWVyYUltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbWVyYUltcGwobWVkaWFTdHJlYW0pIHtcbiAgICAgICAgdGhpcy5tZWRpYVN0cmVhbSA9IG1lZGlhU3RyZWFtO1xuICAgIH1cbiAgICBDYW1lcmFJbXBsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIFJlbmRlcmVkQ2FtZXJhSW1wbC5jcmVhdGUocGFyZW50RWxlbWVudCwgdGhpcy5tZWRpYVN0cmVhbSwgb3B0aW9ucywgY2FsbGJhY2tzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYW1lcmFJbXBsLmNyZWF0ZSA9IGZ1bmN0aW9uICh2aWRlb0NvbnN0cmFpbnRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50cywgbWVkaWFTdHJlYW07XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm5hdmlnYXRvci5tZWRpYURldmljZXMgbm90IHN1cHBvcnRlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvOiB2aWRlb0NvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYVN0cmVhbSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbmV3IENhbWVyYUltcGwobWVkaWFTdHJlYW0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FtZXJhSW1wbDtcbn0oKSk7XG5leHBvcnQgeyBDYW1lcmFJbXBsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLWltcGwuanMubWFwIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fZ2VuZXJhdG9yIiwiYm9keSIsIl8iLCJsYWJlbCIsInNlbnQiLCJ0IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm4iLCJ2Iiwib3AiLCJwb3AiLCJsZW5ndGgiLCJwdXNoIiwiQWJzdHJhY3RDYW1lcmFDYXBhYmlsaXR5IiwibmFtZSIsInRyYWNrIiwiaXNTdXBwb3J0ZWQiLCJnZXRDYXBhYmlsaXRpZXMiLCJjb25zdHJhaW50IiwiY29uc3RyYWludHMiLCJhZHZhbmNlZCIsImFwcGx5Q29uc3RyYWludHMiLCJzZXR0aW5ncyIsImdldFNldHRpbmdzIiwic2V0dGluZ1ZhbHVlIiwiQWJzdHJhY3RSYW5nZUNhbWVyYUNhcGFiaWxpdHkiLCJfc3VwZXIiLCJtaW4iLCJtYXgiLCJmYWlsSWZOb3RTdXBwb3J0ZWQiLCJjYXBhYmlsaXRpZXMiLCJjYXBhYmlsaXR5IiwiRXJyb3IiLCJjb25jYXQiLCJab29tRmVhdHVyZUltcGwiLCJUb3JjaEZlYXR1cmVJbXBsIiwiQ2FtZXJhQ2FwYWJpbGl0aWVzSW1wbCIsInpvb21GZWF0dXJlIiwidG9yY2hGZWF0dXJlIiwiUmVuZGVyZWRDYW1lcmFJbXBsIiwicGFyZW50RWxlbWVudCIsIm1lZGlhU3RyZWFtIiwiY2FsbGJhY2tzIiwiaXNDbG9zZWQiLCJzdXJmYWNlIiwiY3JlYXRlVmlkZW9FbGVtZW50IiwiY2xpZW50V2lkdGgiLCJhcHBlbmQiLCJ3aWR0aCIsInZpZGVvRWxlbWVudCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiZGlzcGxheSIsIm11dGVkIiwic2V0QXR0cmlidXRlIiwicGxheXNJbmxpbmUiLCJzZXR1cFN1cmZhY2UiLCJfdGhpcyIsIm9uYWJvcnQiLCJvbmVycm9yIiwib25WaWRlb1N0YXJ0IiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwib25SZW5kZXJTdXJmYWNlUmVhZHkiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNyY09iamVjdCIsInBsYXkiLCJvcHRpb25zIiwicmVuZGVyZWRDYW1lcmEiLCJhc3BlY3RSYXRpb0NvbnN0cmFpbnQiLCJfYSIsImFzcGVjdFJhdGlvIiwiZ2V0Rmlyc3RUcmFja09yRmFpbCIsImZhaWxJZkNsb3NlZCIsImdldFZpZGVvVHJhY2tzIiwicGF1c2UiLCJyZXN1bWUiLCJvblJlc3VtZUNhbGxiYWNrIiwiJHRoaXMiLCJvblZpZGVvUmVzdW1lIiwic2V0VGltZW91dCIsImlzUGF1c2VkIiwicGF1c2VkIiwiZ2V0U3VyZmFjZSIsImdldFJ1bm5pbmdUcmFja0NhcGFiaWxpdGllcyIsImdldFJ1bm5pbmdUcmFja1NldHRpbmdzIiwiYXBwbHlWaWRlb0NvbnN0cmFpbnRzIiwiY2xvc2UiLCJ0cmFja3MiLCJ0cmFja3NUb0Nsb3NlIiwidHJhY2tzQ2xvc2VkIiwiZm9yRWFjaCIsInZpZGVvVHJhY2siLCJyZW1vdmVUcmFjayIsInN0b3AiLCJyZW1vdmVDaGlsZCIsIkNhbWVyYUltcGwiLCJyZW5kZXIiLCJ2aWRlb0NvbnN0cmFpbnRzIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiYXVkaW8iLCJ2aWRlbyIsImdldFVzZXJNZWRpYSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/camera/core-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/camera/factories.js":
/*!***********************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/camera/factories.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraFactory: () => (/* binding */ CameraFactory)\n/* harmony export */ });\n/* harmony import */ var _core_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core-impl */ \"(ssr)/./node_modules/html5-qrcode/esm/camera/core-impl.js\");\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\n\nvar CameraFactory = function() {\n    function CameraFactory() {}\n    CameraFactory.failIfNotSupported = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                if (!navigator.mediaDevices) {\n                    throw \"navigator.mediaDevices not supported\";\n                }\n                return [\n                    2,\n                    new CameraFactory()\n                ];\n            });\n        });\n    };\n    CameraFactory.prototype.create = function(videoConstraints) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                return [\n                    2,\n                    _core_impl__WEBPACK_IMPORTED_MODULE_0__.CameraImpl.create(videoConstraints)\n                ];\n            });\n        });\n    };\n    return CameraFactory;\n}();\n //# sourceMappingURL=factories.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jYW1lcmEvZmFjdG9yaWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ0EsSUFBSU8sY0FBYyxTQUFLLElBQUksU0FBSSxDQUFDQSxXQUFXLElBQUssU0FBVWxCLE9BQU8sRUFBRW1CLElBQUk7SUFDbkUsSUFBSUMsSUFBSTtRQUFFQyxPQUFPO1FBQUdDLE1BQU07WUFBYSxJQUFJQyxDQUFD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R0gsa0RBQVVBLENBQUNPLE1BQU0sQ0FBQ0M7aUJBQWtCO1lBQ25EO1FBQ0o7SUFDSjtJQUNBLE9BQU9QO0FBQ1g7QUFDeUIsQ0FDekIscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9wb3MvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jYW1lcmEvZmFjdG9yaWVzLmpzP2Y3ZWUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuaW1wb3J0IHsgQ2FtZXJhSW1wbCB9IGZyb20gXCIuL2NvcmUtaW1wbFwiO1xudmFyIENhbWVyYUZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbWVyYUZhY3RvcnkoKSB7XG4gICAgfVxuICAgIENhbWVyYUZhY3RvcnkuZmFpbElmTm90U3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwibmF2aWdhdG9yLm1lZGlhRGV2aWNlcyBub3Qgc3VwcG9ydGVkXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbmV3IENhbWVyYUZhY3RvcnkoKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYW1lcmFGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAodmlkZW9Db25zdHJhaW50cykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBDYW1lcmFJbXBsLmNyZWF0ZSh2aWRlb0NvbnN0cmFpbnRzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FtZXJhRmFjdG9yeTtcbn0oKSk7XG5leHBvcnQgeyBDYW1lcmFGYWN0b3J5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mYWN0b3JpZXMuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fZ2VuZXJhdG9yIiwiYm9keSIsIl8iLCJsYWJlbCIsInNlbnQiLCJ0IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm4iLCJ2Iiwib3AiLCJUeXBlRXJyb3IiLCJjYWxsIiwicG9wIiwibGVuZ3RoIiwicHVzaCIsIkNhbWVyYUltcGwiLCJDYW1lcmFGYWN0b3J5IiwiZmFpbElmTm90U3VwcG9ydGVkIiwiX2EiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJwcm90b3R5cGUiLCJjcmVhdGUiLCJ2aWRlb0NvbnN0cmFpbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/camera/factories.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/camera/permissions.js":
/*!*************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/camera/permissions.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraPermissions: () => (/* binding */ CameraPermissions)\n/* harmony export */ });\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar CameraPermissions = function() {\n    function CameraPermissions() {}\n    CameraPermissions.hasPermissions = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var devices, _i, devices_1, device;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4,\n                            navigator.mediaDevices.enumerateDevices()\n                        ];\n                    case 1:\n                        devices = _a.sent();\n                        for(_i = 0, devices_1 = devices; _i < devices_1.length; _i++){\n                            device = devices_1[_i];\n                            if (device.kind === \"videoinput\" && device.label) {\n                                return [\n                                    2,\n                                    true\n                                ];\n                            }\n                        }\n                        return [\n                            2,\n                            false\n                        ];\n                }\n            });\n        });\n    };\n    return CameraPermissions;\n}();\n //# sourceMappingURL=permissions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jYW1lcmEvcGVybWlzc2lvbnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQUlBLFlBQVksU0FBSyxJQUFJLFNBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNBLElBQUlPLGNBQWMsU0FBSyxJQUFJLFNBQUksQ0FBQ0EsV0FBVyxJQUFLLFNBQVVsQixPQUFPLEVBQUVtQixJQUFJO0lBQ25FLElBQUlDLElBQUk7UUFBRUMsT0FBTztRQUFHQyxNQUFNO1lBQWEsSUFBSUMsQ0FB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LE9BQU9LLElBQUksS0FBSyxnQkFBZ0JMLE9BQU94QixLQUFLLEVBQUU7Z0NBQzlDLE9BQU87b0NBQUM7b0NBQUc7aUNBQUs7NEJBQ3BCO3dCQUNKO3dCQUNBLE9BQU87NEJBQUM7NEJBQUc7eUJBQU07Z0JBQ3pCO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBT21CO0FBQ1g7QUFDNkIsQ0FDN0IsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9wb3MvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jYW1lcmEvcGVybWlzc2lvbnMuanM/MzViNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgQ2FtZXJhUGVybWlzc2lvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbWVyYVBlcm1pc3Npb25zKCkge1xuICAgIH1cbiAgICBDYW1lcmFQZXJtaXNzaW9ucy5oYXNQZXJtaXNzaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRldmljZXMsIF9pLCBkZXZpY2VzXzEsIGRldmljZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgZGV2aWNlc18xID0gZGV2aWNlczsgX2kgPCBkZXZpY2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlID0gZGV2aWNlc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlLmtpbmQgPT09IFwidmlkZW9pbnB1dFwiICYmIGRldmljZS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRydWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgZmFsc2VdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDYW1lcmFQZXJtaXNzaW9ucztcbn0oKSk7XG5leHBvcnQgeyBDYW1lcmFQZXJtaXNzaW9ucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVybWlzc2lvbnMuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fZ2VuZXJhdG9yIiwiYm9keSIsIl8iLCJsYWJlbCIsInNlbnQiLCJ0IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm4iLCJ2Iiwib3AiLCJUeXBlRXJyb3IiLCJjYWxsIiwicG9wIiwibGVuZ3RoIiwicHVzaCIsIkNhbWVyYVBlcm1pc3Npb25zIiwiaGFzUGVybWlzc2lvbnMiLCJkZXZpY2VzIiwiX2kiLCJkZXZpY2VzXzEiLCJkZXZpY2UiLCJfYSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImVudW1lcmF0ZURldmljZXMiLCJraW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/camera/permissions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/camera/retriever.js":
/*!***********************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/camera/retriever.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraRetriever: () => (/* binding */ CameraRetriever)\n/* harmony export */ });\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../strings */ \"(ssr)/./node_modules/html5-qrcode/esm/strings.js\");\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\n\nvar CameraRetriever = function() {\n    function CameraRetriever() {}\n    CameraRetriever.retrieve = function() {\n        if (navigator.mediaDevices) {\n            return CameraRetriever.getCamerasFromMediaDevices();\n        }\n        var mst = MediaStreamTrack;\n        if (MediaStreamTrack && mst.getSources) {\n            return CameraRetriever.getCamerasFromMediaStreamTrack();\n        }\n        return CameraRetriever.rejectWithError();\n    };\n    CameraRetriever.rejectWithError = function() {\n        var errorMessage = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeStrings.unableToQuerySupportedDevices();\n        if (!CameraRetriever.isHttpsOrLocalhost()) {\n            errorMessage = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeStrings.insecureContextCameraQueryError();\n        }\n        return Promise.reject(errorMessage);\n    };\n    CameraRetriever.isHttpsOrLocalhost = function() {\n        if (location.protocol === \"https:\") {\n            return true;\n        }\n        var host = location.host.split(\":\")[0];\n        return host === \"127.0.0.1\" || host === \"localhost\";\n    };\n    CameraRetriever.getCamerasFromMediaDevices = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var closeActiveStreams, mediaStream, devices, results, _i, devices_1, device;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        closeActiveStreams = function(stream) {\n                            var tracks = stream.getVideoTracks();\n                            for(var _i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++){\n                                var track = tracks_1[_i];\n                                track.enabled = false;\n                                track.stop();\n                                stream.removeTrack(track);\n                            }\n                        };\n                        return [\n                            4,\n                            navigator.mediaDevices.getUserMedia({\n                                audio: false,\n                                video: true\n                            })\n                        ];\n                    case 1:\n                        mediaStream = _a.sent();\n                        return [\n                            4,\n                            navigator.mediaDevices.enumerateDevices()\n                        ];\n                    case 2:\n                        devices = _a.sent();\n                        results = [];\n                        for(_i = 0, devices_1 = devices; _i < devices_1.length; _i++){\n                            device = devices_1[_i];\n                            if (device.kind === \"videoinput\") {\n                                results.push({\n                                    id: device.deviceId,\n                                    label: device.label\n                                });\n                            }\n                        }\n                        closeActiveStreams(mediaStream);\n                        return [\n                            2,\n                            results\n                        ];\n                }\n            });\n        });\n    };\n    CameraRetriever.getCamerasFromMediaStreamTrack = function() {\n        return new Promise(function(resolve, _) {\n            var callback = function(sourceInfos) {\n                var results = [];\n                for(var _i = 0, sourceInfos_1 = sourceInfos; _i < sourceInfos_1.length; _i++){\n                    var sourceInfo = sourceInfos_1[_i];\n                    if (sourceInfo.kind === \"video\") {\n                        results.push({\n                            id: sourceInfo.id,\n                            label: sourceInfo.label\n                        });\n                    }\n                }\n                resolve(results);\n            };\n            var mst = MediaStreamTrack;\n            mst.getSources(callback);\n        });\n    };\n    return CameraRetriever;\n}();\n //# sourceMappingURL=retriever.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jYW1lcmEvcmV0cmlldmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ0EsSUFBSU8sY0FBYyxTQUFLLElBQUksU0FBSSxDQUFDQSxXQUFXLElBQUssU0FBVWxCLE9BQU8sRUFBRW1CLElBQUk7SUFDbkUsSUFBSUMsSUFBSTtRQUFFQyxPQUFPO1FBQUdDLE1BQU07WUFBYSxJQUFJQyxDQUFD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QVUxQixNQUFNLEVBQUV5QixLQUFNOzRCQUMzREUsU0FBU0QsU0FBUyxDQUFDRCxHQUFHOzRCQUN0QixJQUFJRSxPQUFPYyxJQUFJLEtBQUssY0FBYztnQ0FDOUJqQixRQUFRdkIsSUFBSSxDQUFDO29DQUNUeUMsSUFBSWYsT0FBT2dCLFFBQVE7b0NBQ25CNUQsT0FBTzRDLE9BQU81QyxLQUFLO2dDQUN2Qjs0QkFDSjt3QkFDSjt3QkFDQXNDLG1CQUFtQkM7d0JBQ25CLE9BQU87NEJBQUM7NEJBQUdFO3lCQUFRO2dCQUMzQjtZQUNKO1FBQ0o7SUFDSjtJQUNBckIsZ0JBQWdCUSw4QkFBOEIsR0FBRztRQUM3QyxPQUFPLElBQUkxQyxRQUFRLFNBQVVELE9BQU8sRUFBRWMsQ0FBQztZQUNuQyxJQUFJOEQsV0FBVyxTQUFVQyxXQUFXO2dCQUNoQyxJQUFJckIsVUFBVSxFQUFFO2dCQUNoQixJQUFLLElBQUlDLEtBQUssR0FBR3FCLGdCQUFnQkQsYUFBYXBCLEtBQUtxQixjQUFjOUMsTUFBTSxFQUFFeUIsS0FBTTtvQkFDM0UsSUFBSXNCLGFBQWFELGFBQWEsQ0FBQ3JCLEdBQUc7b0JBQ2xDLElBQUlzQixXQUFXTixJQUFJLEtBQUssU0FBUzt3QkFDN0JqQixRQUFRdkIsSUFBSSxDQUFDOzRCQUNUeUMsSUFBSUssV0FBV0wsRUFBRTs0QkFDakIzRCxPQUFPZ0UsV0FBV2hFLEtBQUs7d0JBQzNCO29CQUNKO2dCQUNKO2dCQUNBZixRQUFRd0Q7WUFDWjtZQUNBLElBQUloQixNQUFNQztZQUNWRCxJQUFJRSxVQUFVLENBQUNrQztRQUNuQjtJQUNKO0lBQ0EsT0FBT3pDO0FBQ1g7QUFDMkIsQ0FDM0IscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9wb3MvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jYW1lcmEvcmV0cmlldmVyLmpzPzllYWIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuaW1wb3J0IHsgSHRtbDVRcmNvZGVTdHJpbmdzIH0gZnJvbSBcIi4uL3N0cmluZ3NcIjtcbnZhciBDYW1lcmFSZXRyaWV2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbWVyYVJldHJpZXZlcigpIHtcbiAgICB9XG4gICAgQ2FtZXJhUmV0cmlldmVyLnJldHJpZXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgICAgICAgICAgcmV0dXJuIENhbWVyYVJldHJpZXZlci5nZXRDYW1lcmFzRnJvbU1lZGlhRGV2aWNlcygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtc3QgPSBNZWRpYVN0cmVhbVRyYWNrO1xuICAgICAgICBpZiAoTWVkaWFTdHJlYW1UcmFjayAmJiBtc3QuZ2V0U291cmNlcykge1xuICAgICAgICAgICAgcmV0dXJuIENhbWVyYVJldHJpZXZlci5nZXRDYW1lcmFzRnJvbU1lZGlhU3RyZWFtVHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2FtZXJhUmV0cmlldmVyLnJlamVjdFdpdGhFcnJvcigpO1xuICAgIH07XG4gICAgQ2FtZXJhUmV0cmlldmVyLnJlamVjdFdpdGhFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IEh0bWw1UXJjb2RlU3RyaW5ncy51bmFibGVUb1F1ZXJ5U3VwcG9ydGVkRGV2aWNlcygpO1xuICAgICAgICBpZiAoIUNhbWVyYVJldHJpZXZlci5pc0h0dHBzT3JMb2NhbGhvc3QoKSkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gSHRtbDVRcmNvZGVTdHJpbmdzLmluc2VjdXJlQ29udGV4dENhbWVyYVF1ZXJ5RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JNZXNzYWdlKTtcbiAgICB9O1xuICAgIENhbWVyYVJldHJpZXZlci5pc0h0dHBzT3JMb2NhbGhvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChsb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJodHRwczpcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvc3QgPSBsb2NhdGlvbi5ob3N0LnNwbGl0KFwiOlwiKVswXTtcbiAgICAgICAgcmV0dXJuIGhvc3QgPT09IFwiMTI3LjAuMC4xXCIgfHwgaG9zdCA9PT0gXCJsb2NhbGhvc3RcIjtcbiAgICB9O1xuICAgIENhbWVyYVJldHJpZXZlci5nZXRDYW1lcmFzRnJvbU1lZGlhRGV2aWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNsb3NlQWN0aXZlU3RyZWFtcywgbWVkaWFTdHJlYW0sIGRldmljZXMsIHJlc3VsdHMsIF9pLCBkZXZpY2VzXzEsIGRldmljZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlQWN0aXZlU3RyZWFtcyA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB0cmFja3NfMSA9IHRyYWNrczsgX2kgPCB0cmFja3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiBmYWxzZSwgdmlkZW86IHRydWUgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYVN0cmVhbSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIGRldmljZXNfMSA9IGRldmljZXM7IF9pIDwgZGV2aWNlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZSA9IGRldmljZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRldmljZS5raW5kID09PSBcInZpZGVvaW5wdXRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGRldmljZS5kZXZpY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBkZXZpY2UubGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VBY3RpdmVTdHJlYW1zKG1lZGlhU3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzdWx0c107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FtZXJhUmV0cmlldmVyLmdldENhbWVyYXNGcm9tTWVkaWFTdHJlYW1UcmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCBfKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoc291cmNlSW5mb3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgc291cmNlSW5mb3NfMSA9IHNvdXJjZUluZm9zOyBfaSA8IHNvdXJjZUluZm9zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VJbmZvID0gc291cmNlSW5mb3NfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VJbmZvLmtpbmQgPT09IFwidmlkZW9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogc291cmNlSW5mby5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogc291cmNlSW5mby5sYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbXN0ID0gTWVkaWFTdHJlYW1UcmFjaztcbiAgICAgICAgICAgIG1zdC5nZXRTb3VyY2VzKGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FtZXJhUmV0cmlldmVyO1xufSgpKTtcbmV4cG9ydCB7IENhbWVyYVJldHJpZXZlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cmlldmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJ2ZXJiIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJuIiwidiIsIm9wIiwiVHlwZUVycm9yIiwiY2FsbCIsInBvcCIsImxlbmd0aCIsInB1c2giLCJIdG1sNVFyY29kZVN0cmluZ3MiLCJDYW1lcmFSZXRyaWV2ZXIiLCJyZXRyaWV2ZSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldENhbWVyYXNGcm9tTWVkaWFEZXZpY2VzIiwibXN0IiwiTWVkaWFTdHJlYW1UcmFjayIsImdldFNvdXJjZXMiLCJnZXRDYW1lcmFzRnJvbU1lZGlhU3RyZWFtVHJhY2siLCJyZWplY3RXaXRoRXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJ1bmFibGVUb1F1ZXJ5U3VwcG9ydGVkRGV2aWNlcyIsImlzSHR0cHNPckxvY2FsaG9zdCIsImluc2VjdXJlQ29udGV4dENhbWVyYVF1ZXJ5RXJyb3IiLCJsb2NhdGlvbiIsInByb3RvY29sIiwiaG9zdCIsInNwbGl0IiwiY2xvc2VBY3RpdmVTdHJlYW1zIiwibWVkaWFTdHJlYW0iLCJkZXZpY2VzIiwicmVzdWx0cyIsIl9pIiwiZGV2aWNlc18xIiwiZGV2aWNlIiwiX2EiLCJzdHJlYW0iLCJ0cmFja3MiLCJnZXRWaWRlb1RyYWNrcyIsInRyYWNrc18xIiwidHJhY2siLCJlbmFibGVkIiwic3RvcCIsInJlbW92ZVRyYWNrIiwiZ2V0VXNlck1lZGlhIiwiYXVkaW8iLCJ2aWRlbyIsImVudW1lcmF0ZURldmljZXMiLCJraW5kIiwiaWQiLCJkZXZpY2VJZCIsImNhbGxiYWNrIiwic291cmNlSW5mb3MiLCJzb3VyY2VJbmZvc18xIiwic291cmNlSW5mbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/camera/retriever.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/code-decoder.js":
/*!*******************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/code-decoder.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5QrcodeShim: () => (/* binding */ Html5QrcodeShim)\n/* harmony export */ });\n/* harmony import */ var _zxing_html5_qrcode_decoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zxing-html5-qrcode-decoder */ \"(ssr)/./node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js\");\n/* harmony import */ var _native_bar_code_detector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./native-bar-code-detector */ \"(ssr)/./node_modules/html5-qrcode/esm/native-bar-code-detector.js\");\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\n\n\nvar Html5QrcodeShim = function() {\n    function Html5QrcodeShim(requestedFormats, useBarCodeDetectorIfSupported, verbose, logger) {\n        this.EXECUTIONS_TO_REPORT_PERFORMANCE = 100;\n        this.executions = 0;\n        this.executionResults = [];\n        this.wasPrimaryDecoderUsedInLastDecode = false;\n        this.verbose = verbose;\n        if (useBarCodeDetectorIfSupported && _native_bar_code_detector__WEBPACK_IMPORTED_MODULE_1__.BarcodeDetectorDelegate.isSupported()) {\n            this.primaryDecoder = new _native_bar_code_detector__WEBPACK_IMPORTED_MODULE_1__.BarcodeDetectorDelegate(requestedFormats, verbose, logger);\n            this.secondaryDecoder = new _zxing_html5_qrcode_decoder__WEBPACK_IMPORTED_MODULE_0__.ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger);\n        } else {\n            this.primaryDecoder = new _zxing_html5_qrcode_decoder__WEBPACK_IMPORTED_MODULE_0__.ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger);\n        }\n    }\n    Html5QrcodeShim.prototype.decodeAsync = function(canvas) {\n        return __awaiter(this, void 0, void 0, function() {\n            var startTime;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        startTime = performance.now();\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([\n                            1,\n                            ,\n                            3,\n                            4\n                        ]);\n                        return [\n                            4,\n                            this.getDecoder().decodeAsync(canvas)\n                        ];\n                    case 2:\n                        return [\n                            2,\n                            _a.sent()\n                        ];\n                    case 3:\n                        this.possiblyLogPerformance(startTime);\n                        return [\n                            7\n                        ];\n                    case 4:\n                        return [\n                            2\n                        ];\n                }\n            });\n        });\n    };\n    Html5QrcodeShim.prototype.decodeRobustlyAsync = function(canvas) {\n        return __awaiter(this, void 0, void 0, function() {\n            var startTime, error_1;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        startTime = performance.now();\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([\n                            1,\n                            3,\n                            4,\n                            5\n                        ]);\n                        return [\n                            4,\n                            this.primaryDecoder.decodeAsync(canvas)\n                        ];\n                    case 2:\n                        return [\n                            2,\n                            _a.sent()\n                        ];\n                    case 3:\n                        error_1 = _a.sent();\n                        if (this.secondaryDecoder) {\n                            return [\n                                2,\n                                this.secondaryDecoder.decodeAsync(canvas)\n                            ];\n                        }\n                        throw error_1;\n                    case 4:\n                        this.possiblyLogPerformance(startTime);\n                        return [\n                            7\n                        ];\n                    case 5:\n                        return [\n                            2\n                        ];\n                }\n            });\n        });\n    };\n    Html5QrcodeShim.prototype.getDecoder = function() {\n        if (!this.secondaryDecoder) {\n            return this.primaryDecoder;\n        }\n        if (this.wasPrimaryDecoderUsedInLastDecode === false) {\n            this.wasPrimaryDecoderUsedInLastDecode = true;\n            return this.primaryDecoder;\n        }\n        this.wasPrimaryDecoderUsedInLastDecode = false;\n        return this.secondaryDecoder;\n    };\n    Html5QrcodeShim.prototype.possiblyLogPerformance = function(startTime) {\n        if (!this.verbose) {\n            return;\n        }\n        var executionTime = performance.now() - startTime;\n        this.executionResults.push(executionTime);\n        this.executions++;\n        this.possiblyFlushPerformanceReport();\n    };\n    Html5QrcodeShim.prototype.possiblyFlushPerformanceReport = function() {\n        if (this.executions < this.EXECUTIONS_TO_REPORT_PERFORMANCE) {\n            return;\n        }\n        var sum = 0;\n        for(var _i = 0, _a = this.executionResults; _i < _a.length; _i++){\n            var executionTime = _a[_i];\n            sum += executionTime;\n        }\n        var mean = sum / this.executionResults.length;\n        console.log(\"\".concat(mean, \" ms for \").concat(this.executionResults.length, \" last runs.\"));\n        this.executions = 0;\n        this.executionResults = [];\n    };\n    return Html5QrcodeShim;\n}();\n //# sourceMappingURL=code-decoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jb2RlLWRlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ0EsSUFBSU8sY0FBYyxTQUFLLElBQUksU0FBSSxDQUFDQSxXQUFXLElBQUssU0FBVWxCLE9BQU8sRUFBRW1CLElBQUk7SUFDbkUsSUFBSUMsSUFBSTtRQUFFQyxPQUFPO1FBQUdDLE1BQU07WUFBYSxJQUFJQyxDQUFDLENB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QUFJLENBQUNrQiw4QkFBOEI7SUFDdkM7SUFDQXhCLGdCQUFnQlksU0FBUyxDQUFDWSw4QkFBOEIsR0FBRztRQUN2RCxJQUFJLElBQUksQ0FBQ2xCLFVBQVUsR0FBRyxJQUFJLENBQUNELGdDQUFnQyxFQUFFO1lBQ3pEO1FBQ0o7UUFDQSxJQUFJb0IsTUFBTTtRQUNWLElBQUssSUFBSUMsS0FBSyxHQUFHVixLQUFLLElBQUksQ0FBQ1QsZ0JBQWdCLEVBQUVtQixLQUFLVixHQUFHcEIsTUFBTSxFQUFFOEIsS0FBTTtZQUMvRCxJQUFJSCxnQkFBZ0JQLEVBQUUsQ0FBQ1UsR0FBRztZQUMxQkQsT0FBT0Y7UUFDWDtRQUNBLElBQUlJLE9BQU9GLE1BQU0sSUFBSSxDQUFDbEIsZ0JBQWdCLENBQUNYLE1BQU07UUFDN0NnQyxRQUFRQyxHQUFHLENBQUMsR0FBR0MsTUFBTSxDQUFDSCxNQUFNLFlBQVlHLE1BQU0sQ0FBQyxJQUFJLENBQUN2QixnQkFBZ0IsQ0FBQ1gsTUFBTSxFQUFFO1FBQzdFLElBQUksQ0FBQ1UsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsRUFBRTtJQUM5QjtJQUNBLE9BQU9QO0FBQ1g7QUFDMkIsQ0FDM0Isd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9wb3MvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jb2RlLWRlY29kZXIuanM/MjBhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5pbXBvcnQgeyBaWGluZ0h0bWw1UXJjb2RlRGVjb2RlciB9IGZyb20gXCIuL3p4aW5nLWh0bWw1LXFyY29kZS1kZWNvZGVyXCI7XG5pbXBvcnQgeyBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZSB9IGZyb20gXCIuL25hdGl2ZS1iYXItY29kZS1kZXRlY3RvclwiO1xudmFyIEh0bWw1UXJjb2RlU2hpbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHRtbDVRcmNvZGVTaGltKHJlcXVlc3RlZEZvcm1hdHMsIHVzZUJhckNvZGVEZXRlY3RvcklmU3VwcG9ydGVkLCB2ZXJib3NlLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5FWEVDVVRJT05TX1RPX1JFUE9SVF9QRVJGT1JNQU5DRSA9IDEwMDtcbiAgICAgICAgdGhpcy5leGVjdXRpb25zID0gMDtcbiAgICAgICAgdGhpcy5leGVjdXRpb25SZXN1bHRzID0gW107XG4gICAgICAgIHRoaXMud2FzUHJpbWFyeURlY29kZXJVc2VkSW5MYXN0RGVjb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XG4gICAgICAgIGlmICh1c2VCYXJDb2RlRGV0ZWN0b3JJZlN1cHBvcnRlZFxuICAgICAgICAgICAgJiYgQmFyY29kZURldGVjdG9yRGVsZWdhdGUuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5wcmltYXJ5RGVjb2RlciA9IG5ldyBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZShyZXF1ZXN0ZWRGb3JtYXRzLCB2ZXJib3NlLCBsb2dnZXIpO1xuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlEZWNvZGVyID0gbmV3IFpYaW5nSHRtbDVRcmNvZGVEZWNvZGVyKHJlcXVlc3RlZEZvcm1hdHMsIHZlcmJvc2UsIGxvZ2dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByaW1hcnlEZWNvZGVyID0gbmV3IFpYaW5nSHRtbDVRcmNvZGVEZWNvZGVyKHJlcXVlc3RlZEZvcm1hdHMsIHZlcmJvc2UsIGxvZ2dlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSHRtbDVRcmNvZGVTaGltLnByb3RvdHlwZS5kZWNvZGVBc3luYyA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0VGltZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsICwgMywgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLmdldERlY29kZXIoKS5kZWNvZGVBc3luYyhjYW52YXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zc2libHlMb2dQZXJmb3JtYW5jZShzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2hpbS5wcm90b3R5cGUuZGVjb2RlUm9idXN0bHlBc3luYyA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0VGltZSwgZXJyb3JfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsIDQsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5wcmltYXJ5RGVjb2Rlci5kZWNvZGVBc3luYyhjYW52YXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnlEZWNvZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLnNlY29uZGFyeURlY29kZXIuZGVjb2RlQXN5bmMoY2FudmFzKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc3NpYmx5TG9nUGVyZm9ybWFuY2Uoc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbN107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNoaW0ucHJvdG90eXBlLmdldERlY29kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWNvbmRhcnlEZWNvZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmltYXJ5RGVjb2RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53YXNQcmltYXJ5RGVjb2RlclVzZWRJbkxhc3REZWNvZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLndhc1ByaW1hcnlEZWNvZGVyVXNlZEluTGFzdERlY29kZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmltYXJ5RGVjb2RlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhc1ByaW1hcnlEZWNvZGVyVXNlZEluTGFzdERlY29kZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmRhcnlEZWNvZGVyO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTaGltLnByb3RvdHlwZS5wb3NzaWJseUxvZ1BlcmZvcm1hbmNlID0gZnVuY3Rpb24gKHN0YXJ0VGltZSkge1xuICAgICAgICBpZiAoIXRoaXMudmVyYm9zZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleGVjdXRpb25UaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uUmVzdWx0cy5wdXNoKGV4ZWN1dGlvblRpbWUpO1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbnMrKztcbiAgICAgICAgdGhpcy5wb3NzaWJseUZsdXNoUGVyZm9ybWFuY2VSZXBvcnQoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2hpbS5wcm90b3R5cGUucG9zc2libHlGbHVzaFBlcmZvcm1hbmNlUmVwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5leGVjdXRpb25zIDwgdGhpcy5FWEVDVVRJT05TX1RPX1JFUE9SVF9QRVJGT1JNQU5DRSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5leGVjdXRpb25SZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGV4ZWN1dGlvblRpbWUgPSBfYVtfaV07XG4gICAgICAgICAgICBzdW0gKz0gZXhlY3V0aW9uVGltZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVhbiA9IHN1bSAvIHRoaXMuZXhlY3V0aW9uUmVzdWx0cy5sZW5ndGg7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXCIuY29uY2F0KG1lYW4sIFwiIG1zIGZvciBcIikuY29uY2F0KHRoaXMuZXhlY3V0aW9uUmVzdWx0cy5sZW5ndGgsIFwiIGxhc3QgcnVucy5cIikpO1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbnMgPSAwO1xuICAgICAgICB0aGlzLmV4ZWN1dGlvblJlc3VsdHMgPSBbXTtcbiAgICB9O1xuICAgIHJldHVybiBIdG1sNVFyY29kZVNoaW07XG59KCkpO1xuZXhwb3J0IHsgSHRtbDVRcmNvZGVTaGltIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlLWRlY29kZXIuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fZ2VuZXJhdG9yIiwiYm9keSIsIl8iLCJsYWJlbCIsInNlbnQiLCJ0IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm4iLCJ2Iiwib3AiLCJUeXBlRXJyb3IiLCJjYWxsIiwicG9wIiwibGVuZ3RoIiwicHVzaCIsIlpYaW5nSHRtbDVRcmNvZGVEZWNvZGVyIiwiQmFyY29kZURldGVjdG9yRGVsZWdhdGUiLCJIdG1sNVFyY29kZVNoaW0iLCJyZXF1ZXN0ZWRGb3JtYXRzIiwidXNlQmFyQ29kZURldGVjdG9ySWZTdXBwb3J0ZWQiLCJ2ZXJib3NlIiwibG9nZ2VyIiwiRVhFQ1VUSU9OU19UT19SRVBPUlRfUEVSRk9STUFOQ0UiLCJleGVjdXRpb25zIiwiZXhlY3V0aW9uUmVzdWx0cyIsIndhc1ByaW1hcnlEZWNvZGVyVXNlZEluTGFzdERlY29kZSIsImlzU3VwcG9ydGVkIiwicHJpbWFyeURlY29kZXIiLCJzZWNvbmRhcnlEZWNvZGVyIiwicHJvdG90eXBlIiwiZGVjb2RlQXN5bmMiLCJjYW52YXMiLCJzdGFydFRpbWUiLCJfYSIsInBlcmZvcm1hbmNlIiwibm93IiwiZ2V0RGVjb2RlciIsInBvc3NpYmx5TG9nUGVyZm9ybWFuY2UiLCJkZWNvZGVSb2J1c3RseUFzeW5jIiwiZXJyb3JfMSIsImV4ZWN1dGlvblRpbWUiLCJwb3NzaWJseUZsdXNoUGVyZm9ybWFuY2VSZXBvcnQiLCJzdW0iLCJfaSIsIm1lYW4iLCJjb25zb2xlIiwibG9nIiwiY29uY2F0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/code-decoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/core.js":
/*!***********************************************!*\
  !*** ./node_modules/html5-qrcode/esm/core.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseLoggger: () => (/* binding */ BaseLoggger),\n/* harmony export */   DecodedTextType: () => (/* binding */ DecodedTextType),\n/* harmony export */   Html5QrcodeConstants: () => (/* binding */ Html5QrcodeConstants),\n/* harmony export */   Html5QrcodeErrorFactory: () => (/* binding */ Html5QrcodeErrorFactory),\n/* harmony export */   Html5QrcodeErrorTypes: () => (/* binding */ Html5QrcodeErrorTypes),\n/* harmony export */   Html5QrcodeResultFactory: () => (/* binding */ Html5QrcodeResultFactory),\n/* harmony export */   Html5QrcodeScanType: () => (/* binding */ Html5QrcodeScanType),\n/* harmony export */   Html5QrcodeSupportedFormats: () => (/* binding */ Html5QrcodeSupportedFormats),\n/* harmony export */   QrcodeResultFormat: () => (/* binding */ QrcodeResultFormat),\n/* harmony export */   clip: () => (/* binding */ clip),\n/* harmony export */   isNullOrUndefined: () => (/* binding */ isNullOrUndefined),\n/* harmony export */   isValidHtml5QrcodeSupportedFormats: () => (/* binding */ isValidHtml5QrcodeSupportedFormats)\n/* harmony export */ });\nvar Html5QrcodeSupportedFormats;\n(function(Html5QrcodeSupportedFormats) {\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"QR_CODE\"] = 0] = \"QR_CODE\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"AZTEC\"] = 1] = \"AZTEC\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"CODABAR\"] = 2] = \"CODABAR\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"CODE_39\"] = 3] = \"CODE_39\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"CODE_93\"] = 4] = \"CODE_93\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"CODE_128\"] = 5] = \"CODE_128\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"DATA_MATRIX\"] = 6] = \"DATA_MATRIX\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"MAXICODE\"] = 7] = \"MAXICODE\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"ITF\"] = 8] = \"ITF\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"EAN_13\"] = 9] = \"EAN_13\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"EAN_8\"] = 10] = \"EAN_8\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"PDF_417\"] = 11] = \"PDF_417\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"RSS_14\"] = 12] = \"RSS_14\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"RSS_EXPANDED\"] = 13] = \"RSS_EXPANDED\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"UPC_A\"] = 14] = \"UPC_A\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"UPC_E\"] = 15] = \"UPC_E\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"UPC_EAN_EXTENSION\"] = 16] = \"UPC_EAN_EXTENSION\";\n})(Html5QrcodeSupportedFormats || (Html5QrcodeSupportedFormats = {}));\nvar html5QrcodeSupportedFormatsTextMap = new Map([\n    [\n        Html5QrcodeSupportedFormats.QR_CODE,\n        \"QR_CODE\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.AZTEC,\n        \"AZTEC\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.CODABAR,\n        \"CODABAR\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.CODE_39,\n        \"CODE_39\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.CODE_93,\n        \"CODE_93\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.CODE_128,\n        \"CODE_128\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.DATA_MATRIX,\n        \"DATA_MATRIX\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.MAXICODE,\n        \"MAXICODE\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.ITF,\n        \"ITF\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.EAN_13,\n        \"EAN_13\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.EAN_8,\n        \"EAN_8\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.PDF_417,\n        \"PDF_417\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.RSS_14,\n        \"RSS_14\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.RSS_EXPANDED,\n        \"RSS_EXPANDED\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.UPC_A,\n        \"UPC_A\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.UPC_E,\n        \"UPC_E\"\n    ],\n    [\n        Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION,\n        \"UPC_EAN_EXTENSION\"\n    ]\n]);\nvar DecodedTextType;\n(function(DecodedTextType) {\n    DecodedTextType[DecodedTextType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    DecodedTextType[DecodedTextType[\"URL\"] = 1] = \"URL\";\n})(DecodedTextType || (DecodedTextType = {}));\nfunction isValidHtml5QrcodeSupportedFormats(format) {\n    return Object.values(Html5QrcodeSupportedFormats).includes(format);\n}\nvar Html5QrcodeScanType;\n(function(Html5QrcodeScanType) {\n    Html5QrcodeScanType[Html5QrcodeScanType[\"SCAN_TYPE_CAMERA\"] = 0] = \"SCAN_TYPE_CAMERA\";\n    Html5QrcodeScanType[Html5QrcodeScanType[\"SCAN_TYPE_FILE\"] = 1] = \"SCAN_TYPE_FILE\";\n})(Html5QrcodeScanType || (Html5QrcodeScanType = {}));\nvar Html5QrcodeConstants = function() {\n    function Html5QrcodeConstants() {}\n    Html5QrcodeConstants.GITHUB_PROJECT_URL = \"https://github.com/mebjas/html5-qrcode\";\n    Html5QrcodeConstants.SCAN_DEFAULT_FPS = 2;\n    Html5QrcodeConstants.DEFAULT_DISABLE_FLIP = false;\n    Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED = true;\n    Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE = [\n        Html5QrcodeScanType.SCAN_TYPE_CAMERA,\n        Html5QrcodeScanType.SCAN_TYPE_FILE\n    ];\n    return Html5QrcodeConstants;\n}();\n\nvar QrcodeResultFormat = function() {\n    function QrcodeResultFormat(format, formatName) {\n        this.format = format;\n        this.formatName = formatName;\n    }\n    QrcodeResultFormat.prototype.toString = function() {\n        return this.formatName;\n    };\n    QrcodeResultFormat.create = function(format) {\n        if (!html5QrcodeSupportedFormatsTextMap.has(format)) {\n            throw \"\".concat(format, \" not in html5QrcodeSupportedFormatsTextMap\");\n        }\n        return new QrcodeResultFormat(format, html5QrcodeSupportedFormatsTextMap.get(format));\n    };\n    return QrcodeResultFormat;\n}();\n\nvar Html5QrcodeResultFactory = function() {\n    function Html5QrcodeResultFactory() {}\n    Html5QrcodeResultFactory.createFromText = function(decodedText) {\n        var qrcodeResult = {\n            text: decodedText\n        };\n        return {\n            decodedText: decodedText,\n            result: qrcodeResult\n        };\n    };\n    Html5QrcodeResultFactory.createFromQrcodeResult = function(qrcodeResult) {\n        return {\n            decodedText: qrcodeResult.text,\n            result: qrcodeResult\n        };\n    };\n    return Html5QrcodeResultFactory;\n}();\n\nvar Html5QrcodeErrorTypes;\n(function(Html5QrcodeErrorTypes) {\n    Html5QrcodeErrorTypes[Html5QrcodeErrorTypes[\"UNKWOWN_ERROR\"] = 0] = \"UNKWOWN_ERROR\";\n    Html5QrcodeErrorTypes[Html5QrcodeErrorTypes[\"IMPLEMENTATION_ERROR\"] = 1] = \"IMPLEMENTATION_ERROR\";\n    Html5QrcodeErrorTypes[Html5QrcodeErrorTypes[\"NO_CODE_FOUND_ERROR\"] = 2] = \"NO_CODE_FOUND_ERROR\";\n})(Html5QrcodeErrorTypes || (Html5QrcodeErrorTypes = {}));\nvar Html5QrcodeErrorFactory = function() {\n    function Html5QrcodeErrorFactory() {}\n    Html5QrcodeErrorFactory.createFrom = function(error) {\n        return {\n            errorMessage: error,\n            type: Html5QrcodeErrorTypes.UNKWOWN_ERROR\n        };\n    };\n    return Html5QrcodeErrorFactory;\n}();\n\nvar BaseLoggger = function() {\n    function BaseLoggger(verbose) {\n        this.verbose = verbose;\n    }\n    BaseLoggger.prototype.log = function(message) {\n        if (this.verbose) {\n            console.log(message);\n        }\n    };\n    BaseLoggger.prototype.warn = function(message) {\n        if (this.verbose) {\n            console.warn(message);\n        }\n    };\n    BaseLoggger.prototype.logError = function(message, isExperimental) {\n        if (this.verbose || isExperimental === true) {\n            console.error(message);\n        }\n    };\n    BaseLoggger.prototype.logErrors = function(errors) {\n        if (errors.length === 0) {\n            throw \"Logger#logError called without arguments\";\n        }\n        if (this.verbose) {\n            console.error(errors);\n        }\n    };\n    return BaseLoggger;\n}();\n\nfunction isNullOrUndefined(obj) {\n    return typeof obj === \"undefined\" || obj === null;\n}\nfunction clip(value, minValue, maxValue) {\n    if (value > maxValue) {\n        return maxValue;\n    }\n    if (value < minValue) {\n        return minValue;\n    }\n    return value;\n} //# sourceMappingURL=core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jb3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFPLElBQUlBLDRCQUE0QjtBQUN0QyxVQUFVQSwyQkFBMkI7SUFDbENBLDJCQUEyQixDQUFDQSwyQkFBMkIsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzFFQSwyQkFBMkIsQ0FBQ0EsMkJBQTJCLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUN4RUEsMkJBQTJCLENBQUNBLDJCQUEyQixDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDMUVBLDJCQUEyQixDQUFDQSwyQkFBMkIsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzFFQSwyQkFBMkIsQ0FBQ0EsMkJBQTJCLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUMxRUEsMkJBQTJCLENBQUNBLDJCQUEyQixDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDM0VBLDJCQUEyQixDQUFDQSwyQkFBMkIsQ0FBQyxjQUFjLEdBQUcsRUFBRSxHQUFHO0lBQzlFQSwyQkFBMkIsQ0FBQ0EsMkJBQTJCLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztJQUMzRUEsMkJBQTJCLENBQUNBLDJCQUEyQixDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7SUFDdEVBLDJCQUEyQixDQUFDQSwyQkFBMkIsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ3pFQSwyQkFBMkIsQ0FBQ0EsMkJBQTJCLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRztJQUN6RUEsMkJBQTJCLENBQUNBLDJCQUEyQixDQUFDLFVBQVUsR0FBRyxHQUFHLEdBQUc7SUFDM0VBLDJCQUEyQixDQUFDQSwyQkFBMkIsQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQzFFQSwyQkFBMkIsQ0FBQ0EsMkJBQTJCLENBQUMsZUFBZSxHQUFHLEdBQUcsR0FBRztJQUNoRkEsMkJBQTJCLENBQUNBLDJCQUEyQixDQUFDLFFBQVEsR0FB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Q0FILFlBQVlwQixTQUFTLENBQUN5QixJQUFJLEdBQUcsU0FBVUYsT0FBTztRQUMxQyxJQUFJLElBQUksQ0FBQ0YsT0FBTyxFQUFFO1lBQ2RHLFFBQVFDLElBQUksQ0FBQ0Y7UUFDakI7SUFDSjtJQUNBSCxZQUFZcEIsU0FBUyxDQUFDMEIsUUFBUSxHQUFHLFNBQVVILE9BQU8sRUFBRUksY0FBYztRQUM5RCxJQUFJLElBQUksQ0FBQ04sT0FBTyxJQUFJTSxtQkFBbUIsTUFBTTtZQUN6Q0gsUUFBUVIsS0FBSyxDQUFDTztRQUNsQjtJQUNKO0lBQ0FILFlBQVlwQixTQUFTLENBQUM0QixTQUFTLEdBQUcsU0FBVUMsTUFBTTtRQUM5QyxJQUFJQSxPQUFPQyxNQUFNLEtBQUssR0FBRztZQUNyQixNQUFNO1FBQ1Y7UUFDQSxJQUFJLElBQUksQ0FBQ1QsT0FBTyxFQUFFO1lBQ2RHLFFBQVFSLEtBQUssQ0FBQ2E7UUFDbEI7SUFDSjtJQUNBLE9BQU9UO0FBQ1g7QUFDdUI7QUFDaEIsU0FBU1csa0JBQWtCQyxHQUFHO0lBQ2pDLE9BQU8sT0FBUUEsUUFBUSxlQUFnQkEsUUFBUTtBQUNuRDtBQUNPLFNBQVNDLEtBQUtDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxRQUFRO0lBQzFDLElBQUlGLFFBQVFFLFVBQVU7UUFDbEIsT0FBT0E7SUFDWDtJQUNBLElBQUlGLFFBQVFDLFVBQVU7UUFDbEIsT0FBT0E7SUFDWDtJQUNBLE9BQU9EO0FBQ1gsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb3Bvcy8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL2NvcmUuanM/ZWEzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cztcbihmdW5jdGlvbiAoSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzKSB7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIlFSX0NPREVcIl0gPSAwXSA9IFwiUVJfQ09ERVwiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJBWlRFQ1wiXSA9IDFdID0gXCJBWlRFQ1wiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJDT0RBQkFSXCJdID0gMl0gPSBcIkNPREFCQVJcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiQ09ERV8zOVwiXSA9IDNdID0gXCJDT0RFXzM5XCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIkNPREVfOTNcIl0gPSA0XSA9IFwiQ09ERV85M1wiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJDT0RFXzEyOFwiXSA9IDVdID0gXCJDT0RFXzEyOFwiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJEQVRBX01BVFJJWFwiXSA9IDZdID0gXCJEQVRBX01BVFJJWFwiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJNQVhJQ09ERVwiXSA9IDddID0gXCJNQVhJQ09ERVwiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJJVEZcIl0gPSA4XSA9IFwiSVRGXCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIkVBTl8xM1wiXSA9IDldID0gXCJFQU5fMTNcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiRUFOXzhcIl0gPSAxMF0gPSBcIkVBTl84XCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIlBERl80MTdcIl0gPSAxMV0gPSBcIlBERl80MTdcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiUlNTXzE0XCJdID0gMTJdID0gXCJSU1NfMTRcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiUlNTX0VYUEFOREVEXCJdID0gMTNdID0gXCJSU1NfRVhQQU5ERURcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiVVBDX0FcIl0gPSAxNF0gPSBcIlVQQ19BXCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIlVQQ19FXCJdID0gMTVdID0gXCJVUENfRVwiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJVUENfRUFOX0VYVEVOU0lPTlwiXSA9IDE2XSA9IFwiVVBDX0VBTl9FWFRFTlNJT05cIjtcbn0pKEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cyB8fCAoSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzID0ge30pKTtcbnZhciBodG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNUZXh0TWFwID0gbmV3IE1hcChbXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5RUl9DT0RFLCBcIlFSX0NPREVcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5BWlRFQywgXCJBWlRFQ1wiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREFCQVIsIFwiQ09EQUJBUlwiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfMzksIFwiQ09ERV8zOVwiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfOTMsIFwiQ09ERV85M1wiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfMTI4LCBcIkNPREVfMTI4XCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuREFUQV9NQVRSSVgsIFwiREFUQV9NQVRSSVhcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5NQVhJQ09ERSwgXCJNQVhJQ09ERVwiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLklURiwgXCJJVEZcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5FQU5fMTMsIFwiRUFOXzEzXCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuRUFOXzgsIFwiRUFOXzhcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5QREZfNDE3LCBcIlBERl80MTdcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5SU1NfMTQsIFwiUlNTXzE0XCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUlNTX0VYUEFOREVELCBcIlJTU19FWFBBTkRFRFwiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19BLCBcIlVQQ19BXCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuVVBDX0UsIFwiVVBDX0VcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5VUENfRUFOX0VYVEVOU0lPTiwgXCJVUENfRUFOX0VYVEVOU0lPTlwiXVxuXSk7XG5leHBvcnQgdmFyIERlY29kZWRUZXh0VHlwZTtcbihmdW5jdGlvbiAoRGVjb2RlZFRleHRUeXBlKSB7XG4gICAgRGVjb2RlZFRleHRUeXBlW0RlY29kZWRUZXh0VHlwZVtcIlVOS05PV05cIl0gPSAwXSA9IFwiVU5LTk9XTlwiO1xuICAgIERlY29kZWRUZXh0VHlwZVtEZWNvZGVkVGV4dFR5cGVbXCJVUkxcIl0gPSAxXSA9IFwiVVJMXCI7XG59KShEZWNvZGVkVGV4dFR5cGUgfHwgKERlY29kZWRUZXh0VHlwZSA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cyhmb3JtYXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMpLmluY2x1ZGVzKGZvcm1hdCk7XG59XG5leHBvcnQgdmFyIEh0bWw1UXJjb2RlU2NhblR5cGU7XG4oZnVuY3Rpb24gKEh0bWw1UXJjb2RlU2NhblR5cGUpIHtcbiAgICBIdG1sNVFyY29kZVNjYW5UeXBlW0h0bWw1UXJjb2RlU2NhblR5cGVbXCJTQ0FOX1RZUEVfQ0FNRVJBXCJdID0gMF0gPSBcIlNDQU5fVFlQRV9DQU1FUkFcIjtcbiAgICBIdG1sNVFyY29kZVNjYW5UeXBlW0h0bWw1UXJjb2RlU2NhblR5cGVbXCJTQ0FOX1RZUEVfRklMRVwiXSA9IDFdID0gXCJTQ0FOX1RZUEVfRklMRVwiO1xufSkoSHRtbDVRcmNvZGVTY2FuVHlwZSB8fCAoSHRtbDVRcmNvZGVTY2FuVHlwZSA9IHt9KSk7XG52YXIgSHRtbDVRcmNvZGVDb25zdGFudHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWw1UXJjb2RlQ29uc3RhbnRzKCkge1xuICAgIH1cbiAgICBIdG1sNVFyY29kZUNvbnN0YW50cy5HSVRIVUJfUFJPSkVDVF9VUkwgPSBcImh0dHBzOi8vZ2l0aHViLmNvbS9tZWJqYXMvaHRtbDUtcXJjb2RlXCI7XG4gICAgSHRtbDVRcmNvZGVDb25zdGFudHMuU0NBTl9ERUZBVUxUX0ZQUyA9IDI7XG4gICAgSHRtbDVRcmNvZGVDb25zdGFudHMuREVGQVVMVF9ESVNBQkxFX0ZMSVAgPSBmYWxzZTtcbiAgICBIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1JFTUVNQkVSX0xBU1RfQ0FNRVJBX1VTRUQgPSB0cnVlO1xuICAgIEh0bWw1UXJjb2RlQ29uc3RhbnRzLkRFRkFVTFRfU1VQUE9SVEVEX1NDQU5fVFlQRSA9IFtcbiAgICAgICAgSHRtbDVRcmNvZGVTY2FuVHlwZS5TQ0FOX1RZUEVfQ0FNRVJBLFxuICAgICAgICBIdG1sNVFyY29kZVNjYW5UeXBlLlNDQU5fVFlQRV9GSUxFXG4gICAgXTtcbiAgICByZXR1cm4gSHRtbDVRcmNvZGVDb25zdGFudHM7XG59KCkpO1xuZXhwb3J0IHsgSHRtbDVRcmNvZGVDb25zdGFudHMgfTtcbnZhciBRcmNvZGVSZXN1bHRGb3JtYXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFFyY29kZVJlc3VsdEZvcm1hdChmb3JtYXQsIGZvcm1hdE5hbWUpIHtcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHRoaXMuZm9ybWF0TmFtZSA9IGZvcm1hdE5hbWU7XG4gICAgfVxuICAgIFFyY29kZVJlc3VsdEZvcm1hdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdE5hbWU7XG4gICAgfTtcbiAgICBRcmNvZGVSZXN1bHRGb3JtYXQuY3JlYXRlID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBpZiAoIWh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1RleHRNYXAuaGFzKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIHRocm93IFwiXCIuY29uY2F0KGZvcm1hdCwgXCIgbm90IGluIGh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1RleHRNYXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBRcmNvZGVSZXN1bHRGb3JtYXQoZm9ybWF0LCBodG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNUZXh0TWFwLmdldChmb3JtYXQpKTtcbiAgICB9O1xuICAgIHJldHVybiBRcmNvZGVSZXN1bHRGb3JtYXQ7XG59KCkpO1xuZXhwb3J0IHsgUXJjb2RlUmVzdWx0Rm9ybWF0IH07XG52YXIgSHRtbDVRcmNvZGVSZXN1bHRGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNVFyY29kZVJlc3VsdEZhY3RvcnkoKSB7XG4gICAgfVxuICAgIEh0bWw1UXJjb2RlUmVzdWx0RmFjdG9yeS5jcmVhdGVGcm9tVGV4dCA9IGZ1bmN0aW9uIChkZWNvZGVkVGV4dCkge1xuICAgICAgICB2YXIgcXJjb2RlUmVzdWx0ID0ge1xuICAgICAgICAgICAgdGV4dDogZGVjb2RlZFRleHRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlY29kZWRUZXh0OiBkZWNvZGVkVGV4dCxcbiAgICAgICAgICAgIHJlc3VsdDogcXJjb2RlUmVzdWx0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVJlc3VsdEZhY3RvcnkuY3JlYXRlRnJvbVFyY29kZVJlc3VsdCA9IGZ1bmN0aW9uIChxcmNvZGVSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlY29kZWRUZXh0OiBxcmNvZGVSZXN1bHQudGV4dCxcbiAgICAgICAgICAgIHJlc3VsdDogcXJjb2RlUmVzdWx0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbDVRcmNvZGVSZXN1bHRGYWN0b3J5O1xufSgpKTtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlUmVzdWx0RmFjdG9yeSB9O1xuZXhwb3J0IHZhciBIdG1sNVFyY29kZUVycm9yVHlwZXM7XG4oZnVuY3Rpb24gKEh0bWw1UXJjb2RlRXJyb3JUeXBlcykge1xuICAgIEh0bWw1UXJjb2RlRXJyb3JUeXBlc1tIdG1sNVFyY29kZUVycm9yVHlwZXNbXCJVTktXT1dOX0VSUk9SXCJdID0gMF0gPSBcIlVOS1dPV05fRVJST1JcIjtcbiAgICBIdG1sNVFyY29kZUVycm9yVHlwZXNbSHRtbDVRcmNvZGVFcnJvclR5cGVzW1wiSU1QTEVNRU5UQVRJT05fRVJST1JcIl0gPSAxXSA9IFwiSU1QTEVNRU5UQVRJT05fRVJST1JcIjtcbiAgICBIdG1sNVFyY29kZUVycm9yVHlwZXNbSHRtbDVRcmNvZGVFcnJvclR5cGVzW1wiTk9fQ09ERV9GT1VORF9FUlJPUlwiXSA9IDJdID0gXCJOT19DT0RFX0ZPVU5EX0VSUk9SXCI7XG59KShIdG1sNVFyY29kZUVycm9yVHlwZXMgfHwgKEh0bWw1UXJjb2RlRXJyb3JUeXBlcyA9IHt9KSk7XG52YXIgSHRtbDVRcmNvZGVFcnJvckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWw1UXJjb2RlRXJyb3JGYWN0b3J5KCkge1xuICAgIH1cbiAgICBIdG1sNVFyY29kZUVycm9yRmFjdG9yeS5jcmVhdGVGcm9tID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgICAgdHlwZTogSHRtbDVRcmNvZGVFcnJvclR5cGVzLlVOS1dPV05fRVJST1JcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBIdG1sNVFyY29kZUVycm9yRmFjdG9yeTtcbn0oKSk7XG5leHBvcnQgeyBIdG1sNVFyY29kZUVycm9yRmFjdG9yeSB9O1xudmFyIEJhc2VMb2dnZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlTG9nZ2dlcih2ZXJib3NlKSB7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XG4gICAgfVxuICAgIEJhc2VMb2dnZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFzZUxvZ2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhc2VMb2dnZ2VyLnByb3RvdHlwZS5sb2dFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBpc0V4cGVyaW1lbnRhbCkge1xuICAgICAgICBpZiAodGhpcy52ZXJib3NlIHx8IGlzRXhwZXJpbWVudGFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCYXNlTG9nZ2dlci5wcm90b3R5cGUubG9nRXJyb3JzID0gZnVuY3Rpb24gKGVycm9ycykge1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgXCJMb2dnZXIjbG9nRXJyb3IgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZUxvZ2dnZXI7XG59KCkpO1xuZXhwb3J0IHsgQmFzZUxvZ2dnZXIgfTtcbmV4cG9ydCBmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIpIHx8IG9iaiA9PT0gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGlwKHZhbHVlLCBtaW5WYWx1ZSwgbWF4VmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWF4VmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IG1pblZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtaW5WYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS5qcy5tYXAiXSwibmFtZXMiOlsiSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzIiwiaHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzVGV4dE1hcCIsIk1hcCIsIlFSX0NPREUiLCJBWlRFQyIsIkNPREFCQVIiLCJDT0RFXzM5IiwiQ09ERV85MyIsIkNPREVfMTI4IiwiREFUQV9NQVRSSVgiLCJNQVhJQ09ERSIsIklURiIsIkVBTl8xMyIsIkVBTl84IiwiUERGXzQxNyIsIlJTU18xNCIsIlJTU19FWFBBTkRFRCIsIlVQQ19BIiwiVVBDX0UiLCJVUENfRUFOX0VYVEVOU0lPTiIsIkRlY29kZWRUZXh0VHlwZSIsImlzVmFsaWRIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMiLCJmb3JtYXQiLCJPYmplY3QiLCJ2YWx1ZXMiLCJpbmNsdWRlcyIsIkh0bWw1UXJjb2RlU2NhblR5cGUiLCJIdG1sNVFyY29kZUNvbnN0YW50cyIsIkdJVEhVQl9QUk9KRUNUX1VSTCIsIlNDQU5fREVGQVVMVF9GUFMiLCJERUZBVUxUX0RJU0FCTEVfRkxJUCIsIkRFRkFVTFRfUkVNRU1CRVJfTEFTVF9DQU1FUkFfVVNFRCIsIkRFRkFVTFRfU1VQUE9SVEVEX1NDQU5fVFlQRSIsIlNDQU5fVFlQRV9DQU1FUkEiLCJTQ0FOX1RZUEVfRklMRSIsIlFyY29kZVJlc3VsdEZvcm1hdCIsImZvcm1hdE5hbWUiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNyZWF0ZSIsImhhcyIsImNvbmNhdCIsImdldCIsIkh0bWw1UXJjb2RlUmVzdWx0RmFjdG9yeSIsImNyZWF0ZUZyb21UZXh0IiwiZGVjb2RlZFRleHQiLCJxcmNvZGVSZXN1bHQiLCJ0ZXh0IiwicmVzdWx0IiwiY3JlYXRlRnJvbVFyY29kZVJlc3VsdCIsIkh0bWw1UXJjb2RlRXJyb3JUeXBlcyIsIkh0bWw1UXJjb2RlRXJyb3JGYWN0b3J5IiwiY3JlYXRlRnJvbSIsImVycm9yIiwiZXJyb3JNZXNzYWdlIiwidHlwZSIsIlVOS1dPV05fRVJST1IiLCJCYXNlTG9nZ2dlciIsInZlcmJvc2UiLCJsb2ciLCJtZXNzYWdlIiwiY29uc29sZSIsIndhcm4iLCJsb2dFcnJvciIsImlzRXhwZXJpbWVudGFsIiwibG9nRXJyb3JzIiwiZXJyb3JzIiwibGVuZ3RoIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJvYmoiLCJjbGlwIiwidmFsdWUiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/html5-qrcode-scanner.js":
/*!***************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/html5-qrcode-scanner.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5QrcodeScanner: () => (/* binding */ Html5QrcodeScanner)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"(ssr)/./node_modules/html5-qrcode/esm/core.js\");\n/* harmony import */ var _html5_qrcode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./html5-qrcode */ \"(ssr)/./node_modules/html5-qrcode/esm/html5-qrcode.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./strings */ \"(ssr)/./node_modules/html5-qrcode/esm/strings.js\");\n/* harmony import */ var _image_assets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./image-assets */ \"(ssr)/./node_modules/html5-qrcode/esm/image-assets.js\");\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./storage */ \"(ssr)/./node_modules/html5-qrcode/esm/storage.js\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui */ \"(ssr)/./node_modules/html5-qrcode/esm/ui.js\");\n/* harmony import */ var _camera_permissions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./camera/permissions */ \"(ssr)/./node_modules/html5-qrcode/esm/camera/permissions.js\");\n/* harmony import */ var _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ui/scanner/scan-type-selector */ \"(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js\");\n/* harmony import */ var _ui_scanner_torch_button__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ui/scanner/torch-button */ \"(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/torch-button.js\");\n/* harmony import */ var _ui_scanner_file_selection_ui__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ui/scanner/file-selection-ui */ \"(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js\");\n/* harmony import */ var _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ui/scanner/base */ \"(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/base.js\");\n/* harmony import */ var _ui_scanner_camera_selection_ui__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ui/scanner/camera-selection-ui */ \"(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js\");\n/* harmony import */ var _ui_scanner_camera_zoom_ui__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ui/scanner/camera-zoom-ui */ \"(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Html5QrcodeScannerStatus;\n(function(Html5QrcodeScannerStatus) {\n    Html5QrcodeScannerStatus[Html5QrcodeScannerStatus[\"STATUS_DEFAULT\"] = 0] = \"STATUS_DEFAULT\";\n    Html5QrcodeScannerStatus[Html5QrcodeScannerStatus[\"STATUS_SUCCESS\"] = 1] = \"STATUS_SUCCESS\";\n    Html5QrcodeScannerStatus[Html5QrcodeScannerStatus[\"STATUS_WARNING\"] = 2] = \"STATUS_WARNING\";\n    Html5QrcodeScannerStatus[Html5QrcodeScannerStatus[\"STATUS_REQUESTING_PERMISSION\"] = 3] = \"STATUS_REQUESTING_PERMISSION\";\n})(Html5QrcodeScannerStatus || (Html5QrcodeScannerStatus = {}));\nfunction toHtml5QrcodeCameraScanConfig(config) {\n    return {\n        fps: config.fps,\n        qrbox: config.qrbox,\n        aspectRatio: config.aspectRatio,\n        disableFlip: config.disableFlip,\n        videoConstraints: config.videoConstraints\n    };\n}\nfunction toHtml5QrcodeFullConfig(config, verbose) {\n    return {\n        formatsToSupport: config.formatsToSupport,\n        useBarCodeDetectorIfSupported: config.useBarCodeDetectorIfSupported,\n        experimentalFeatures: config.experimentalFeatures,\n        verbose: verbose\n    };\n}\nvar Html5QrcodeScanner = function() {\n    function Html5QrcodeScanner(elementId, config, verbose) {\n        this.lastMatchFound = null;\n        this.cameraScanImage = null;\n        this.fileScanImage = null;\n        this.fileSelectionUi = null;\n        this.elementId = elementId;\n        this.config = this.createConfig(config);\n        this.verbose = verbose === true;\n        if (!document.getElementById(elementId)) {\n            throw \"HTML Element with id=\".concat(elementId, \" not found\");\n        }\n        this.scanTypeSelector = new _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector(this.config.supportedScanTypes);\n        this.currentScanType = this.scanTypeSelector.getDefaultScanType();\n        this.sectionSwapAllowed = true;\n        this.logger = new _core__WEBPACK_IMPORTED_MODULE_0__.BaseLoggger(this.verbose);\n        this.persistedDataManager = new _storage__WEBPACK_IMPORTED_MODULE_4__.PersistedDataManager();\n        if (config.rememberLastUsedCamera !== true) {\n            this.persistedDataManager.reset();\n        }\n    }\n    Html5QrcodeScanner.prototype.render = function(qrCodeSuccessCallback, qrCodeErrorCallback) {\n        var _this = this;\n        this.lastMatchFound = null;\n        this.qrCodeSuccessCallback = function(decodedText, result) {\n            if (qrCodeSuccessCallback) {\n                qrCodeSuccessCallback(decodedText, result);\n            } else {\n                if (_this.lastMatchFound === decodedText) {\n                    return;\n                }\n                _this.lastMatchFound = decodedText;\n                _this.setHeaderMessage(_strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.lastMatch(decodedText), Html5QrcodeScannerStatus.STATUS_SUCCESS);\n            }\n        };\n        this.qrCodeErrorCallback = function(errorMessage, error) {\n            if (qrCodeErrorCallback) {\n                qrCodeErrorCallback(errorMessage, error);\n            }\n        };\n        var container = document.getElementById(this.elementId);\n        if (!container) {\n            throw \"HTML Element with id=\".concat(this.elementId, \" not found\");\n        }\n        container.innerHTML = \"\";\n        this.createBasicLayout(container);\n        this.html5Qrcode = new _html5_qrcode__WEBPACK_IMPORTED_MODULE_1__.Html5Qrcode(this.getScanRegionId(), toHtml5QrcodeFullConfig(this.config, this.verbose));\n    };\n    Html5QrcodeScanner.prototype.pause = function(shouldPauseVideo) {\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(shouldPauseVideo) || shouldPauseVideo !== true) {\n            shouldPauseVideo = false;\n        }\n        this.getHtml5QrcodeOrFail().pause(shouldPauseVideo);\n    };\n    Html5QrcodeScanner.prototype.resume = function() {\n        this.getHtml5QrcodeOrFail().resume();\n    };\n    Html5QrcodeScanner.prototype.getState = function() {\n        return this.getHtml5QrcodeOrFail().getState();\n    };\n    Html5QrcodeScanner.prototype.clear = function() {\n        var _this = this;\n        var emptyHtmlContainer = function() {\n            var mainContainer = document.getElementById(_this.elementId);\n            if (mainContainer) {\n                mainContainer.innerHTML = \"\";\n                _this.resetBasicLayout(mainContainer);\n            }\n        };\n        if (this.html5Qrcode) {\n            return new Promise(function(resolve, reject) {\n                if (!_this.html5Qrcode) {\n                    resolve();\n                    return;\n                }\n                if (_this.html5Qrcode.isScanning) {\n                    _this.html5Qrcode.stop().then(function(_) {\n                        if (!_this.html5Qrcode) {\n                            resolve();\n                            return;\n                        }\n                        _this.html5Qrcode.clear();\n                        emptyHtmlContainer();\n                        resolve();\n                    }).catch(function(error) {\n                        if (_this.verbose) {\n                            _this.logger.logError(\"Unable to stop qrcode scanner\", error);\n                        }\n                        reject(error);\n                    });\n                } else {\n                    _this.html5Qrcode.clear();\n                    emptyHtmlContainer();\n                    resolve();\n                }\n            });\n        }\n        return Promise.resolve();\n    };\n    Html5QrcodeScanner.prototype.getRunningTrackCapabilities = function() {\n        return this.getHtml5QrcodeOrFail().getRunningTrackCapabilities();\n    };\n    Html5QrcodeScanner.prototype.getRunningTrackSettings = function() {\n        return this.getHtml5QrcodeOrFail().getRunningTrackSettings();\n    };\n    Html5QrcodeScanner.prototype.applyVideoConstraints = function(videoConstaints) {\n        return this.getHtml5QrcodeOrFail().applyVideoConstraints(videoConstaints);\n    };\n    Html5QrcodeScanner.prototype.getHtml5QrcodeOrFail = function() {\n        if (!this.html5Qrcode) {\n            throw \"Code scanner not initialized.\";\n        }\n        return this.html5Qrcode;\n    };\n    Html5QrcodeScanner.prototype.createConfig = function(config) {\n        if (config) {\n            if (!config.fps) {\n                config.fps = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.SCAN_DEFAULT_FPS;\n            }\n            if (config.rememberLastUsedCamera !== !_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED) {\n                config.rememberLastUsedCamera = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED;\n            }\n            if (!config.supportedScanTypes) {\n                config.supportedScanTypes = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE;\n            }\n            return config;\n        }\n        return {\n            fps: _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.SCAN_DEFAULT_FPS,\n            rememberLastUsedCamera: _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED,\n            supportedScanTypes: _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE\n        };\n    };\n    Html5QrcodeScanner.prototype.createBasicLayout = function(parent) {\n        parent.style.position = \"relative\";\n        parent.style.padding = \"0px\";\n        parent.style.border = \"1px solid silver\";\n        this.createHeader(parent);\n        var qrCodeScanRegion = document.createElement(\"div\");\n        var scanRegionId = this.getScanRegionId();\n        qrCodeScanRegion.id = scanRegionId;\n        qrCodeScanRegion.style.width = \"100%\";\n        qrCodeScanRegion.style.minHeight = \"100px\";\n        qrCodeScanRegion.style.textAlign = \"center\";\n        parent.appendChild(qrCodeScanRegion);\n        if (_ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType(this.currentScanType)) {\n            this.insertCameraScanImageToScanRegion();\n        } else {\n            this.insertFileScanImageToScanRegion();\n        }\n        var qrCodeDashboard = document.createElement(\"div\");\n        var dashboardId = this.getDashboardId();\n        qrCodeDashboard.id = dashboardId;\n        qrCodeDashboard.style.width = \"100%\";\n        parent.appendChild(qrCodeDashboard);\n        this.setupInitialDashboard(qrCodeDashboard);\n    };\n    Html5QrcodeScanner.prototype.resetBasicLayout = function(mainContainer) {\n        mainContainer.style.border = \"none\";\n    };\n    Html5QrcodeScanner.prototype.setupInitialDashboard = function(dashboard) {\n        this.createSection(dashboard);\n        this.createSectionControlPanel();\n        if (this.scanTypeSelector.hasMoreThanOneScanType()) {\n            this.createSectionSwap();\n        }\n    };\n    Html5QrcodeScanner.prototype.createHeader = function(dashboard) {\n        var header = document.createElement(\"div\");\n        header.style.textAlign = \"left\";\n        header.style.margin = \"0px\";\n        dashboard.appendChild(header);\n        var libraryInfo = new _ui__WEBPACK_IMPORTED_MODULE_5__.LibraryInfoContainer();\n        libraryInfo.renderInto(header);\n        var headerMessageContainer = document.createElement(\"div\");\n        headerMessageContainer.id = this.getHeaderMessageContainerId();\n        headerMessageContainer.style.display = \"none\";\n        headerMessageContainer.style.textAlign = \"center\";\n        headerMessageContainer.style.fontSize = \"14px\";\n        headerMessageContainer.style.padding = \"2px 10px\";\n        headerMessageContainer.style.margin = \"4px\";\n        headerMessageContainer.style.borderTop = \"1px solid #f6f6f6\";\n        header.appendChild(headerMessageContainer);\n    };\n    Html5QrcodeScanner.prototype.createSection = function(dashboard) {\n        var section = document.createElement(\"div\");\n        section.id = this.getDashboardSectionId();\n        section.style.width = \"100%\";\n        section.style.padding = \"10px 0px 10px 0px\";\n        section.style.textAlign = \"left\";\n        dashboard.appendChild(section);\n    };\n    Html5QrcodeScanner.prototype.createCameraListUi = function(scpCameraScanRegion, requestPermissionContainer, requestPermissionButton) {\n        var $this = this;\n        $this.showHideScanTypeSwapLink(false);\n        $this.setHeaderMessage(_strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.cameraPermissionRequesting());\n        var createPermissionButtonIfNotExists = function() {\n            if (!requestPermissionButton) {\n                $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);\n            }\n        };\n        _html5_qrcode__WEBPACK_IMPORTED_MODULE_1__.Html5Qrcode.getCameras().then(function(cameras) {\n            $this.persistedDataManager.setHasPermission(true);\n            $this.showHideScanTypeSwapLink(true);\n            $this.resetHeaderMessage();\n            if (cameras && cameras.length > 0) {\n                scpCameraScanRegion.removeChild(requestPermissionContainer);\n                $this.renderCameraSelection(cameras);\n            } else {\n                $this.setHeaderMessage(_strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.noCameraFound(), Html5QrcodeScannerStatus.STATUS_WARNING);\n                createPermissionButtonIfNotExists();\n            }\n        }).catch(function(error) {\n            $this.persistedDataManager.setHasPermission(false);\n            if (requestPermissionButton) {\n                requestPermissionButton.disabled = false;\n            } else {\n                createPermissionButtonIfNotExists();\n            }\n            $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);\n            $this.showHideScanTypeSwapLink(true);\n        });\n    };\n    Html5QrcodeScanner.prototype.createPermissionButton = function(scpCameraScanRegion, requestPermissionContainer) {\n        var $this = this;\n        var requestPermissionButton = _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.BaseUiElementFactory.createElement(\"button\", this.getCameraPermissionButtonId());\n        requestPermissionButton.innerText = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.cameraPermissionTitle();\n        requestPermissionButton.addEventListener(\"click\", function() {\n            requestPermissionButton.disabled = true;\n            $this.createCameraListUi(scpCameraScanRegion, requestPermissionContainer, requestPermissionButton);\n        });\n        requestPermissionContainer.appendChild(requestPermissionButton);\n    };\n    Html5QrcodeScanner.prototype.createPermissionsUi = function(scpCameraScanRegion, requestPermissionContainer) {\n        var $this = this;\n        if (_ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType(this.currentScanType) && this.persistedDataManager.hasCameraPermissions()) {\n            _camera_permissions__WEBPACK_IMPORTED_MODULE_6__.CameraPermissions.hasPermissions().then(function(hasPermissions) {\n                if (hasPermissions) {\n                    $this.createCameraListUi(scpCameraScanRegion, requestPermissionContainer);\n                } else {\n                    $this.persistedDataManager.setHasPermission(false);\n                    $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);\n                }\n            }).catch(function(_) {\n                $this.persistedDataManager.setHasPermission(false);\n                $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);\n            });\n            return;\n        }\n        this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);\n    };\n    Html5QrcodeScanner.prototype.createSectionControlPanel = function() {\n        var section = document.getElementById(this.getDashboardSectionId());\n        var sectionControlPanel = document.createElement(\"div\");\n        section.appendChild(sectionControlPanel);\n        var scpCameraScanRegion = document.createElement(\"div\");\n        scpCameraScanRegion.id = this.getDashboardSectionCameraScanRegionId();\n        scpCameraScanRegion.style.display = _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType(this.currentScanType) ? \"block\" : \"none\";\n        sectionControlPanel.appendChild(scpCameraScanRegion);\n        var requestPermissionContainer = document.createElement(\"div\");\n        requestPermissionContainer.style.textAlign = \"center\";\n        scpCameraScanRegion.appendChild(requestPermissionContainer);\n        if (this.scanTypeSelector.isCameraScanRequired()) {\n            this.createPermissionsUi(scpCameraScanRegion, requestPermissionContainer);\n        }\n        this.renderFileScanUi(sectionControlPanel);\n    };\n    Html5QrcodeScanner.prototype.renderFileScanUi = function(parent) {\n        var showOnRender = _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isFileScanType(this.currentScanType);\n        var $this = this;\n        var onFileSelected = function(file) {\n            if (!$this.html5Qrcode) {\n                throw \"html5Qrcode not defined\";\n            }\n            if (!_ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isFileScanType($this.currentScanType)) {\n                return;\n            }\n            $this.setHeaderMessage(_strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.loadingImage());\n            $this.html5Qrcode.scanFileV2(file, true).then(function(html5qrcodeResult) {\n                $this.resetHeaderMessage();\n                $this.qrCodeSuccessCallback(html5qrcodeResult.decodedText, html5qrcodeResult);\n            }).catch(function(error) {\n                $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);\n                $this.qrCodeErrorCallback(error, _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeErrorFactory.createFrom(error));\n            });\n        };\n        this.fileSelectionUi = _ui_scanner_file_selection_ui__WEBPACK_IMPORTED_MODULE_9__.FileSelectionUi.create(parent, showOnRender, onFileSelected);\n    };\n    Html5QrcodeScanner.prototype.renderCameraSelection = function(cameras) {\n        var _this = this;\n        var $this = this;\n        var scpCameraScanRegion = document.getElementById(this.getDashboardSectionCameraScanRegionId());\n        scpCameraScanRegion.style.textAlign = \"center\";\n        var cameraZoomUi = _ui_scanner_camera_zoom_ui__WEBPACK_IMPORTED_MODULE_12__.CameraZoomUi.create(scpCameraScanRegion, false);\n        var renderCameraZoomUiIfSupported = function(cameraCapabilities) {\n            var zoomCapability = cameraCapabilities.zoomFeature();\n            if (!zoomCapability.isSupported()) {\n                return;\n            }\n            cameraZoomUi.setOnCameraZoomValueChangeCallback(function(zoomValue) {\n                zoomCapability.apply(zoomValue);\n            });\n            var defaultZoom = 1;\n            if (_this.config.defaultZoomValueIfSupported) {\n                defaultZoom = _this.config.defaultZoomValueIfSupported;\n            }\n            defaultZoom = (0,_core__WEBPACK_IMPORTED_MODULE_0__.clip)(defaultZoom, zoomCapability.min(), zoomCapability.max());\n            cameraZoomUi.setValues(zoomCapability.min(), zoomCapability.max(), defaultZoom, zoomCapability.step());\n            cameraZoomUi.show();\n        };\n        var cameraSelectUi = _ui_scanner_camera_selection_ui__WEBPACK_IMPORTED_MODULE_11__.CameraSelectionUi.create(scpCameraScanRegion, cameras);\n        var cameraActionContainer = document.createElement(\"span\");\n        var cameraActionStartButton = _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.BaseUiElementFactory.createElement(\"button\", _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.PublicUiElementIdAndClasses.CAMERA_START_BUTTON_ID);\n        cameraActionStartButton.innerText = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.scanButtonStartScanningText();\n        cameraActionContainer.appendChild(cameraActionStartButton);\n        var cameraActionStopButton = _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.BaseUiElementFactory.createElement(\"button\", _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.PublicUiElementIdAndClasses.CAMERA_STOP_BUTTON_ID);\n        cameraActionStopButton.innerText = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.scanButtonStopScanningText();\n        cameraActionStopButton.style.display = \"none\";\n        cameraActionStopButton.disabled = true;\n        cameraActionContainer.appendChild(cameraActionStopButton);\n        var torchButton;\n        var createAndShowTorchButtonIfSupported = function(cameraCapabilities) {\n            if (!cameraCapabilities.torchFeature().isSupported()) {\n                if (torchButton) {\n                    torchButton.hide();\n                }\n                return;\n            }\n            if (!torchButton) {\n                torchButton = _ui_scanner_torch_button__WEBPACK_IMPORTED_MODULE_8__.TorchButton.create(cameraActionContainer, cameraCapabilities.torchFeature(), {\n                    display: \"none\",\n                    marginLeft: \"5px\"\n                }, function(errorMessage) {\n                    $this.setHeaderMessage(errorMessage, Html5QrcodeScannerStatus.STATUS_WARNING);\n                });\n            } else {\n                torchButton.updateTorchCapability(cameraCapabilities.torchFeature());\n            }\n            torchButton.show();\n        };\n        scpCameraScanRegion.appendChild(cameraActionContainer);\n        var resetCameraActionStartButton = function(shouldShow) {\n            if (!shouldShow) {\n                cameraActionStartButton.style.display = \"none\";\n            }\n            cameraActionStartButton.innerText = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.scanButtonStartScanningText();\n            cameraActionStartButton.style.opacity = \"1\";\n            cameraActionStartButton.disabled = false;\n            if (shouldShow) {\n                cameraActionStartButton.style.display = \"inline-block\";\n            }\n        };\n        cameraActionStartButton.addEventListener(\"click\", function(_) {\n            cameraActionStartButton.innerText = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.scanButtonScanningStarting();\n            cameraSelectUi.disable();\n            cameraActionStartButton.disabled = true;\n            cameraActionStartButton.style.opacity = \"0.5\";\n            if (_this.scanTypeSelector.hasMoreThanOneScanType()) {\n                $this.showHideScanTypeSwapLink(false);\n            }\n            $this.resetHeaderMessage();\n            var cameraId = cameraSelectUi.getValue();\n            $this.persistedDataManager.setLastUsedCameraId(cameraId);\n            $this.html5Qrcode.start(cameraId, toHtml5QrcodeCameraScanConfig($this.config), $this.qrCodeSuccessCallback, $this.qrCodeErrorCallback).then(function(_) {\n                cameraActionStopButton.disabled = false;\n                cameraActionStopButton.style.display = \"inline-block\";\n                resetCameraActionStartButton(false);\n                var cameraCapabilities = $this.html5Qrcode.getRunningTrackCameraCapabilities();\n                if (_this.config.showTorchButtonIfSupported === true) {\n                    createAndShowTorchButtonIfSupported(cameraCapabilities);\n                }\n                if (_this.config.showZoomSliderIfSupported === true) {\n                    renderCameraZoomUiIfSupported(cameraCapabilities);\n                }\n            }).catch(function(error) {\n                $this.showHideScanTypeSwapLink(true);\n                cameraSelectUi.enable();\n                resetCameraActionStartButton(true);\n                $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);\n            });\n        });\n        if (cameraSelectUi.hasSingleItem()) {\n            cameraActionStartButton.click();\n        }\n        cameraActionStopButton.addEventListener(\"click\", function(_) {\n            if (!$this.html5Qrcode) {\n                throw \"html5Qrcode not defined\";\n            }\n            cameraActionStopButton.disabled = true;\n            $this.html5Qrcode.stop().then(function(_) {\n                if (_this.scanTypeSelector.hasMoreThanOneScanType()) {\n                    $this.showHideScanTypeSwapLink(true);\n                }\n                cameraSelectUi.enable();\n                cameraActionStartButton.disabled = false;\n                cameraActionStopButton.style.display = \"none\";\n                cameraActionStartButton.style.display = \"inline-block\";\n                if (torchButton) {\n                    torchButton.reset();\n                    torchButton.hide();\n                }\n                cameraZoomUi.removeOnCameraZoomValueChangeCallback();\n                cameraZoomUi.hide();\n                $this.insertCameraScanImageToScanRegion();\n            }).catch(function(error) {\n                cameraActionStopButton.disabled = false;\n                $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);\n            });\n        });\n        if ($this.persistedDataManager.getLastUsedCameraId()) {\n            var cameraId = $this.persistedDataManager.getLastUsedCameraId();\n            if (cameraSelectUi.hasValue(cameraId)) {\n                cameraSelectUi.setValue(cameraId);\n                cameraActionStartButton.click();\n            } else {\n                $this.persistedDataManager.resetLastUsedCameraId();\n            }\n        }\n    };\n    Html5QrcodeScanner.prototype.createSectionSwap = function() {\n        var $this = this;\n        var TEXT_IF_CAMERA_SCAN_SELECTED = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.textIfCameraScanSelected();\n        var TEXT_IF_FILE_SCAN_SELECTED = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.textIfFileScanSelected();\n        var section = document.getElementById(this.getDashboardSectionId());\n        var switchContainer = document.createElement(\"div\");\n        switchContainer.style.textAlign = \"center\";\n        var switchScanTypeLink = _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.BaseUiElementFactory.createElement(\"span\", this.getDashboardSectionSwapLinkId());\n        switchScanTypeLink.style.textDecoration = \"underline\";\n        switchScanTypeLink.style.cursor = \"pointer\";\n        switchScanTypeLink.innerText = _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType(this.currentScanType) ? TEXT_IF_CAMERA_SCAN_SELECTED : TEXT_IF_FILE_SCAN_SELECTED;\n        switchScanTypeLink.addEventListener(\"click\", function() {\n            if (!$this.sectionSwapAllowed) {\n                if ($this.verbose) {\n                    $this.logger.logError(\"Section swap called when not allowed\");\n                }\n                return;\n            }\n            $this.resetHeaderMessage();\n            $this.fileSelectionUi.resetValue();\n            $this.sectionSwapAllowed = false;\n            if (_ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType($this.currentScanType)) {\n                $this.clearScanRegion();\n                $this.getCameraScanRegion().style.display = \"none\";\n                $this.fileSelectionUi.show();\n                switchScanTypeLink.innerText = TEXT_IF_FILE_SCAN_SELECTED;\n                $this.currentScanType = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScanType.SCAN_TYPE_FILE;\n                $this.insertFileScanImageToScanRegion();\n            } else {\n                $this.clearScanRegion();\n                $this.getCameraScanRegion().style.display = \"block\";\n                $this.fileSelectionUi.hide();\n                switchScanTypeLink.innerText = TEXT_IF_CAMERA_SCAN_SELECTED;\n                $this.currentScanType = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScanType.SCAN_TYPE_CAMERA;\n                $this.insertCameraScanImageToScanRegion();\n                $this.startCameraScanIfPermissionExistsOnSwap();\n            }\n            $this.sectionSwapAllowed = true;\n        });\n        switchContainer.appendChild(switchScanTypeLink);\n        section.appendChild(switchContainer);\n    };\n    Html5QrcodeScanner.prototype.startCameraScanIfPermissionExistsOnSwap = function() {\n        var _this = this;\n        var $this = this;\n        if (this.persistedDataManager.hasCameraPermissions()) {\n            _camera_permissions__WEBPACK_IMPORTED_MODULE_6__.CameraPermissions.hasPermissions().then(function(hasPermissions) {\n                if (hasPermissions) {\n                    var permissionButton = document.getElementById($this.getCameraPermissionButtonId());\n                    if (!permissionButton) {\n                        _this.logger.logError(\"Permission button not found, fail;\");\n                        throw \"Permission button not found\";\n                    }\n                    permissionButton.click();\n                } else {\n                    $this.persistedDataManager.setHasPermission(false);\n                }\n            }).catch(function(_) {\n                $this.persistedDataManager.setHasPermission(false);\n            });\n            return;\n        }\n    };\n    Html5QrcodeScanner.prototype.resetHeaderMessage = function() {\n        var messageDiv = document.getElementById(this.getHeaderMessageContainerId());\n        messageDiv.style.display = \"none\";\n    };\n    Html5QrcodeScanner.prototype.setHeaderMessage = function(messageText, scannerStatus) {\n        if (!scannerStatus) {\n            scannerStatus = Html5QrcodeScannerStatus.STATUS_DEFAULT;\n        }\n        var messageDiv = this.getHeaderMessageDiv();\n        messageDiv.innerText = messageText;\n        messageDiv.style.display = \"block\";\n        switch(scannerStatus){\n            case Html5QrcodeScannerStatus.STATUS_SUCCESS:\n                messageDiv.style.background = \"rgba(106, 175, 80, 0.26)\";\n                messageDiv.style.color = \"#477735\";\n                break;\n            case Html5QrcodeScannerStatus.STATUS_WARNING:\n                messageDiv.style.background = \"rgba(203, 36, 49, 0.14)\";\n                messageDiv.style.color = \"#cb2431\";\n                break;\n            case Html5QrcodeScannerStatus.STATUS_DEFAULT:\n            default:\n                messageDiv.style.background = \"rgba(0, 0, 0, 0)\";\n                messageDiv.style.color = \"rgb(17, 17, 17)\";\n                break;\n        }\n    };\n    Html5QrcodeScanner.prototype.showHideScanTypeSwapLink = function(shouldDisplay) {\n        if (this.scanTypeSelector.hasMoreThanOneScanType()) {\n            if (shouldDisplay !== true) {\n                shouldDisplay = false;\n            }\n            this.sectionSwapAllowed = shouldDisplay;\n            this.getDashboardSectionSwapLink().style.display = shouldDisplay ? \"inline-block\" : \"none\";\n        }\n    };\n    Html5QrcodeScanner.prototype.insertCameraScanImageToScanRegion = function() {\n        var $this = this;\n        var qrCodeScanRegion = document.getElementById(this.getScanRegionId());\n        if (this.cameraScanImage) {\n            qrCodeScanRegion.innerHTML = \"<br>\";\n            qrCodeScanRegion.appendChild(this.cameraScanImage);\n            return;\n        }\n        this.cameraScanImage = new Image;\n        this.cameraScanImage.onload = function(_) {\n            qrCodeScanRegion.innerHTML = \"<br>\";\n            qrCodeScanRegion.appendChild($this.cameraScanImage);\n        };\n        this.cameraScanImage.width = 64;\n        this.cameraScanImage.style.opacity = \"0.8\";\n        this.cameraScanImage.src = _image_assets__WEBPACK_IMPORTED_MODULE_3__.ASSET_CAMERA_SCAN;\n        this.cameraScanImage.alt = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.cameraScanAltText();\n    };\n    Html5QrcodeScanner.prototype.insertFileScanImageToScanRegion = function() {\n        var $this = this;\n        var qrCodeScanRegion = document.getElementById(this.getScanRegionId());\n        if (this.fileScanImage) {\n            qrCodeScanRegion.innerHTML = \"<br>\";\n            qrCodeScanRegion.appendChild(this.fileScanImage);\n            return;\n        }\n        this.fileScanImage = new Image;\n        this.fileScanImage.onload = function(_) {\n            qrCodeScanRegion.innerHTML = \"<br>\";\n            qrCodeScanRegion.appendChild($this.fileScanImage);\n        };\n        this.fileScanImage.width = 64;\n        this.fileScanImage.style.opacity = \"0.8\";\n        this.fileScanImage.src = _image_assets__WEBPACK_IMPORTED_MODULE_3__.ASSET_FILE_SCAN;\n        this.fileScanImage.alt = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.fileScanAltText();\n    };\n    Html5QrcodeScanner.prototype.clearScanRegion = function() {\n        var qrCodeScanRegion = document.getElementById(this.getScanRegionId());\n        qrCodeScanRegion.innerHTML = \"\";\n    };\n    Html5QrcodeScanner.prototype.getDashboardSectionId = function() {\n        return \"\".concat(this.elementId, \"__dashboard_section\");\n    };\n    Html5QrcodeScanner.prototype.getDashboardSectionCameraScanRegionId = function() {\n        return \"\".concat(this.elementId, \"__dashboard_section_csr\");\n    };\n    Html5QrcodeScanner.prototype.getDashboardSectionSwapLinkId = function() {\n        return _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.PublicUiElementIdAndClasses.SCAN_TYPE_CHANGE_ANCHOR_ID;\n    };\n    Html5QrcodeScanner.prototype.getScanRegionId = function() {\n        return \"\".concat(this.elementId, \"__scan_region\");\n    };\n    Html5QrcodeScanner.prototype.getDashboardId = function() {\n        return \"\".concat(this.elementId, \"__dashboard\");\n    };\n    Html5QrcodeScanner.prototype.getHeaderMessageContainerId = function() {\n        return \"\".concat(this.elementId, \"__header_message\");\n    };\n    Html5QrcodeScanner.prototype.getCameraPermissionButtonId = function() {\n        return _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.PublicUiElementIdAndClasses.CAMERA_PERMISSION_BUTTON_ID;\n    };\n    Html5QrcodeScanner.prototype.getCameraScanRegion = function() {\n        return document.getElementById(this.getDashboardSectionCameraScanRegionId());\n    };\n    Html5QrcodeScanner.prototype.getDashboardSectionSwapLink = function() {\n        return document.getElementById(this.getDashboardSectionSwapLinkId());\n    };\n    Html5QrcodeScanner.prototype.getHeaderMessageDiv = function() {\n        return document.getElementById(this.getHeaderMessageContainerId());\n    };\n    return Html5QrcodeScanner;\n}();\n //# sourceMappingURL=html5-qrcode-scanner.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9odG1sNS1xcmNvZGUtc2Nhbm5lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFtSTtBQUNyRjtBQUNTO0FBQ2M7QUFDcEI7QUFDTDtBQUNhO0FBQ1U7QUFDWDtBQUNTO0FBQ3FCO0FBQ2pCO0FBQ1Y7QUFDM0QsSUFBSW9CO0FBQ0gsVUFBVUEsd0JBQXdCO0lBQy9CQSx3QkFBd0IsQ0FBQ0Esd0JBQXdCLENBQUMsaUJBQWlCLEdBQUcsRUFBRSxHQUFHO0lBQzNFQSx3QkFBd0IsQ0FBQ0Esd0JBQXdCLENBQUMsaUJBQWlCLEdBQUcsRUFBRSxHQUFHO0lBQzNFQSx3QkFBd0IsQ0FBQ0Esd0JBQXdCLENBQUMsaUJBQWlCLEdBQUcsRUFBRSxHQUFHO0lBQzNFQSx3QkFBd0IsQ0FBQ0Esd0JBQXdCLENBQUMsK0JBQStCLEdBQUcsRUFBRSxHQUFHO0FBQzdGLEdBQUdBLDRCQUE2QkEsQ0FBQUEsMkJBQTJCLENBQUM7QUFDNUQsU0FBU0MsOEJBQThCQyxNQUFNO0lBQ3pDLE9BQU87UUFDSEMsS0FBS0QsT0FBT0MsR0FBRztRQUNmQyxPQUFPRixPQUFPRSxLQUFLO1FBQ25CQyxhQUFhSCxPQUFPRyxXQUFXO1FBQy9CQyxhQUFhSixPQUFPSSxXQUFXO1FBQy9CQyxrQkFBa0JMLE9BQU9LLGdCQUFnQjtJQUM3QztBQUNKO0FBQ0EsU0FBU0Msd0JBQXdCTixNQUFNLEVBQUVPLE9BQU87SUFDNUMsT0FBTztRQUNIQyxrQkFBa0JSLE9BQU9RLGdCQUFnQjtRQUN6Q0MsK0JBQStCVCxPQUFPUyw2QkFBNkI7UUFDbkVDLHNCQUFzQlYsT0FBT1Usb0JBQW9CO1FBQ2pESCxTQUFTQTtJQUNiO0FBQ0o7QUFDQSxJQUFJSSxxQkFBc0I7SUFDdEIsU0FBU0EsbUJBQW1CQyxTQUFTLEVBQUVaLE1BQU0sRUFBRU8sT0FBTztRQUNsRCxJQUFJLENBQUNNLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLGVB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Qm1CLFNBQVMsQ0FBQzRMLG1CQUFtQixHQUFHO1FBQy9DLE9BQU94TSxTQUFTQyxjQUFjLENBQUMsSUFBSSxDQUFDb0YsMkJBQTJCO0lBQ25FO0lBQ0EsT0FBTzVGO0FBQ1g7QUFDOEIsQ0FDOUIsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9wb3MvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9odG1sNS1xcmNvZGUtc2Nhbm5lci5qcz84N2I3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEh0bWw1UXJjb2RlQ29uc3RhbnRzLCBIdG1sNVFyY29kZVNjYW5UeXBlLCBIdG1sNVFyY29kZUVycm9yRmFjdG9yeSwgQmFzZUxvZ2dnZXIsIGlzTnVsbE9yVW5kZWZpbmVkLCBjbGlwLCB9IGZyb20gXCIuL2NvcmVcIjtcbmltcG9ydCB7IEh0bWw1UXJjb2RlLCB9IGZyb20gXCIuL2h0bWw1LXFyY29kZVwiO1xuaW1wb3J0IHsgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncywgfSBmcm9tIFwiLi9zdHJpbmdzXCI7XG5pbXBvcnQgeyBBU1NFVF9GSUxFX1NDQU4sIEFTU0VUX0NBTUVSQV9TQ0FOLCB9IGZyb20gXCIuL2ltYWdlLWFzc2V0c1wiO1xuaW1wb3J0IHsgUGVyc2lzdGVkRGF0YU1hbmFnZXIgfSBmcm9tIFwiLi9zdG9yYWdlXCI7XG5pbXBvcnQgeyBMaWJyYXJ5SW5mb0NvbnRhaW5lciB9IGZyb20gXCIuL3VpXCI7XG5pbXBvcnQgeyBDYW1lcmFQZXJtaXNzaW9ucyB9IGZyb20gXCIuL2NhbWVyYS9wZXJtaXNzaW9uc1wiO1xuaW1wb3J0IHsgU2NhblR5cGVTZWxlY3RvciB9IGZyb20gXCIuL3VpL3NjYW5uZXIvc2Nhbi10eXBlLXNlbGVjdG9yXCI7XG5pbXBvcnQgeyBUb3JjaEJ1dHRvbiB9IGZyb20gXCIuL3VpL3NjYW5uZXIvdG9yY2gtYnV0dG9uXCI7XG5pbXBvcnQgeyBGaWxlU2VsZWN0aW9uVWkgfSBmcm9tIFwiLi91aS9zY2FubmVyL2ZpbGUtc2VsZWN0aW9uLXVpXCI7XG5pbXBvcnQgeyBCYXNlVWlFbGVtZW50RmFjdG9yeSwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzIH0gZnJvbSBcIi4vdWkvc2Nhbm5lci9iYXNlXCI7XG5pbXBvcnQgeyBDYW1lcmFTZWxlY3Rpb25VaSB9IGZyb20gXCIuL3VpL3NjYW5uZXIvY2FtZXJhLXNlbGVjdGlvbi11aVwiO1xuaW1wb3J0IHsgQ2FtZXJhWm9vbVVpIH0gZnJvbSBcIi4vdWkvc2Nhbm5lci9jYW1lcmEtem9vbS11aVwiO1xudmFyIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cztcbihmdW5jdGlvbiAoSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzKSB7XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzW0h0bWw1UXJjb2RlU2Nhbm5lclN0YXR1c1tcIlNUQVRVU19ERUZBVUxUXCJdID0gMF0gPSBcIlNUQVRVU19ERUZBVUxUXCI7XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzW0h0bWw1UXJjb2RlU2Nhbm5lclN0YXR1c1tcIlNUQVRVU19TVUNDRVNTXCJdID0gMV0gPSBcIlNUQVRVU19TVUNDRVNTXCI7XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzW0h0bWw1UXJjb2RlU2Nhbm5lclN0YXR1c1tcIlNUQVRVU19XQVJOSU5HXCJdID0gMl0gPSBcIlNUQVRVU19XQVJOSU5HXCI7XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzW0h0bWw1UXJjb2RlU2Nhbm5lclN0YXR1c1tcIlNUQVRVU19SRVFVRVNUSU5HX1BFUk1JU1NJT05cIl0gPSAzXSA9IFwiU1RBVFVTX1JFUVVFU1RJTkdfUEVSTUlTU0lPTlwiO1xufSkoSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzIHx8IChIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMgPSB7fSkpO1xuZnVuY3Rpb24gdG9IdG1sNVFyY29kZUNhbWVyYVNjYW5Db25maWcoY29uZmlnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnBzOiBjb25maWcuZnBzLFxuICAgICAgICBxcmJveDogY29uZmlnLnFyYm94LFxuICAgICAgICBhc3BlY3RSYXRpbzogY29uZmlnLmFzcGVjdFJhdGlvLFxuICAgICAgICBkaXNhYmxlRmxpcDogY29uZmlnLmRpc2FibGVGbGlwLFxuICAgICAgICB2aWRlb0NvbnN0cmFpbnRzOiBjb25maWcudmlkZW9Db25zdHJhaW50c1xuICAgIH07XG59XG5mdW5jdGlvbiB0b0h0bWw1UXJjb2RlRnVsbENvbmZpZyhjb25maWcsIHZlcmJvc2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb3JtYXRzVG9TdXBwb3J0OiBjb25maWcuZm9ybWF0c1RvU3VwcG9ydCxcbiAgICAgICAgdXNlQmFyQ29kZURldGVjdG9ySWZTdXBwb3J0ZWQ6IGNvbmZpZy51c2VCYXJDb2RlRGV0ZWN0b3JJZlN1cHBvcnRlZCxcbiAgICAgICAgZXhwZXJpbWVudGFsRmVhdHVyZXM6IGNvbmZpZy5leHBlcmltZW50YWxGZWF0dXJlcyxcbiAgICAgICAgdmVyYm9zZTogdmVyYm9zZVxuICAgIH07XG59XG52YXIgSHRtbDVRcmNvZGVTY2FubmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNVFyY29kZVNjYW5uZXIoZWxlbWVudElkLCBjb25maWcsIHZlcmJvc2UpIHtcbiAgICAgICAgdGhpcy5sYXN0TWF0Y2hGb3VuZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FtZXJhU2NhbkltYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWxlU2NhbkltYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWxlU2VsZWN0aW9uVWkgPSBudWxsO1xuICAgICAgICB0aGlzLmVsZW1lbnRJZCA9IGVsZW1lbnRJZDtcbiAgICAgICAgdGhpcy5jb25maWcgPSB0aGlzLmNyZWF0ZUNvbmZpZyhjb25maWcpO1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSB2ZXJib3NlID09PSB0cnVlO1xuICAgICAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCkpIHtcbiAgICAgICAgICAgIHRocm93IFwiSFRNTCBFbGVtZW50IHdpdGggaWQ9XCIuY29uY2F0KGVsZW1lbnRJZCwgXCIgbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NhblR5cGVTZWxlY3RvciA9IG5ldyBTY2FuVHlwZVNlbGVjdG9yKHRoaXMuY29uZmlnLnN1cHBvcnRlZFNjYW5UeXBlcyk7XG4gICAgICAgIHRoaXMuY3VycmVudFNjYW5UeXBlID0gdGhpcy5zY2FuVHlwZVNlbGVjdG9yLmdldERlZmF1bHRTY2FuVHlwZSgpO1xuICAgICAgICB0aGlzLnNlY3Rpb25Td2FwQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbmV3IEJhc2VMb2dnZ2VyKHRoaXMudmVyYm9zZSk7XG4gICAgICAgIHRoaXMucGVyc2lzdGVkRGF0YU1hbmFnZXIgPSBuZXcgUGVyc2lzdGVkRGF0YU1hbmFnZXIoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5yZW1lbWJlckxhc3RVc2VkQ2FtZXJhICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocXJDb2RlU3VjY2Vzc0NhbGxiYWNrLCBxckNvZGVFcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoRm91bmQgPSBudWxsO1xuICAgICAgICB0aGlzLnFyQ29kZVN1Y2Nlc3NDYWxsYmFja1xuICAgICAgICAgICAgPSBmdW5jdGlvbiAoZGVjb2RlZFRleHQsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChxckNvZGVTdWNjZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcXJDb2RlU3VjY2Vzc0NhbGxiYWNrKGRlY29kZWRUZXh0LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmxhc3RNYXRjaEZvdW5kID09PSBkZWNvZGVkVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxhc3RNYXRjaEZvdW5kID0gZGVjb2RlZFRleHQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEhlYWRlck1lc3NhZ2UoSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5sYXN0TWF0Y2goZGVjb2RlZFRleHQpLCBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMuU1RBVFVTX1NVQ0NFU1MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMucXJDb2RlRXJyb3JDYWxsYmFjayA9XG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3JNZXNzYWdlLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChxckNvZGVFcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHFyQ29kZUVycm9yQ2FsbGJhY2soZXJyb3JNZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZWxlbWVudElkKTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHRocm93IFwiSFRNTCBFbGVtZW50IHdpdGggaWQ9XCIuY29uY2F0KHRoaXMuZWxlbWVudElkLCBcIiBub3QgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIHRoaXMuY3JlYXRlQmFzaWNMYXlvdXQoY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5odG1sNVFyY29kZSA9IG5ldyBIdG1sNVFyY29kZSh0aGlzLmdldFNjYW5SZWdpb25JZCgpLCB0b0h0bWw1UXJjb2RlRnVsbENvbmZpZyh0aGlzLmNvbmZpZywgdGhpcy52ZXJib3NlKSk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKHNob3VsZFBhdXNlVmlkZW8pIHtcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHNob3VsZFBhdXNlVmlkZW8pIHx8IHNob3VsZFBhdXNlVmlkZW8gIT09IHRydWUpIHtcbiAgICAgICAgICAgIHNob3VsZFBhdXNlVmlkZW8gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldEh0bWw1UXJjb2RlT3JGYWlsKCkucGF1c2Uoc2hvdWxkUGF1c2VWaWRlbyk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRIdG1sNVFyY29kZU9yRmFpbCgpLnJlc3VtZSgpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SHRtbDVRcmNvZGVPckZhaWwoKS5nZXRTdGF0ZSgpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVtcHR5SHRtbENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYWluQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoX3RoaXMuZWxlbWVudElkKTtcbiAgICAgICAgICAgIGlmIChtYWluQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgbWFpbkNvbnRhaW5lci5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0QmFzaWNMYXlvdXQobWFpbkNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmh0bWw1UXJjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaHRtbDVRcmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5odG1sNVFyY29kZS5pc1NjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmh0bWw1UXJjb2RlLnN0b3AoKS50aGVuKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmh0bWw1UXJjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmh0bWw1UXJjb2RlLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbXB0eUh0bWxDb250YWluZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2dFcnJvcihcIlVuYWJsZSB0byBzdG9wIHFyY29kZSBzY2FubmVyXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaHRtbDVRcmNvZGUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlIdG1sQ29udGFpbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldFJ1bm5pbmdUcmFja0NhcGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SHRtbDVRcmNvZGVPckZhaWwoKS5nZXRSdW5uaW5nVHJhY2tDYXBhYmlsaXRpZXMoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0UnVubmluZ1RyYWNrU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEh0bWw1UXJjb2RlT3JGYWlsKCkuZ2V0UnVubmluZ1RyYWNrU2V0dGluZ3MoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuYXBwbHlWaWRlb0NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHZpZGVvQ29uc3RhaW50cykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIdG1sNVFyY29kZU9yRmFpbCgpLmFwcGx5VmlkZW9Db25zdHJhaW50cyh2aWRlb0NvbnN0YWludHMpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5nZXRIdG1sNVFyY29kZU9yRmFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmh0bWw1UXJjb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNvZGUgc2Nhbm5lciBub3QgaW5pdGlhbGl6ZWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaHRtbDVRcmNvZGU7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmNyZWF0ZUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKCFjb25maWcuZnBzKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmZwcyA9IEh0bWw1UXJjb2RlQ29uc3RhbnRzLlNDQU5fREVGQVVMVF9GUFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLnJlbWVtYmVyTGFzdFVzZWRDYW1lcmEgIT09ICghSHRtbDVRcmNvZGVDb25zdGFudHMuREVGQVVMVF9SRU1FTUJFUl9MQVNUX0NBTUVSQV9VU0VEKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5yZW1lbWJlckxhc3RVc2VkQ2FtZXJhXG4gICAgICAgICAgICAgICAgICAgID0gSHRtbDVRcmNvZGVDb25zdGFudHMuREVGQVVMVF9SRU1FTUJFUl9MQVNUX0NBTUVSQV9VU0VEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25maWcuc3VwcG9ydGVkU2NhblR5cGVzKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnN1cHBvcnRlZFNjYW5UeXBlc1xuICAgICAgICAgICAgICAgICAgICA9IEh0bWw1UXJjb2RlQ29uc3RhbnRzLkRFRkFVTFRfU1VQUE9SVEVEX1NDQU5fVFlQRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZwczogSHRtbDVRcmNvZGVDb25zdGFudHMuU0NBTl9ERUZBVUxUX0ZQUyxcbiAgICAgICAgICAgIHJlbWVtYmVyTGFzdFVzZWRDYW1lcmE6IEh0bWw1UXJjb2RlQ29uc3RhbnRzLkRFRkFVTFRfUkVNRU1CRVJfTEFTVF9DQU1FUkFfVVNFRCxcbiAgICAgICAgICAgIHN1cHBvcnRlZFNjYW5UeXBlczogSHRtbDVRcmNvZGVDb25zdGFudHMuREVGQVVMVF9TVVBQT1JURURfU0NBTl9UWVBFXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmNyZWF0ZUJhc2ljTGF5b3V0ID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgIHBhcmVudC5zdHlsZS5wYWRkaW5nID0gXCIwcHhcIjtcbiAgICAgICAgcGFyZW50LnN0eWxlLmJvcmRlciA9IFwiMXB4IHNvbGlkIHNpbHZlclwiO1xuICAgICAgICB0aGlzLmNyZWF0ZUhlYWRlcihwYXJlbnQpO1xuICAgICAgICB2YXIgcXJDb2RlU2NhblJlZ2lvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBzY2FuUmVnaW9uSWQgPSB0aGlzLmdldFNjYW5SZWdpb25JZCgpO1xuICAgICAgICBxckNvZGVTY2FuUmVnaW9uLmlkID0gc2NhblJlZ2lvbklkO1xuICAgICAgICBxckNvZGVTY2FuUmVnaW9uLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgIHFyQ29kZVNjYW5SZWdpb24uc3R5bGUubWluSGVpZ2h0ID0gXCIxMDBweFwiO1xuICAgICAgICBxckNvZGVTY2FuUmVnaW9uLnN0eWxlLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChxckNvZGVTY2FuUmVnaW9uKTtcbiAgICAgICAgaWYgKFNjYW5UeXBlU2VsZWN0b3IuaXNDYW1lcmFTY2FuVHlwZSh0aGlzLmN1cnJlbnRTY2FuVHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0Q2FtZXJhU2NhbkltYWdlVG9TY2FuUmVnaW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEZpbGVTY2FuSW1hZ2VUb1NjYW5SZWdpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcXJDb2RlRGFzaGJvYXJkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIGRhc2hib2FyZElkID0gdGhpcy5nZXREYXNoYm9hcmRJZCgpO1xuICAgICAgICBxckNvZGVEYXNoYm9hcmQuaWQgPSBkYXNoYm9hcmRJZDtcbiAgICAgICAgcXJDb2RlRGFzaGJvYXJkLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChxckNvZGVEYXNoYm9hcmQpO1xuICAgICAgICB0aGlzLnNldHVwSW5pdGlhbERhc2hib2FyZChxckNvZGVEYXNoYm9hcmQpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5yZXNldEJhc2ljTGF5b3V0ID0gZnVuY3Rpb24gKG1haW5Db250YWluZXIpIHtcbiAgICAgICAgbWFpbkNvbnRhaW5lci5zdHlsZS5ib3JkZXIgPSBcIm5vbmVcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuc2V0dXBJbml0aWFsRGFzaGJvYXJkID0gZnVuY3Rpb24gKGRhc2hib2FyZCkge1xuICAgICAgICB0aGlzLmNyZWF0ZVNlY3Rpb24oZGFzaGJvYXJkKTtcbiAgICAgICAgdGhpcy5jcmVhdGVTZWN0aW9uQ29udHJvbFBhbmVsKCk7XG4gICAgICAgIGlmICh0aGlzLnNjYW5UeXBlU2VsZWN0b3IuaGFzTW9yZVRoYW5PbmVTY2FuVHlwZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVNlY3Rpb25Td2FwKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuY3JlYXRlSGVhZGVyID0gZnVuY3Rpb24gKGRhc2hib2FyZCkge1xuICAgICAgICB2YXIgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaGVhZGVyLnN0eWxlLnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICBoZWFkZXIuc3R5bGUubWFyZ2luID0gXCIwcHhcIjtcbiAgICAgICAgZGFzaGJvYXJkLmFwcGVuZENoaWxkKGhlYWRlcik7XG4gICAgICAgIHZhciBsaWJyYXJ5SW5mbyA9IG5ldyBMaWJyYXJ5SW5mb0NvbnRhaW5lcigpO1xuICAgICAgICBsaWJyYXJ5SW5mby5yZW5kZXJJbnRvKGhlYWRlcik7XG4gICAgICAgIHZhciBoZWFkZXJNZXNzYWdlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaGVhZGVyTWVzc2FnZUNvbnRhaW5lci5pZCA9IHRoaXMuZ2V0SGVhZGVyTWVzc2FnZUNvbnRhaW5lcklkKCk7XG4gICAgICAgIGhlYWRlck1lc3NhZ2VDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBoZWFkZXJNZXNzYWdlQ29udGFpbmVyLnN0eWxlLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIGhlYWRlck1lc3NhZ2VDb250YWluZXIuc3R5bGUuZm9udFNpemUgPSBcIjE0cHhcIjtcbiAgICAgICAgaGVhZGVyTWVzc2FnZUNvbnRhaW5lci5zdHlsZS5wYWRkaW5nID0gXCIycHggMTBweFwiO1xuICAgICAgICBoZWFkZXJNZXNzYWdlQ29udGFpbmVyLnN0eWxlLm1hcmdpbiA9IFwiNHB4XCI7XG4gICAgICAgIGhlYWRlck1lc3NhZ2VDb250YWluZXIuc3R5bGUuYm9yZGVyVG9wID0gXCIxcHggc29saWQgI2Y2ZjZmNlwiO1xuICAgICAgICBoZWFkZXIuYXBwZW5kQ2hpbGQoaGVhZGVyTWVzc2FnZUNvbnRhaW5lcik7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmNyZWF0ZVNlY3Rpb24gPSBmdW5jdGlvbiAoZGFzaGJvYXJkKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgc2VjdGlvbi5pZCA9IHRoaXMuZ2V0RGFzaGJvYXJkU2VjdGlvbklkKCk7XG4gICAgICAgIHNlY3Rpb24uc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgc2VjdGlvbi5zdHlsZS5wYWRkaW5nID0gXCIxMHB4IDBweCAxMHB4IDBweFwiO1xuICAgICAgICBzZWN0aW9uLnN0eWxlLnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICBkYXNoYm9hcmQuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmNyZWF0ZUNhbWVyYUxpc3RVaSA9IGZ1bmN0aW9uIChzY3BDYW1lcmFTY2FuUmVnaW9uLCByZXF1ZXN0UGVybWlzc2lvbkNvbnRhaW5lciwgcmVxdWVzdFBlcm1pc3Npb25CdXR0b24pIHtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgJHRoaXMuc2hvd0hpZGVTY2FuVHlwZVN3YXBMaW5rKGZhbHNlKTtcbiAgICAgICAgJHRoaXMuc2V0SGVhZGVyTWVzc2FnZShIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmNhbWVyYVBlcm1pc3Npb25SZXF1ZXN0aW5nKCkpO1xuICAgICAgICB2YXIgY3JlYXRlUGVybWlzc2lvbkJ1dHRvbklmTm90RXhpc3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0UGVybWlzc2lvbkJ1dHRvbikge1xuICAgICAgICAgICAgICAgICR0aGlzLmNyZWF0ZVBlcm1pc3Npb25CdXR0b24oc2NwQ2FtZXJhU2NhblJlZ2lvbiwgcmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBIdG1sNVFyY29kZS5nZXRDYW1lcmFzKCkudGhlbihmdW5jdGlvbiAoY2FtZXJhcykge1xuICAgICAgICAgICAgJHRoaXMucGVyc2lzdGVkRGF0YU1hbmFnZXIuc2V0SGFzUGVybWlzc2lvbih0cnVlKTtcbiAgICAgICAgICAgICR0aGlzLnNob3dIaWRlU2NhblR5cGVTd2FwTGluayh0cnVlKTtcbiAgICAgICAgICAgICR0aGlzLnJlc2V0SGVhZGVyTWVzc2FnZSgpO1xuICAgICAgICAgICAgaWYgKGNhbWVyYXMgJiYgY2FtZXJhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2NwQ2FtZXJhU2NhblJlZ2lvbi5yZW1vdmVDaGlsZChyZXF1ZXN0UGVybWlzc2lvbkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgJHRoaXMucmVuZGVyQ2FtZXJhU2VsZWN0aW9uKGNhbWVyYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuc2V0SGVhZGVyTWVzc2FnZShIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLm5vQ2FtZXJhRm91bmQoKSwgSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzLlNUQVRVU19XQVJOSU5HKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVQZXJtaXNzaW9uQnV0dG9uSWZOb3RFeGlzdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAkdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5zZXRIYXNQZXJtaXNzaW9uKGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGVybWlzc2lvbkJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RQZXJtaXNzaW9uQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVQZXJtaXNzaW9uQnV0dG9uSWZOb3RFeGlzdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR0aGlzLnNldEhlYWRlck1lc3NhZ2UoZXJyb3IsIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfV0FSTklORyk7XG4gICAgICAgICAgICAkdGhpcy5zaG93SGlkZVNjYW5UeXBlU3dhcExpbmsodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5jcmVhdGVQZXJtaXNzaW9uQnV0dG9uID0gZnVuY3Rpb24gKHNjcENhbWVyYVNjYW5SZWdpb24sIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKSB7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXF1ZXN0UGVybWlzc2lvbkJ1dHRvbiA9IEJhc2VVaUVsZW1lbnRGYWN0b3J5XG4gICAgICAgICAgICAuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB0aGlzLmdldENhbWVyYVBlcm1pc3Npb25CdXR0b25JZCgpKTtcbiAgICAgICAgcmVxdWVzdFBlcm1pc3Npb25CdXR0b24uaW5uZXJUZXh0XG4gICAgICAgICAgICA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuY2FtZXJhUGVybWlzc2lvblRpdGxlKCk7XG4gICAgICAgIHJlcXVlc3RQZXJtaXNzaW9uQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGVybWlzc2lvbkJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAkdGhpcy5jcmVhdGVDYW1lcmFMaXN0VWkoc2NwQ2FtZXJhU2NhblJlZ2lvbiwgcmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIsIHJlcXVlc3RQZXJtaXNzaW9uQnV0dG9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKHJlcXVlc3RQZXJtaXNzaW9uQnV0dG9uKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuY3JlYXRlUGVybWlzc2lvbnNVaSA9IGZ1bmN0aW9uIChzY3BDYW1lcmFTY2FuUmVnaW9uLCByZXF1ZXN0UGVybWlzc2lvbkNvbnRhaW5lcikge1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoU2NhblR5cGVTZWxlY3Rvci5pc0NhbWVyYVNjYW5UeXBlKHRoaXMuY3VycmVudFNjYW5UeXBlKVxuICAgICAgICAgICAgJiYgdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5oYXNDYW1lcmFQZXJtaXNzaW9ucygpKSB7XG4gICAgICAgICAgICBDYW1lcmFQZXJtaXNzaW9ucy5oYXNQZXJtaXNzaW9ucygpLnRoZW4oZnVuY3Rpb24gKGhhc1Blcm1pc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1Blcm1pc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmNyZWF0ZUNhbWVyYUxpc3RVaShzY3BDYW1lcmFTY2FuUmVnaW9uLCByZXF1ZXN0UGVybWlzc2lvbkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5zZXRIYXNQZXJtaXNzaW9uKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuY3JlYXRlUGVybWlzc2lvbkJ1dHRvbihzY3BDYW1lcmFTY2FuUmVnaW9uLCByZXF1ZXN0UGVybWlzc2lvbkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5zZXRIYXNQZXJtaXNzaW9uKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5jcmVhdGVQZXJtaXNzaW9uQnV0dG9uKHNjcENhbWVyYVNjYW5SZWdpb24sIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlUGVybWlzc2lvbkJ1dHRvbihzY3BDYW1lcmFTY2FuUmVnaW9uLCByZXF1ZXN0UGVybWlzc2lvbkNvbnRhaW5lcik7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmNyZWF0ZVNlY3Rpb25Db250cm9sUGFuZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5nZXREYXNoYm9hcmRTZWN0aW9uSWQoKSk7XG4gICAgICAgIHZhciBzZWN0aW9uQ29udHJvbFBhbmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZChzZWN0aW9uQ29udHJvbFBhbmVsKTtcbiAgICAgICAgdmFyIHNjcENhbWVyYVNjYW5SZWdpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzY3BDYW1lcmFTY2FuUmVnaW9uLmlkID0gdGhpcy5nZXREYXNoYm9hcmRTZWN0aW9uQ2FtZXJhU2NhblJlZ2lvbklkKCk7XG4gICAgICAgIHNjcENhbWVyYVNjYW5SZWdpb24uc3R5bGUuZGlzcGxheVxuICAgICAgICAgICAgPSBTY2FuVHlwZVNlbGVjdG9yLmlzQ2FtZXJhU2NhblR5cGUodGhpcy5jdXJyZW50U2NhblR5cGUpXG4gICAgICAgICAgICAgICAgPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgc2VjdGlvbkNvbnRyb2xQYW5lbC5hcHBlbmRDaGlsZChzY3BDYW1lcmFTY2FuUmVnaW9uKTtcbiAgICAgICAgdmFyIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgcmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIuc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgc2NwQ2FtZXJhU2NhblJlZ2lvbi5hcHBlbmRDaGlsZChyZXF1ZXN0UGVybWlzc2lvbkNvbnRhaW5lcik7XG4gICAgICAgIGlmICh0aGlzLnNjYW5UeXBlU2VsZWN0b3IuaXNDYW1lcmFTY2FuUmVxdWlyZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVQZXJtaXNzaW9uc1VpKHNjcENhbWVyYVNjYW5SZWdpb24sIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlckZpbGVTY2FuVWkoc2VjdGlvbkNvbnRyb2xQYW5lbCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLnJlbmRlckZpbGVTY2FuVWkgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBzaG93T25SZW5kZXIgPSBTY2FuVHlwZVNlbGVjdG9yLmlzRmlsZVNjYW5UeXBlKHRoaXMuY3VycmVudFNjYW5UeXBlKTtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9uRmlsZVNlbGVjdGVkID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgIGlmICghJHRoaXMuaHRtbDVRcmNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcImh0bWw1UXJjb2RlIG5vdCBkZWZpbmVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVNjYW5UeXBlU2VsZWN0b3IuaXNGaWxlU2NhblR5cGUoJHRoaXMuY3VycmVudFNjYW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR0aGlzLnNldEhlYWRlck1lc3NhZ2UoSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5sb2FkaW5nSW1hZ2UoKSk7XG4gICAgICAgICAgICAkdGhpcy5odG1sNVFyY29kZS5zY2FuRmlsZVYyKGZpbGUsIHRydWUpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGh0bWw1cXJjb2RlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgJHRoaXMucmVzZXRIZWFkZXJNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgJHRoaXMucXJDb2RlU3VjY2Vzc0NhbGxiYWNrKGh0bWw1cXJjb2RlUmVzdWx0LmRlY29kZWRUZXh0LCBodG1sNXFyY29kZVJlc3VsdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5zZXRIZWFkZXJNZXNzYWdlKGVycm9yLCBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMuU1RBVFVTX1dBUk5JTkcpO1xuICAgICAgICAgICAgICAgICR0aGlzLnFyQ29kZUVycm9yQ2FsbGJhY2soZXJyb3IsIEh0bWw1UXJjb2RlRXJyb3JGYWN0b3J5LmNyZWF0ZUZyb20oZXJyb3IpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZpbGVTZWxlY3Rpb25VaSA9IEZpbGVTZWxlY3Rpb25VaS5jcmVhdGUocGFyZW50LCBzaG93T25SZW5kZXIsIG9uRmlsZVNlbGVjdGVkKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUucmVuZGVyQ2FtZXJhU2VsZWN0aW9uID0gZnVuY3Rpb24gKGNhbWVyYXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNjcENhbWVyYVNjYW5SZWdpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldERhc2hib2FyZFNlY3Rpb25DYW1lcmFTY2FuUmVnaW9uSWQoKSk7XG4gICAgICAgIHNjcENhbWVyYVNjYW5SZWdpb24uc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgdmFyIGNhbWVyYVpvb21VaSA9IENhbWVyYVpvb21VaS5jcmVhdGUoc2NwQ2FtZXJhU2NhblJlZ2lvbiwgZmFsc2UpO1xuICAgICAgICB2YXIgcmVuZGVyQ2FtZXJhWm9vbVVpSWZTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoY2FtZXJhQ2FwYWJpbGl0aWVzKSB7XG4gICAgICAgICAgICB2YXIgem9vbUNhcGFiaWxpdHkgPSBjYW1lcmFDYXBhYmlsaXRpZXMuem9vbUZlYXR1cmUoKTtcbiAgICAgICAgICAgIGlmICghem9vbUNhcGFiaWxpdHkuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbWVyYVpvb21VaS5zZXRPbkNhbWVyYVpvb21WYWx1ZUNoYW5nZUNhbGxiYWNrKGZ1bmN0aW9uICh6b29tVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB6b29tQ2FwYWJpbGl0eS5hcHBseSh6b29tVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFpvb20gPSAxO1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5kZWZhdWx0Wm9vbVZhbHVlSWZTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Wm9vbSA9IF90aGlzLmNvbmZpZy5kZWZhdWx0Wm9vbVZhbHVlSWZTdXBwb3J0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0Wm9vbSA9IGNsaXAoZGVmYXVsdFpvb20sIHpvb21DYXBhYmlsaXR5Lm1pbigpLCB6b29tQ2FwYWJpbGl0eS5tYXgoKSk7XG4gICAgICAgICAgICBjYW1lcmFab29tVWkuc2V0VmFsdWVzKHpvb21DYXBhYmlsaXR5Lm1pbigpLCB6b29tQ2FwYWJpbGl0eS5tYXgoKSwgZGVmYXVsdFpvb20sIHpvb21DYXBhYmlsaXR5LnN0ZXAoKSk7XG4gICAgICAgICAgICBjYW1lcmFab29tVWkuc2hvdygpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2FtZXJhU2VsZWN0VWkgPSBDYW1lcmFTZWxlY3Rpb25VaS5jcmVhdGUoc2NwQ2FtZXJhU2NhblJlZ2lvbiwgY2FtZXJhcyk7XG4gICAgICAgIHZhciBjYW1lcmFBY3Rpb25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgdmFyIGNhbWVyYUFjdGlvblN0YXJ0QnV0dG9uID0gQmFzZVVpRWxlbWVudEZhY3RvcnkuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuQ0FNRVJBX1NUQVJUX0JVVFRPTl9JRCk7XG4gICAgICAgIGNhbWVyYUFjdGlvblN0YXJ0QnV0dG9uLmlubmVyVGV4dFxuICAgICAgICAgICAgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnNjYW5CdXR0b25TdGFydFNjYW5uaW5nVGV4dCgpO1xuICAgICAgICBjYW1lcmFBY3Rpb25Db250YWluZXIuYXBwZW5kQ2hpbGQoY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24pO1xuICAgICAgICB2YXIgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbiA9IEJhc2VVaUVsZW1lbnRGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLkNBTUVSQV9TVE9QX0JVVFRPTl9JRCk7XG4gICAgICAgIGNhbWVyYUFjdGlvblN0b3BCdXR0b24uaW5uZXJUZXh0XG4gICAgICAgICAgICA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Muc2NhbkJ1dHRvblN0b3BTY2FubmluZ1RleHQoKTtcbiAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIGNhbWVyYUFjdGlvblN0b3BCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBjYW1lcmFBY3Rpb25Db250YWluZXIuYXBwZW5kQ2hpbGQoY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbik7XG4gICAgICAgIHZhciB0b3JjaEJ1dHRvbjtcbiAgICAgICAgdmFyIGNyZWF0ZUFuZFNob3dUb3JjaEJ1dHRvbklmU3VwcG9ydGVkID0gZnVuY3Rpb24gKGNhbWVyYUNhcGFiaWxpdGllcykge1xuICAgICAgICAgICAgaWYgKCFjYW1lcmFDYXBhYmlsaXRpZXMudG9yY2hGZWF0dXJlKCkuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3JjaEJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICB0b3JjaEJ1dHRvbi5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdG9yY2hCdXR0b24pIHtcbiAgICAgICAgICAgICAgICB0b3JjaEJ1dHRvbiA9IFRvcmNoQnV0dG9uLmNyZWF0ZShjYW1lcmFBY3Rpb25Db250YWluZXIsIGNhbWVyYUNhcGFiaWxpdGllcy50b3JjaEZlYXR1cmUoKSwgeyBkaXNwbGF5OiBcIm5vbmVcIiwgbWFyZ2luTGVmdDogXCI1cHhcIiB9LCBmdW5jdGlvbiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnNldEhlYWRlck1lc3NhZ2UoZXJyb3JNZXNzYWdlLCBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMuU1RBVFVTX1dBUk5JTkcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9yY2hCdXR0b24udXBkYXRlVG9yY2hDYXBhYmlsaXR5KGNhbWVyYUNhcGFiaWxpdGllcy50b3JjaEZlYXR1cmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3JjaEJ1dHRvbi5zaG93KCk7XG4gICAgICAgIH07XG4gICAgICAgIHNjcENhbWVyYVNjYW5SZWdpb24uYXBwZW5kQ2hpbGQoY2FtZXJhQWN0aW9uQ29udGFpbmVyKTtcbiAgICAgICAgdmFyIHJlc2V0Q2FtZXJhQWN0aW9uU3RhcnRCdXR0b24gPSBmdW5jdGlvbiAoc2hvdWxkU2hvdykge1xuICAgICAgICAgICAgaWYgKCFzaG91bGRTaG93KSB7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uaW5uZXJUZXh0XG4gICAgICAgICAgICAgICAgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FuQnV0dG9uU3RhcnRTY2FubmluZ1RleHQoKTtcbiAgICAgICAgICAgIGNhbWVyYUFjdGlvblN0YXJ0QnV0dG9uLnN0eWxlLm9wYWNpdHkgPSBcIjFcIjtcbiAgICAgICAgICAgIGNhbWVyYUFjdGlvblN0YXJ0QnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU2hvdykge1xuICAgICAgICAgICAgICAgIGNhbWVyYUFjdGlvblN0YXJ0QnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGNhbWVyYUFjdGlvblN0YXJ0QnV0dG9uLmlubmVyVGV4dFxuICAgICAgICAgICAgICAgID0gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5zY2FuQnV0dG9uU2Nhbm5pbmdTdGFydGluZygpO1xuICAgICAgICAgICAgY2FtZXJhU2VsZWN0VWkuZGlzYWJsZSgpO1xuICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uc3R5bGUub3BhY2l0eSA9IFwiMC41XCI7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2NhblR5cGVTZWxlY3Rvci5oYXNNb3JlVGhhbk9uZVNjYW5UeXBlKCkpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5zaG93SGlkZVNjYW5UeXBlU3dhcExpbmsoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHRoaXMucmVzZXRIZWFkZXJNZXNzYWdlKCk7XG4gICAgICAgICAgICB2YXIgY2FtZXJhSWQgPSBjYW1lcmFTZWxlY3RVaS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgJHRoaXMucGVyc2lzdGVkRGF0YU1hbmFnZXIuc2V0TGFzdFVzZWRDYW1lcmFJZChjYW1lcmFJZCk7XG4gICAgICAgICAgICAkdGhpcy5odG1sNVFyY29kZS5zdGFydChjYW1lcmFJZCwgdG9IdG1sNVFyY29kZUNhbWVyYVNjYW5Db25maWcoJHRoaXMuY29uZmlnKSwgJHRoaXMucXJDb2RlU3VjY2Vzc0NhbGxiYWNrLCAkdGhpcy5xckNvZGVFcnJvckNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNhbWVyYUFjdGlvblN0b3BCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgICAgICAgICAgcmVzZXRDYW1lcmFBY3Rpb25TdGFydEJ1dHRvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNhbWVyYUNhcGFiaWxpdGllcyA9ICR0aGlzLmh0bWw1UXJjb2RlLmdldFJ1bm5pbmdUcmFja0NhbWVyYUNhcGFiaWxpdGllcygpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb25maWcuc2hvd1RvcmNoQnV0dG9uSWZTdXBwb3J0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQW5kU2hvd1RvcmNoQnV0dG9uSWZTdXBwb3J0ZWQoY2FtZXJhQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5zaG93Wm9vbVNsaWRlcklmU3VwcG9ydGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckNhbWVyYVpvb21VaUlmU3VwcG9ydGVkKGNhbWVyYUNhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuc2hvd0hpZGVTY2FuVHlwZVN3YXBMaW5rKHRydWUpO1xuICAgICAgICAgICAgICAgIGNhbWVyYVNlbGVjdFVpLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIHJlc2V0Q2FtZXJhQWN0aW9uU3RhcnRCdXR0b24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgJHRoaXMuc2V0SGVhZGVyTWVzc2FnZShlcnJvciwgSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzLlNUQVRVU19XQVJOSU5HKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhbWVyYVNlbGVjdFVpLmhhc1NpbmdsZUl0ZW0oKSkge1xuICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uY2xpY2soKTtcbiAgICAgICAgfVxuICAgICAgICBjYW1lcmFBY3Rpb25TdG9wQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCEkdGhpcy5odG1sNVFyY29kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiaHRtbDVRcmNvZGUgbm90IGRlZmluZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbWVyYUFjdGlvblN0b3BCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgJHRoaXMuaHRtbDVRcmNvZGUuc3RvcCgpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc2NhblR5cGVTZWxlY3Rvci5oYXNNb3JlVGhhbk9uZVNjYW5UeXBlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuc2hvd0hpZGVTY2FuVHlwZVN3YXBMaW5rKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYW1lcmFTZWxlY3RVaS5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICBjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNhbWVyYUFjdGlvblN0b3BCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIGNhbWVyYUFjdGlvblN0YXJ0QnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICAgICAgICAgIGlmICh0b3JjaEJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICB0b3JjaEJ1dHRvbi5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICB0b3JjaEJ1dHRvbi5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbWVyYVpvb21VaS5yZW1vdmVPbkNhbWVyYVpvb21WYWx1ZUNoYW5nZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgY2FtZXJhWm9vbVVpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5pbnNlcnRDYW1lcmFTY2FuSW1hZ2VUb1NjYW5SZWdpb24oKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhbWVyYUFjdGlvblN0b3BCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAkdGhpcy5zZXRIZWFkZXJNZXNzYWdlKGVycm9yLCBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMuU1RBVFVTX1dBUk5JTkcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoJHRoaXMucGVyc2lzdGVkRGF0YU1hbmFnZXIuZ2V0TGFzdFVzZWRDYW1lcmFJZCgpKSB7XG4gICAgICAgICAgICB2YXIgY2FtZXJhSWQgPSAkdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5nZXRMYXN0VXNlZENhbWVyYUlkKCk7XG4gICAgICAgICAgICBpZiAoY2FtZXJhU2VsZWN0VWkuaGFzVmFsdWUoY2FtZXJhSWQpKSB7XG4gICAgICAgICAgICAgICAgY2FtZXJhU2VsZWN0VWkuc2V0VmFsdWUoY2FtZXJhSWQpO1xuICAgICAgICAgICAgICAgIGNhbWVyYUFjdGlvblN0YXJ0QnV0dG9uLmNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5yZXNldExhc3RVc2VkQ2FtZXJhSWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5jcmVhdGVTZWN0aW9uU3dhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIFRFWFRfSUZfQ0FNRVJBX1NDQU5fU0VMRUNURUQgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnRleHRJZkNhbWVyYVNjYW5TZWxlY3RlZCgpO1xuICAgICAgICB2YXIgVEVYVF9JRl9GSUxFX1NDQU5fU0VMRUNURUQgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnRleHRJZkZpbGVTY2FuU2VsZWN0ZWQoKTtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldERhc2hib2FyZFNlY3Rpb25JZCgpKTtcbiAgICAgICAgdmFyIHN3aXRjaENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHN3aXRjaENvbnRhaW5lci5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB2YXIgc3dpdGNoU2NhblR5cGVMaW5rID0gQmFzZVVpRWxlbWVudEZhY3RvcnkuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgdGhpcy5nZXREYXNoYm9hcmRTZWN0aW9uU3dhcExpbmtJZCgpKTtcbiAgICAgICAgc3dpdGNoU2NhblR5cGVMaW5rLnN0eWxlLnRleHREZWNvcmF0aW9uID0gXCJ1bmRlcmxpbmVcIjtcbiAgICAgICAgc3dpdGNoU2NhblR5cGVMaW5rLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xuICAgICAgICBzd2l0Y2hTY2FuVHlwZUxpbmsuaW5uZXJUZXh0XG4gICAgICAgICAgICA9IFNjYW5UeXBlU2VsZWN0b3IuaXNDYW1lcmFTY2FuVHlwZSh0aGlzLmN1cnJlbnRTY2FuVHlwZSlcbiAgICAgICAgICAgICAgICA/IFRFWFRfSUZfQ0FNRVJBX1NDQU5fU0VMRUNURUQgOiBURVhUX0lGX0ZJTEVfU0NBTl9TRUxFQ1RFRDtcbiAgICAgICAgc3dpdGNoU2NhblR5cGVMaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISR0aGlzLnNlY3Rpb25Td2FwQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIGlmICgkdGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmxvZ2dlci5sb2dFcnJvcihcIlNlY3Rpb24gc3dhcCBjYWxsZWQgd2hlbiBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHRoaXMucmVzZXRIZWFkZXJNZXNzYWdlKCk7XG4gICAgICAgICAgICAkdGhpcy5maWxlU2VsZWN0aW9uVWkucmVzZXRWYWx1ZSgpO1xuICAgICAgICAgICAgJHRoaXMuc2VjdGlvblN3YXBBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoU2NhblR5cGVTZWxlY3Rvci5pc0NhbWVyYVNjYW5UeXBlKCR0aGlzLmN1cnJlbnRTY2FuVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5jbGVhclNjYW5SZWdpb24oKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5nZXRDYW1lcmFTY2FuUmVnaW9uKCkuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICR0aGlzLmZpbGVTZWxlY3Rpb25VaS5zaG93KCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoU2NhblR5cGVMaW5rLmlubmVyVGV4dCA9IFRFWFRfSUZfRklMRV9TQ0FOX1NFTEVDVEVEO1xuICAgICAgICAgICAgICAgICR0aGlzLmN1cnJlbnRTY2FuVHlwZSA9IEh0bWw1UXJjb2RlU2NhblR5cGUuU0NBTl9UWVBFX0ZJTEU7XG4gICAgICAgICAgICAgICAgJHRoaXMuaW5zZXJ0RmlsZVNjYW5JbWFnZVRvU2NhblJlZ2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuY2xlYXJTY2FuUmVnaW9uKCk7XG4gICAgICAgICAgICAgICAgJHRoaXMuZ2V0Q2FtZXJhU2NhblJlZ2lvbigpLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICAgICAgJHRoaXMuZmlsZVNlbGVjdGlvblVpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hTY2FuVHlwZUxpbmsuaW5uZXJUZXh0ID0gVEVYVF9JRl9DQU1FUkFfU0NBTl9TRUxFQ1RFRDtcbiAgICAgICAgICAgICAgICAkdGhpcy5jdXJyZW50U2NhblR5cGUgPSBIdG1sNVFyY29kZVNjYW5UeXBlLlNDQU5fVFlQRV9DQU1FUkE7XG4gICAgICAgICAgICAgICAgJHRoaXMuaW5zZXJ0Q2FtZXJhU2NhbkltYWdlVG9TY2FuUmVnaW9uKCk7XG4gICAgICAgICAgICAgICAgJHRoaXMuc3RhcnRDYW1lcmFTY2FuSWZQZXJtaXNzaW9uRXhpc3RzT25Td2FwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkdGhpcy5zZWN0aW9uU3dhcEFsbG93ZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3dpdGNoQ29udGFpbmVyLmFwcGVuZENoaWxkKHN3aXRjaFNjYW5UeXBlTGluayk7XG4gICAgICAgIHNlY3Rpb24uYXBwZW5kQ2hpbGQoc3dpdGNoQ29udGFpbmVyKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuc3RhcnRDYW1lcmFTY2FuSWZQZXJtaXNzaW9uRXhpc3RzT25Td2FwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5oYXNDYW1lcmFQZXJtaXNzaW9ucygpKSB7XG4gICAgICAgICAgICBDYW1lcmFQZXJtaXNzaW9ucy5oYXNQZXJtaXNzaW9ucygpLnRoZW4oZnVuY3Rpb24gKGhhc1Blcm1pc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1Blcm1pc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJtaXNzaW9uQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJHRoaXMuZ2V0Q2FtZXJhUGVybWlzc2lvbkJ1dHRvbklkKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBlcm1pc3Npb25CdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2dFcnJvcihcIlBlcm1pc3Npb24gYnV0dG9uIG5vdCBmb3VuZCwgZmFpbDtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIlBlcm1pc3Npb24gYnV0dG9uIG5vdCBmb3VuZFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb25CdXR0b24uY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLnNldEhhc1Blcm1pc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMucGVyc2lzdGVkRGF0YU1hbmFnZXIuc2V0SGFzUGVybWlzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5yZXNldEhlYWRlck1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZXNzYWdlRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5nZXRIZWFkZXJNZXNzYWdlQ29udGFpbmVySWQoKSk7XG4gICAgICAgIG1lc3NhZ2VEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5zZXRIZWFkZXJNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2VUZXh0LCBzY2FubmVyU3RhdHVzKSB7XG4gICAgICAgIGlmICghc2Nhbm5lclN0YXR1cykge1xuICAgICAgICAgICAgc2Nhbm5lclN0YXR1cyA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfREVGQVVMVDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZURpdiA9IHRoaXMuZ2V0SGVhZGVyTWVzc2FnZURpdigpO1xuICAgICAgICBtZXNzYWdlRGl2LmlubmVyVGV4dCA9IG1lc3NhZ2VUZXh0O1xuICAgICAgICBtZXNzYWdlRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHN3aXRjaCAoc2Nhbm5lclN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMuU1RBVFVTX1NVQ0NFU1M6XG4gICAgICAgICAgICAgICAgbWVzc2FnZURpdi5zdHlsZS5iYWNrZ3JvdW5kID0gXCJyZ2JhKDEwNiwgMTc1LCA4MCwgMC4yNilcIjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGl2LnN0eWxlLmNvbG9yID0gXCIjNDc3NzM1XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfV0FSTklORzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGl2LnN0eWxlLmJhY2tncm91bmQgPSBcInJnYmEoMjAzLCAzNiwgNDksIDAuMTQpXCI7XG4gICAgICAgICAgICAgICAgbWVzc2FnZURpdi5zdHlsZS5jb2xvciA9IFwiI2NiMjQzMVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMuU1RBVFVTX0RFRkFVTFQ6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2VEaXYuc3R5bGUuYmFja2dyb3VuZCA9IFwicmdiYSgwLCAwLCAwLCAwKVwiO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VEaXYuc3R5bGUuY29sb3IgPSBcInJnYigxNywgMTcsIDE3KVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLnNob3dIaWRlU2NhblR5cGVTd2FwTGluayA9IGZ1bmN0aW9uIChzaG91bGREaXNwbGF5KSB7XG4gICAgICAgIGlmICh0aGlzLnNjYW5UeXBlU2VsZWN0b3IuaGFzTW9yZVRoYW5PbmVTY2FuVHlwZSgpKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRGlzcGxheSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHNob3VsZERpc3BsYXkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN3YXBBbGxvd2VkID0gc2hvdWxkRGlzcGxheTtcbiAgICAgICAgICAgIHRoaXMuZ2V0RGFzaGJvYXJkU2VjdGlvblN3YXBMaW5rKCkuc3R5bGUuZGlzcGxheVxuICAgICAgICAgICAgICAgID0gc2hvdWxkRGlzcGxheSA/IFwiaW5saW5lLWJsb2NrXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5pbnNlcnRDYW1lcmFTY2FuSW1hZ2VUb1NjYW5SZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBxckNvZGVTY2FuUmVnaW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5nZXRTY2FuUmVnaW9uSWQoKSk7XG4gICAgICAgIGlmICh0aGlzLmNhbWVyYVNjYW5JbWFnZSkge1xuICAgICAgICAgICAgcXJDb2RlU2NhblJlZ2lvbi5pbm5lckhUTUwgPSBcIjxicj5cIjtcbiAgICAgICAgICAgIHFyQ29kZVNjYW5SZWdpb24uYXBwZW5kQ2hpbGQodGhpcy5jYW1lcmFTY2FuSW1hZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FtZXJhU2NhbkltYWdlID0gbmV3IEltYWdlO1xuICAgICAgICB0aGlzLmNhbWVyYVNjYW5JbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcXJDb2RlU2NhblJlZ2lvbi5pbm5lckhUTUwgPSBcIjxicj5cIjtcbiAgICAgICAgICAgIHFyQ29kZVNjYW5SZWdpb24uYXBwZW5kQ2hpbGQoJHRoaXMuY2FtZXJhU2NhbkltYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYW1lcmFTY2FuSW1hZ2Uud2lkdGggPSA2NDtcbiAgICAgICAgdGhpcy5jYW1lcmFTY2FuSW1hZ2Uuc3R5bGUub3BhY2l0eSA9IFwiMC44XCI7XG4gICAgICAgIHRoaXMuY2FtZXJhU2NhbkltYWdlLnNyYyA9IEFTU0VUX0NBTUVSQV9TQ0FOO1xuICAgICAgICB0aGlzLmNhbWVyYVNjYW5JbWFnZS5hbHQgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmNhbWVyYVNjYW5BbHRUZXh0KCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmluc2VydEZpbGVTY2FuSW1hZ2VUb1NjYW5SZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBxckNvZGVTY2FuUmVnaW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5nZXRTY2FuUmVnaW9uSWQoKSk7XG4gICAgICAgIGlmICh0aGlzLmZpbGVTY2FuSW1hZ2UpIHtcbiAgICAgICAgICAgIHFyQ29kZVNjYW5SZWdpb24uaW5uZXJIVE1MID0gXCI8YnI+XCI7XG4gICAgICAgICAgICBxckNvZGVTY2FuUmVnaW9uLmFwcGVuZENoaWxkKHRoaXMuZmlsZVNjYW5JbWFnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWxlU2NhbkltYWdlID0gbmV3IEltYWdlO1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHFyQ29kZVNjYW5SZWdpb24uaW5uZXJIVE1MID0gXCI8YnI+XCI7XG4gICAgICAgICAgICBxckNvZGVTY2FuUmVnaW9uLmFwcGVuZENoaWxkKCR0aGlzLmZpbGVTY2FuSW1hZ2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW1hZ2Uud2lkdGggPSA2NDtcbiAgICAgICAgdGhpcy5maWxlU2NhbkltYWdlLnN0eWxlLm9wYWNpdHkgPSBcIjAuOFwiO1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW1hZ2Uuc3JjID0gQVNTRVRfRklMRV9TQ0FOO1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW1hZ2UuYWx0ID0gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5maWxlU2NhbkFsdFRleHQoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuY2xlYXJTY2FuUmVnaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcXJDb2RlU2NhblJlZ2lvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZ2V0U2NhblJlZ2lvbklkKCkpO1xuICAgICAgICBxckNvZGVTY2FuUmVnaW9uLmlubmVySFRNTCA9IFwiXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldERhc2hib2FyZFNlY3Rpb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuZWxlbWVudElkLCBcIl9fZGFzaGJvYXJkX3NlY3Rpb25cIik7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldERhc2hib2FyZFNlY3Rpb25DYW1lcmFTY2FuUmVnaW9uSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLmVsZW1lbnRJZCwgXCJfX2Rhc2hib2FyZF9zZWN0aW9uX2NzclwiKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0RGFzaGJvYXJkU2VjdGlvblN3YXBMaW5rSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuU0NBTl9UWVBFX0NIQU5HRV9BTkNIT1JfSUQ7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldFNjYW5SZWdpb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuZWxlbWVudElkLCBcIl9fc2Nhbl9yZWdpb25cIik7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldERhc2hib2FyZElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5lbGVtZW50SWQsIFwiX19kYXNoYm9hcmRcIik7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldEhlYWRlck1lc3NhZ2VDb250YWluZXJJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuZWxlbWVudElkLCBcIl9faGVhZGVyX21lc3NhZ2VcIik7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldENhbWVyYVBlcm1pc3Npb25CdXR0b25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5DQU1FUkFfUEVSTUlTU0lPTl9CVVRUT05fSUQ7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldENhbWVyYVNjYW5SZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldERhc2hib2FyZFNlY3Rpb25DYW1lcmFTY2FuUmVnaW9uSWQoKSk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldERhc2hib2FyZFNlY3Rpb25Td2FwTGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZ2V0RGFzaGJvYXJkU2VjdGlvblN3YXBMaW5rSWQoKSk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldEhlYWRlck1lc3NhZ2VEaXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldEhlYWRlck1lc3NhZ2VDb250YWluZXJJZCgpKTtcbiAgICB9O1xuICAgIHJldHVybiBIdG1sNVFyY29kZVNjYW5uZXI7XG59KCkpO1xuZXhwb3J0IHsgSHRtbDVRcmNvZGVTY2FubmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odG1sNS1xcmNvZGUtc2Nhbm5lci5qcy5tYXAiXSwibmFtZXMiOlsiSHRtbDVRcmNvZGVDb25zdGFudHMiLCJIdG1sNVFyY29kZVNjYW5UeXBlIiwiSHRtbDVRcmNvZGVFcnJvckZhY3RvcnkiLCJCYXNlTG9nZ2dlciIsImlzTnVsbE9yVW5kZWZpbmVkIiwiY2xpcCIsIkh0bWw1UXJjb2RlIiwiSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncyIsIkFTU0VUX0ZJTEVfU0NBTiIsIkFTU0VUX0NBTUVSQV9TQ0FOIiwiUGVyc2lzdGVkRGF0YU1hbmFnZXIiLCJMaWJyYXJ5SW5mb0NvbnRhaW5lciIsIkNhbWVyYVBlcm1pc3Npb25zIiwiU2NhblR5cGVTZWxlY3RvciIsIlRvcmNoQnV0dG9uIiwiRmlsZVNlbGVjdGlvblVpIiwiQmFzZVVpRWxlbWVudEZhY3RvcnkiLCJQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMiLCJDYW1lcmFTZWxlY3Rpb25VaSIsIkNhbWVyYVpvb21VaSIsIkh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cyIsInRvSHRtbDVRcmNvZGVDYW1lcmFTY2FuQ29uZmlnIiwiY29uZmlnIiwiZnBzIiwicXJib3giLCJhc3BlY3RSYXRpbyIsImRpc2FibGVGbGlwIiwidmlkZW9Db25zdHJhaW50cyIsInRvSHRtbDVRcmNvZGVGdWxsQ29uZmlnIiwidmVyYm9zZSIsImZvcm1hdHNUb1N1cHBvcnQiLCJ1c2VCYXJDb2RlRGV0ZWN0b3JJZlN1cHBvcnRlZCIsImV4cGVyaW1lbnRhbEZlYXR1cmVzIiwiSHRtbDVRcmNvZGVTY2FubmVyIiwiZWxlbWVudElkIiwibGFzdE1hdGNoRm91bmQiLCJjYW1lcmFTY2FuSW1hZ2UiLCJmaWxlU2NhbkltYWdlIiwiZmlsZVNlbGVjdGlvblVpIiwiY3JlYXRlQ29uZmlnIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImNvbmNhdCIsInNjYW5UeXBlU2VsZWN0b3IiLCJzdXBwb3J0ZWRTY2FuVHlwZXMiLCJjdXJyZW50U2NhblR5cGUiLCJnZXREZWZhdWx0U2NhblR5cGUiLCJzZWN0aW9uU3dhcEFsbG93ZWQiLCJsb2dnZXIiLCJwZXJzaXN0ZWREYXRhTWFuYWdlciIsInJlbWVtYmVyTGFzdFVzZWRDYW1lcmEiLCJyZXNldCIsInByb3RvdHlwZSIsInJlbmRlciIsInFyQ29kZVN1Y2Nlc3NDYWxsYmFjayIsInFyQ29kZUVycm9yQ2FsbGJhY2siLCJfdGhpcyIsImRlY29kZWRUZXh0IiwicmVzdWx0Iiwic2V0SGVhZGVyTWVzc2FnZSIsImxhc3RNYXRjaCIsIlNUQVRVU19TVUNDRVNTIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3IiLCJjb250YWluZXIiLCJpbm5lckhUTUwiLCJjcmVhdGVCYXNpY0xheW91dCIsImh0bWw1UXJjb2RlIiwiZ2V0U2NhblJlZ2lvbklkIiwicGF1c2UiLCJzaG91bGRQYXVzZVZpZGVvIiwiZ2V0SHRtbDVRcmNvZGVPckZhaWwiLCJyZXN1bWUiLCJnZXRTdGF0ZSIsImNsZWFyIiwiZW1wdHlIdG1sQ29udGFpbmVyIiwibWFpbkNvbnRhaW5lciIsInJlc2V0QmFzaWNMYXlvdXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImlzU2Nhbm5pbmciLCJzdG9wIiwidGhlbiIsIl8iLCJjYXRjaCIsImxvZ0Vycm9yIiwiZ2V0UnVubmluZ1RyYWNrQ2FwYWJpbGl0aWVzIiwiZ2V0UnVubmluZ1RyYWNrU2V0dGluZ3MiLCJhcHBseVZpZGVvQ29uc3RyYWludHMiLCJ2aWRlb0NvbnN0YWludHMiLCJTQ0FOX0RFRkFVTFRfRlBTIiwiREVGQVVMVF9SRU1FTUJFUl9MQVNUX0NBTUVSQV9VU0VEIiwiREVGQVVMVF9TVVBQT1JURURfU0NBTl9UWVBFIiwicGFyZW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsInBhZGRpbmciLCJib3JkZXIiLCJjcmVhdGVIZWFkZXIiLCJxckNvZGVTY2FuUmVnaW9uIiwiY3JlYXRlRWxlbWVudCIsInNjYW5SZWdpb25JZCIsImlkIiwid2lkdGgiLCJtaW5IZWlnaHQiLCJ0ZXh0QWxpZ24iLCJhcHBlbmRDaGlsZCIsImlzQ2FtZXJhU2NhblR5cGUiLCJpbnNlcnRDYW1lcmFTY2FuSW1hZ2VUb1NjYW5SZWdpb24iLCJpbnNlcnRGaWxlU2NhbkltYWdlVG9TY2FuUmVnaW9uIiwicXJDb2RlRGFzaGJvYXJkIiwiZGFzaGJvYXJkSWQiLCJnZXREYXNoYm9hcmRJZCIsInNldHVwSW5pdGlhbERhc2hib2FyZCIsImRhc2hib2FyZCIsImNyZWF0ZVNlY3Rpb24iLCJjcmVhdGVTZWN0aW9uQ29udHJvbFBhbmVsIiwiaGFzTW9yZVRoYW5PbmVTY2FuVHlwZSIsImNyZWF0ZVNlY3Rpb25Td2FwIiwiaGVhZGVyIiwibWFyZ2luIiwibGlicmFyeUluZm8iLCJyZW5kZXJJbnRvIiwiaGVhZGVyTWVzc2FnZUNvbnRhaW5lciIsImdldEhlYWRlck1lc3NhZ2VDb250YWluZXJJZCIsImRpc3BsYXkiLCJmb250U2l6ZSIsImJvcmRlclRvcCIsInNlY3Rpb24iLCJnZXREYXNoYm9hcmRTZWN0aW9uSWQiLCJjcmVhdGVDYW1lcmFMaXN0VWkiLCJzY3BDYW1lcmFTY2FuUmVnaW9uIiwicmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIiLCJyZXF1ZXN0UGVybWlzc2lvbkJ1dHRvbiIsIiR0aGlzIiwic2hvd0hpZGVTY2FuVHlwZVN3YXBMaW5rIiwiY2FtZXJhUGVybWlzc2lvblJlcXVlc3RpbmciLCJjcmVhdGVQZXJtaXNzaW9uQnV0dG9uSWZOb3RFeGlzdHMiLCJjcmVhdGVQZXJtaXNzaW9uQnV0dG9uIiwiZ2V0Q2FtZXJhcyIsImNhbWVyYXMiLCJzZXRIYXNQZXJtaXNzaW9uIiwicmVzZXRIZWFkZXJNZXNzYWdlIiwibGVuZ3RoIiwicmVtb3ZlQ2hpbGQiLCJyZW5kZXJDYW1lcmFTZWxlY3Rpb24iLCJub0NhbWVyYUZvdW5kIiwiU1RBVFVTX1dBUk5JTkciLCJkaXNhYmxlZCIsImdldENhbWVyYVBlcm1pc3Npb25CdXR0b25JZCIsImlubmVyVGV4dCIsImNhbWVyYVBlcm1pc3Npb25UaXRsZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJjcmVhdGVQZXJtaXNzaW9uc1VpIiwiaGFzQ2FtZXJhUGVybWlzc2lvbnMiLCJoYXNQZXJtaXNzaW9ucyIsInNlY3Rpb25Db250cm9sUGFuZWwiLCJnZXREYXNoYm9hcmRTZWN0aW9uQ2FtZXJhU2NhblJlZ2lvbklkIiwiaXNDYW1lcmFTY2FuUmVxdWlyZWQiLCJyZW5kZXJGaWxlU2NhblVpIiwic2hvd09uUmVuZGVyIiwiaXNGaWxlU2NhblR5cGUiLCJvbkZpbGVTZWxlY3RlZCIsImZpbGUiLCJsb2FkaW5nSW1hZ2UiLCJzY2FuRmlsZVYyIiwiaHRtbDVxcmNvZGVSZXN1bHQiLCJjcmVhdGVGcm9tIiwiY3JlYXRlIiwiY2FtZXJhWm9vbVVpIiwicmVuZGVyQ2FtZXJhWm9vbVVpSWZTdXBwb3J0ZWQiLCJjYW1lcmFDYXBhYmlsaXRpZXMiLCJ6b29tQ2FwYWJpbGl0eSIsInpvb21GZWF0dXJlIiwiaXNTdXBwb3J0ZWQiLCJzZXRPbkNhbWVyYVpvb21WYWx1ZUNoYW5nZUNhbGxiYWNrIiwiem9vbVZhbHVlIiwiYXBwbHkiLCJkZWZhdWx0Wm9vbSIsImRlZmF1bHRab29tVmFsdWVJZlN1cHBvcnRlZCIsIm1pbiIsIm1heCIsInNldFZhbHVlcyIsInN0ZXAiLCJzaG93IiwiY2FtZXJhU2VsZWN0VWkiLCJjYW1lcmFBY3Rpb25Db250YWluZXIiLCJjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbiIsIkNBTUVSQV9TVEFSVF9CVVRUT05fSUQiLCJzY2FuQnV0dG9uU3RhcnRTY2FubmluZ1RleHQiLCJjYW1lcmFBY3Rpb25TdG9wQnV0dG9uIiwiQ0FNRVJBX1NUT1BfQlVUVE9OX0lEIiwic2NhbkJ1dHRvblN0b3BTY2FubmluZ1RleHQiLCJ0b3JjaEJ1dHRvbiIsImNyZWF0ZUFuZFNob3dUb3JjaEJ1dHRvbklmU3VwcG9ydGVkIiwidG9yY2hGZWF0dXJlIiwiaGlkZSIsIm1hcmdpbkxlZnQiLCJ1cGRhdGVUb3JjaENhcGFiaWxpdHkiLCJyZXNldENhbWVyYUFjdGlvblN0YXJ0QnV0dG9uIiwic2hvdWxkU2hvdyIsIm9wYWNpdHkiLCJzY2FuQnV0dG9uU2Nhbm5pbmdTdGFydGluZyIsImRpc2FibGUiLCJjYW1lcmFJZCIsImdldFZhbHVlIiwic2V0TGFzdFVzZWRDYW1lcmFJZCIsInN0YXJ0IiwiZ2V0UnVubmluZ1RyYWNrQ2FtZXJhQ2FwYWJpbGl0aWVzIiwic2hvd1RvcmNoQnV0dG9uSWZTdXBwb3J0ZWQiLCJzaG93Wm9vbVNsaWRlcklmU3VwcG9ydGVkIiwiZW5hYmxlIiwiaGFzU2luZ2xlSXRlbSIsImNsaWNrIiwicmVtb3ZlT25DYW1lcmFab29tVmFsdWVDaGFuZ2VDYWxsYmFjayIsImdldExhc3RVc2VkQ2FtZXJhSWQiLCJoYXNWYWx1ZSIsInNldFZhbHVlIiwicmVzZXRMYXN0VXNlZENhbWVyYUlkIiwiVEVYVF9JRl9DQU1FUkFfU0NBTl9TRUxFQ1RFRCIsInRleHRJZkNhbWVyYVNjYW5TZWxlY3RlZCIsIlRFWFRfSUZfRklMRV9TQ0FOX1NFTEVDVEVEIiwidGV4dElmRmlsZVNjYW5TZWxlY3RlZCIsInN3aXRjaENvbnRhaW5lciIsInN3aXRjaFNjYW5UeXBlTGluayIsImdldERhc2hib2FyZFNlY3Rpb25Td2FwTGlua0lkIiwidGV4dERlY29yYXRpb24iLCJjdXJzb3IiLCJyZXNldFZhbHVlIiwiY2xlYXJTY2FuUmVnaW9uIiwiZ2V0Q2FtZXJhU2NhblJlZ2lvbiIsIlNDQU5fVFlQRV9GSUxFIiwiU0NBTl9UWVBFX0NBTUVSQSIsInN0YXJ0Q2FtZXJhU2NhbklmUGVybWlzc2lvbkV4aXN0c09uU3dhcCIsInBlcm1pc3Npb25CdXR0b24iLCJtZXNzYWdlRGl2IiwibWVzc2FnZVRleHQiLCJzY2FubmVyU3RhdHVzIiwiU1RBVFVTX0RFRkFVTFQiLCJnZXRIZWFkZXJNZXNzYWdlRGl2IiwiYmFja2dyb3VuZCIsImNvbG9yIiwic2hvdWxkRGlzcGxheSIsImdldERhc2hib2FyZFNlY3Rpb25Td2FwTGluayIsIkltYWdlIiwib25sb2FkIiwic3JjIiwiYWx0IiwiY2FtZXJhU2NhbkFsdFRleHQiLCJmaWxlU2NhbkFsdFRleHQiLCJTQ0FOX1RZUEVfQ0hBTkdFX0FOQ0hPUl9JRCIsIkNBTUVSQV9QRVJNSVNTSU9OX0JVVFRPTl9JRCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/html5-qrcode-scanner.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/html5-qrcode.js":
/*!*******************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/html5-qrcode.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5Qrcode: () => (/* binding */ Html5Qrcode)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"(ssr)/./node_modules/html5-qrcode/esm/core.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./strings */ \"(ssr)/./node_modules/html5-qrcode/esm/strings.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/html5-qrcode/esm/utils.js\");\n/* harmony import */ var _code_decoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./code-decoder */ \"(ssr)/./node_modules/html5-qrcode/esm/code-decoder.js\");\n/* harmony import */ var _camera_factories__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./camera/factories */ \"(ssr)/./node_modules/html5-qrcode/esm/camera/factories.js\");\n/* harmony import */ var _camera_retriever__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./camera/retriever */ \"(ssr)/./node_modules/html5-qrcode/esm/camera/retriever.js\");\n/* harmony import */ var _state_manager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./state-manager */ \"(ssr)/./node_modules/html5-qrcode/esm/state-manager.js\");\nvar __extends = undefined && undefined.__extends || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\n\n\n\n\n\n\n\nvar Constants = function(_super) {\n    __extends(Constants, _super);\n    function Constants() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Constants.DEFAULT_WIDTH = 300;\n    Constants.DEFAULT_WIDTH_OFFSET = 2;\n    Constants.FILE_SCAN_MIN_HEIGHT = 300;\n    Constants.FILE_SCAN_HIDDEN_CANVAS_PADDING = 100;\n    Constants.MIN_QR_BOX_SIZE = 50;\n    Constants.SHADED_LEFT = 1;\n    Constants.SHADED_RIGHT = 2;\n    Constants.SHADED_TOP = 3;\n    Constants.SHADED_BOTTOM = 4;\n    Constants.SHADED_REGION_ELEMENT_ID = \"qr-shaded-region\";\n    Constants.VERBOSE = false;\n    Constants.BORDER_SHADER_DEFAULT_COLOR = \"#ffffff\";\n    Constants.BORDER_SHADER_MATCH_COLOR = \"rgb(90, 193, 56)\";\n    return Constants;\n}(_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants);\nvar InternalHtml5QrcodeConfig = function() {\n    function InternalHtml5QrcodeConfig(config, logger) {\n        this.logger = logger;\n        this.fps = Constants.SCAN_DEFAULT_FPS;\n        if (!config) {\n            this.disableFlip = Constants.DEFAULT_DISABLE_FLIP;\n        } else {\n            if (config.fps) {\n                this.fps = config.fps;\n            }\n            this.disableFlip = config.disableFlip === true;\n            this.qrbox = config.qrbox;\n            this.aspectRatio = config.aspectRatio;\n            this.videoConstraints = config.videoConstraints;\n        }\n    }\n    InternalHtml5QrcodeConfig.prototype.isMediaStreamConstraintsValid = function() {\n        if (!this.videoConstraints) {\n            this.logger.logError(\"Empty videoConstraints\", true);\n            return false;\n        }\n        return _utils__WEBPACK_IMPORTED_MODULE_2__.VideoConstraintsUtil.isMediaStreamConstraintsValid(this.videoConstraints, this.logger);\n    };\n    InternalHtml5QrcodeConfig.prototype.isShadedBoxEnabled = function() {\n        return !(0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.qrbox);\n    };\n    InternalHtml5QrcodeConfig.create = function(config, logger) {\n        return new InternalHtml5QrcodeConfig(config, logger);\n    };\n    return InternalHtml5QrcodeConfig;\n}();\nvar Html5Qrcode = function() {\n    function Html5Qrcode(elementId, configOrVerbosityFlag) {\n        this.element = null;\n        this.canvasElement = null;\n        this.scannerPausedUiElement = null;\n        this.hasBorderShaders = null;\n        this.borderShaders = null;\n        this.qrMatch = null;\n        this.renderedCamera = null;\n        this.qrRegion = null;\n        this.context = null;\n        this.lastScanImageFile = null;\n        this.isScanning = false;\n        if (!document.getElementById(elementId)) {\n            throw \"HTML Element with id=\".concat(elementId, \" not found\");\n        }\n        this.elementId = elementId;\n        this.verbose = false;\n        var experimentalFeatureConfig;\n        var configObject;\n        if (typeof configOrVerbosityFlag == \"boolean\") {\n            this.verbose = configOrVerbosityFlag === true;\n        } else if (configOrVerbosityFlag) {\n            configObject = configOrVerbosityFlag;\n            this.verbose = configObject.verbose === true;\n            experimentalFeatureConfig = configObject.experimentalFeatures;\n        }\n        this.logger = new _core__WEBPACK_IMPORTED_MODULE_0__.BaseLoggger(this.verbose);\n        this.qrcode = new _code_decoder__WEBPACK_IMPORTED_MODULE_3__.Html5QrcodeShim(this.getSupportedFormats(configOrVerbosityFlag), this.getUseBarCodeDetectorIfSupported(configObject), this.verbose, this.logger);\n        this.foreverScanTimeout;\n        this.shouldScan = true;\n        this.stateManagerProxy = _state_manager__WEBPACK_IMPORTED_MODULE_6__.StateManagerFactory.create();\n    }\n    Html5Qrcode.prototype.start = function(cameraIdOrConfig, configuration, qrCodeSuccessCallback, qrCodeErrorCallback) {\n        var _this = this;\n        if (!cameraIdOrConfig) {\n            throw \"cameraIdOrConfig is required\";\n        }\n        if (!qrCodeSuccessCallback || typeof qrCodeSuccessCallback != \"function\") {\n            throw \"qrCodeSuccessCallback is required and should be a function.\";\n        }\n        var qrCodeErrorCallbackInternal;\n        if (qrCodeErrorCallback) {\n            qrCodeErrorCallbackInternal = qrCodeErrorCallback;\n        } else {\n            qrCodeErrorCallbackInternal = this.verbose ? this.logger.log : function() {};\n        }\n        var internalConfig = InternalHtml5QrcodeConfig.create(configuration, this.logger);\n        this.clearElement();\n        var videoConstraintsAvailableAndValid = false;\n        if (internalConfig.videoConstraints) {\n            if (!internalConfig.isMediaStreamConstraintsValid()) {\n                this.logger.logError(\"'videoConstraints' is not valid 'MediaStreamConstraints, \" + \"it will be ignored.'\", true);\n            } else {\n                videoConstraintsAvailableAndValid = true;\n            }\n        }\n        var areVideoConstraintsEnabled = videoConstraintsAvailableAndValid;\n        var element = document.getElementById(this.elementId);\n        var rootElementWidth = element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;\n        element.style.position = \"relative\";\n        this.shouldScan = true;\n        this.element = element;\n        var $this = this;\n        var toScanningStateChangeTransaction = this.stateManagerProxy.startTransition(_state_manager__WEBPACK_IMPORTED_MODULE_6__.Html5QrcodeScannerState.SCANNING);\n        return new Promise(function(resolve, reject) {\n            var videoConstraints = areVideoConstraintsEnabled ? internalConfig.videoConstraints : $this.createVideoConstraints(cameraIdOrConfig);\n            if (!videoConstraints) {\n                toScanningStateChangeTransaction.cancel();\n                reject(\"videoConstraints should be defined\");\n                return;\n            }\n            var cameraRenderingOptions = {};\n            if (!areVideoConstraintsEnabled || internalConfig.aspectRatio) {\n                cameraRenderingOptions.aspectRatio = internalConfig.aspectRatio;\n            }\n            var renderingCallbacks = {\n                onRenderSurfaceReady: function(viewfinderWidth, viewfinderHeight) {\n                    $this.setupUi(viewfinderWidth, viewfinderHeight, internalConfig);\n                    $this.isScanning = true;\n                    $this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallbackInternal);\n                }\n            };\n            _camera_factories__WEBPACK_IMPORTED_MODULE_4__.CameraFactory.failIfNotSupported().then(function(factory) {\n                factory.create(videoConstraints).then(function(camera) {\n                    return camera.render(_this.element, cameraRenderingOptions, renderingCallbacks).then(function(renderedCamera) {\n                        $this.renderedCamera = renderedCamera;\n                        toScanningStateChangeTransaction.execute();\n                        resolve(null);\n                    }).catch(function(error) {\n                        toScanningStateChangeTransaction.cancel();\n                        reject(error);\n                    });\n                }).catch(function(error) {\n                    toScanningStateChangeTransaction.cancel();\n                    reject(_strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeStrings.errorGettingUserMedia(error));\n                });\n            }).catch(function(_) {\n                toScanningStateChangeTransaction.cancel();\n                reject(_strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeStrings.cameraStreamingNotSupported());\n            });\n        });\n    };\n    Html5Qrcode.prototype.pause = function(shouldPauseVideo) {\n        if (!this.stateManagerProxy.isStrictlyScanning()) {\n            throw \"Cannot pause, scanner is not scanning.\";\n        }\n        this.stateManagerProxy.directTransition(_state_manager__WEBPACK_IMPORTED_MODULE_6__.Html5QrcodeScannerState.PAUSED);\n        this.showPausedState();\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(shouldPauseVideo) || shouldPauseVideo !== true) {\n            shouldPauseVideo = false;\n        }\n        if (shouldPauseVideo && this.renderedCamera) {\n            this.renderedCamera.pause();\n        }\n    };\n    Html5Qrcode.prototype.resume = function() {\n        if (!this.stateManagerProxy.isPaused()) {\n            throw \"Cannot result, scanner is not paused.\";\n        }\n        if (!this.renderedCamera) {\n            throw \"renderedCamera doesn't exist while trying resume()\";\n        }\n        var $this = this;\n        var transitionToScanning = function() {\n            $this.stateManagerProxy.directTransition(_state_manager__WEBPACK_IMPORTED_MODULE_6__.Html5QrcodeScannerState.SCANNING);\n            $this.hidePausedState();\n        };\n        if (!this.renderedCamera.isPaused()) {\n            transitionToScanning();\n            return;\n        }\n        this.renderedCamera.resume(function() {\n            transitionToScanning();\n        });\n    };\n    Html5Qrcode.prototype.getState = function() {\n        return this.stateManagerProxy.getState();\n    };\n    Html5Qrcode.prototype.stop = function() {\n        var _this = this;\n        if (!this.stateManagerProxy.isScanning()) {\n            throw \"Cannot stop, scanner is not running or paused.\";\n        }\n        var toStoppedStateTransaction = this.stateManagerProxy.startTransition(_state_manager__WEBPACK_IMPORTED_MODULE_6__.Html5QrcodeScannerState.NOT_STARTED);\n        this.shouldScan = false;\n        if (this.foreverScanTimeout) {\n            clearTimeout(this.foreverScanTimeout);\n        }\n        var removeQrRegion = function() {\n            if (!_this.element) {\n                return;\n            }\n            var childElement = document.getElementById(Constants.SHADED_REGION_ELEMENT_ID);\n            if (childElement) {\n                _this.element.removeChild(childElement);\n            }\n        };\n        var $this = this;\n        return this.renderedCamera.close().then(function() {\n            $this.renderedCamera = null;\n            if ($this.element) {\n                $this.element.removeChild($this.canvasElement);\n                $this.canvasElement = null;\n            }\n            removeQrRegion();\n            if ($this.qrRegion) {\n                $this.qrRegion = null;\n            }\n            if ($this.context) {\n                $this.context = null;\n            }\n            toStoppedStateTransaction.execute();\n            $this.hidePausedState();\n            $this.isScanning = false;\n            return Promise.resolve();\n        });\n    };\n    Html5Qrcode.prototype.scanFile = function(imageFile, showImage) {\n        return this.scanFileV2(imageFile, showImage).then(function(html5qrcodeResult) {\n            return html5qrcodeResult.decodedText;\n        });\n    };\n    Html5Qrcode.prototype.scanFileV2 = function(imageFile, showImage) {\n        var _this = this;\n        if (!imageFile || !(imageFile instanceof File)) {\n            throw \"imageFile argument is mandatory and should be instance \" + \"of File. Use 'event.target.files[0]'.\";\n        }\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(showImage)) {\n            showImage = true;\n        }\n        if (!this.stateManagerProxy.canScanFile()) {\n            throw \"Cannot start file scan - ongoing camera scan\";\n        }\n        return new Promise(function(resolve, reject) {\n            _this.possiblyCloseLastScanImageFile();\n            _this.clearElement();\n            _this.lastScanImageFile = URL.createObjectURL(imageFile);\n            var inputImage = new Image;\n            inputImage.onload = function() {\n                var imageWidth = inputImage.width;\n                var imageHeight = inputImage.height;\n                var element = document.getElementById(_this.elementId);\n                var containerWidth = element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;\n                var containerHeight = Math.max(element.clientHeight ? element.clientHeight : imageHeight, Constants.FILE_SCAN_MIN_HEIGHT);\n                var config = _this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);\n                if (showImage) {\n                    var visibleCanvas = _this.createCanvasElement(containerWidth, containerHeight, \"qr-canvas-visible\");\n                    visibleCanvas.style.display = \"inline-block\";\n                    element.appendChild(visibleCanvas);\n                    var context_1 = visibleCanvas.getContext(\"2d\");\n                    if (!context_1) {\n                        throw \"Unable to get 2d context from canvas\";\n                    }\n                    context_1.canvas.width = containerWidth;\n                    context_1.canvas.height = containerHeight;\n                    context_1.drawImage(inputImage, 0, 0, imageWidth, imageHeight, config.x, config.y, config.width, config.height);\n                }\n                var padding = Constants.FILE_SCAN_HIDDEN_CANVAS_PADDING;\n                var hiddenImageWidth = Math.max(inputImage.width, config.width);\n                var hiddenImageHeight = Math.max(inputImage.height, config.height);\n                var hiddenCanvasWidth = hiddenImageWidth + 2 * padding;\n                var hiddenCanvasHeight = hiddenImageHeight + 2 * padding;\n                var hiddenCanvas = _this.createCanvasElement(hiddenCanvasWidth, hiddenCanvasHeight);\n                element.appendChild(hiddenCanvas);\n                var context = hiddenCanvas.getContext(\"2d\");\n                if (!context) {\n                    throw \"Unable to get 2d context from canvas\";\n                }\n                context.canvas.width = hiddenCanvasWidth;\n                context.canvas.height = hiddenCanvasHeight;\n                context.drawImage(inputImage, 0, 0, imageWidth, imageHeight, padding, padding, hiddenImageWidth, hiddenImageHeight);\n                try {\n                    _this.qrcode.decodeRobustlyAsync(hiddenCanvas).then(function(result) {\n                        resolve(_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeResultFactory.createFromQrcodeResult(result));\n                    }).catch(reject);\n                } catch (exception) {\n                    reject(\"QR code parse error, error = \".concat(exception));\n                }\n            };\n            inputImage.onerror = reject;\n            inputImage.onabort = reject;\n            inputImage.onstalled = reject;\n            inputImage.onsuspend = reject;\n            inputImage.src = URL.createObjectURL(imageFile);\n        });\n    };\n    Html5Qrcode.prototype.clear = function() {\n        this.clearElement();\n    };\n    Html5Qrcode.getCameras = function() {\n        return _camera_retriever__WEBPACK_IMPORTED_MODULE_5__.CameraRetriever.retrieve();\n    };\n    Html5Qrcode.prototype.getRunningTrackCapabilities = function() {\n        return this.getRenderedCameraOrFail().getRunningTrackCapabilities();\n    };\n    Html5Qrcode.prototype.getRunningTrackSettings = function() {\n        return this.getRenderedCameraOrFail().getRunningTrackSettings();\n    };\n    Html5Qrcode.prototype.getRunningTrackCameraCapabilities = function() {\n        return this.getRenderedCameraOrFail().getCapabilities();\n    };\n    Html5Qrcode.prototype.applyVideoConstraints = function(videoConstaints) {\n        if (!videoConstaints) {\n            throw \"videoConstaints is required argument.\";\n        } else if (!_utils__WEBPACK_IMPORTED_MODULE_2__.VideoConstraintsUtil.isMediaStreamConstraintsValid(videoConstaints, this.logger)) {\n            throw \"invalid videoConstaints passed, check logs for more details\";\n        }\n        return this.getRenderedCameraOrFail().applyVideoConstraints(videoConstaints);\n    };\n    Html5Qrcode.prototype.getRenderedCameraOrFail = function() {\n        if (this.renderedCamera == null) {\n            throw \"Scanning is not in running state, call this API only when\" + \" QR code scanning using camera is in running state.\";\n        }\n        return this.renderedCamera;\n    };\n    Html5Qrcode.prototype.getSupportedFormats = function(configOrVerbosityFlag) {\n        var allFormats = [\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.QR_CODE,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.AZTEC,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODABAR,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_39,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_93,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_128,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.DATA_MATRIX,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.MAXICODE,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.ITF,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.EAN_13,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.EAN_8,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.PDF_417,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.RSS_14,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.RSS_EXPANDED,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_A,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_E,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION\n        ];\n        if (!configOrVerbosityFlag || typeof configOrVerbosityFlag == \"boolean\") {\n            return allFormats;\n        }\n        if (!configOrVerbosityFlag.formatsToSupport) {\n            return allFormats;\n        }\n        if (!Array.isArray(configOrVerbosityFlag.formatsToSupport)) {\n            throw \"configOrVerbosityFlag.formatsToSupport should be undefined \" + \"or an array.\";\n        }\n        if (configOrVerbosityFlag.formatsToSupport.length === 0) {\n            throw \"Atleast 1 formatsToSupport is needed.\";\n        }\n        var supportedFormats = [];\n        for(var _i = 0, _a = configOrVerbosityFlag.formatsToSupport; _i < _a.length; _i++){\n            var format = _a[_i];\n            if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isValidHtml5QrcodeSupportedFormats)(format)) {\n                supportedFormats.push(format);\n            } else {\n                this.logger.warn(\"Invalid format: \".concat(format, \" passed in config, ignoring.\"));\n            }\n        }\n        if (supportedFormats.length === 0) {\n            throw \"None of formatsToSupport match supported values.\";\n        }\n        return supportedFormats;\n    };\n    Html5Qrcode.prototype.getUseBarCodeDetectorIfSupported = function(config) {\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(config)) {\n            return true;\n        }\n        if (!(0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(config.useBarCodeDetectorIfSupported)) {\n            return config.useBarCodeDetectorIfSupported !== false;\n        }\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(config.experimentalFeatures)) {\n            return true;\n        }\n        var experimentalFeatures = config.experimentalFeatures;\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(experimentalFeatures.useBarCodeDetectorIfSupported)) {\n            return true;\n        }\n        return experimentalFeatures.useBarCodeDetectorIfSupported !== false;\n    };\n    Html5Qrcode.prototype.validateQrboxSize = function(viewfinderWidth, viewfinderHeight, internalConfig) {\n        var _this = this;\n        var qrboxSize = internalConfig.qrbox;\n        this.validateQrboxConfig(qrboxSize);\n        var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);\n        var validateMinSize = function(size) {\n            if (size < Constants.MIN_QR_BOX_SIZE) {\n                throw \"minimum size of 'config.qrbox' dimension value is\" + \" \".concat(Constants.MIN_QR_BOX_SIZE, \"px.\");\n            }\n        };\n        var correctWidthBasedOnRootElementSize = function(configWidth) {\n            if (configWidth > viewfinderWidth) {\n                _this.logger.warn(\"`qrbox.width` or `qrbox` is larger than the\" + \" width of the root element. The width will be truncated\" + \" to the width of root element.\");\n                configWidth = viewfinderWidth;\n            }\n            return configWidth;\n        };\n        validateMinSize(qrDimensions.width);\n        validateMinSize(qrDimensions.height);\n        qrDimensions.width = correctWidthBasedOnRootElementSize(qrDimensions.width);\n    };\n    Html5Qrcode.prototype.validateQrboxConfig = function(qrboxSize) {\n        if (typeof qrboxSize === \"number\") {\n            return;\n        }\n        if (typeof qrboxSize === \"function\") {\n            return;\n        }\n        if (qrboxSize.width === undefined || qrboxSize.height === undefined) {\n            throw \"Invalid instance of QrDimensions passed for \" + \"'config.qrbox'. Both 'width' and 'height' should be set.\";\n        }\n    };\n    Html5Qrcode.prototype.toQrdimensions = function(viewfinderWidth, viewfinderHeight, qrboxSize) {\n        if (typeof qrboxSize === \"number\") {\n            return {\n                width: qrboxSize,\n                height: qrboxSize\n            };\n        } else if (typeof qrboxSize === \"function\") {\n            try {\n                return qrboxSize(viewfinderWidth, viewfinderHeight);\n            } catch (error) {\n                throw new Error(\"qrbox config was passed as a function but it failed with \" + \"unknown error\" + error);\n            }\n        }\n        return qrboxSize;\n    };\n    Html5Qrcode.prototype.setupUi = function(viewfinderWidth, viewfinderHeight, internalConfig) {\n        if (internalConfig.isShadedBoxEnabled()) {\n            this.validateQrboxSize(viewfinderWidth, viewfinderHeight, internalConfig);\n        }\n        var qrboxSize = (0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(internalConfig.qrbox) ? {\n            width: viewfinderWidth,\n            height: viewfinderHeight\n        } : internalConfig.qrbox;\n        this.validateQrboxConfig(qrboxSize);\n        var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);\n        if (qrDimensions.height > viewfinderHeight) {\n            this.logger.warn(\"[Html5Qrcode] config.qrbox has height that is\" + \"greater than the height of the video stream. Shading will be\" + \" ignored\");\n        }\n        var shouldShadingBeApplied = internalConfig.isShadedBoxEnabled() && qrDimensions.height <= viewfinderHeight;\n        var defaultQrRegion = {\n            x: 0,\n            y: 0,\n            width: viewfinderWidth,\n            height: viewfinderHeight\n        };\n        var qrRegion = shouldShadingBeApplied ? this.getShadedRegionBounds(viewfinderWidth, viewfinderHeight, qrDimensions) : defaultQrRegion;\n        var canvasElement = this.createCanvasElement(qrRegion.width, qrRegion.height);\n        var contextAttributes = {\n            willReadFrequently: true\n        };\n        var context = canvasElement.getContext(\"2d\", contextAttributes);\n        context.canvas.width = qrRegion.width;\n        context.canvas.height = qrRegion.height;\n        this.element.append(canvasElement);\n        if (shouldShadingBeApplied) {\n            this.possiblyInsertShadingElement(this.element, viewfinderWidth, viewfinderHeight, qrDimensions);\n        }\n        this.createScannerPausedUiElement(this.element);\n        this.qrRegion = qrRegion;\n        this.context = context;\n        this.canvasElement = canvasElement;\n    };\n    Html5Qrcode.prototype.createScannerPausedUiElement = function(rootElement) {\n        var scannerPausedUiElement = document.createElement(\"div\");\n        scannerPausedUiElement.innerText = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeStrings.scannerPaused();\n        scannerPausedUiElement.style.display = \"none\";\n        scannerPausedUiElement.style.position = \"absolute\";\n        scannerPausedUiElement.style.top = \"0px\";\n        scannerPausedUiElement.style.zIndex = \"1\";\n        scannerPausedUiElement.style.background = \"rgba(9, 9, 9, 0.46)\";\n        scannerPausedUiElement.style.color = \"#FFECEC\";\n        scannerPausedUiElement.style.textAlign = \"center\";\n        scannerPausedUiElement.style.width = \"100%\";\n        rootElement.appendChild(scannerPausedUiElement);\n        this.scannerPausedUiElement = scannerPausedUiElement;\n    };\n    Html5Qrcode.prototype.scanContext = function(qrCodeSuccessCallback, qrCodeErrorCallback) {\n        var _this = this;\n        if (this.stateManagerProxy.isPaused()) {\n            return Promise.resolve(false);\n        }\n        return this.qrcode.decodeAsync(this.canvasElement).then(function(result) {\n            qrCodeSuccessCallback(result.text, _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeResultFactory.createFromQrcodeResult(result));\n            _this.possiblyUpdateShaders(true);\n            return true;\n        }).catch(function(error) {\n            _this.possiblyUpdateShaders(false);\n            var errorMessage = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeStrings.codeParseError(error);\n            qrCodeErrorCallback(errorMessage, _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeErrorFactory.createFrom(errorMessage));\n            return false;\n        });\n    };\n    Html5Qrcode.prototype.foreverScan = function(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback) {\n        var _this = this;\n        if (!this.shouldScan) {\n            return;\n        }\n        if (!this.renderedCamera) {\n            return;\n        }\n        var videoElement = this.renderedCamera.getSurface();\n        var widthRatio = videoElement.videoWidth / videoElement.clientWidth;\n        var heightRatio = videoElement.videoHeight / videoElement.clientHeight;\n        if (!this.qrRegion) {\n            throw \"qrRegion undefined when localMediaStream is ready.\";\n        }\n        var sWidthOffset = this.qrRegion.width * widthRatio;\n        var sHeightOffset = this.qrRegion.height * heightRatio;\n        var sxOffset = this.qrRegion.x * widthRatio;\n        var syOffset = this.qrRegion.y * heightRatio;\n        this.context.drawImage(videoElement, sxOffset, syOffset, sWidthOffset, sHeightOffset, 0, 0, this.qrRegion.width, this.qrRegion.height);\n        var triggerNextScan = function() {\n            _this.foreverScanTimeout = setTimeout(function() {\n                _this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback);\n            }, _this.getTimeoutFps(internalConfig.fps));\n        };\n        this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).then(function(isSuccessfull) {\n            if (!isSuccessfull && internalConfig.disableFlip !== true) {\n                _this.context.translate(_this.context.canvas.width, 0);\n                _this.context.scale(-1, 1);\n                _this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).finally(function() {\n                    triggerNextScan();\n                });\n            } else {\n                triggerNextScan();\n            }\n        }).catch(function(error) {\n            _this.logger.logError(\"Error happend while scanning context\", error);\n            triggerNextScan();\n        });\n    };\n    Html5Qrcode.prototype.createVideoConstraints = function(cameraIdOrConfig) {\n        if (typeof cameraIdOrConfig == \"string\") {\n            return {\n                deviceId: {\n                    exact: cameraIdOrConfig\n                }\n            };\n        } else if (typeof cameraIdOrConfig == \"object\") {\n            var facingModeKey = \"facingMode\";\n            var deviceIdKey = \"deviceId\";\n            var allowedFacingModeValues_1 = {\n                \"user\": true,\n                \"environment\": true\n            };\n            var exactKey = \"exact\";\n            var isValidFacingModeValue = function(value) {\n                if (value in allowedFacingModeValues_1) {\n                    return true;\n                } else {\n                    throw \"config has invalid 'facingMode' value = \" + \"'\".concat(value, \"'\");\n                }\n            };\n            var keys = Object.keys(cameraIdOrConfig);\n            if (keys.length !== 1) {\n                throw \"'cameraIdOrConfig' object should have exactly 1 key,\" + \" if passed as an object, found \".concat(keys.length, \" keys\");\n            }\n            var key = Object.keys(cameraIdOrConfig)[0];\n            if (key !== facingModeKey && key !== deviceIdKey) {\n                throw \"Only '\".concat(facingModeKey, \"' and '\").concat(deviceIdKey, \"' \") + \" are supported for 'cameraIdOrConfig'\";\n            }\n            if (key === facingModeKey) {\n                var facingMode = cameraIdOrConfig.facingMode;\n                if (typeof facingMode == \"string\") {\n                    if (isValidFacingModeValue(facingMode)) {\n                        return {\n                            facingMode: facingMode\n                        };\n                    }\n                } else if (typeof facingMode == \"object\") {\n                    if (exactKey in facingMode) {\n                        if (isValidFacingModeValue(facingMode[\"\".concat(exactKey)])) {\n                            return {\n                                facingMode: {\n                                    exact: facingMode[\"\".concat(exactKey)]\n                                }\n                            };\n                        }\n                    } else {\n                        throw \"'facingMode' should be string or object with\" + \" \".concat(exactKey, \" as key.\");\n                    }\n                } else {\n                    var type_1 = typeof facingMode;\n                    throw \"Invalid type of 'facingMode' = \".concat(type_1);\n                }\n            } else {\n                var deviceId = cameraIdOrConfig.deviceId;\n                if (typeof deviceId == \"string\") {\n                    return {\n                        deviceId: deviceId\n                    };\n                } else if (typeof deviceId == \"object\") {\n                    if (exactKey in deviceId) {\n                        return {\n                            deviceId: {\n                                exact: deviceId[\"\".concat(exactKey)]\n                            }\n                        };\n                    } else {\n                        throw \"'deviceId' should be string or object with\" + \" \".concat(exactKey, \" as key.\");\n                    }\n                } else {\n                    var type_2 = typeof deviceId;\n                    throw \"Invalid type of 'deviceId' = \".concat(type_2);\n                }\n            }\n        }\n        var type = typeof cameraIdOrConfig;\n        throw \"Invalid type of 'cameraIdOrConfig' = \".concat(type);\n    };\n    Html5Qrcode.prototype.computeCanvasDrawConfig = function(imageWidth, imageHeight, containerWidth, containerHeight) {\n        if (imageWidth <= containerWidth && imageHeight <= containerHeight) {\n            var xoffset = (containerWidth - imageWidth) / 2;\n            var yoffset = (containerHeight - imageHeight) / 2;\n            return {\n                x: xoffset,\n                y: yoffset,\n                width: imageWidth,\n                height: imageHeight\n            };\n        } else {\n            var formerImageWidth = imageWidth;\n            var formerImageHeight = imageHeight;\n            if (imageWidth > containerWidth) {\n                imageHeight = containerWidth / imageWidth * imageHeight;\n                imageWidth = containerWidth;\n            }\n            if (imageHeight > containerHeight) {\n                imageWidth = containerHeight / imageHeight * imageWidth;\n                imageHeight = containerHeight;\n            }\n            this.logger.log(\"Image downsampled from \" + \"\".concat(formerImageWidth, \"X\").concat(formerImageHeight) + \" to \".concat(imageWidth, \"X\").concat(imageHeight, \".\"));\n            return this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);\n        }\n    };\n    Html5Qrcode.prototype.clearElement = function() {\n        if (this.stateManagerProxy.isScanning()) {\n            throw \"Cannot clear while scan is ongoing, close it first.\";\n        }\n        var element = document.getElementById(this.elementId);\n        if (element) {\n            element.innerHTML = \"\";\n        }\n    };\n    Html5Qrcode.prototype.possiblyUpdateShaders = function(qrMatch) {\n        if (this.qrMatch === qrMatch) {\n            return;\n        }\n        if (this.hasBorderShaders && this.borderShaders && this.borderShaders.length) {\n            this.borderShaders.forEach(function(shader) {\n                shader.style.backgroundColor = qrMatch ? Constants.BORDER_SHADER_MATCH_COLOR : Constants.BORDER_SHADER_DEFAULT_COLOR;\n            });\n        }\n        this.qrMatch = qrMatch;\n    };\n    Html5Qrcode.prototype.possiblyCloseLastScanImageFile = function() {\n        if (this.lastScanImageFile) {\n            URL.revokeObjectURL(this.lastScanImageFile);\n            this.lastScanImageFile = null;\n        }\n    };\n    Html5Qrcode.prototype.createCanvasElement = function(width, height, customId) {\n        var canvasWidth = width;\n        var canvasHeight = height;\n        var canvasElement = document.createElement(\"canvas\");\n        canvasElement.style.width = \"\".concat(canvasWidth, \"px\");\n        canvasElement.style.height = \"\".concat(canvasHeight, \"px\");\n        canvasElement.style.display = \"none\";\n        canvasElement.id = (0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(customId) ? \"qr-canvas\" : customId;\n        return canvasElement;\n    };\n    Html5Qrcode.prototype.getShadedRegionBounds = function(width, height, qrboxSize) {\n        if (qrboxSize.width > width || qrboxSize.height > height) {\n            throw \"'config.qrbox' dimensions should not be greater than the \" + \"dimensions of the root HTML element.\";\n        }\n        return {\n            x: (width - qrboxSize.width) / 2,\n            y: (height - qrboxSize.height) / 2,\n            width: qrboxSize.width,\n            height: qrboxSize.height\n        };\n    };\n    Html5Qrcode.prototype.possiblyInsertShadingElement = function(element, width, height, qrboxSize) {\n        if (width - qrboxSize.width < 1 || height - qrboxSize.height < 1) {\n            return;\n        }\n        var shadingElement = document.createElement(\"div\");\n        shadingElement.style.position = \"absolute\";\n        var rightLeftBorderSize = (width - qrboxSize.width) / 2;\n        var topBottomBorderSize = (height - qrboxSize.height) / 2;\n        shadingElement.style.borderLeft = \"\".concat(rightLeftBorderSize, \"px solid rgba(0, 0, 0, 0.48)\");\n        shadingElement.style.borderRight = \"\".concat(rightLeftBorderSize, \"px solid rgba(0, 0, 0, 0.48)\");\n        shadingElement.style.borderTop = \"\".concat(topBottomBorderSize, \"px solid rgba(0, 0, 0, 0.48)\");\n        shadingElement.style.borderBottom = \"\".concat(topBottomBorderSize, \"px solid rgba(0, 0, 0, 0.48)\");\n        shadingElement.style.boxSizing = \"border-box\";\n        shadingElement.style.top = \"0px\";\n        shadingElement.style.bottom = \"0px\";\n        shadingElement.style.left = \"0px\";\n        shadingElement.style.right = \"0px\";\n        shadingElement.id = \"\".concat(Constants.SHADED_REGION_ELEMENT_ID);\n        if (width - qrboxSize.width < 11 || height - qrboxSize.height < 11) {\n            this.hasBorderShaders = false;\n        } else {\n            var smallSize = 5;\n            var largeSize = 40;\n            this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, true);\n            this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, false);\n            this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, true);\n            this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, false);\n            this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, true);\n            this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, true);\n            this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, false);\n            this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, false);\n            this.hasBorderShaders = true;\n        }\n        element.append(shadingElement);\n    };\n    Html5Qrcode.prototype.insertShaderBorders = function(shaderElem, width, height, top, bottom, side, isLeft) {\n        var elem = document.createElement(\"div\");\n        elem.style.position = \"absolute\";\n        elem.style.backgroundColor = Constants.BORDER_SHADER_DEFAULT_COLOR;\n        elem.style.width = \"\".concat(width, \"px\");\n        elem.style.height = \"\".concat(height, \"px\");\n        if (top !== null) {\n            elem.style.top = \"\".concat(top, \"px\");\n        }\n        if (bottom !== null) {\n            elem.style.bottom = \"\".concat(bottom, \"px\");\n        }\n        if (isLeft) {\n            elem.style.left = \"\".concat(side, \"px\");\n        } else {\n            elem.style.right = \"\".concat(side, \"px\");\n        }\n        if (!this.borderShaders) {\n            this.borderShaders = [];\n        }\n        this.borderShaders.push(elem);\n        shaderElem.appendChild(elem);\n    };\n    Html5Qrcode.prototype.showPausedState = function() {\n        if (!this.scannerPausedUiElement) {\n            throw \"[internal error] scanner paused UI element not found\";\n        }\n        this.scannerPausedUiElement.style.display = \"block\";\n    };\n    Html5Qrcode.prototype.hidePausedState = function() {\n        if (!this.scannerPausedUiElement) {\n            throw \"[internal error] scanner paused UI element not found\";\n        }\n        this.scannerPausedUiElement.style.display = \"none\";\n    };\n    Html5Qrcode.prototype.getTimeoutFps = function(fps) {\n        return 1000 / fps;\n    };\n    return Html5Qrcode;\n}();\n //# sourceMappingURL=html5-qrcode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9odG1sNS1xcmNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSztJQUN4QyxJQUFJQyxnQkFBZ0IsU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO1FBQzlCRixnQkFBZ0JHLE9BQU9DLGNBQWMsSUFDaEM7WUFBRUMsV0FBVyxFQUFFO1FBQUMsY0FBYUMsU0FBUyxTQUFVTCxDQUFDLEVBQUVDLENBQUM7WUFBSUQsRUFBRUksU0FBUyxHQUFHSDtRQUFHLEtBQzFFLFNBQVVELENBQUMsRUFBRUMsQ0FBQztZQUFJLElBQUssSUFBSUssS0FBS0wsRUFBRyxJQUFJQyxPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUFJTixDQUFDLENBQUNNLEVBQUUsR0FBR0wsQ0FBQyxDQUFDSyxFQUFFO1FBQUU7UUFDcEcsT0FBT1AsY0FBY0MsR0FBR0M7SUFDNUI7SUFDQSxPQUFPLFNBQVVELENBQUMsRUFBRUMsQ0FBQztRQUNqQixJQUFJLE9BQU9BLE1BQU0sY0FBY0EsTUFBTSxNQUNqQyxNQUFNLElBQUlTLFVBQVUseUJBQXlCQyxPQUFPVixLQUFLO1FBQzdERixjQUFjQyxHQUFHQztRQUNqQixTQUFTVztZQUFPLElBQUksQ0FBQ0MsV0FBVyxHQUFHYjtRQUFHO1FBQ3RDQSxFQUFFTyxTQUFTLEdBQUdOLE1BQU0sT0FBT0MsT0FBT1ksTUFBTSxDQUFDYixLQUFNVyxDQUFBQSxHQUFHTCxTQUFTLEdBQUdOLEVBQUVNLFNBQVMsRUFBRSxJQUFJSyxJQUFHO0lBQ3RGO0FBQ0o7QUFDa007QUFDbko7QUFDQTtBQUNFO0FBQ0U7QUFDRTtBQUMwQjtBQUMvRSxJQUFJaUIsWUFBYSxTQUFVQyxNQUFNO0lBQzdCaEMsVUFBVStCLFdBQVdDO0lBQ3JCLFNBQVNEO1FBQ0wsT0FBT0MsV0FBVyxRQUFRQSxPQUFP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b0MsS0FBSyxDQUFDMEUsT0FBTyxHQUFHO0lBQ2hEO0lBQ0FuSCxZQUFZcEQsU0FBUyxDQUFDbUksZUFBZSxHQUFHO1FBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUMxRSxzQkFBc0IsRUFBRTtZQUM5QixNQUFNO1FBQ1Y7UUFDQSxJQUFJLENBQUNBLHNCQUFzQixDQUFDb0MsS0FBSyxDQUFDMEUsT0FBTyxHQUFHO0lBQ2hEO0lBQ0FuSCxZQUFZcEQsU0FBUyxDQUFDbVIsYUFBYSxHQUFHLFNBQVV6TyxHQUFHO1FBQy9DLE9BQU8sT0FBT0E7SUFDbEI7SUFDQSxPQUFPVTtBQUNYO0FBQ3VCLENBQ3ZCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL21pY3JvcG9zLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vaHRtbDUtcXJjb2RlLmpzPzBjZmQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IEJhc2VMb2dnZ2VyLCBIdG1sNVFyY29kZVJlc3VsdEZhY3RvcnksIEh0bWw1UXJjb2RlRXJyb3JGYWN0b3J5LCBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMsIGlzVmFsaWRIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMsIEh0bWw1UXJjb2RlQ29uc3RhbnRzLCBpc051bGxPclVuZGVmaW5lZCB9IGZyb20gXCIuL2NvcmVcIjtcbmltcG9ydCB7IEh0bWw1UXJjb2RlU3RyaW5ncyB9IGZyb20gXCIuL3N0cmluZ3NcIjtcbmltcG9ydCB7IFZpZGVvQ29uc3RyYWludHNVdGlsIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IEh0bWw1UXJjb2RlU2hpbSB9IGZyb20gXCIuL2NvZGUtZGVjb2RlclwiO1xuaW1wb3J0IHsgQ2FtZXJhRmFjdG9yeSB9IGZyb20gXCIuL2NhbWVyYS9mYWN0b3JpZXNcIjtcbmltcG9ydCB7IENhbWVyYVJldHJpZXZlciB9IGZyb20gXCIuL2NhbWVyYS9yZXRyaWV2ZXJcIjtcbmltcG9ydCB7IFN0YXRlTWFuYWdlckZhY3RvcnksIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlIH0gZnJvbSBcIi4vc3RhdGUtbWFuYWdlclwiO1xudmFyIENvbnN0YW50cyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnN0YW50cywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25zdGFudHMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ29uc3RhbnRzLkRFRkFVTFRfV0lEVEggPSAzMDA7XG4gICAgQ29uc3RhbnRzLkRFRkFVTFRfV0lEVEhfT0ZGU0VUID0gMjtcbiAgICBDb25zdGFudHMuRklMRV9TQ0FOX01JTl9IRUlHSFQgPSAzMDA7XG4gICAgQ29uc3RhbnRzLkZJTEVfU0NBTl9ISURERU5fQ0FOVkFTX1BBRERJTkcgPSAxMDA7XG4gICAgQ29uc3RhbnRzLk1JTl9RUl9CT1hfU0laRSA9IDUwO1xuICAgIENvbnN0YW50cy5TSEFERURfTEVGVCA9IDE7XG4gICAgQ29uc3RhbnRzLlNIQURFRF9SSUdIVCA9IDI7XG4gICAgQ29uc3RhbnRzLlNIQURFRF9UT1AgPSAzO1xuICAgIENvbnN0YW50cy5TSEFERURfQk9UVE9NID0gNDtcbiAgICBDb25zdGFudHMuU0hBREVEX1JFR0lPTl9FTEVNRU5UX0lEID0gXCJxci1zaGFkZWQtcmVnaW9uXCI7XG4gICAgQ29uc3RhbnRzLlZFUkJPU0UgPSBmYWxzZTtcbiAgICBDb25zdGFudHMuQk9SREVSX1NIQURFUl9ERUZBVUxUX0NPTE9SID0gXCIjZmZmZmZmXCI7XG4gICAgQ29uc3RhbnRzLkJPUkRFUl9TSEFERVJfTUFUQ0hfQ09MT1IgPSBcInJnYig5MCwgMTkzLCA1NilcIjtcbiAgICByZXR1cm4gQ29uc3RhbnRzO1xufShIdG1sNVFyY29kZUNvbnN0YW50cykpO1xudmFyIEludGVybmFsSHRtbDVRcmNvZGVDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludGVybmFsSHRtbDVRcmNvZGVDb25maWcoY29uZmlnLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMuZnBzID0gQ29uc3RhbnRzLlNDQU5fREVGQVVMVF9GUFM7XG4gICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVGbGlwID0gQ29uc3RhbnRzLkRFRkFVTFRfRElTQUJMRV9GTElQO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5mcHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZwcyA9IGNvbmZpZy5mcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVGbGlwID0gY29uZmlnLmRpc2FibGVGbGlwID09PSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5xcmJveCA9IGNvbmZpZy5xcmJveDtcbiAgICAgICAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSBjb25maWcuYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB0aGlzLnZpZGVvQ29uc3RyYWludHMgPSBjb25maWcudmlkZW9Db25zdHJhaW50cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBJbnRlcm5hbEh0bWw1UXJjb2RlQ29uZmlnLnByb3RvdHlwZS5pc01lZGlhU3RyZWFtQ29uc3RyYWludHNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiRW1wdHkgdmlkZW9Db25zdHJhaW50c1wiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmlkZW9Db25zdHJhaW50c1V0aWwuaXNNZWRpYVN0cmVhbUNvbnN0cmFpbnRzVmFsaWQodGhpcy52aWRlb0NvbnN0cmFpbnRzLCB0aGlzLmxvZ2dlcik7XG4gICAgfTtcbiAgICBJbnRlcm5hbEh0bWw1UXJjb2RlQ29uZmlnLnByb3RvdHlwZS5pc1NoYWRlZEJveEVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhaXNOdWxsT3JVbmRlZmluZWQodGhpcy5xcmJveCk7XG4gICAgfTtcbiAgICBJbnRlcm5hbEh0bWw1UXJjb2RlQ29uZmlnLmNyZWF0ZSA9IGZ1bmN0aW9uIChjb25maWcsIGxvZ2dlcikge1xuICAgICAgICByZXR1cm4gbmV3IEludGVybmFsSHRtbDVRcmNvZGVDb25maWcoY29uZmlnLCBsb2dnZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVybmFsSHRtbDVRcmNvZGVDb25maWc7XG59KCkpO1xudmFyIEh0bWw1UXJjb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNVFyY29kZShlbGVtZW50SWQsIGNvbmZpZ09yVmVyYm9zaXR5RmxhZykge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnNjYW5uZXJQYXVzZWRVaUVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc0JvcmRlclNoYWRlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmJvcmRlclNoYWRlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLnFyTWF0Y2ggPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVkQ2FtZXJhID0gbnVsbDtcbiAgICAgICAgdGhpcy5xclJlZ2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNjYW5JbWFnZUZpbGUgPSBudWxsO1xuICAgICAgICB0aGlzLmlzU2Nhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkhUTUwgRWxlbWVudCB3aXRoIGlkPVwiLmNvbmNhdChlbGVtZW50SWQsIFwiIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnRJZCA9IGVsZW1lbnRJZDtcbiAgICAgICAgdGhpcy52ZXJib3NlID0gZmFsc2U7XG4gICAgICAgIHZhciBleHBlcmltZW50YWxGZWF0dXJlQ29uZmlnO1xuICAgICAgICB2YXIgY29uZmlnT2JqZWN0O1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZ09yVmVyYm9zaXR5RmxhZyA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy52ZXJib3NlID0gY29uZmlnT3JWZXJib3NpdHlGbGFnID09PSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZ09yVmVyYm9zaXR5RmxhZykge1xuICAgICAgICAgICAgY29uZmlnT2JqZWN0ID0gY29uZmlnT3JWZXJib3NpdHlGbGFnO1xuICAgICAgICAgICAgdGhpcy52ZXJib3NlID0gY29uZmlnT2JqZWN0LnZlcmJvc2UgPT09IHRydWU7XG4gICAgICAgICAgICBleHBlcmltZW50YWxGZWF0dXJlQ29uZmlnID0gY29uZmlnT2JqZWN0LmV4cGVyaW1lbnRhbEZlYXR1cmVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbmV3IEJhc2VMb2dnZ2VyKHRoaXMudmVyYm9zZSk7XG4gICAgICAgIHRoaXMucXJjb2RlID0gbmV3IEh0bWw1UXJjb2RlU2hpbSh0aGlzLmdldFN1cHBvcnRlZEZvcm1hdHMoY29uZmlnT3JWZXJib3NpdHlGbGFnKSwgdGhpcy5nZXRVc2VCYXJDb2RlRGV0ZWN0b3JJZlN1cHBvcnRlZChjb25maWdPYmplY3QpLCB0aGlzLnZlcmJvc2UsIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgdGhpcy5mb3JldmVyU2NhblRpbWVvdXQ7XG4gICAgICAgIHRoaXMuc2hvdWxkU2NhbiA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGVNYW5hZ2VyUHJveHkgPSBTdGF0ZU1hbmFnZXJGYWN0b3J5LmNyZWF0ZSgpO1xuICAgIH1cbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoY2FtZXJhSWRPckNvbmZpZywgY29uZmlndXJhdGlvbiwgcXJDb2RlU3VjY2Vzc0NhbGxiYWNrLCBxckNvZGVFcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghY2FtZXJhSWRPckNvbmZpZykge1xuICAgICAgICAgICAgdGhyb3cgXCJjYW1lcmFJZE9yQ29uZmlnIGlzIHJlcXVpcmVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFxckNvZGVTdWNjZXNzQ2FsbGJhY2tcbiAgICAgICAgICAgIHx8IHR5cGVvZiBxckNvZGVTdWNjZXNzQ2FsbGJhY2sgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBcInFyQ29kZVN1Y2Nlc3NDYWxsYmFjayBpcyByZXF1aXJlZCBhbmQgc2hvdWxkIGJlIGEgZnVuY3Rpb24uXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHFyQ29kZUVycm9yQ2FsbGJhY2tJbnRlcm5hbDtcbiAgICAgICAgaWYgKHFyQ29kZUVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHFyQ29kZUVycm9yQ2FsbGJhY2tJbnRlcm5hbCA9IHFyQ29kZUVycm9yQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxckNvZGVFcnJvckNhbGxiYWNrSW50ZXJuYWxcbiAgICAgICAgICAgICAgICA9IHRoaXMudmVyYm9zZSA/IHRoaXMubG9nZ2VyLmxvZyA6IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJuYWxDb25maWcgPSBJbnRlcm5hbEh0bWw1UXJjb2RlQ29uZmlnLmNyZWF0ZShjb25maWd1cmF0aW9uLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgIHRoaXMuY2xlYXJFbGVtZW50KCk7XG4gICAgICAgIHZhciB2aWRlb0NvbnN0cmFpbnRzQXZhaWxhYmxlQW5kVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGludGVybmFsQ29uZmlnLnZpZGVvQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxDb25maWcuaXNNZWRpYVN0cmVhbUNvbnN0cmFpbnRzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiJ3ZpZGVvQ29uc3RyYWludHMnIGlzIG5vdCB2YWxpZCAnTWVkaWFTdHJlYW1Db25zdHJhaW50cywgXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcIml0IHdpbGwgYmUgaWdub3JlZC4nXCIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50c0F2YWlsYWJsZUFuZFZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJlVmlkZW9Db25zdHJhaW50c0VuYWJsZWQgPSB2aWRlb0NvbnN0cmFpbnRzQXZhaWxhYmxlQW5kVmFsaWQ7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbGVtZW50SWQpO1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnRXaWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgICAgICAgID8gZWxlbWVudC5jbGllbnRXaWR0aCA6IENvbnN0YW50cy5ERUZBVUxUX1dJRFRIO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICB0aGlzLnNob3VsZFNjYW4gPSB0cnVlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdG9TY2FubmluZ1N0YXRlQ2hhbmdlVHJhbnNhY3Rpb24gPSB0aGlzLnN0YXRlTWFuYWdlclByb3h5LnN0YXJ0VHJhbnNpdGlvbihIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5TQ0FOTklORyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgdmlkZW9Db25zdHJhaW50cyA9IGFyZVZpZGVvQ29uc3RyYWludHNFbmFibGVkXG4gICAgICAgICAgICAgICAgPyBpbnRlcm5hbENvbmZpZy52aWRlb0NvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgOiAkdGhpcy5jcmVhdGVWaWRlb0NvbnN0cmFpbnRzKGNhbWVyYUlkT3JDb25maWcpO1xuICAgICAgICAgICAgaWYgKCF2aWRlb0NvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgdG9TY2FubmluZ1N0YXRlQ2hhbmdlVHJhbnNhY3Rpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFwidmlkZW9Db25zdHJhaW50cyBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2FtZXJhUmVuZGVyaW5nT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgaWYgKCFhcmVWaWRlb0NvbnN0cmFpbnRzRW5hYmxlZCB8fCBpbnRlcm5hbENvbmZpZy5hc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIGNhbWVyYVJlbmRlcmluZ09wdGlvbnMuYXNwZWN0UmF0aW8gPSBpbnRlcm5hbENvbmZpZy5hc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZW5kZXJpbmdDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAgICAgb25SZW5kZXJTdXJmYWNlUmVhZHk6IGZ1bmN0aW9uICh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuc2V0dXBVaSh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQsIGludGVybmFsQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuaXNTY2FubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmZvcmV2ZXJTY2FuKGludGVybmFsQ29uZmlnLCBxckNvZGVTdWNjZXNzQ2FsbGJhY2ssIHFyQ29kZUVycm9yQ2FsbGJhY2tJbnRlcm5hbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENhbWVyYUZhY3RvcnkuZmFpbElmTm90U3VwcG9ydGVkKCkudGhlbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkuY3JlYXRlKHZpZGVvQ29uc3RyYWludHMpLnRoZW4oZnVuY3Rpb24gKGNhbWVyYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FtZXJhLnJlbmRlcihfdGhpcy5lbGVtZW50LCBjYW1lcmFSZW5kZXJpbmdPcHRpb25zLCByZW5kZXJpbmdDYWxsYmFja3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVuZGVyZWRDYW1lcmEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnJlbmRlcmVkQ2FtZXJhID0gcmVuZGVyZWRDYW1lcmE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1NjYW5uaW5nU3RhdGVDaGFuZ2VUcmFuc2FjdGlvbi5leGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9TY2FubmluZ1N0YXRlQ2hhbmdlVHJhbnNhY3Rpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9TY2FubmluZ1N0YXRlQ2hhbmdlVHJhbnNhY3Rpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChIdG1sNVFyY29kZVN0cmluZ3MuZXJyb3JHZXR0aW5nVXNlck1lZGlhKGVycm9yKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHRvU2Nhbm5pbmdTdGF0ZUNoYW5nZVRyYW5zYWN0aW9uLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChIdG1sNVFyY29kZVN0cmluZ3MuY2FtZXJhU3RyZWFtaW5nTm90U3VwcG9ydGVkKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKHNob3VsZFBhdXNlVmlkZW8pIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlTWFuYWdlclByb3h5LmlzU3RyaWN0bHlTY2FubmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCBwYXVzZSwgc2Nhbm5lciBpcyBub3Qgc2Nhbm5pbmcuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZU1hbmFnZXJQcm94eS5kaXJlY3RUcmFuc2l0aW9uKEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLlBBVVNFRCk7XG4gICAgICAgIHRoaXMuc2hvd1BhdXNlZFN0YXRlKCk7XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChzaG91bGRQYXVzZVZpZGVvKSB8fCBzaG91bGRQYXVzZVZpZGVvICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBzaG91bGRQYXVzZVZpZGVvID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFBhdXNlVmlkZW8gJiYgdGhpcy5yZW5kZXJlZENhbWVyYSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZENhbWVyYS5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGVNYW5hZ2VyUHJveHkuaXNQYXVzZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3QgcmVzdWx0LCBzY2FubmVyIGlzIG5vdCBwYXVzZWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVkQ2FtZXJhKSB7XG4gICAgICAgICAgICB0aHJvdyBcInJlbmRlcmVkQ2FtZXJhIGRvZXNuJ3QgZXhpc3Qgd2hpbGUgdHJ5aW5nIHJlc3VtZSgpXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRyYW5zaXRpb25Ub1NjYW5uaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHRoaXMuc3RhdGVNYW5hZ2VyUHJveHkuZGlyZWN0VHJhbnNpdGlvbihIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5TQ0FOTklORyk7XG4gICAgICAgICAgICAkdGhpcy5oaWRlUGF1c2VkU3RhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVkQ2FtZXJhLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25Ub1NjYW5uaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlZENhbWVyYS5yZXN1bWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNpdGlvblRvU2Nhbm5pbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlTWFuYWdlclByb3h5LmdldFN0YXRlKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlTWFuYWdlclByb3h5LmlzU2Nhbm5pbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3Qgc3RvcCwgc2Nhbm5lciBpcyBub3QgcnVubmluZyBvciBwYXVzZWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvU3RvcHBlZFN0YXRlVHJhbnNhY3Rpb24gPSB0aGlzLnN0YXRlTWFuYWdlclByb3h5LnN0YXJ0VHJhbnNpdGlvbihIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5OT1RfU1RBUlRFRCk7XG4gICAgICAgIHRoaXMuc2hvdWxkU2NhbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mb3JldmVyU2NhblRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZvcmV2ZXJTY2FuVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbW92ZVFyUmVnaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKENvbnN0YW50cy5TSEFERURfUkVHSU9OX0VMRU1FTlRfSUQpO1xuICAgICAgICAgICAgaWYgKGNoaWxkRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWRDYW1lcmEuY2xvc2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICR0aGlzLnJlbmRlcmVkQ2FtZXJhID0gbnVsbDtcbiAgICAgICAgICAgIGlmICgkdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCgkdGhpcy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAkdGhpcy5jYW52YXNFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZVFyUmVnaW9uKCk7XG4gICAgICAgICAgICBpZiAoJHRoaXMucXJSZWdpb24pIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5xclJlZ2lvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJHRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgICAgICR0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9TdG9wcGVkU3RhdGVUcmFuc2FjdGlvbi5leGVjdXRlKCk7XG4gICAgICAgICAgICAkdGhpcy5oaWRlUGF1c2VkU3RhdGUoKTtcbiAgICAgICAgICAgICR0aGlzLmlzU2Nhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuc2NhbkZpbGUgPSBmdW5jdGlvbiAoaW1hZ2VGaWxlLCBzaG93SW1hZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkZpbGVWMihpbWFnZUZpbGUsIHNob3dJbWFnZSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChodG1sNXFyY29kZVJlc3VsdCkgeyByZXR1cm4gaHRtbDVxcmNvZGVSZXN1bHQuZGVjb2RlZFRleHQ7IH0pO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnNjYW5GaWxlVjIgPSBmdW5jdGlvbiAoaW1hZ2VGaWxlLCBzaG93SW1hZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFpbWFnZUZpbGUgfHwgIShpbWFnZUZpbGUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJpbWFnZUZpbGUgYXJndW1lbnQgaXMgbWFuZGF0b3J5IGFuZCBzaG91bGQgYmUgaW5zdGFuY2UgXCJcbiAgICAgICAgICAgICAgICArIFwib2YgRmlsZS4gVXNlICdldmVudC50YXJnZXQuZmlsZXNbMF0nLlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChzaG93SW1hZ2UpKSB7XG4gICAgICAgICAgICBzaG93SW1hZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZU1hbmFnZXJQcm94eS5jYW5TY2FuRmlsZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCBzdGFydCBmaWxlIHNjYW4gLSBvbmdvaW5nIGNhbWVyYSBzY2FuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLnBvc3NpYmx5Q2xvc2VMYXN0U2NhbkltYWdlRmlsZSgpO1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJFbGVtZW50KCk7XG4gICAgICAgICAgICBfdGhpcy5sYXN0U2NhbkltYWdlRmlsZSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoaW1hZ2VGaWxlKTtcbiAgICAgICAgICAgIHZhciBpbnB1dEltYWdlID0gbmV3IEltYWdlO1xuICAgICAgICAgICAgaW5wdXRJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlV2lkdGggPSBpbnB1dEltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBpbWFnZUhlaWdodCA9IGlucHV0SW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoX3RoaXMuZWxlbWVudElkKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoXG4gICAgICAgICAgICAgICAgICAgID8gZWxlbWVudC5jbGllbnRXaWR0aCA6IENvbnN0YW50cy5ERUZBVUxUX1dJRFRIO1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBNYXRoLm1heChlbGVtZW50LmNsaWVudEhlaWdodCA/IGVsZW1lbnQuY2xpZW50SGVpZ2h0IDogaW1hZ2VIZWlnaHQsIENvbnN0YW50cy5GSUxFX1NDQU5fTUlOX0hFSUdIVCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IF90aGlzLmNvbXB1dGVDYW52YXNEcmF3Q29uZmlnKGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0LCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvd0ltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlQ2FudmFzID0gX3RoaXMuY3JlYXRlQ2FudmFzRWxlbWVudChjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0LCBcInFyLWNhbnZhcy12aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlQ2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHZpc2libGVDYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dF8xID0gdmlzaWJsZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIlVuYWJsZSB0byBnZXQgMmQgY29udGV4dCBmcm9tIGNhbnZhc1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfMS5jYW52YXMud2lkdGggPSBjb250YWluZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF8xLmNhbnZhcy5oZWlnaHQgPSBjb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfMS5kcmF3SW1hZ2UoaW5wdXRJbWFnZSwgMCwgMCwgaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQsIGNvbmZpZy54LCBjb25maWcueSwgY29uZmlnLndpZHRoLCBjb25maWcuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBDb25zdGFudHMuRklMRV9TQ0FOX0hJRERFTl9DQU5WQVNfUEFERElORztcbiAgICAgICAgICAgICAgICB2YXIgaGlkZGVuSW1hZ2VXaWR0aCA9IE1hdGgubWF4KGlucHV0SW1hZ2Uud2lkdGgsIGNvbmZpZy53aWR0aCk7XG4gICAgICAgICAgICAgICAgdmFyIGhpZGRlbkltYWdlSGVpZ2h0ID0gTWF0aC5tYXgoaW5wdXRJbWFnZS5oZWlnaHQsIGNvbmZpZy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHZhciBoaWRkZW5DYW52YXNXaWR0aCA9IGhpZGRlbkltYWdlV2lkdGggKyAyICogcGFkZGluZztcbiAgICAgICAgICAgICAgICB2YXIgaGlkZGVuQ2FudmFzSGVpZ2h0ID0gaGlkZGVuSW1hZ2VIZWlnaHQgKyAyICogcGFkZGluZztcbiAgICAgICAgICAgICAgICB2YXIgaGlkZGVuQ2FudmFzID0gX3RoaXMuY3JlYXRlQ2FudmFzRWxlbWVudChoaWRkZW5DYW52YXNXaWR0aCwgaGlkZGVuQ2FudmFzSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGhpZGRlbkNhbnZhcyk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBoaWRkZW5DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIlVuYWJsZSB0byBnZXQgMmQgY29udGV4dCBmcm9tIGNhbnZhc1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LmNhbnZhcy53aWR0aCA9IGhpZGRlbkNhbnZhc1dpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2FudmFzLmhlaWdodCA9IGhpZGRlbkNhbnZhc0hlaWdodDtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbnB1dEltYWdlLCAwLCAwLCBpbWFnZVdpZHRoLCBpbWFnZUhlaWdodCwgcGFkZGluZywgcGFkZGluZywgaGlkZGVuSW1hZ2VXaWR0aCwgaGlkZGVuSW1hZ2VIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnFyY29kZS5kZWNvZGVSb2J1c3RseUFzeW5jKGhpZGRlbkNhbnZhcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoSHRtbDVRcmNvZGVSZXN1bHRGYWN0b3J5LmNyZWF0ZUZyb21RcmNvZGVSZXN1bHQocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoXCJRUiBjb2RlIHBhcnNlIGVycm9yLCBlcnJvciA9IFwiLmNvbmNhdChleGNlcHRpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW5wdXRJbWFnZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgaW5wdXRJbWFnZS5vbmFib3J0ID0gcmVqZWN0O1xuICAgICAgICAgICAgaW5wdXRJbWFnZS5vbnN0YWxsZWQgPSByZWplY3Q7XG4gICAgICAgICAgICBpbnB1dEltYWdlLm9uc3VzcGVuZCA9IHJlamVjdDtcbiAgICAgICAgICAgIGlucHV0SW1hZ2Uuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChpbWFnZUZpbGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhckVsZW1lbnQoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLmdldENhbWVyYXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBDYW1lcmFSZXRyaWV2ZXIucmV0cmlldmUoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRSdW5uaW5nVHJhY2tDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVkQ2FtZXJhT3JGYWlsKCkuZ2V0UnVubmluZ1RyYWNrQ2FwYWJpbGl0aWVzKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuZ2V0UnVubmluZ1RyYWNrU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVkQ2FtZXJhT3JGYWlsKCkuZ2V0UnVubmluZ1RyYWNrU2V0dGluZ3MoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRSdW5uaW5nVHJhY2tDYW1lcmFDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVkQ2FtZXJhT3JGYWlsKCkuZ2V0Q2FwYWJpbGl0aWVzKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuYXBwbHlWaWRlb0NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHZpZGVvQ29uc3RhaW50cykge1xuICAgICAgICBpZiAoIXZpZGVvQ29uc3RhaW50cykge1xuICAgICAgICAgICAgdGhyb3cgXCJ2aWRlb0NvbnN0YWludHMgaXMgcmVxdWlyZWQgYXJndW1lbnQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIVZpZGVvQ29uc3RyYWludHNVdGlsLmlzTWVkaWFTdHJlYW1Db25zdHJhaW50c1ZhbGlkKHZpZGVvQ29uc3RhaW50cywgdGhpcy5sb2dnZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBcImludmFsaWQgdmlkZW9Db25zdGFpbnRzIHBhc3NlZCwgY2hlY2sgbG9ncyBmb3IgbW9yZSBkZXRhaWxzXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyZWRDYW1lcmFPckZhaWwoKS5hcHBseVZpZGVvQ29uc3RyYWludHModmlkZW9Db25zdGFpbnRzKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRSZW5kZXJlZENhbWVyYU9yRmFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRDYW1lcmEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgXCJTY2FubmluZyBpcyBub3QgaW4gcnVubmluZyBzdGF0ZSwgY2FsbCB0aGlzIEFQSSBvbmx5IHdoZW5cIlxuICAgICAgICAgICAgICAgICsgXCIgUVIgY29kZSBzY2FubmluZyB1c2luZyBjYW1lcmEgaXMgaW4gcnVubmluZyBzdGF0ZS5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZENhbWVyYTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRTdXBwb3J0ZWRGb3JtYXRzID0gZnVuY3Rpb24gKGNvbmZpZ09yVmVyYm9zaXR5RmxhZykge1xuICAgICAgICB2YXIgYWxsRm9ybWF0cyA9IFtcbiAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5RUl9DT0RFLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkFaVEVDLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREFCQVIsXG4gICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQ09ERV8zOSxcbiAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RFXzkzLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfMTI4LFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkRBVEFfTUFUUklYLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLk1BWElDT0RFLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLklURixcbiAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5FQU5fMTMsXG4gICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuRUFOXzgsXG4gICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUERGXzQxNyxcbiAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5SU1NfMTQsXG4gICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUlNTX0VYUEFOREVELFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19BLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19FLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19FQU5fRVhURU5TSU9OLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoIWNvbmZpZ09yVmVyYm9zaXR5RmxhZ1xuICAgICAgICAgICAgfHwgdHlwZW9mIGNvbmZpZ09yVmVyYm9zaXR5RmxhZyA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIGFsbEZvcm1hdHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWdPclZlcmJvc2l0eUZsYWcuZm9ybWF0c1RvU3VwcG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIGFsbEZvcm1hdHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ09yVmVyYm9zaXR5RmxhZy5mb3JtYXRzVG9TdXBwb3J0KSkge1xuICAgICAgICAgICAgdGhyb3cgXCJjb25maWdPclZlcmJvc2l0eUZsYWcuZm9ybWF0c1RvU3VwcG9ydCBzaG91bGQgYmUgdW5kZWZpbmVkIFwiXG4gICAgICAgICAgICAgICAgKyBcIm9yIGFuIGFycmF5LlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWdPclZlcmJvc2l0eUZsYWcuZm9ybWF0c1RvU3VwcG9ydC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IFwiQXRsZWFzdCAxIGZvcm1hdHNUb1N1cHBvcnQgaXMgbmVlZGVkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdXBwb3J0ZWRGb3JtYXRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb25maWdPclZlcmJvc2l0eUZsYWcuZm9ybWF0c1RvU3VwcG9ydDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cyhmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkRm9ybWF0cy5wdXNoKGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiSW52YWxpZCBmb3JtYXQ6IFwiLmNvbmNhdChmb3JtYXQsIFwiIHBhc3NlZCBpbiBjb25maWcsIGlnbm9yaW5nLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1cHBvcnRlZEZvcm1hdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBcIk5vbmUgb2YgZm9ybWF0c1RvU3VwcG9ydCBtYXRjaCBzdXBwb3J0ZWQgdmFsdWVzLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWRGb3JtYXRzO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmdldFVzZUJhckNvZGVEZXRlY3RvcklmU3VwcG9ydGVkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoY29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChjb25maWcudXNlQmFyQ29kZURldGVjdG9ySWZTdXBwb3J0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnVzZUJhckNvZGVEZXRlY3RvcklmU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoY29uZmlnLmV4cGVyaW1lbnRhbEZlYXR1cmVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4cGVyaW1lbnRhbEZlYXR1cmVzID0gY29uZmlnLmV4cGVyaW1lbnRhbEZlYXR1cmVzO1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoZXhwZXJpbWVudGFsRmVhdHVyZXMudXNlQmFyQ29kZURldGVjdG9ySWZTdXBwb3J0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwZXJpbWVudGFsRmVhdHVyZXMudXNlQmFyQ29kZURldGVjdG9ySWZTdXBwb3J0ZWQgIT09IGZhbHNlO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnZhbGlkYXRlUXJib3hTaXplID0gZnVuY3Rpb24gKHZpZXdmaW5kZXJXaWR0aCwgdmlld2ZpbmRlckhlaWdodCwgaW50ZXJuYWxDb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHFyYm94U2l6ZSA9IGludGVybmFsQ29uZmlnLnFyYm94O1xuICAgICAgICB0aGlzLnZhbGlkYXRlUXJib3hDb25maWcocXJib3hTaXplKTtcbiAgICAgICAgdmFyIHFyRGltZW5zaW9ucyA9IHRoaXMudG9RcmRpbWVuc2lvbnModmlld2ZpbmRlcldpZHRoLCB2aWV3ZmluZGVySGVpZ2h0LCBxcmJveFNpemUpO1xuICAgICAgICB2YXIgdmFsaWRhdGVNaW5TaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICAgIGlmIChzaXplIDwgQ29uc3RhbnRzLk1JTl9RUl9CT1hfU0laRSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwibWluaW11bSBzaXplIG9mICdjb25maWcucXJib3gnIGRpbWVuc2lvbiB2YWx1ZSBpc1wiXG4gICAgICAgICAgICAgICAgICAgICsgXCIgXCIuY29uY2F0KENvbnN0YW50cy5NSU5fUVJfQk9YX1NJWkUsIFwicHguXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29ycmVjdFdpZHRoQmFzZWRPblJvb3RFbGVtZW50U2l6ZSA9IGZ1bmN0aW9uIChjb25maWdXaWR0aCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZ1dpZHRoID4gdmlld2ZpbmRlcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJgcXJib3gud2lkdGhgIG9yIGBxcmJveGAgaXMgbGFyZ2VyIHRoYW4gdGhlXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcIiB3aWR0aCBvZiB0aGUgcm9vdCBlbGVtZW50LiBUaGUgd2lkdGggd2lsbCBiZSB0cnVuY2F0ZWRcIlxuICAgICAgICAgICAgICAgICAgICArIFwiIHRvIHRoZSB3aWR0aCBvZiByb290IGVsZW1lbnQuXCIpO1xuICAgICAgICAgICAgICAgIGNvbmZpZ1dpZHRoID0gdmlld2ZpbmRlcldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ1dpZHRoO1xuICAgICAgICB9O1xuICAgICAgICB2YWxpZGF0ZU1pblNpemUocXJEaW1lbnNpb25zLndpZHRoKTtcbiAgICAgICAgdmFsaWRhdGVNaW5TaXplKHFyRGltZW5zaW9ucy5oZWlnaHQpO1xuICAgICAgICBxckRpbWVuc2lvbnMud2lkdGggPSBjb3JyZWN0V2lkdGhCYXNlZE9uUm9vdEVsZW1lbnRTaXplKHFyRGltZW5zaW9ucy53aWR0aCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUudmFsaWRhdGVRcmJveENvbmZpZyA9IGZ1bmN0aW9uIChxcmJveFNpemUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBxcmJveFNpemUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHFyYm94U2l6ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHFyYm94U2l6ZS53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHFyYm94U2l6ZS5oZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGluc3RhbmNlIG9mIFFyRGltZW5zaW9ucyBwYXNzZWQgZm9yIFwiXG4gICAgICAgICAgICAgICAgKyBcIidjb25maWcucXJib3gnLiBCb3RoICd3aWR0aCcgYW5kICdoZWlnaHQnIHNob3VsZCBiZSBzZXQuXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS50b1FyZGltZW5zaW9ucyA9IGZ1bmN0aW9uICh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQsIHFyYm94U2l6ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHFyYm94U2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHFyYm94U2l6ZSwgaGVpZ2h0OiBxcmJveFNpemUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcXJib3hTaXplID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFyYm94U2l6ZSh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicXJib3ggY29uZmlnIHdhcyBwYXNzZWQgYXMgYSBmdW5jdGlvbiBidXQgaXQgZmFpbGVkIHdpdGggXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcInVua25vd24gZXJyb3JcIiArIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXJib3hTaXplO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnNldHVwVWkgPSBmdW5jdGlvbiAodmlld2ZpbmRlcldpZHRoLCB2aWV3ZmluZGVySGVpZ2h0LCBpbnRlcm5hbENvbmZpZykge1xuICAgICAgICBpZiAoaW50ZXJuYWxDb25maWcuaXNTaGFkZWRCb3hFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVRcmJveFNpemUodmlld2ZpbmRlcldpZHRoLCB2aWV3ZmluZGVySGVpZ2h0LCBpbnRlcm5hbENvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHFyYm94U2l6ZSA9IGlzTnVsbE9yVW5kZWZpbmVkKGludGVybmFsQ29uZmlnLnFyYm94KSA/XG4gICAgICAgICAgICB7IHdpZHRoOiB2aWV3ZmluZGVyV2lkdGgsIGhlaWdodDogdmlld2ZpbmRlckhlaWdodCB9IDogaW50ZXJuYWxDb25maWcucXJib3g7XG4gICAgICAgIHRoaXMudmFsaWRhdGVRcmJveENvbmZpZyhxcmJveFNpemUpO1xuICAgICAgICB2YXIgcXJEaW1lbnNpb25zID0gdGhpcy50b1FyZGltZW5zaW9ucyh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQsIHFyYm94U2l6ZSk7XG4gICAgICAgIGlmIChxckRpbWVuc2lvbnMuaGVpZ2h0ID4gdmlld2ZpbmRlckhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIltIdG1sNVFyY29kZV0gY29uZmlnLnFyYm94IGhhcyBoZWlnaHQgdGhhdCBpc1wiXG4gICAgICAgICAgICAgICAgKyBcImdyZWF0ZXIgdGhhbiB0aGUgaGVpZ2h0IG9mIHRoZSB2aWRlbyBzdHJlYW0uIFNoYWRpbmcgd2lsbCBiZVwiXG4gICAgICAgICAgICAgICAgKyBcIiBpZ25vcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRTaGFkaW5nQmVBcHBsaWVkID0gaW50ZXJuYWxDb25maWcuaXNTaGFkZWRCb3hFbmFibGVkKClcbiAgICAgICAgICAgICYmIHFyRGltZW5zaW9ucy5oZWlnaHQgPD0gdmlld2ZpbmRlckhlaWdodDtcbiAgICAgICAgdmFyIGRlZmF1bHRRclJlZ2lvbiA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IHZpZXdmaW5kZXJXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdmlld2ZpbmRlckhlaWdodFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcXJSZWdpb24gPSBzaG91bGRTaGFkaW5nQmVBcHBsaWVkXG4gICAgICAgICAgICA/IHRoaXMuZ2V0U2hhZGVkUmVnaW9uQm91bmRzKHZpZXdmaW5kZXJXaWR0aCwgdmlld2ZpbmRlckhlaWdodCwgcXJEaW1lbnNpb25zKVxuICAgICAgICAgICAgOiBkZWZhdWx0UXJSZWdpb247XG4gICAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy5jcmVhdGVDYW52YXNFbGVtZW50KHFyUmVnaW9uLndpZHRoLCBxclJlZ2lvbi5oZWlnaHQpO1xuICAgICAgICB2YXIgY29udGV4dEF0dHJpYnV0ZXMgPSB7IHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZSB9O1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRBdHRyaWJ1dGVzKTtcbiAgICAgICAgY29udGV4dC5jYW52YXMud2lkdGggPSBxclJlZ2lvbi53aWR0aDtcbiAgICAgICAgY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gcXJSZWdpb24uaGVpZ2h0O1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKGNhbnZhc0VsZW1lbnQpO1xuICAgICAgICBpZiAoc2hvdWxkU2hhZGluZ0JlQXBwbGllZCkge1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJseUluc2VydFNoYWRpbmdFbGVtZW50KHRoaXMuZWxlbWVudCwgdmlld2ZpbmRlcldpZHRoLCB2aWV3ZmluZGVySGVpZ2h0LCBxckRpbWVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlU2Nhbm5lclBhdXNlZFVpRWxlbWVudCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLnFyUmVnaW9uID0gcXJSZWdpb247XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudCA9IGNhbnZhc0VsZW1lbnQ7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuY3JlYXRlU2Nhbm5lclBhdXNlZFVpRWxlbWVudCA9IGZ1bmN0aW9uIChyb290RWxlbWVudCkge1xuICAgICAgICB2YXIgc2Nhbm5lclBhdXNlZFVpRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuaW5uZXJUZXh0ID0gSHRtbDVRcmNvZGVTdHJpbmdzLnNjYW5uZXJQYXVzZWQoKTtcbiAgICAgICAgc2Nhbm5lclBhdXNlZFVpRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgc2Nhbm5lclBhdXNlZFVpRWxlbWVudC5zdHlsZS56SW5kZXggPSBcIjFcIjtcbiAgICAgICAgc2Nhbm5lclBhdXNlZFVpRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kID0gXCJyZ2JhKDksIDksIDksIDAuNDYpXCI7XG4gICAgICAgIHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUuY29sb3IgPSBcIiNGRkVDRUNcIjtcbiAgICAgICAgc2Nhbm5lclBhdXNlZFVpRWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICBzY2FubmVyUGF1c2VkVWlFbGVtZW50LnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgIHJvb3RFbGVtZW50LmFwcGVuZENoaWxkKHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQpO1xuICAgICAgICB0aGlzLnNjYW5uZXJQYXVzZWRVaUVsZW1lbnQgPSBzY2FubmVyUGF1c2VkVWlFbGVtZW50O1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnNjYW5Db250ZXh0ID0gZnVuY3Rpb24gKHFyQ29kZVN1Y2Nlc3NDYWxsYmFjaywgcXJDb2RlRXJyb3JDYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZU1hbmFnZXJQcm94eS5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xcmNvZGUuZGVjb2RlQXN5bmModGhpcy5jYW52YXNFbGVtZW50KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgcXJDb2RlU3VjY2Vzc0NhbGxiYWNrKHJlc3VsdC50ZXh0LCBIdG1sNVFyY29kZVJlc3VsdEZhY3RvcnkuY3JlYXRlRnJvbVFyY29kZVJlc3VsdChyZXN1bHQpKTtcbiAgICAgICAgICAgIF90aGlzLnBvc3NpYmx5VXBkYXRlU2hhZGVycyh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLnBvc3NpYmx5VXBkYXRlU2hhZGVycyhmYWxzZSk7XG4gICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gSHRtbDVRcmNvZGVTdHJpbmdzLmNvZGVQYXJzZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHFyQ29kZUVycm9yQ2FsbGJhY2soZXJyb3JNZXNzYWdlLCBIdG1sNVFyY29kZUVycm9yRmFjdG9yeS5jcmVhdGVGcm9tKGVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5mb3JldmVyU2NhbiA9IGZ1bmN0aW9uIChpbnRlcm5hbENvbmZpZywgcXJDb2RlU3VjY2Vzc0NhbGxiYWNrLCBxckNvZGVFcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zaG91bGRTY2FuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVkQ2FtZXJhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZGVvRWxlbWVudCA9IHRoaXMucmVuZGVyZWRDYW1lcmEuZ2V0U3VyZmFjZSgpO1xuICAgICAgICB2YXIgd2lkdGhSYXRpbyA9IHZpZGVvRWxlbWVudC52aWRlb1dpZHRoIC8gdmlkZW9FbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0UmF0aW8gPSB2aWRlb0VsZW1lbnQudmlkZW9IZWlnaHQgLyB2aWRlb0VsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAoIXRoaXMucXJSZWdpb24pIHtcbiAgICAgICAgICAgIHRocm93IFwicXJSZWdpb24gdW5kZWZpbmVkIHdoZW4gbG9jYWxNZWRpYVN0cmVhbSBpcyByZWFkeS5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc1dpZHRoT2Zmc2V0ID0gdGhpcy5xclJlZ2lvbi53aWR0aCAqIHdpZHRoUmF0aW87XG4gICAgICAgIHZhciBzSGVpZ2h0T2Zmc2V0ID0gdGhpcy5xclJlZ2lvbi5oZWlnaHQgKiBoZWlnaHRSYXRpbztcbiAgICAgICAgdmFyIHN4T2Zmc2V0ID0gdGhpcy5xclJlZ2lvbi54ICogd2lkdGhSYXRpbztcbiAgICAgICAgdmFyIHN5T2Zmc2V0ID0gdGhpcy5xclJlZ2lvbi55ICogaGVpZ2h0UmF0aW87XG4gICAgICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UodmlkZW9FbGVtZW50LCBzeE9mZnNldCwgc3lPZmZzZXQsIHNXaWR0aE9mZnNldCwgc0hlaWdodE9mZnNldCwgMCwgMCwgdGhpcy5xclJlZ2lvbi53aWR0aCwgdGhpcy5xclJlZ2lvbi5oZWlnaHQpO1xuICAgICAgICB2YXIgdHJpZ2dlck5leHRTY2FuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZm9yZXZlclNjYW5UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZm9yZXZlclNjYW4oaW50ZXJuYWxDb25maWcsIHFyQ29kZVN1Y2Nlc3NDYWxsYmFjaywgcXJDb2RlRXJyb3JDYWxsYmFjayk7XG4gICAgICAgICAgICB9LCBfdGhpcy5nZXRUaW1lb3V0RnBzKGludGVybmFsQ29uZmlnLmZwcykpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNjYW5Db250ZXh0KHFyQ29kZVN1Y2Nlc3NDYWxsYmFjaywgcXJDb2RlRXJyb3JDYWxsYmFjaylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChpc1N1Y2Nlc3NmdWxsKSB7XG4gICAgICAgICAgICBpZiAoIWlzU3VjY2Vzc2Z1bGwgJiYgaW50ZXJuYWxDb25maWcuZGlzYWJsZUZsaXAgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LnRyYW5zbGF0ZShfdGhpcy5jb250ZXh0LmNhbnZhcy53aWR0aCwgMCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC5zY2FsZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2NhbkNvbnRleHQocXJDb2RlU3VjY2Vzc0NhbGxiYWNrLCBxckNvZGVFcnJvckNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJOZXh0U2NhbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlck5leHRTY2FuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiRXJyb3IgaGFwcGVuZCB3aGlsZSBzY2FubmluZyBjb250ZXh0XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHRyaWdnZXJOZXh0U2NhbigpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5jcmVhdGVWaWRlb0NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGNhbWVyYUlkT3JDb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYW1lcmFJZE9yQ29uZmlnID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRldmljZUlkOiB7IGV4YWN0OiBjYW1lcmFJZE9yQ29uZmlnIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2FtZXJhSWRPckNvbmZpZyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2YXIgZmFjaW5nTW9kZUtleSA9IFwiZmFjaW5nTW9kZVwiO1xuICAgICAgICAgICAgdmFyIGRldmljZUlkS2V5ID0gXCJkZXZpY2VJZFwiO1xuICAgICAgICAgICAgdmFyIGFsbG93ZWRGYWNpbmdNb2RlVmFsdWVzXzEgPSB7IFwidXNlclwiOiB0cnVlLCBcImVudmlyb25tZW50XCI6IHRydWUgfTtcbiAgICAgICAgICAgIHZhciBleGFjdEtleSA9IFwiZXhhY3RcIjtcbiAgICAgICAgICAgIHZhciBpc1ZhbGlkRmFjaW5nTW9kZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluIGFsbG93ZWRGYWNpbmdNb2RlVmFsdWVzXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcImNvbmZpZyBoYXMgaW52YWxpZCAnZmFjaW5nTW9kZScgdmFsdWUgPSBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBcIidcIi5jb25jYXQodmFsdWUsIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjYW1lcmFJZE9yQ29uZmlnKTtcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiJ2NhbWVyYUlkT3JDb25maWcnIG9iamVjdCBzaG91bGQgaGF2ZSBleGFjdGx5IDEga2V5LFwiXG4gICAgICAgICAgICAgICAgICAgICsgXCIgaWYgcGFzc2VkIGFzIGFuIG9iamVjdCwgZm91bmQgXCIuY29uY2F0KGtleXMubGVuZ3RoLCBcIiBrZXlzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IE9iamVjdC5rZXlzKGNhbWVyYUlkT3JDb25maWcpWzBdO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gZmFjaW5nTW9kZUtleSAmJiBrZXkgIT09IGRldmljZUlkS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJPbmx5ICdcIi5jb25jYXQoZmFjaW5nTW9kZUtleSwgXCInIGFuZCAnXCIpLmNvbmNhdChkZXZpY2VJZEtleSwgXCInIFwiKVxuICAgICAgICAgICAgICAgICAgICArIFwiIGFyZSBzdXBwb3J0ZWQgZm9yICdjYW1lcmFJZE9yQ29uZmlnJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gZmFjaW5nTW9kZUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBmYWNpbmdNb2RlID0gY2FtZXJhSWRPckNvbmZpZy5mYWNpbmdNb2RlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmFjaW5nTW9kZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkRmFjaW5nTW9kZVZhbHVlKGZhY2luZ01vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmYWNpbmdNb2RlOiBmYWNpbmdNb2RlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZhY2luZ01vZGUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhhY3RLZXkgaW4gZmFjaW5nTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRGYWNpbmdNb2RlVmFsdWUoZmFjaW5nTW9kZVtcIlwiLmNvbmNhdChleGFjdEtleSldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY2luZ01vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWNpbmdNb2RlW1wiXCIuY29uY2F0KGV4YWN0S2V5KV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIidmYWNpbmdNb2RlJyBzaG91bGQgYmUgc3RyaW5nIG9yIG9iamVjdCB3aXRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIFwiIFwiLmNvbmNhdChleGFjdEtleSwgXCIgYXMga2V5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVfMSA9ICh0eXBlb2YgZmFjaW5nTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCB0eXBlIG9mICdmYWNpbmdNb2RlJyA9IFwiLmNvbmNhdCh0eXBlXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkZXZpY2VJZCA9IGNhbWVyYUlkT3JDb25maWcuZGV2aWNlSWQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXZpY2VJZCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRldmljZUlkOiBkZXZpY2VJZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGV2aWNlSWQgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhhY3RLZXkgaW4gZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQ6IHsgZXhhY3Q6IGRldmljZUlkW1wiXCIuY29uY2F0KGV4YWN0S2V5KV0gfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiJ2RldmljZUlkJyBzaG91bGQgYmUgc3RyaW5nIG9yIG9iamVjdCB3aXRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIFwiIFwiLmNvbmNhdChleGFjdEtleSwgXCIgYXMga2V5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVfMiA9ICh0eXBlb2YgZGV2aWNlSWQpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdHlwZSBvZiAnZGV2aWNlSWQnID0gXCIuY29uY2F0KHR5cGVfMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gKHR5cGVvZiBjYW1lcmFJZE9yQ29uZmlnKTtcbiAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHR5cGUgb2YgJ2NhbWVyYUlkT3JDb25maWcnID0gXCIuY29uY2F0KHR5cGUpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmNvbXB1dGVDYW52YXNEcmF3Q29uZmlnID0gZnVuY3Rpb24gKGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0LCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgIGlmIChpbWFnZVdpZHRoIDw9IGNvbnRhaW5lcldpZHRoXG4gICAgICAgICAgICAmJiBpbWFnZUhlaWdodCA8PSBjb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciB4b2Zmc2V0ID0gKGNvbnRhaW5lcldpZHRoIC0gaW1hZ2VXaWR0aCkgLyAyO1xuICAgICAgICAgICAgdmFyIHlvZmZzZXQgPSAoY29udGFpbmVySGVpZ2h0IC0gaW1hZ2VIZWlnaHQpIC8gMjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogeG9mZnNldCxcbiAgICAgICAgICAgICAgICB5OiB5b2Zmc2V0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBpbWFnZVdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaW1hZ2VIZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm9ybWVySW1hZ2VXaWR0aCA9IGltYWdlV2lkdGg7XG4gICAgICAgICAgICB2YXIgZm9ybWVySW1hZ2VIZWlnaHQgPSBpbWFnZUhlaWdodDtcbiAgICAgICAgICAgIGlmIChpbWFnZVdpZHRoID4gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpbWFnZUhlaWdodCA9IChjb250YWluZXJXaWR0aCAvIGltYWdlV2lkdGgpICogaW1hZ2VIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaW1hZ2VXaWR0aCA9IGNvbnRhaW5lcldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltYWdlSGVpZ2h0ID4gY29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VXaWR0aCA9IChjb250YWluZXJIZWlnaHQgLyBpbWFnZUhlaWdodCkgKiBpbWFnZVdpZHRoO1xuICAgICAgICAgICAgICAgIGltYWdlSGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSW1hZ2UgZG93bnNhbXBsZWQgZnJvbSBcIlxuICAgICAgICAgICAgICAgICsgXCJcIi5jb25jYXQoZm9ybWVySW1hZ2VXaWR0aCwgXCJYXCIpLmNvbmNhdChmb3JtZXJJbWFnZUhlaWdodClcbiAgICAgICAgICAgICAgICArIFwiIHRvIFwiLmNvbmNhdChpbWFnZVdpZHRoLCBcIlhcIikuY29uY2F0KGltYWdlSGVpZ2h0LCBcIi5cIikpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUNhbnZhc0RyYXdDb25maWcoaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQsIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuY2xlYXJFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZU1hbmFnZXJQcm94eS5pc1NjYW5uaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IFwiQ2Fubm90IGNsZWFyIHdoaWxlIHNjYW4gaXMgb25nb2luZywgY2xvc2UgaXQgZmlyc3QuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmVsZW1lbnRJZCk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5wb3NzaWJseVVwZGF0ZVNoYWRlcnMgPSBmdW5jdGlvbiAocXJNYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5xck1hdGNoID09PSBxck1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzQm9yZGVyU2hhZGVyc1xuICAgICAgICAgICAgJiYgdGhpcy5ib3JkZXJTaGFkZXJzXG4gICAgICAgICAgICAmJiB0aGlzLmJvcmRlclNoYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJvcmRlclNoYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgc2hhZGVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHFyTWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgPyBDb25zdGFudHMuQk9SREVSX1NIQURFUl9NQVRDSF9DT0xPUlxuICAgICAgICAgICAgICAgICAgICA6IENvbnN0YW50cy5CT1JERVJfU0hBREVSX0RFRkFVTFRfQ09MT1I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnFyTWF0Y2ggPSBxck1hdGNoO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnBvc3NpYmx5Q2xvc2VMYXN0U2NhbkltYWdlRmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdFNjYW5JbWFnZUZpbGUpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5sYXN0U2NhbkltYWdlRmlsZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RTY2FuSW1hZ2VGaWxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmNyZWF0ZUNhbnZhc0VsZW1lbnQgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgY3VzdG9tSWQpIHtcbiAgICAgICAgdmFyIGNhbnZhc1dpZHRoID0gd2lkdGg7XG4gICAgICAgIHZhciBjYW52YXNIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgY2FudmFzRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KGNhbnZhc1dpZHRoLCBcInB4XCIpO1xuICAgICAgICBjYW52YXNFbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGNhbnZhc0hlaWdodCwgXCJweFwiKTtcbiAgICAgICAgY2FudmFzRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuaWQgPSBpc051bGxPclVuZGVmaW5lZChjdXN0b21JZClcbiAgICAgICAgICAgID8gXCJxci1jYW52YXNcIiA6IGN1c3RvbUlkO1xuICAgICAgICByZXR1cm4gY2FudmFzRWxlbWVudDtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRTaGFkZWRSZWdpb25Cb3VuZHMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgcXJib3hTaXplKSB7XG4gICAgICAgIGlmIChxcmJveFNpemUud2lkdGggPiB3aWR0aCB8fCBxcmJveFNpemUuaGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aHJvdyBcIidjb25maWcucXJib3gnIGRpbWVuc2lvbnMgc2hvdWxkIG5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIFwiXG4gICAgICAgICAgICAgICAgKyBcImRpbWVuc2lvbnMgb2YgdGhlIHJvb3QgSFRNTCBlbGVtZW50LlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAod2lkdGggLSBxcmJveFNpemUud2lkdGgpIC8gMixcbiAgICAgICAgICAgIHk6IChoZWlnaHQgLSBxcmJveFNpemUuaGVpZ2h0KSAvIDIsXG4gICAgICAgICAgICB3aWR0aDogcXJib3hTaXplLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBxcmJveFNpemUuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUucG9zc2libHlJbnNlcnRTaGFkaW5nRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBxcmJveFNpemUpIHtcbiAgICAgICAgaWYgKCh3aWR0aCAtIHFyYm94U2l6ZS53aWR0aCkgPCAxIHx8IChoZWlnaHQgLSBxcmJveFNpemUuaGVpZ2h0KSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hhZGluZ0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgdmFyIHJpZ2h0TGVmdEJvcmRlclNpemUgPSAod2lkdGggLSBxcmJveFNpemUud2lkdGgpIC8gMjtcbiAgICAgICAgdmFyIHRvcEJvdHRvbUJvcmRlclNpemUgPSAoaGVpZ2h0IC0gcXJib3hTaXplLmhlaWdodCkgLyAyO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5ib3JkZXJMZWZ0XG4gICAgICAgICAgICA9IFwiXCIuY29uY2F0KHJpZ2h0TGVmdEJvcmRlclNpemUsIFwicHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjQ4KVwiKTtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuc3R5bGUuYm9yZGVyUmlnaHRcbiAgICAgICAgICAgID0gXCJcIi5jb25jYXQocmlnaHRMZWZ0Qm9yZGVyU2l6ZSwgXCJweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNDgpXCIpO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5ib3JkZXJUb3BcbiAgICAgICAgICAgID0gXCJcIi5jb25jYXQodG9wQm90dG9tQm9yZGVyU2l6ZSwgXCJweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNDgpXCIpO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5ib3JkZXJCb3R0b21cbiAgICAgICAgICAgID0gXCJcIi5jb25jYXQodG9wQm90dG9tQm9yZGVyU2l6ZSwgXCJweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNDgpXCIpO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIjtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuc3R5bGUuYm90dG9tID0gXCIwcHhcIjtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIHNoYWRpbmdFbGVtZW50LnN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuaWQgPSBcIlwiLmNvbmNhdChDb25zdGFudHMuU0hBREVEX1JFR0lPTl9FTEVNRU5UX0lEKTtcbiAgICAgICAgaWYgKCh3aWR0aCAtIHFyYm94U2l6ZS53aWR0aCkgPCAxMVxuICAgICAgICAgICAgfHwgKGhlaWdodCAtIHFyYm94U2l6ZS5oZWlnaHQpIDwgMTEpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQm9yZGVyU2hhZGVycyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNtYWxsU2l6ZSA9IDU7XG4gICAgICAgICAgICB2YXIgbGFyZ2VTaXplID0gNDA7XG4gICAgICAgICAgICB0aGlzLmluc2VydFNoYWRlckJvcmRlcnMoc2hhZGluZ0VsZW1lbnQsIGxhcmdlU2l6ZSwgc21hbGxTaXplLCAtc21hbGxTaXplLCBudWxsLCAwLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhZGVyQm9yZGVycyhzaGFkaW5nRWxlbWVudCwgbGFyZ2VTaXplLCBzbWFsbFNpemUsIC1zbWFsbFNpemUsIG51bGwsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhZGVyQm9yZGVycyhzaGFkaW5nRWxlbWVudCwgbGFyZ2VTaXplLCBzbWFsbFNpemUsIG51bGwsIC1zbWFsbFNpemUsIDAsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRTaGFkZXJCb3JkZXJzKHNoYWRpbmdFbGVtZW50LCBsYXJnZVNpemUsIHNtYWxsU2l6ZSwgbnVsbCwgLXNtYWxsU2l6ZSwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRTaGFkZXJCb3JkZXJzKHNoYWRpbmdFbGVtZW50LCBzbWFsbFNpemUsIGxhcmdlU2l6ZSArIHNtYWxsU2l6ZSwgLXNtYWxsU2l6ZSwgbnVsbCwgLXNtYWxsU2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmluc2VydFNoYWRlckJvcmRlcnMoc2hhZGluZ0VsZW1lbnQsIHNtYWxsU2l6ZSwgbGFyZ2VTaXplICsgc21hbGxTaXplLCBudWxsLCAtc21hbGxTaXplLCAtc21hbGxTaXplLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhZGVyQm9yZGVycyhzaGFkaW5nRWxlbWVudCwgc21hbGxTaXplLCBsYXJnZVNpemUgKyBzbWFsbFNpemUsIC1zbWFsbFNpemUsIG51bGwsIC1zbWFsbFNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhZGVyQm9yZGVycyhzaGFkaW5nRWxlbWVudCwgc21hbGxTaXplLCBsYXJnZVNpemUgKyBzbWFsbFNpemUsIG51bGwsIC1zbWFsbFNpemUsIC1zbWFsbFNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaGFzQm9yZGVyU2hhZGVycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5hcHBlbmQoc2hhZGluZ0VsZW1lbnQpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmluc2VydFNoYWRlckJvcmRlcnMgPSBmdW5jdGlvbiAoc2hhZGVyRWxlbSwgd2lkdGgsIGhlaWdodCwgdG9wLCBib3R0b20sIHNpZGUsIGlzTGVmdCkge1xuICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIGVsZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gQ29uc3RhbnRzLkJPUkRFUl9TSEFERVJfREVGQVVMVF9DT0xPUjtcbiAgICAgICAgZWxlbS5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpO1xuICAgICAgICBlbGVtLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgaWYgKHRvcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZWxlbS5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdCh0b3AsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvdHRvbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5ib3R0b20gPSBcIlwiLmNvbmNhdChib3R0b20sIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGVmdCkge1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQoc2lkZSwgXCJweFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0uc3R5bGUucmlnaHQgPSBcIlwiLmNvbmNhdChzaWRlLCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ib3JkZXJTaGFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmJvcmRlclNoYWRlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvcmRlclNoYWRlcnMucHVzaChlbGVtKTtcbiAgICAgICAgc2hhZGVyRWxlbS5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5zaG93UGF1c2VkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zY2FubmVyUGF1c2VkVWlFbGVtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBcIltpbnRlcm5hbCBlcnJvcl0gc2Nhbm5lciBwYXVzZWQgVUkgZWxlbWVudCBub3QgZm91bmRcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5oaWRlUGF1c2VkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zY2FubmVyUGF1c2VkVWlFbGVtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBcIltpbnRlcm5hbCBlcnJvcl0gc2Nhbm5lciBwYXVzZWQgVUkgZWxlbWVudCBub3QgZm91bmRcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmdldFRpbWVvdXRGcHMgPSBmdW5jdGlvbiAoZnBzKSB7XG4gICAgICAgIHJldHVybiAxMDAwIC8gZnBzO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWw1UXJjb2RlO1xufSgpKTtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odG1sNS1xcmNvZGUuanMubWFwIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIkJhc2VMb2dnZ2VyIiwiSHRtbDVRcmNvZGVSZXN1bHRGYWN0b3J5IiwiSHRtbDVRcmNvZGVFcnJvckZhY3RvcnkiLCJIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMiLCJpc1ZhbGlkSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzIiwiSHRtbDVRcmNvZGVDb25zdGFudHMiLCJpc051bGxPclVuZGVmaW5lZCIsIkh0bWw1UXJjb2RlU3RyaW5ncyIsIlZpZGVvQ29uc3RyYWludHNVdGlsIiwiSHRtbDVRcmNvZGVTaGltIiwiQ2FtZXJhRmFjdG9yeSIsIkNhbWVyYVJldHJpZXZlciIsIlN0YXRlTWFuYWdlckZhY3RvcnkiLCJIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZSIsIkNvbnN0YW50cyIsIl9zdXBlciIsImFwcGx5IiwiYXJndW1lbnRzIiwiREVGQVVMVF9XSURUSCIsIkRFRkFVTFRfV0lEVEhfT0ZGU0VUIiwiRklMRV9TQ0FOX01JTl9IRUlHSFQiLCJGSUxFX1NDQU5fSElEREVOX0NBTlZBU19QQURESU5HIiwiTUlOX1FSX0JPWF9TSVpFIiwiU0hBREVEX0xFRlQiLCJTSEFERURfUklHSFQiLCJTSEFERURfVE9QIiwiU0hBREVEX0JPVFRPTSIsIlNIQURFRF9SRUdJT05fRUxFTUVOVF9JRCIsIlZFUkJPU0UiLCJCT1JERVJfU0hBREVSX0RFRkFVTFRfQ09MT1IiLCJCT1JERVJfU0hBREVSX01BVENIX0NPTE9SIiwiSW50ZXJuYWxIdG1sNVFyY29kZUNvbmZpZyIsImNvbmZpZyIsImxvZ2dlciIsImZwcyIsIlNDQU5fREVGQVVMVF9GUFMiLCJkaXNhYmxlRmxpcCIsIkRFRkFVTFRfRElTQUJMRV9GTElQIiwicXJib3giLCJhc3BlY3RSYXRpbyIsInZpZGVvQ29uc3RyYWludHMiLCJpc01lZGlhU3RyZWFtQ29uc3RyYWludHNWYWxpZCIsImxvZ0Vycm9yIiwiaXNTaGFkZWRCb3hFbmFibGVkIiwiSHRtbDVRcmNvZGUiLCJlbGVtZW50SWQiLCJjb25maWdPclZlcmJvc2l0eUZsYWciLCJlbGVtZW50IiwiY2FudmFzRWxlbWVudCIsInNjYW5uZXJQYXVzZWRVaUVsZW1lbnQiLCJoYXNCb3JkZXJTaGFkZXJzIiwiYm9yZGVyU2hhZGVycyIsInFyTWF0Y2giLCJyZW5kZXJlZENhbWVyYSIsInFyUmVnaW9uIiwiY29udGV4dCIsImxhc3RTY2FuSW1hZ2VGaWxlIiwiaXNTY2FubmluZyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjb25jYXQiLCJ2ZXJib3NlIiwiZXhwZXJpbWVudGFsRmVhdHVyZUNvbmZpZyIsImNvbmZpZ09iamVjdCIsImV4cGVyaW1lbnRhbEZlYXR1cmVzIiwicXJjb2RlIiwiZ2V0U3VwcG9ydGVkRm9ybWF0cyIsImdldFVzZUJhckNvZGVEZXRlY3RvcklmU3VwcG9ydGVkIiwiZm9yZXZlclNjYW5UaW1lb3V0Iiwic2hvdWxkU2NhbiIsInN0YXRlTWFuYWdlclByb3h5Iiwic3RhcnQiLCJjYW1lcmFJZE9yQ29uZmlnIiwiY29uZmlndXJhdGlvbiIsInFyQ29kZVN1Y2Nlc3NDYWxsYmFjayIsInFyQ29kZUVycm9yQ2FsbGJhY2siLCJfdGhpcyIsInFyQ29kZUVycm9yQ2FsbGJhY2tJbnRlcm5hbCIsImxvZyIsImludGVybmFsQ29uZmlnIiwiY2xlYXJFbGVtZW50IiwidmlkZW9Db25zdHJhaW50c0F2YWlsYWJsZUFuZFZhbGlkIiwiYXJlVmlkZW9Db25zdHJhaW50c0VuYWJsZWQiLCJyb290RWxlbWVudFdpZHRoIiwiY2xpZW50V2lkdGgiLCJzdHlsZSIsInBvc2l0aW9uIiwiJHRoaXMiLCJ0b1NjYW5uaW5nU3RhdGVDaGFuZ2VUcmFuc2FjdGlvbiIsInN0YXJ0VHJhbnNpdGlvbiIsIlNDQU5OSU5HIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjcmVhdGVWaWRlb0NvbnN0cmFpbnRzIiwiY2FuY2VsIiwiY2FtZXJhUmVuZGVyaW5nT3B0aW9ucyIsInJlbmRlcmluZ0NhbGxiYWNrcyIsIm9uUmVuZGVyU3VyZmFjZVJlYWR5Iiwidmlld2ZpbmRlcldpZHRoIiwidmlld2ZpbmRlckhlaWdodCIsInNldHVwVWkiLCJmb3JldmVyU2NhbiIsImZhaWxJZk5vdFN1cHBvcnRlZCIsInRoZW4iLCJmYWN0b3J5IiwiY2FtZXJhIiwicmVuZGVyIiwiZXhlY3V0ZSIsImNhdGNoIiwiZXJyb3IiLCJlcnJvckdldHRpbmdVc2VyTWVkaWEiLCJfIiwiY2FtZXJhU3RyZWFtaW5nTm90U3VwcG9ydGVkIiwicGF1c2UiLCJzaG91bGRQYXVzZVZpZGVvIiwiaXNTdHJpY3RseVNjYW5uaW5nIiwiZGlyZWN0VHJhbnNpdGlvbiIsIlBBVVNFRCIsInNob3dQYXVzZWRTdGF0ZSIsInJlc3VtZSIsImlzUGF1c2VkIiwidHJhbnNpdGlvblRvU2Nhbm5pbmciLCJoaWRlUGF1c2VkU3RhdGUiLCJnZXRTdGF0ZSIsInN0b3AiLCJ0b1N0b3BwZWRTdGF0ZVRyYW5zYWN0aW9uIiwiTk9UX1NUQVJURUQiLCJjbGVhclRpbWVvdXQiLCJyZW1vdmVRclJlZ2lvbiIsImNoaWxkRWxlbWVudCIsInJlbW92ZUNoaWxkIiwiY2xvc2UiLCJzY2FuRmlsZSIsImltYWdlRmlsZSIsInNob3dJbWFnZSIsInNjYW5GaWxlVjIiLCJodG1sNXFyY29kZVJlc3VsdCIsImRlY29kZWRUZXh0IiwiRmlsZSIsImNhblNjYW5GaWxlIiwicG9zc2libHlDbG9zZUxhc3RTY2FuSW1hZ2VGaWxlIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiaW5wdXRJbWFnZSIsIkltYWdlIiwib25sb2FkIiwiaW1hZ2VXaWR0aCIsIndpZHRoIiwiaW1hZ2VIZWlnaHQiLCJoZWlnaHQiLCJjb250YWluZXJXaWR0aCIsImNvbnRhaW5lckhlaWdodCIsIk1hdGgiLCJtYXgiLCJjbGllbnRIZWlnaHQiLCJjb21wdXRlQ2FudmFzRHJhd0NvbmZpZyIsInZpc2libGVDYW52YXMiLCJjcmVhdGVDYW52YXNFbGVtZW50IiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwiY29udGV4dF8xIiwiZ2V0Q29udGV4dCIsImNhbnZhcyIsImRyYXdJbWFnZSIsIngiLCJ5IiwicGFkZGluZyIsImhpZGRlbkltYWdlV2lkdGgiLCJoaWRkZW5JbWFnZUhlaWdodCIsImhpZGRlbkNhbnZhc1dpZHRoIiwiaGlkZGVuQ2FudmFzSGVpZ2h0IiwiaGlkZGVuQ2FudmFzIiwiZGVjb2RlUm9idXN0bHlBc3luYyIsInJlc3VsdCIsImNyZWF0ZUZyb21RcmNvZGVSZXN1bHQiLCJleGNlcHRpb24iLCJvbmVycm9yIiwib25hYm9ydCIsIm9uc3RhbGxlZCIsIm9uc3VzcGVuZCIsInNyYyIsImNsZWFyIiwiZ2V0Q2FtZXJhcyIsInJldHJpZXZlIiwiZ2V0UnVubmluZ1RyYWNrQ2FwYWJpbGl0aWVzIiwiZ2V0UmVuZGVyZWRDYW1lcmFPckZhaWwiLCJnZXRSdW5uaW5nVHJhY2tTZXR0aW5ncyIsImdldFJ1bm5pbmdUcmFja0NhbWVyYUNhcGFiaWxpdGllcyIsImdldENhcGFiaWxpdGllcyIsImFwcGx5VmlkZW9Db25zdHJhaW50cyIsInZpZGVvQ29uc3RhaW50cyIsImFsbEZvcm1hdHMiLCJRUl9DT0RFIiwiQVpURUMiLCJDT0RBQkFSIiwiQ09ERV8zOSIsIkNPREVfOTMiLCJDT0RFXzEyOCIsIkRBVEFfTUFUUklYIiwiTUFYSUNPREUiLCJJVEYiLCJFQU5fMTMiLCJFQU5fOCIsIlBERl80MTciLCJSU1NfMTQiLCJSU1NfRVhQQU5ERUQiLCJVUENfQSIsIlVQQ19FIiwiVVBDX0VBTl9FWFRFTlNJT04iLCJmb3JtYXRzVG9TdXBwb3J0IiwiaXNBcnJheSIsImxlbmd0aCIsInN1cHBvcnRlZEZvcm1hdHMiLCJfaSIsIl9hIiwiZm9ybWF0IiwicHVzaCIsIndhcm4iLCJ1c2VCYXJDb2RlRGV0ZWN0b3JJZlN1cHBvcnRlZCIsInZhbGlkYXRlUXJib3hTaXplIiwicXJib3hTaXplIiwidmFsaWRhdGVRcmJveENvbmZpZyIsInFyRGltZW5zaW9ucyIsInRvUXJkaW1lbnNpb25zIiwidmFsaWRhdGVNaW5TaXplIiwic2l6ZSIsImNvcnJlY3RXaWR0aEJhc2VkT25Sb290RWxlbWVudFNpemUiLCJjb25maWdXaWR0aCIsInVuZGVmaW5lZCIsIkVycm9yIiwic2hvdWxkU2hhZGluZ0JlQXBwbGllZCIsImRlZmF1bHRRclJlZ2lvbiIsImdldFNoYWRlZFJlZ2lvbkJvdW5kcyIsImNvbnRleHRBdHRyaWJ1dGVzIiwid2lsbFJlYWRGcmVxdWVudGx5IiwiYXBwZW5kIiwicG9zc2libHlJbnNlcnRTaGFkaW5nRWxlbWVudCIsImNyZWF0ZVNjYW5uZXJQYXVzZWRVaUVsZW1lbnQiLCJyb290RWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lclRleHQiLCJzY2FubmVyUGF1c2VkIiwidG9wIiwiekluZGV4IiwiYmFja2dyb3VuZCIsImNvbG9yIiwidGV4dEFsaWduIiwic2NhbkNvbnRleHQiLCJkZWNvZGVBc3luYyIsInRleHQiLCJwb3NzaWJseVVwZGF0ZVNoYWRlcnMiLCJlcnJvck1lc3NhZ2UiLCJjb2RlUGFyc2VFcnJvciIsImNyZWF0ZUZyb20iLCJ2aWRlb0VsZW1lbnQiLCJnZXRTdXJmYWNlIiwid2lkdGhSYXRpbyIsInZpZGVvV2lkdGgiLCJoZWlnaHRSYXRpbyIsInZpZGVvSGVpZ2h0Iiwic1dpZHRoT2Zmc2V0Iiwic0hlaWdodE9mZnNldCIsInN4T2Zmc2V0Iiwic3lPZmZzZXQiLCJ0cmlnZ2VyTmV4dFNjYW4iLCJzZXRUaW1lb3V0IiwiZ2V0VGltZW91dEZwcyIsImlzU3VjY2Vzc2Z1bGwiLCJ0cmFuc2xhdGUiLCJzY2FsZSIsImZpbmFsbHkiLCJkZXZpY2VJZCIsImV4YWN0IiwiZmFjaW5nTW9kZUtleSIsImRldmljZUlkS2V5IiwiYWxsb3dlZEZhY2luZ01vZGVWYWx1ZXNfMSIsImV4YWN0S2V5IiwiaXNWYWxpZEZhY2luZ01vZGVWYWx1ZSIsInZhbHVlIiwia2V5cyIsImtleSIsImZhY2luZ01vZGUiLCJ0eXBlXzEiLCJ0eXBlXzIiLCJ0eXBlIiwieG9mZnNldCIsInlvZmZzZXQiLCJmb3JtZXJJbWFnZVdpZHRoIiwiZm9ybWVySW1hZ2VIZWlnaHQiLCJpbm5lckhUTUwiLCJmb3JFYWNoIiwic2hhZGVyIiwiYmFja2dyb3VuZENvbG9yIiwicmV2b2tlT2JqZWN0VVJMIiwiY3VzdG9tSWQiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsImlkIiwic2hhZGluZ0VsZW1lbnQiLCJyaWdodExlZnRCb3JkZXJTaXplIiwidG9wQm90dG9tQm9yZGVyU2l6ZSIsImJvcmRlckxlZnQiLCJib3JkZXJSaWdodCIsImJvcmRlclRvcCIsImJvcmRlckJvdHRvbSIsImJveFNpemluZyIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsInNtYWxsU2l6ZSIsImxhcmdlU2l6ZSIsImluc2VydFNoYWRlckJvcmRlcnMiLCJzaGFkZXJFbGVtIiwic2lkZSIsImlzTGVmdCIsImVsZW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/html5-qrcode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/image-assets.js":
/*!*******************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/image-assets.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASSET_CAMERA_SCAN: () => (/* binding */ ASSET_CAMERA_SCAN),\n/* harmony export */   ASSET_CLOSE_ICON_16PX: () => (/* binding */ ASSET_CLOSE_ICON_16PX),\n/* harmony export */   ASSET_FILE_SCAN: () => (/* binding */ ASSET_FILE_SCAN),\n/* harmony export */   ASSET_INFO_ICON_16PX: () => (/* binding */ ASSET_INFO_ICON_16PX)\n/* harmony export */ });\nvar SVG_XML_PREFIX = \"data:image/svg+xml;base64,\";\nvar ASSET_CAMERA_SCAN = SVG_XML_PREFIX + \"PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzNzEuNjQzIDM3MS42NDMiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDM3MS42NDMgMzcxLjY0MyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PHBhdGggZD0iTTEwNS4wODQgMzguMjcxaDE2My43Njh2MjBIMTA1LjA4NHoiLz48cGF0aCBkPSJNMzExLjU5NiAxOTAuMTg5Yy03LjQ0MS05LjM0Ny0xOC40MDMtMTYuMjA2LTMyLjc0My0yMC41MjJWMzBjMC0xNi41NDItMTMuNDU4LTMwLTMwLTMwSDEyNS4wODRjLTE2LjU0MiAwLTMwIDEzLjQ1OC0zMCAzMHYxMjAuMTQzaC04LjI5NmMtMTYuNTQyIDAtMzAgMTMuNDU4LTMwIDMwdjEuMzMzYTI5LjgwNCAyOS44MDQgMCAwIDAgNC42MDMgMTUuOTM5Yy03LjM0IDUuNDc0LTEyLjEwMyAxNC4yMjEtMTIuMTAzIDI0LjA2MXYxLjMzM2MwIDkuODQgNC43NjMgMTguNTg3IDEyLjEwMyAyNC4wNjJhMjkuODEgMjkuODEgMCAwIDAtNC42MDMgMTUuOTM4djEuMzMzYzAgMTYuNTQyIDEzLjQ1OCAzMCAzMCAzMGg4LjMyNGMuNDI3IDExLjYzMSA3LjUwMyAyMS41ODcgMTcuNTM0IDI2LjE3Ny45MzEgMTAuNTAzIDQuMDg0IDMwLjE4NyAxNC43NjggNDUuNTM3YTkuOTg4IDkuOTg4IDAgMCAwIDguMjE2IDQuMjg4IDkuOTU4IDkuOTU4IDAgMCAwIDUuNzA0LTEuNzkzYzQuNTMzLTMuMTU1IDUuNjUtOS4zODggMi40OTUtMTMuOTIxLTYuNzk4LTkuNzY3LTkuNjAyLTIyLjYwOC0xMC43Ni0zMS40aDgyLjY4NWMuMjcyLjQxNC41NDUuODE4LjgxNSAxLjIxIDMuMTQyIDQuNTQxIDkuMzcyIDUuNjc5IDEzLjkxMyAyLjUzNCA0LjU0Mi0zLjE0MiA1LjY3Ny05LjM3MSAyLjUzNS0xMy45MTMtMTEuOTE5LTE3LjIyOS04Ljc4Ny0zNS44ODQgOS41ODEtNTcuMDEyIDMuMDY3LTIuNjUyIDEyLjMwNy0xMS43MzIgMTEuMjE3LTI0LjAzMy0uODI4LTkuMzQzLTcuMTA5LTE3LjE5NC0xOC42NjktMjMuMzM3YTkuODU3IDkuODU3IDAgMCAwLTEuMDYxLS40ODZjLS40NjYtLjE4Mi0xMS40MDMtNC41NzktOS43NDEtMTUuNzA2IDEuMDA3LTYuNzM3IDE0Ljc2OC04LjI3MyAyMy43NjYtNy42NjYgMjMuMTU2IDEuNTY5IDM5LjY5OCA3LjgwMyA0Ny44MzYgMTguMDI2IDUuNzUyIDcuMjI1IDcuNjA3IDE2LjYyMyA1LjY3MyAyOC43MzMtLjQxMyAyLjU4NS0uODI0IDUuMjQxLTEuMjQ1IDcuOTU5LTUuNzU2IDM3LjE5NC0xMi45MTkgODMuNDgzLTQ5Ljg3IDExNC42NjEtNC4yMjEgMy41NjEtNC43NTYgOS44Ny0xLjE5NCAxNC4wOTJhOS45OCA5Ljk4IDAgMCAwIDcuNjQ4IDMuNTUxIDkuOTU1IDkuOTU1IDAgMCAwIDYuNDQ0LTIuMzU4YzQyLjY3Mi0zNi4wMDUgNTAuODAyLTg4LjUzMyA1Ni43MzctMTI2Ljg4OC40MTUtMi42ODQuODIxLTUuMzA5IDEuMjI5LTcuODYzIDIuODM0LTE3LjcyMS0uNDU1LTMyLjY0MS05Ljc3Mi00NC4zNDV6bS0yMzIuMzA4IDQyLjYyYy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi0xLjMzM2MwLTUuNTE0IDQuNDg2LTEwIDEwLTEwaDE1djIxLjMzM2gtMTV6bS0yLjUtNTIuNjY2YzAtNS41MTQgNC40ODYtMTAgMTAtMTBoNy41djIxLjMzM2gtNy41Yy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi0xLjMzM3ptMTcuNSA5My45OTloLTcuNWMtNS41MTQgMC0xMC00LjQ4Ni0xMC0xMHYtMS4zMzNjMC01LjUxNCA0LjQ4Ni0xMCAxMC0xMGg3LjV2MjEuMzMzem0zMC43OTYgMjguODg3Yy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi04LjI3MWg5MS40NTdjLS44NTEgNi42NjgtLjQzNyAxMi43ODcuNzMxIDE4LjI3MWgtODIuMTg4em03OS40ODItMTEzLjY5OGMtMy4xMjQgMjAuOTA2IDEyLjQyNyAzMy4xODQgMjEuNjI1IDM3LjA0IDUuNDQxIDIuOTY4IDcuNTUxIDUuNjQ3IDcuNzAxIDcuMTg4LjIxIDIuMTUtMi41NTMgNS42ODQtNC40NzcgNy4yNTEtLjQ4Mi4zNzgtLjkyOS44LTEuMzM1IDEuMjYxLTYuOTg3IDcuOTM2LTExLjk4MiAxNS41Mi0xNS40MzIgMjIuNjg4aC05Ny41NjRWMzBjMC01LjUxNCA0LjQ4Ni0xMCAxMC0xMGgxMjMuNzY5YzUuNTE0IDAgMTAgNC40ODYgMTAgMTB2MTM1LjU3OWMtMy4wMzItLjM4MS02LjE1LS42OTQtOS4zODktLjkxNC0yNS4xNTktMS42OTQtNDIuMzcgNy43NDgtNDQuODk4IDI0LjY2NnoiLz48cGF0aCBkPSJNMTc5LjEyOSA4My4xNjdoLTI0LjA2YTUgNSAwIDAgMC01IDV2MjQuMDYxYTUgNSAwIDAgMCA1IDVoMjQuMDZhNSA1IDAgMCAwIDUtNVY4OC4xNjdhNSA1IDAgMCAwLTUtNXpNMTcyLjYyOSAxNDIuODZoLTEyLjU2VjEzMC44YTUgNSAwIDEgMC0xMCAwdjE3LjA2MWE1IDUgMCAwIDAgNSA1aDE3LjU2YTUgNSAwIDEgMCAwLTEwLjAwMXpNMjE2LjU2OCA4My4xNjdoLTI0LjA2YTUgNSAwIDAgMC01IDV2MjQuMDYxYTUgNSAwIDAgMCA1IDVoMjQuMDZhNSA1IDAgMCAwIDUtNVY4OC4xNjdhNSA1IDAgMCAwLTUtNXptLTUgMjQuMDYxaC0xNC4wNlY5My4xNjdoMTQuMDZ2MTQuMDYxek0yMTEuNjY5IDEyNS45MzZIMTk3LjQxYTUgNSAwIDAgMC01IDV2MTQuMjU3YTUgNSAwIDAgMCA1IDVoMTQuMjU5YTUgNSAwIDAgMCA1LTV2LTE0LjI1N2E1IDUgMCAwIDAtNS01eiIvPjwvc3ZnPg==\";\nvar ASSET_FILE_SCAN = SVG_XML_PREFIX + \"PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1OS4wMTggNTkuMDE4IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1OS4wMTggNTkuMDE4IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJtNTguNzQxIDU0LjgwOS01Ljk2OS02LjI0NGExMC43NCAxMC43NCAwIDAgMCAyLjgyLTcuMjVjMC01Ljk1My00Ljg0My0xMC43OTYtMTAuNzk2LTEwLjc5NlMzNCAzNS4zNjEgMzQgNDEuMzE0IDM4Ljg0MyA1Mi4xMSA0NC43OTYgNTIuMTFjMi40NDEgMCA0LjY4OC0uODI0IDYuNDk5LTIuMTk2bDYuMDAxIDYuMjc3YS45OTguOTk4IDAgMCAwIDEuNDE0LjAzMiAxIDEgMCAwIDAgLjAzMS0xLjQxNHpNMzYgNDEuMzE0YzAtNC44NSAzLjk0Ni04Ljc5NiA4Ljc5Ni04Ljc5NnM4Ljc5NiAzLjk0NiA4Ljc5NiA4Ljc5Ni0zLjk0NiA4Ljc5Ni04Ljc5NiA4Ljc5NlMzNiA0Ni4xNjQgMzYgNDEuMzE0ek0xMC40MzEgMTYuMDg4YzAgMy4wNyAyLjQ5OCA1LjU2OCA1LjU2OSA1LjU2OHM1LjU2OS0yLjQ5OCA1LjU2OS01LjU2OGMwLTMuMDcxLTIuNDk4LTUuNTY5LTUuNTY5LTUuNTY5cy01LjU2OSAyLjQ5OC01LjU2OSA1LjU2OXptOS4xMzggMGMwIDEuOTY4LTEuNjAyIDMuNTY4LTMuNTY5IDMuNTY4cy0zLjU2OS0xLjYwMS0zLjU2OS0zLjU2OCAxLjYwMi0zLjU2OSAzLjU2OS0zLjU2OSAzLjU2OSAxLjYwMSAzLjU2OSAzLjU2OXoiLz48cGF0aCBkPSJtMzAuODgyIDI4Ljk4NyA5LjE4LTEwLjA1NCAxMS4yNjIgMTAuMzIzYTEgMSAwIDAgMCAxLjM1MS0xLjQ3NWwtMTItMTFhMSAxIDAgMCAwLTEuNDE0LjA2M2wtOS43OTQgMTAuNzI3LTQuNzQzLTQuNzQzYTEuMDAzIDEuMDAzIDAgMCAwLTEuMzY4LS4wNDRMNi4zMzkgMzcuNzY4YTEgMSAwIDEgMCAxLjMyMiAxLjUwMWwxNi4zMTMtMTQuMzYyIDcuMzE5IDcuMzE4YS45OTkuOTk5IDAgMSAwIDEuNDE0LTEuNDE0bC0xLjgyNS0xLjgyNHoiLz48cGF0aCBkPSJNMzAgNDYuNTE4SDJ2LTQyaDU0djI4YTEgMSAwIDEgMCAyIDB2LTI5YTEgMSAwIDAgMC0xLTFIMWExIDEgMCAwIDAtMSAxdjQ0YTEgMSAwIDAgMCAxIDFoMjlhMSAxIDAgMSAwIDAtMnoiLz48L3N2Zz4=\";\nvar ASSET_INFO_ICON_16PX = SVG_XML_PREFIX + \"PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0NjAgNDYwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NjAgNDYwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNMjMwIDBDMTAyLjk3NSAwIDAgMTAyLjk3NSAwIDIzMHMxMDIuOTc1IDIzMCAyMzAgMjMwIDIzMC0xMDIuOTc0IDIzMC0yMzBTMzU3LjAyNSAwIDIzMCAwem0zOC4zMzMgMzc3LjM2YzAgOC42NzYtNy4wMzQgMTUuNzEtMTUuNzEgMTUuNzFoLTQzLjEwMWMtOC42NzYgMC0xNS43MS03LjAzNC0xNS43MS0xNS43MVYyMDIuNDc3YzAtOC42NzYgNy4wMzMtMTUuNzEgMTUuNzEtMTUuNzFoNDMuMTAxYzguNjc2IDAgMTUuNzEgNy4wMzMgMTUuNzEgMTUuNzFWMzc3LjM2ek0yMzAgMTU3Yy0yMS41MzkgMC0zOS0xNy40NjEtMzktMzlzMTcuNDYxLTM5IDM5LTM5IDM5IDE3LjQ2MSAzOSAzOS0xNy40NjEgMzktMzkgMzl6Ii8+PC9zdmc+\";\nvar ASSET_CLOSE_ICON_16PX = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAQgAAAEIBarqQRAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAE1SURBVDiNfdI7S0NBEAXgLya1otFgpbYSbISAgpXYi6CmiH9KCAiChaVga6OiWPgfRDQ+0itaGVNosXtluWwcuMzePfM4M3sq8lbHBubwg1dc4m1E/J/N4ghDPOIsfk/4xiEao5KX0McFljN4C9d4QTPXuY99jP3DsIoDPGM6BY5i5yI5R7O4q+ImFkJY2DCh3cAH2klyB+9J1xUMMAG7eCh1a+Mr+k48b5diXrFVwwLuS+BJ9MfR7+G0FHOHhTHhnXNWS87VDF4pcnfQK4Ep7XScNLmPTZgURNKKYENYWDpzW1BhscS1WHS8CDgURFJQrWcoF3c13KKbgg1BYQfy8xZWEzTTw1QZbAoKu8FqJnktdu5hcVSHmchiILzzuaDQvjBzV2m8yohCE1jHfPx/xhU+y4G/D75ELlRJsSYAAAAASUVORK5CYII=\"; //# sourceMappingURL=image-assets.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9pbWFnZS1hc3NldHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLElBQUlBLGlCQUFpQjtBQUNkLElBQUlDLG9CQUFvQkQsaUJBQWlCLCsyR0FBKzJHO0FBQ3g1RyxJQUFJRSxrQkFBa0JGLGlCQUFpQix1OENBQXU4QztBQUM5K0MsSUFBSUcsdUJBQXVCSCxpQkFBaUIsK29CQUErb0I7QUFDM3JCLElBQUlJLHdCQUF3QixxbUJBQXFtQixDQUN4b0Isd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9wb3MvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9pbWFnZS1hc3NldHMuanM/YzExNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU1ZHX1hNTF9QUkVGSVggPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsXCI7XG5leHBvcnQgdmFyIEFTU0VUX0NBTUVSQV9TQ0FOID0gU1ZHX1hNTF9QUkVGSVggKyBcIlBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSFpwWlhkQ2IzZzlJakFnTUNBek56RXVOalF6SURNM01TNDJORE1pSUhOMGVXeGxQU0psYm1GaWJHVXRZbUZqYTJkeWIzVnVaRHB1WlhjZ01DQXdJRE0zTVM0Mk5ETWdNemN4TGpZME15SWdlRzFzT25Od1lXTmxQU0p3Y21WelpYSjJaU0krUEhCaGRHZ2daRDBpVFRFd05TNHdPRFFnTXpndU1qY3hhREUyTXk0M05qaDJNakJJTVRBMUxqQTROSG9pTHo0OGNHRjBhQ0JrUFNKTk16RXhMalU1TmlBeE9UQXVNVGc1WXkwM0xqUTBNUzA1TGpNME55MHhPQzQwTURNdE1UWXVNakEyTFRNeUxqYzBNeTB5TUM0MU1qSldNekJqTUMweE5pNDFOREl0TVRNdU5EVTRMVE13TFRNd0xUTXdTREV5TlM0d09EUmpMVEUyTGpVME1pQXdMVE13SURFekxqUTFPQzB6TUNBek1IWXhNakF1TVRRemFDMDRMakk1Tm1NdE1UWXVOVFF5SURBdE16QWdNVE11TkRVNExUTXdJRE13ZGpFdU16TXpZVEk1TGpnd05DQXlPUzQ0TURRZ01DQXdJREFnTkM0Mk1ETWdNVFV1T1RNNVl5MDNMak0wSURVdU5EYzBMVEV5TGpFd015QXhOQzR5TWpFdE1USXVNVEF6SURJMExqQTJNWFl4TGpNek0yTXdJRGt1T0RRZ05DNDNOak1nTVRndU5UZzNJREV5TGpFd015QXlOQzR3TmpKaE1qa3VPREVnTWprdU9ERWdNQ0F3SURBdE5DNDJNRE1nTVRVdU9UTTRkakV1TXpNell6QWdNVFl1TlRReUlERXpMalExT0NBek1DQXpNQ0F6TUdnNExqTXlOR011TkRJM0lERXhMall6TVNBM0xqVXdNeUF5TVM0MU9EY2dNVGN1TlRNMElESTJMakUzTnk0NU16RWdNVEF1TlRBeklEUXVNRGcwSURNd0xqRTROeUF4TkM0M05qZ2dORFV1TlRNM1lUa3VPVGc0SURrdU9UZzRJREFnTUNBd0lEZ3VNakUySURRdU1qZzRJRGt1T1RVNElEa3VPVFU0SURBZ01DQXdJRFV1TnpBMExURXVOemt6WXpRdU5UTXpMVE11TVRVMUlEVXVOalV0T1M0ek9EZ2dNaTQwT1RVdE1UTXVPVEl4TFRZdU56azRMVGt1TnpZM0xUa3VOakF5TFRJeUxqWXdPQzB4TUM0M05pMHpNUzQwYURneUxqWTROV011TWpjeUxqUXhOQzQxTkRVdU9ERTRMamd4TlNBeExqSXhJRE11TVRReUlEUXVOVFF4SURrdU16Y3lJRFV1TmpjNUlERXpMamt4TXlBeUxqVXpOQ0EwTGpVME1pMHpMakUwTWlBMUxqWTNOeTA1TGpNM01TQXlMalV6TlMweE15NDVNVE10TVRFdU9URTVMVEUzTGpJeU9TMDRMamM0Tnkwek5TNDRPRFFnT1M0MU9ERXROVGN1TURFeUlETXVNRFkzTFRJdU5qVXlJREV5TGpNd055MHhNUzQzTXpJZ01URXVNakUzTFRJMExqQXpNeTB1T0RJNExUa3VNelF6TFRjdU1UQTVMVEUzTGpFNU5DMHhPQzQyTmprdE1qTXVNek0zWVRrdU9EVTNJRGt1T0RVM0lEQWdNQ0F3TFRFdU1EWXhMUzQwT0RaakxTNDBOall0TGpFNE1pMHhNUzQwTURNdE5DNDFOemt0T1M0M05ERXRNVFV1TnpBMklERXVNREEzTFRZdU56TTNJREUwTGpjMk9DMDRMakkzTXlBeU15NDNOall0Tnk0Mk5qWWdNak11TVRVMklERXVOVFk1SURNNUxqWTVPQ0EzTGpnd015QTBOeTQ0TXpZZ01UZ3VNREkySURVdU56VXlJRGN1TWpJMUlEY3VOakEzSURFMkxqWXlNeUExTGpZM015QXlPQzQzTXpNdExqUXhNeUF5TGpVNE5TMHVPREkwSURVdU1qUXhMVEV1TWpRMUlEY3VPVFU1TFRVdU56VTJJRE0zTGpFNU5DMHhNaTQ1TVRrZ09ETXVORGd6TFRRNUxqZzNJREV4TkM0Mk5qRXROQzR5TWpFZ015NDFOakV0TkM0M05UWWdPUzQ0TnkweExqRTVOQ0F4TkM0d09USmhPUzQ1T0NBNUxqazRJREFnTUNBd0lEY3VOalE0SURNdU5UVXhJRGt1T1RVMUlEa3VPVFUxSURBZ01DQXdJRFl1TkRRMExUSXVNelU0WXpReUxqWTNNaTB6Tmk0d01EVWdOVEF1T0RBeUxUZzRMalV6TXlBMU5pNDNNemN0TVRJMkxqZzRPQzQwTVRVdE1pNDJPRFF1T0RJeExUVXVNekE1SURFdU1qSTVMVGN1T0RZeklESXVPRE0wTFRFM0xqY3lNUzB1TkRVMUxUTXlMalkwTVMwNUxqYzNNaTAwTkM0ek5EVjZiUzB5TXpJdU16QTRJRFF5TGpZeVl5MDFMalV4TkNBd0xURXdMVFF1TkRnMkxURXdMVEV3ZGkweExqTXpNMk13TFRVdU5URTBJRFF1TkRnMkxURXdJREV3TFRFd2FERTFkakl4TGpNek0yZ3RNVFY2YlMweUxqVXROVEl1TmpZMll6QXROUzQxTVRRZ05DNDBPRFl0TVRBZ01UQXRNVEJvTnk0MWRqSXhMak16TTJndE55NDFZeTAxTGpVeE5DQXdMVEV3TFRRdU5EZzJMVEV3TFRFd2RpMHhMak16TTNwdE1UY3VOU0E1TXk0NU9UbG9MVGN1TldNdE5TNDFNVFFnTUMweE1DMDBMalE0TmkweE1DMHhNSFl0TVM0ek16TmpNQzAxTGpVeE5DQTBMalE0TmkweE1DQXhNQzB4TUdnM0xqVjJNakV1TXpNemVtMHpNQzQzT1RZZ01qZ3VPRGczWXkwMUxqVXhOQ0F3TFRFd0xUUXVORGcyTFRFd0xURXdkaTA0TGpJM01XZzVNUzQwTlRkakxTNDROVEVnTmk0Mk5qZ3RMalF6TnlBeE1pNDNPRGN1TnpNeElERTRMakkzTVdndE9ESXVNVGc0ZW0wM09TNDBPREl0TVRFekxqWTVPR010TXk0eE1qUWdNakF1T1RBMklERXlMalF5TnlBek15NHhPRFFnTWpFdU5qSTFJRE0zTGpBMElEVXVORFF4SURJdU9UWTRJRGN1TlRVeElEVXVOalEzSURjdU56QXhJRGN1TVRnNExqSXhJREl1TVRVdE1pNDFOVE1nTlM0Mk9EUXROQzQwTnpjZ055NHlOVEV0TGpRNE1pNHpOemd0TGpreU9TNDRMVEV1TXpNMUlERXVNall4TFRZdU9UZzNJRGN1T1RNMkxURXhMams0TWlBeE5TNDFNaTB4TlM0ME16SWdNakl1TmpnNGFDMDVOeTQxTmpSV016QmpNQzAxTGpVeE5DQTBMalE0TmkweE1DQXhNQzB4TUdneE1qTXVOelk1WXpVdU5URTBJREFnTVRBZ05DNDBPRFlnTVRBZ01UQjJNVE0xTGpVM09XTXRNeTR3TXpJdExqTTRNUzAyTGpFMUxTNDJPVFF0T1M0ek9Ea3RMamt4TkMweU5TNHhOVGt0TVM0Mk9UUXROREl1TXpjZ055NDNORGd0TkRRdU9EazRJREkwTGpZMk5ub2lMejQ4Y0dGMGFDQmtQU0pOTVRjNUxqRXlPU0E0TXk0eE5qZG9MVEkwTGpBMllUVWdOU0F3SURBZ01DMDFJRFYyTWpRdU1EWXhZVFVnTlNBd0lEQWdNQ0ExSURWb01qUXVNRFpoTlNBMUlEQWdNQ0F3SURVdE5WWTRPQzR4TmpkaE5TQTFJREFnTUNBd0xUVXROWHBOTVRjeUxqWXlPU0F4TkRJdU9EWm9MVEV5TGpVMlZqRXpNQzQ0WVRVZ05TQXdJREVnTUMweE1DQXdkakUzTGpBMk1XRTFJRFVnTUNBd0lEQWdOU0ExYURFM0xqVTJZVFVnTlNBd0lERWdNQ0F3TFRFd0xqQXdNWHBOTWpFMkxqVTJPQ0E0TXk0eE5qZG9MVEkwTGpBMllUVWdOU0F3SURBZ01DMDFJRFYyTWpRdU1EWXhZVFVnTlNBd0lEQWdNQ0ExSURWb01qUXVNRFpoTlNBMUlEQWdNQ0F3SURVdE5WWTRPQzR4TmpkaE5TQTFJREFnTUNBd0xUVXROWHB0TFRVZ01qUXVNRFl4YUMweE5DNHdObFk1TXk0eE5qZG9NVFF1TURaMk1UUXVNRFl4ZWsweU1URXVOalk1SURFeU5TNDVNelpJTVRrM0xqUXhZVFVnTlNBd0lEQWdNQzAxSURWMk1UUXVNalUzWVRVZ05TQXdJREFnTUNBMUlEVm9NVFF1TWpVNVlUVWdOU0F3SURBZ01DQTFMVFYyTFRFMExqSTFOMkUxSURVZ01DQXdJREF0TlMwMWVpSXZQand2YzNablBnPT1cIjtcbmV4cG9ydCB2YXIgQVNTRVRfRklMRV9TQ0FOID0gU1ZHX1hNTF9QUkVGSVggKyBcIlBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSFpwWlhkQ2IzZzlJakFnTUNBMU9TNHdNVGdnTlRrdU1ERTRJaUJ6ZEhsc1pUMGlaVzVoWW14bExXSmhZMnRuY205MWJtUTZibVYzSURBZ01DQTFPUzR3TVRnZ05Ua3VNREU0SWlCNGJXdzZjM0JoWTJVOUluQnlaWE5sY25abElqNDhjR0YwYUNCa1BTSnROVGd1TnpReElEVTBMamd3T1MwMUxqazJPUzAyTGpJME5HRXhNQzQzTkNBeE1DNDNOQ0F3SURBZ01DQXlMamd5TFRjdU1qVmpNQzAxTGprMU15MDBMamcwTXkweE1DNDNPVFl0TVRBdU56azJMVEV3TGpjNU5sTXpOQ0F6TlM0ek5qRWdNelFnTkRFdU16RTBJRE00TGpnME15QTFNaTR4TVNBME5DNDNPVFlnTlRJdU1URmpNaTQwTkRFZ01DQTBMalk0T0MwdU9ESTBJRFl1TkRrNUxUSXVNVGsyYkRZdU1EQXhJRFl1TWpjM1lTNDVPVGd1T1RrNElEQWdNQ0F3SURFdU5ERTBMakF6TWlBeElERWdNQ0F3SURBZ0xqQXpNUzB4TGpReE5IcE5NellnTkRFdU16RTBZekF0TkM0NE5TQXpMamswTmkwNExqYzVOaUE0TGpjNU5pMDRMamM1Tm5NNExqYzVOaUF6TGprME5pQTRMamM1TmlBNExqYzVOaTB6TGprME5pQTRMamM1TmkwNExqYzVOaUE0TGpjNU5sTXpOaUEwTmk0eE5qUWdNellnTkRFdU16RTBlazB4TUM0ME16RWdNVFl1TURnNFl6QWdNeTR3TnlBeUxqUTVPQ0ExTGpVMk9DQTFMalUyT1NBMUxqVTJPSE0xTGpVMk9TMHlMalE1T0NBMUxqVTJPUzAxTGpVMk9HTXdMVE11TURjeExUSXVORGs0TFRVdU5UWTVMVFV1TlRZNUxUVXVOVFk1Y3kwMUxqVTJPU0F5TGpRNU9DMDFMalUyT1NBMUxqVTJPWHB0T1M0eE16Z2dNR013SURFdU9UWTRMVEV1TmpBeUlETXVOVFk0TFRNdU5UWTVJRE11TlRZNGN5MHpMalUyT1MweExqWXdNUzB6TGpVMk9TMHpMalUyT0NBeExqWXdNaTB6TGpVMk9TQXpMalUyT1MwekxqVTJPU0F6TGpVMk9TQXhMall3TVNBekxqVTJPU0F6TGpVMk9Yb2lMejQ4Y0dGMGFDQmtQU0p0TXpBdU9EZ3lJREk0TGprNE55QTVMakU0TFRFd0xqQTFOQ0F4TVM0eU5qSWdNVEF1TXpJellURWdNU0F3SURBZ01DQXhMak0xTVMweExqUTNOV3d0TVRJdE1URmhNU0F4SURBZ01DQXdMVEV1TkRFMExqQTJNMnd0T1M0M09UUWdNVEF1TnpJM0xUUXVOelF6TFRRdU56UXpZVEV1TURBeklERXVNREF6SURBZ01DQXdMVEV1TXpZNExTNHdORFJNTmk0ek16a2dNemN1TnpZNFlURWdNU0F3SURFZ01DQXhMak15TWlBeExqVXdNV3d4Tmk0ek1UTXRNVFF1TXpZeUlEY3VNekU1SURjdU16RTRZUzQ1T1RrdU9UazVJREFnTVNBd0lERXVOREUwTFRFdU5ERTBiQzB4TGpneU5TMHhMamd5TkhvaUx6NDhjR0YwYUNCa1BTSk5NekFnTkRZdU5URTRTREoyTFRReWFEVTBkakk0WVRFZ01TQXdJREVnTUNBeUlEQjJMVEk1WVRFZ01TQXdJREFnTUMweExURklNV0V4SURFZ01DQXdJREF0TVNBeGRqUTBZVEVnTVNBd0lEQWdNQ0F4SURGb01qbGhNU0F4SURBZ01TQXdJREF0TW5vaUx6NDhMM04yWno0PVwiO1xuZXhwb3J0IHZhciBBU1NFVF9JTkZPX0lDT05fMTZQWCA9IFNWR19YTUxfUFJFRklYICsgXCJQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQTBOakFnTkRZd0lpQnpkSGxzWlQwaVpXNWhZbXhsTFdKaFkydG5jbTkxYm1RNmJtVjNJREFnTUNBME5qQWdORFl3SWlCNGJXdzZjM0JoWTJVOUluQnlaWE5sY25abElqNDhjR0YwYUNCa1BTSk5Nak13SURCRE1UQXlMamszTlNBd0lEQWdNVEF5TGprM05TQXdJREl6TUhNeE1ESXVPVGMxSURJek1DQXlNekFnTWpNd0lESXpNQzB4TURJdU9UYzBJREl6TUMweU16QlRNelUzTGpBeU5TQXdJREl6TUNBd2VtMHpPQzR6TXpNZ016YzNMak0yWXpBZ09DNDJOell0Tnk0d016UWdNVFV1TnpFdE1UVXVOekVnTVRVdU56Rm9MVFF6TGpFd01XTXRPQzQyTnpZZ01DMHhOUzQzTVMwM0xqQXpOQzB4TlM0M01TMHhOUzQzTVZZeU1ESXVORGMzWXpBdE9DNDJOellnTnk0d016TXRNVFV1TnpFZ01UVXVOekV0TVRVdU56Rm9ORE11TVRBeFl6Z3VOamMySURBZ01UVXVOekVnTnk0d016TWdNVFV1TnpFZ01UVXVOekZXTXpjM0xqTTJlazB5TXpBZ01UVTNZeTB5TVM0MU16a2dNQzB6T1MweE55NDBOakV0TXprdE16bHpNVGN1TkRZeExUTTVJRE01TFRNNUlETTVJREUzTGpRMk1TQXpPU0F6T1MweE55NDBOakVnTXprdE16a2dNemw2SWk4K1BDOXpkbWMrXCI7XG5leHBvcnQgdmFyIEFTU0VUX0NMT1NFX0lDT05fMTZQWCA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FZQUFBQWY4LzloQUFBQUJITkNTVlFJQ0FnSWZBaGtpQUFBQUFsd1NGbHpBQUFBUWdBQUFFSUJhcnFRUkFBQUFCbDBSVmgwVTI5bWRIZGhjbVVBZDNkM0xtbHVhM05qWVhCbExtOXlaNXZ1UEJvQUFBRTFTVVJCVkRpTmZkSTdTME5CRUFYZ0x5YTFvdEZncGJZU2JJU0FncFhZaTZDbWlIOUtDQWlDaGFWZ2E2T2lXUGdmUkRRKzBpdGFHVk5vc1h0bHVXd2N1TXplUGZNNE0zc3E4bGJIQnVid2cxZGM0bTFFL0ovTjRnaERQT0lzZmsvNHhpRWFvNUtYME1jRmxqTjRDOWQ0UVRQWHVZOTlqUDNEc0lvRFBHTTZCWTVpNXlJNVI3TzRxK0ltRmtKWTJEQ2gzY0FIMmtseUIrOUoxeFVNTUFHN2VDaDFhK01yK2s0OGI1ZGlYckZWd3dMdVMrQko5TWZSNytHMEZIT0hoVEhoblhOV1M4N1ZERjRwY25mUUs0RXA3WFNjTkxtUFRaZ1VSTktLWUVOWVdEcHpXMUJoc2NTMVdIUzhDRGdVUkZKUXJXY29GM2MxM0tLYmdnMUJZUWZ5OHhaV0V6VFR3MVFaYkFvS3U4RnFKbmt0ZHU1aGNWU0htY2hpSUx6enVhRFF2akJ6VjJtOHlvaENFMWpIZlB4L3hoVSt5NEcvRDc1RUxsUkpzU1lBQUFBQVNVVk9SSzVDWUlJPVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtYXNzZXRzLmpzLm1hcCJdLCJuYW1lcyI6WyJTVkdfWE1MX1BSRUZJWCIsIkFTU0VUX0NBTUVSQV9TQ0FOIiwiQVNTRVRfRklMRV9TQ0FOIiwiQVNTRVRfSU5GT19JQ09OXzE2UFgiLCJBU1NFVF9DTE9TRV9JQ09OXzE2UFgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/image-assets.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5Qrcode: () => (/* reexport safe */ _html5_qrcode__WEBPACK_IMPORTED_MODULE_0__.Html5Qrcode),\n/* harmony export */   Html5QrcodeScanType: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScanType),\n/* harmony export */   Html5QrcodeScanner: () => (/* reexport safe */ _html5_qrcode_scanner__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScanner),\n/* harmony export */   Html5QrcodeScannerState: () => (/* reexport safe */ _state_manager__WEBPACK_IMPORTED_MODULE_3__.Html5QrcodeScannerState),\n/* harmony export */   Html5QrcodeSupportedFormats: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeSupportedFormats)\n/* harmony export */ });\n/* harmony import */ var _html5_qrcode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./html5-qrcode */ \"(ssr)/./node_modules/html5-qrcode/esm/html5-qrcode.js\");\n/* harmony import */ var _html5_qrcode_scanner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./html5-qrcode-scanner */ \"(ssr)/./node_modules/html5-qrcode/esm/html5-qrcode-scanner.js\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core */ \"(ssr)/./node_modules/html5-qrcode/esm/core.js\");\n/* harmony import */ var _state_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./state-manager */ \"(ssr)/./node_modules/html5-qrcode/esm/state-manager.js\");\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBNkM7QUFDZTtBQUNQO0FBQ0s7QUFDYixDQUM3QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb3Bvcy8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL2luZGV4LmpzP2U3YWEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgSHRtbDVRcmNvZGUgfSBmcm9tIFwiLi9odG1sNS1xcmNvZGVcIjtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlU2Nhbm5lciB9IGZyb20gXCIuL2h0bWw1LXFyY29kZS1zY2FubmVyXCI7XG5leHBvcnQgeyBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMgfSBmcm9tIFwiLi9jb3JlXCI7XG5leHBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZSB9IGZyb20gXCIuL3N0YXRlLW1hbmFnZXJcIjtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlU2NhblR5cGUgfSBmcm9tIFwiLi9jb3JlXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiSHRtbDVRcmNvZGUiLCJIdG1sNVFyY29kZVNjYW5uZXIiLCJIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMiLCJIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZSIsIkh0bWw1UXJjb2RlU2NhblR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/native-bar-code-detector.js":
/*!*******************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/native-bar-code-detector.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BarcodeDetectorDelegate: () => (/* binding */ BarcodeDetectorDelegate)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"(ssr)/./node_modules/html5-qrcode/esm/core.js\");\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\n\nvar BarcodeDetectorDelegate = function() {\n    function BarcodeDetectorDelegate(requestedFormats, verbose, logger) {\n        this.formatMap = new Map([\n            [\n                _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.QR_CODE,\n                \"qr_code\"\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.AZTEC,\n                \"aztec\"\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODABAR,\n                \"codabar\"\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_39,\n                \"code_39\"\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_93,\n                \"code_93\"\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_128,\n                \"code_128\"\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.DATA_MATRIX,\n                \"data_matrix\"\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.ITF,\n                \"itf\"\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.EAN_13,\n                \"ean_13\"\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.EAN_8,\n                \"ean_8\"\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.PDF_417,\n                \"pdf417\"\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_A,\n                \"upc_a\"\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_E,\n                \"upc_e\"\n            ]\n        ]);\n        this.reverseFormatMap = this.createReverseFormatMap();\n        if (!BarcodeDetectorDelegate.isSupported()) {\n            throw \"Use html5qrcode.min.js without edit, Use \" + \"BarcodeDetectorDelegate only if it isSupported();\";\n        }\n        this.verbose = verbose;\n        this.logger = logger;\n        var formats = this.createBarcodeDetectorFormats(requestedFormats);\n        this.detector = new BarcodeDetector(formats);\n        if (!this.detector) {\n            throw \"BarcodeDetector detector not supported\";\n        }\n    }\n    BarcodeDetectorDelegate.isSupported = function() {\n        if (!(\"BarcodeDetector\" in window)) {\n            return false;\n        }\n        var dummyDetector = new BarcodeDetector({\n            formats: [\n                \"qr_code\"\n            ]\n        });\n        return typeof dummyDetector !== \"undefined\";\n    };\n    BarcodeDetectorDelegate.prototype.decodeAsync = function(canvas) {\n        return __awaiter(this, void 0, void 0, function() {\n            var barcodes, largestBarcode;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4,\n                            this.detector.detect(canvas)\n                        ];\n                    case 1:\n                        barcodes = _a.sent();\n                        if (!barcodes || barcodes.length === 0) {\n                            throw \"No barcode or QR code detected.\";\n                        }\n                        largestBarcode = this.selectLargestBarcode(barcodes);\n                        return [\n                            2,\n                            {\n                                text: largestBarcode.rawValue,\n                                format: _core__WEBPACK_IMPORTED_MODULE_0__.QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(largestBarcode.format)),\n                                debugData: this.createDebugData()\n                            }\n                        ];\n                }\n            });\n        });\n    };\n    BarcodeDetectorDelegate.prototype.selectLargestBarcode = function(barcodes) {\n        var largestBarcode = null;\n        var maxArea = 0;\n        for(var _i = 0, barcodes_1 = barcodes; _i < barcodes_1.length; _i++){\n            var barcode = barcodes_1[_i];\n            var area = barcode.boundingBox.width * barcode.boundingBox.height;\n            if (area > maxArea) {\n                maxArea = area;\n                largestBarcode = barcode;\n            }\n        }\n        if (!largestBarcode) {\n            throw \"No largest barcode found\";\n        }\n        return largestBarcode;\n    };\n    BarcodeDetectorDelegate.prototype.createBarcodeDetectorFormats = function(requestedFormats) {\n        var formats = [];\n        for(var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++){\n            var requestedFormat = requestedFormats_1[_i];\n            if (this.formatMap.has(requestedFormat)) {\n                formats.push(this.formatMap.get(requestedFormat));\n            } else {\n                this.logger.warn(\"\".concat(requestedFormat, \" is not supported by\") + \"BarcodeDetectorDelegate\");\n            }\n        }\n        return {\n            formats: formats\n        };\n    };\n    BarcodeDetectorDelegate.prototype.toHtml5QrcodeSupportedFormats = function(barcodeDetectorFormat) {\n        if (!this.reverseFormatMap.has(barcodeDetectorFormat)) {\n            throw \"reverseFormatMap doesn't have \".concat(barcodeDetectorFormat);\n        }\n        return this.reverseFormatMap.get(barcodeDetectorFormat);\n    };\n    BarcodeDetectorDelegate.prototype.createReverseFormatMap = function() {\n        var result = new Map();\n        this.formatMap.forEach(function(value, key, _) {\n            result.set(value, key);\n        });\n        return result;\n    };\n    BarcodeDetectorDelegate.prototype.createDebugData = function() {\n        return {\n            decoderName: \"BarcodeDetector\"\n        };\n    };\n    return BarcodeDetectorDelegate;\n}();\n //# sourceMappingURL=native-bar-code-detector.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9uYXRpdmUtYmFyLWNvZGUtZGV0ZWN0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDQSxJQUFJTyxjQUFjLFNBQUssSUFBSSxTQUFJLENBQUNBLFdBQVcsSUFBSyxTQUFVbEIsT0FBTyxFQUFFbUIsSUFBSTtJQUNuRSxJQUFJQyxJQUFJO1FBQUVDLE9BQU87UUFBR0MsTUFBTTtZQUFhLElB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YXRpdmUtYmFyLWNvZGUtZGV0ZWN0b3IuanM/YmFmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5pbXBvcnQgeyBRcmNvZGVSZXN1bHRGb3JtYXQsIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cyB9IGZyb20gXCIuL2NvcmVcIjtcbnZhciBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFyY29kZURldGVjdG9yRGVsZWdhdGUocmVxdWVzdGVkRm9ybWF0cywgdmVyYm9zZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuZm9ybWF0TWFwID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlFSX0NPREUsIFwicXJfY29kZVwiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQVpURUMsIFwiYXp0ZWNcIl0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREFCQVIsIFwiY29kYWJhclwiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQ09ERV8zOSwgXCJjb2RlXzM5XCJdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RFXzkzLCBcImNvZGVfOTNcIl0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfMTI4LCBcImNvZGVfMTI4XCJdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5EQVRBX01BVFJJWCwgXCJkYXRhX21hdHJpeFwiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuSVRGLCBcIml0ZlwiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuRUFOXzEzLCBcImVhbl8xM1wiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuRUFOXzgsIFwiZWFuXzhcIl0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlBERl80MTcsIFwicGRmNDE3XCJdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5VUENfQSwgXCJ1cGNfYVwiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuVVBDX0UsIFwidXBjX2VcIl1cbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMucmV2ZXJzZUZvcm1hdE1hcCA9IHRoaXMuY3JlYXRlUmV2ZXJzZUZvcm1hdE1hcCgpO1xuICAgICAgICBpZiAoIUJhcmNvZGVEZXRlY3RvckRlbGVnYXRlLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IFwiVXNlIGh0bWw1cXJjb2RlLm1pbi5qcyB3aXRob3V0IGVkaXQsIFVzZSBcIlxuICAgICAgICAgICAgICAgICsgXCJCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZSBvbmx5IGlmIGl0IGlzU3VwcG9ydGVkKCk7XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJib3NlID0gdmVyYm9zZTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHZhciBmb3JtYXRzID0gdGhpcy5jcmVhdGVCYXJjb2RlRGV0ZWN0b3JGb3JtYXRzKHJlcXVlc3RlZEZvcm1hdHMpO1xuICAgICAgICB0aGlzLmRldGVjdG9yID0gbmV3IEJhcmNvZGVEZXRlY3Rvcihmb3JtYXRzKTtcbiAgICAgICAgaWYgKCF0aGlzLmRldGVjdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkJhcmNvZGVEZXRlY3RvciBkZXRlY3RvciBub3Qgc3VwcG9ydGVkXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQmFyY29kZURldGVjdG9yRGVsZWdhdGUuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghKFwiQmFyY29kZURldGVjdG9yXCIgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkdW1teURldGVjdG9yID0gbmV3IEJhcmNvZGVEZXRlY3Rvcih7IGZvcm1hdHM6IFtcInFyX2NvZGVcIl0gfSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZHVtbXlEZXRlY3RvciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB9O1xuICAgIEJhcmNvZGVEZXRlY3RvckRlbGVnYXRlLnByb3RvdHlwZS5kZWNvZGVBc3luYyA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhcmNvZGVzLCBsYXJnZXN0QmFyY29kZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB0aGlzLmRldGVjdG9yLmRldGVjdChjYW52YXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhcmNvZGVzIHx8IGJhcmNvZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiTm8gYmFyY29kZSBvciBRUiBjb2RlIGRldGVjdGVkLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFyZ2VzdEJhcmNvZGUgPSB0aGlzLnNlbGVjdExhcmdlc3RCYXJjb2RlKGJhcmNvZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsYXJnZXN0QmFyY29kZS5yYXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBRcmNvZGVSZXN1bHRGb3JtYXQuY3JlYXRlKHRoaXMudG9IdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMobGFyZ2VzdEJhcmNvZGUuZm9ybWF0KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnRGF0YTogdGhpcy5jcmVhdGVEZWJ1Z0RhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhcmNvZGVEZXRlY3RvckRlbGVnYXRlLnByb3RvdHlwZS5zZWxlY3RMYXJnZXN0QmFyY29kZSA9IGZ1bmN0aW9uIChiYXJjb2Rlcykge1xuICAgICAgICB2YXIgbGFyZ2VzdEJhcmNvZGUgPSBudWxsO1xuICAgICAgICB2YXIgbWF4QXJlYSA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYmFyY29kZXNfMSA9IGJhcmNvZGVzOyBfaSA8IGJhcmNvZGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgYmFyY29kZSA9IGJhcmNvZGVzXzFbX2ldO1xuICAgICAgICAgICAgdmFyIGFyZWEgPSBiYXJjb2RlLmJvdW5kaW5nQm94LndpZHRoICogYmFyY29kZS5ib3VuZGluZ0JveC5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICBsYXJnZXN0QmFyY29kZSA9IGJhcmNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXJnZXN0QmFyY29kZSkge1xuICAgICAgICAgICAgdGhyb3cgXCJObyBsYXJnZXN0IGJhcmNvZGUgZm91bmRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFyZ2VzdEJhcmNvZGU7XG4gICAgfTtcbiAgICBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZS5wcm90b3R5cGUuY3JlYXRlQmFyY29kZURldGVjdG9yRm9ybWF0cyA9IGZ1bmN0aW9uIChyZXF1ZXN0ZWRGb3JtYXRzKSB7XG4gICAgICAgIHZhciBmb3JtYXRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcmVxdWVzdGVkRm9ybWF0c18xID0gcmVxdWVzdGVkRm9ybWF0czsgX2kgPCByZXF1ZXN0ZWRGb3JtYXRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdGVkRm9ybWF0ID0gcmVxdWVzdGVkRm9ybWF0c18xW19pXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdE1hcC5oYXMocmVxdWVzdGVkRm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHMucHVzaCh0aGlzLmZvcm1hdE1hcC5nZXQocmVxdWVzdGVkRm9ybWF0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiXCIuY29uY2F0KHJlcXVlc3RlZEZvcm1hdCwgXCIgaXMgbm90IHN1cHBvcnRlZCBieVwiKVxuICAgICAgICAgICAgICAgICAgICArIFwiQmFyY29kZURldGVjdG9yRGVsZWdhdGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9ybWF0czogZm9ybWF0cyB9O1xuICAgIH07XG4gICAgQmFyY29kZURldGVjdG9yRGVsZWdhdGUucHJvdG90eXBlLnRvSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzID0gZnVuY3Rpb24gKGJhcmNvZGVEZXRlY3RvckZvcm1hdCkge1xuICAgICAgICBpZiAoIXRoaXMucmV2ZXJzZUZvcm1hdE1hcC5oYXMoYmFyY29kZURldGVjdG9yRm9ybWF0KSkge1xuICAgICAgICAgICAgdGhyb3cgXCJyZXZlcnNlRm9ybWF0TWFwIGRvZXNuJ3QgaGF2ZSBcIi5jb25jYXQoYmFyY29kZURldGVjdG9yRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlRm9ybWF0TWFwLmdldChiYXJjb2RlRGV0ZWN0b3JGb3JtYXQpO1xuICAgIH07XG4gICAgQmFyY29kZURldGVjdG9yRGVsZWdhdGUucHJvdG90eXBlLmNyZWF0ZVJldmVyc2VGb3JtYXRNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZm9ybWF0TWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXksIF8pIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQodmFsdWUsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQmFyY29kZURldGVjdG9yRGVsZWdhdGUucHJvdG90eXBlLmNyZWF0ZURlYnVnRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgZGVjb2Rlck5hbWU6IFwiQmFyY29kZURldGVjdG9yXCIgfTtcbiAgICB9O1xuICAgIHJldHVybiBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZTtcbn0oKSk7XG5leHBvcnQgeyBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF0aXZlLWJhci1jb2RlLWRldGVjdG9yLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJ2ZXJiIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJuIiwidiIsIm9wIiwiVHlwZUVycm9yIiwiY2FsbCIsInBvcCIsImxlbmd0aCIsInB1c2giLCJRcmNvZGVSZXN1bHRGb3JtYXQiLCJIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMiLCJCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZSIsInJlcXVlc3RlZEZvcm1hdHMiLCJ2ZXJib3NlIiwibG9nZ2VyIiwiZm9ybWF0TWFwIiwiTWFwIiwiUVJfQ09ERSIsIkFaVEVDIiwiQ09EQUJBUiIsIkNPREVfMzkiLCJDT0RFXzkzIiwiQ09ERV8xMjgiLCJEQVRBX01BVFJJWCIsIklURiIsIkVBTl8xMyIsIkVBTl84IiwiUERGXzQxNyIsIlVQQ19BIiwiVVBDX0UiLCJyZXZlcnNlRm9ybWF0TWFwIiwiY3JlYXRlUmV2ZXJzZUZvcm1hdE1hcCIsImlzU3VwcG9ydGVkIiwiZm9ybWF0cyIsImNyZWF0ZUJhcmNvZGVEZXRlY3RvckZvcm1hdHMiLCJkZXRlY3RvciIsIkJhcmNvZGVEZXRlY3RvciIsIndpbmRvdyIsImR1bW15RGV0ZWN0b3IiLCJwcm90b3R5cGUiLCJkZWNvZGVBc3luYyIsImNhbnZhcyIsImJhcmNvZGVzIiwibGFyZ2VzdEJhcmNvZGUiLCJfYSIsImRldGVjdCIsInNlbGVjdExhcmdlc3RCYXJjb2RlIiwidGV4dCIsInJhd1ZhbHVlIiwiZm9ybWF0IiwiY3JlYXRlIiwidG9IdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMiLCJkZWJ1Z0RhdGEiLCJjcmVhdGVEZWJ1Z0RhdGEiLCJtYXhBcmVhIiwiX2kiLCJiYXJjb2Rlc18xIiwiYmFyY29kZSIsImFyZWEiLCJib3VuZGluZ0JveCIsIndpZHRoIiwiaGVpZ2h0IiwicmVxdWVzdGVkRm9ybWF0c18xIiwicmVxdWVzdGVkRm9ybWF0IiwiaGFzIiwiZ2V0Iiwid2FybiIsImNvbmNhdCIsImJhcmNvZGVEZXRlY3RvckZvcm1hdCIsImZvckVhY2giLCJrZXkiLCJzZXQiLCJkZWNvZGVyTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/native-bar-code-detector.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/state-manager.js":
/*!********************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/state-manager.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5QrcodeScannerState: () => (/* binding */ Html5QrcodeScannerState),\n/* harmony export */   StateManagerFactory: () => (/* binding */ StateManagerFactory),\n/* harmony export */   StateManagerProxy: () => (/* binding */ StateManagerProxy)\n/* harmony export */ });\nvar Html5QrcodeScannerState;\n(function(Html5QrcodeScannerState) {\n    Html5QrcodeScannerState[Html5QrcodeScannerState[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    Html5QrcodeScannerState[Html5QrcodeScannerState[\"NOT_STARTED\"] = 1] = \"NOT_STARTED\";\n    Html5QrcodeScannerState[Html5QrcodeScannerState[\"SCANNING\"] = 2] = \"SCANNING\";\n    Html5QrcodeScannerState[Html5QrcodeScannerState[\"PAUSED\"] = 3] = \"PAUSED\";\n})(Html5QrcodeScannerState || (Html5QrcodeScannerState = {}));\nvar StateManagerImpl = function() {\n    function StateManagerImpl() {\n        this.state = Html5QrcodeScannerState.NOT_STARTED;\n        this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;\n    }\n    StateManagerImpl.prototype.directTransition = function(newState) {\n        this.failIfTransitionOngoing();\n        this.validateTransition(newState);\n        this.state = newState;\n    };\n    StateManagerImpl.prototype.startTransition = function(newState) {\n        this.failIfTransitionOngoing();\n        this.validateTransition(newState);\n        this.onGoingTransactionNewState = newState;\n        return this;\n    };\n    StateManagerImpl.prototype.execute = function() {\n        if (this.onGoingTransactionNewState === Html5QrcodeScannerState.UNKNOWN) {\n            throw \"Transaction is already cancelled, cannot execute().\";\n        }\n        var tempNewState = this.onGoingTransactionNewState;\n        this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;\n        this.directTransition(tempNewState);\n    };\n    StateManagerImpl.prototype.cancel = function() {\n        if (this.onGoingTransactionNewState === Html5QrcodeScannerState.UNKNOWN) {\n            throw \"Transaction is already cancelled, cannot cancel().\";\n        }\n        this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;\n    };\n    StateManagerImpl.prototype.getState = function() {\n        return this.state;\n    };\n    StateManagerImpl.prototype.failIfTransitionOngoing = function() {\n        if (this.onGoingTransactionNewState !== Html5QrcodeScannerState.UNKNOWN) {\n            throw \"Cannot transition to a new state, already under transition\";\n        }\n    };\n    StateManagerImpl.prototype.validateTransition = function(newState) {\n        switch(this.state){\n            case Html5QrcodeScannerState.UNKNOWN:\n                throw \"Transition from unknown is not allowed\";\n            case Html5QrcodeScannerState.NOT_STARTED:\n                this.failIfNewStateIs(newState, [\n                    Html5QrcodeScannerState.PAUSED\n                ]);\n                break;\n            case Html5QrcodeScannerState.SCANNING:\n                break;\n            case Html5QrcodeScannerState.PAUSED:\n                break;\n        }\n    };\n    StateManagerImpl.prototype.failIfNewStateIs = function(newState, disallowedStatesToTransition) {\n        for(var _i = 0, disallowedStatesToTransition_1 = disallowedStatesToTransition; _i < disallowedStatesToTransition_1.length; _i++){\n            var disallowedState = disallowedStatesToTransition_1[_i];\n            if (newState === disallowedState) {\n                throw \"Cannot transition from \".concat(this.state, \" to \").concat(newState);\n            }\n        }\n    };\n    return StateManagerImpl;\n}();\nvar StateManagerProxy = function() {\n    function StateManagerProxy(stateManager) {\n        this.stateManager = stateManager;\n    }\n    StateManagerProxy.prototype.startTransition = function(newState) {\n        return this.stateManager.startTransition(newState);\n    };\n    StateManagerProxy.prototype.directTransition = function(newState) {\n        this.stateManager.directTransition(newState);\n    };\n    StateManagerProxy.prototype.getState = function() {\n        return this.stateManager.getState();\n    };\n    StateManagerProxy.prototype.canScanFile = function() {\n        return this.stateManager.getState() === Html5QrcodeScannerState.NOT_STARTED;\n    };\n    StateManagerProxy.prototype.isScanning = function() {\n        return this.stateManager.getState() !== Html5QrcodeScannerState.NOT_STARTED;\n    };\n    StateManagerProxy.prototype.isStrictlyScanning = function() {\n        return this.stateManager.getState() === Html5QrcodeScannerState.SCANNING;\n    };\n    StateManagerProxy.prototype.isPaused = function() {\n        return this.stateManager.getState() === Html5QrcodeScannerState.PAUSED;\n    };\n    return StateManagerProxy;\n}();\n\nvar StateManagerFactory = function() {\n    function StateManagerFactory() {}\n    StateManagerFactory.create = function() {\n        return new StateManagerProxy(new StateManagerImpl());\n    };\n    return StateManagerFactory;\n}();\n //# sourceMappingURL=state-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9zdGF0ZS1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFPLElBQUlBLHdCQUF3QjtBQUNsQyxVQUFVQSx1QkFBdUI7SUFDOUJBLHVCQUF1QixDQUFDQSx1QkFBdUIsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQ2xFQSx1QkFBdUIsQ0FBQ0EsdUJBQXVCLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUN0RUEsdUJBQXVCLENBQUNBLHVCQUF1QixDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDbkVBLHVCQUF1QixDQUFDQSx1QkFBdUIsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0FBQ3JFLEdBQUdBLDJCQUE0QkEsQ0FBQUEsMEJBQTBCLENBQUM7QUFDMUQsSUFBSUMsbUJBQW9CO0lBQ3BCLFNBQVNBO1FBQ0wsSUFBSSxDQUFDQyxLQUFLLEdBQUdGLHdCQUF3QkcsV0FBVztRQUNoRCxJQUFJLENBQUNDLDBCQUEwQixHQUFHSix3QkFBd0JLLE9BQU87SUFDckU7SUFDQUosaUJBQWlCSyxTQUFTLENBQUNDLGdCQUFnQixHQUFHLFNBQVVDLFFBQVE7UUFDNUQsSUFBSSxDQUFDQyx1QkFBdUI7UUFDNUIsSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQ0Y7UUFDeEIsSUFBSSxDQUFDTixLQUFLLEdBQUdNO0lBQ2pCO0lBQ0FQLGlCQUFpQkssU0FBUyxDQUFDSyxlQUFlLEdBQUcsU0FBVUgsUUFBUTtRQUMzRCxJQUFJLENBQUNDLHVCQUF1QjtRQUM1QixJQUFJLENBQUNDLGtCQUFrQixDQUFDRjtRQUN4QixJQUFJLENBQUNKLDBCQUEwQixHQUFHSTtRQUNsQyxPQUFPLElBQUk7SUFDZjtJQUNBUCxpQkFBaUJLLFNBQVMsQ0FBQ00sT0FBTyxHQUFHO1FBQ2pDLElBQUksSUFBSSxDQUFDUiwwQkFBMEIsS0FDM0JKLHdCQUF3QkssT0FBTyxFQUFFO1lBQ3JDLE1BQU07UUFDVjtRQUNBLElBQUlR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NkI7QUFDN0IsSUFBSU0sc0JBQXVCO0lBQ3ZCLFNBQVNBLHVCQUNUO0lBQ0FBLG9CQUFvQkMsTUFBTSxHQUFHO1FBQ3pCLE9BQU8sSUFBSVAsa0JBQWtCLElBQUl4QjtJQUNyQztJQUNBLE9BQU84QjtBQUNYO0FBQytCLENBQy9CLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL21pY3JvcG9zLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vc3RhdGUtbWFuYWdlci5qcz81NzM0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgSHRtbDVRcmNvZGVTY2FubmVyU3RhdGU7XG4oZnVuY3Rpb24gKEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlKSB7XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RhdGVbSHRtbDVRcmNvZGVTY2FubmVyU3RhdGVbXCJVTktOT1dOXCJdID0gMF0gPSBcIlVOS05PV05cIjtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZVtIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZVtcIk5PVF9TVEFSVEVEXCJdID0gMV0gPSBcIk5PVF9TVEFSVEVEXCI7XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RhdGVbSHRtbDVRcmNvZGVTY2FubmVyU3RhdGVbXCJTQ0FOTklOR1wiXSA9IDJdID0gXCJTQ0FOTklOR1wiO1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlW0h0bWw1UXJjb2RlU2Nhbm5lclN0YXRlW1wiUEFVU0VEXCJdID0gM10gPSBcIlBBVVNFRFwiO1xufSkoSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUgfHwgKEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlID0ge30pKTtcbnZhciBTdGF0ZU1hbmFnZXJJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZU1hbmFnZXJJbXBsKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuTk9UX1NUQVJURUQ7XG4gICAgICAgIHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGUgPSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5VTktOT1dOO1xuICAgIH1cbiAgICBTdGF0ZU1hbmFnZXJJbXBsLnByb3RvdHlwZS5kaXJlY3RUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuZmFpbElmVHJhbnNpdGlvbk9uZ29pbmcoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVRyYW5zaXRpb24obmV3U3RhdGUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJJbXBsLnByb3RvdHlwZS5zdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5mYWlsSWZUcmFuc2l0aW9uT25nb2luZygpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlVHJhbnNpdGlvbihuZXdTdGF0ZSk7XG4gICAgICAgIHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJJbXBsLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vbkdvaW5nVHJhbnNhY3Rpb25OZXdTdGF0ZVxuICAgICAgICAgICAgPT09IEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLlVOS05PV04pIHtcbiAgICAgICAgICAgIHRocm93IFwiVHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBjYW5jZWxsZWQsIGNhbm5vdCBleGVjdXRlKCkuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlbXBOZXdTdGF0ZSA9IHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGU7XG4gICAgICAgIHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGUgPSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5VTktOT1dOO1xuICAgICAgICB0aGlzLmRpcmVjdFRyYW5zaXRpb24odGVtcE5ld1N0YXRlKTtcbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlckltcGwucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGVcbiAgICAgICAgICAgID09PSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5VTktOT1dOKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlRyYW5zYWN0aW9uIGlzIGFscmVhZHkgY2FuY2VsbGVkLCBjYW5ub3QgY2FuY2VsKCkuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkdvaW5nVHJhbnNhY3Rpb25OZXdTdGF0ZSA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLlVOS05PV047XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJJbXBsLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJJbXBsLnByb3RvdHlwZS5mYWlsSWZUcmFuc2l0aW9uT25nb2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGVcbiAgICAgICAgICAgICE9PSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5VTktOT1dOKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCB0cmFuc2l0aW9uIHRvIGEgbmV3IHN0YXRlLCBhbHJlYWR5IHVuZGVyIHRyYW5zaXRpb25cIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGVNYW5hZ2VySW1wbC5wcm90b3R5cGUudmFsaWRhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5VTktOT1dOOlxuICAgICAgICAgICAgICAgIHRocm93IFwiVHJhbnNpdGlvbiBmcm9tIHVua25vd24gaXMgbm90IGFsbG93ZWRcIjtcbiAgICAgICAgICAgIGNhc2UgSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuTk9UX1NUQVJURUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsSWZOZXdTdGF0ZUlzKG5ld1N0YXRlLCBbSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuUEFVU0VEXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLlNDQU5OSU5HOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5QQVVTRUQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlckltcGwucHJvdG90eXBlLmZhaWxJZk5ld1N0YXRlSXMgPSBmdW5jdGlvbiAobmV3U3RhdGUsIGRpc2FsbG93ZWRTdGF0ZXNUb1RyYW5zaXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBkaXNhbGxvd2VkU3RhdGVzVG9UcmFuc2l0aW9uXzEgPSBkaXNhbGxvd2VkU3RhdGVzVG9UcmFuc2l0aW9uOyBfaSA8IGRpc2FsbG93ZWRTdGF0ZXNUb1RyYW5zaXRpb25fMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBkaXNhbGxvd2VkU3RhdGUgPSBkaXNhbGxvd2VkU3RhdGVzVG9UcmFuc2l0aW9uXzFbX2ldO1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBkaXNhbGxvd2VkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCB0cmFuc2l0aW9uIGZyb20gXCIuY29uY2F0KHRoaXMuc3RhdGUsIFwiIHRvIFwiKS5jb25jYXQobmV3U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVNYW5hZ2VySW1wbDtcbn0oKSk7XG52YXIgU3RhdGVNYW5hZ2VyUHJveHkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlTWFuYWdlclByb3h5KHN0YXRlTWFuYWdlcikge1xuICAgICAgICB0aGlzLnN0YXRlTWFuYWdlciA9IHN0YXRlTWFuYWdlcjtcbiAgICB9XG4gICAgU3RhdGVNYW5hZ2VyUHJveHkucHJvdG90eXBlLnN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uKG5ld1N0YXRlKTtcbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlclByb3h5LnByb3RvdHlwZS5kaXJlY3RUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGVNYW5hZ2VyLmRpcmVjdFRyYW5zaXRpb24obmV3U3RhdGUpO1xuICAgIH07XG4gICAgU3RhdGVNYW5hZ2VyUHJveHkucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlclByb3h5LnByb3RvdHlwZS5jYW5TY2FuRmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCkgPT09IEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLk5PVF9TVEFSVEVEO1xuICAgIH07XG4gICAgU3RhdGVNYW5hZ2VyUHJveHkucHJvdG90eXBlLmlzU2Nhbm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpICE9PSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5OT1RfU1RBUlRFRDtcbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlclByb3h5LnByb3RvdHlwZS5pc1N0cmljdGx5U2Nhbm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpID09PSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5TQ0FOTklORztcbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlclByb3h5LnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCkgPT09IEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLlBBVVNFRDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZU1hbmFnZXJQcm94eTtcbn0oKSk7XG5leHBvcnQgeyBTdGF0ZU1hbmFnZXJQcm94eSB9O1xudmFyIFN0YXRlTWFuYWdlckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlTWFuYWdlckZhY3RvcnkoKSB7XG4gICAgfVxuICAgIFN0YXRlTWFuYWdlckZhY3RvcnkuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlTWFuYWdlclByb3h5KG5ldyBTdGF0ZU1hbmFnZXJJbXBsKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlTWFuYWdlckZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0IHsgU3RhdGVNYW5hZ2VyRmFjdG9yeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGUtbWFuYWdlci5qcy5tYXAiXSwibmFtZXMiOlsiSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUiLCJTdGF0ZU1hbmFnZXJJbXBsIiwic3RhdGUiLCJOT1RfU1RBUlRFRCIsIm9uR29pbmdUcmFuc2FjdGlvbk5ld1N0YXRlIiwiVU5LTk9XTiIsInByb3RvdHlwZSIsImRpcmVjdFRyYW5zaXRpb24iLCJuZXdTdGF0ZSIsImZhaWxJZlRyYW5zaXRpb25PbmdvaW5nIiwidmFsaWRhdGVUcmFuc2l0aW9uIiwic3RhcnRUcmFuc2l0aW9uIiwiZXhlY3V0ZSIsInRlbXBOZXdTdGF0ZSIsImNhbmNlbCIsImdldFN0YXRlIiwiZmFpbElmTmV3U3RhdGVJcyIsIlBBVVNFRCIsIlNDQU5OSU5HIiwiZGlzYWxsb3dlZFN0YXRlc1RvVHJhbnNpdGlvbiIsIl9pIiwiZGlzYWxsb3dlZFN0YXRlc1RvVHJhbnNpdGlvbl8xIiwibGVuZ3RoIiwiZGlzYWxsb3dlZFN0YXRlIiwiY29uY2F0IiwiU3RhdGVNYW5hZ2VyUHJveHkiLCJzdGF0ZU1hbmFnZXIiLCJjYW5TY2FuRmlsZSIsImlzU2Nhbm5pbmciLCJpc1N0cmljdGx5U2Nhbm5pbmciLCJpc1BhdXNlZCIsIlN0YXRlTWFuYWdlckZhY3RvcnkiLCJjcmVhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/state-manager.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/storage.js":
/*!**************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/storage.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PersistedDataManager: () => (/* binding */ PersistedDataManager)\n/* harmony export */ });\nvar PersistedDataFactory = function() {\n    function PersistedDataFactory() {}\n    PersistedDataFactory.createDefault = function() {\n        return {\n            hasPermission: false,\n            lastUsedCameraId: null\n        };\n    };\n    return PersistedDataFactory;\n}();\nvar PersistedDataManager = function() {\n    function PersistedDataManager() {\n        this.data = PersistedDataFactory.createDefault();\n        var data = localStorage.getItem(PersistedDataManager.LOCAL_STORAGE_KEY);\n        if (!data) {\n            this.reset();\n        } else {\n            this.data = JSON.parse(data);\n        }\n    }\n    PersistedDataManager.prototype.hasCameraPermissions = function() {\n        return this.data.hasPermission;\n    };\n    PersistedDataManager.prototype.getLastUsedCameraId = function() {\n        return this.data.lastUsedCameraId;\n    };\n    PersistedDataManager.prototype.setHasPermission = function(hasPermission) {\n        this.data.hasPermission = hasPermission;\n        this.flush();\n    };\n    PersistedDataManager.prototype.setLastUsedCameraId = function(lastUsedCameraId) {\n        this.data.lastUsedCameraId = lastUsedCameraId;\n        this.flush();\n    };\n    PersistedDataManager.prototype.resetLastUsedCameraId = function() {\n        this.data.lastUsedCameraId = null;\n        this.flush();\n    };\n    PersistedDataManager.prototype.reset = function() {\n        this.data = PersistedDataFactory.createDefault();\n        this.flush();\n    };\n    PersistedDataManager.prototype.flush = function() {\n        localStorage.setItem(PersistedDataManager.LOCAL_STORAGE_KEY, JSON.stringify(this.data));\n    };\n    PersistedDataManager.LOCAL_STORAGE_KEY = \"HTML5_QRCODE_DATA\";\n    return PersistedDataManager;\n}();\n //# sourceMappingURL=storage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9zdG9yYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQSx1QkFBd0I7SUFDeEIsU0FBU0Esd0JBQ1Q7SUFDQUEscUJBQXFCQyxhQUFhLEdBQUc7UUFDakMsT0FBTztZQUNIQyxlQUFlO1lBQ2ZDLGtCQUFrQjtRQUN0QjtJQUNKO0lBQ0EsT0FBT0g7QUFDWDtBQUNBLElBQUlJLHVCQUF3QjtJQUN4QixTQUFTQTtRQUNMLElBQUksQ0FBQ0MsSUFBSSxHQUFHTCxxQkFBcUJDLGFBQWE7UUFDOUMsSUFBSUksT0FBT0MsYUFBYUMsT0FBTyxDQUFDSCxxQkFBcUJJLGlCQUFpQjtRQUN0RSxJQUFJLENBQUNILE1BQU07WUFDUCxJQUFJLENBQUNJLEtBQUs7UUFDZCxPQUNLO1lBQ0QsSUFBSSxDQUFDSixJQUFJLEdBQUdLLEtBQUtDLEtBQUssQ0FBQ047UUFDM0I7SUFDSjtJQUNBRCxxQkFBcUJRLFNBQVMsQ0FBQ0Msb0JBQW9CLEdBQUc7UUFDbEQsT0FBTyxJQUFJLENBQUNSLElBQUksQ0FBQ0gsYUFBYTtJQUNsQztJQUNBRSxxQkFBcUJRLFNBQVMsQ0FBQ0UsbUJBQW1CLEdBQUc7UUFDakQsT0FBTyxJQUFJLENBQUNULElBQUksQ0FBQ0YsZ0JBQWdCO0lBQ3JDO0lBQ0FDLHFCQUFxQlEsU0FBUyxDQUFDRyxnQkFBZ0IsR0FBRyxTQUFVYixhQUFhO1FBQ3JFLElBQUksQ0FBQ0csSUFBSSxDQUFDSCxhQUFhLEdBQUdBO1FBQzFCLElBQUksQ0FBQ2MsS0FBSztJQUNkO0lBQ0FaLHFCQUFxQlEsU0FBUyxDQUFDSyxtQkFBbUIsR0FBRyxTQUFVZCxnQkFBZ0I7UUFDM0UsSUFBSSxDQUFDRSxJQUFJLENBQUNGLGdCQUFnQixHQUFHQTtRQUM3QixJQUFJLENBQUNhLEtBQUs7SUFDZDtJQUNBWixxQkFBcUJRLFNBQVMsQ0FBQ00scUJBQXFCLEdBQUc7UUFDbkQsSUFBSSxDQUFDYixJQUFJLENBQUNGLGdCQUFnQixHQUFHO1FBQzdCLElBQUksQ0FBQ2EsS0FBSztJQUNkO0lBQ0FaLHFCQUFxQlEsU0FBUyxDQUFDSCxLQUFLLEdBQUc7UUFDbkMsSUFBSSxDQUFDSixJQUFJLEdBQUdMLHFCQUFxQkMsYUFBYTtRQUM5QyxJQUFJLENBQUNlLEtBQUs7SUFDZDtJQUNBWixxQkFBcUJRLFNBQVMsQ0FBQ0ksS0FBSyxHQUFHO1FBQ25DVixhQUFhYSxPQUFPLENBQUNmLHFCQUFxQkksaUJBQWlCLEVBQUVFLEtBQUtVLFNBQVMsQ0FBQyxJQUFJLENBQUNmLElBQUk7SUFDekY7SUFDQUQscUJBQXFCSSxpQkFBaUIsR0FBRztJQUN6QyxPQUFPSjtBQUNYO0FBQ2dDLENBQ2hDLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL21pY3JvcG9zLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vc3RvcmFnZS5qcz8zZDg2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBQZXJzaXN0ZWREYXRhRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGVyc2lzdGVkRGF0YUZhY3RvcnkoKSB7XG4gICAgfVxuICAgIFBlcnNpc3RlZERhdGFGYWN0b3J5LmNyZWF0ZURlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoYXNQZXJtaXNzaW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGxhc3RVc2VkQ2FtZXJhSWQ6IG51bGxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBQZXJzaXN0ZWREYXRhRmFjdG9yeTtcbn0oKSk7XG52YXIgUGVyc2lzdGVkRGF0YU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBlcnNpc3RlZERhdGFNYW5hZ2VyKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBQZXJzaXN0ZWREYXRhRmFjdG9yeS5jcmVhdGVEZWZhdWx0KCk7XG4gICAgICAgIHZhciBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oUGVyc2lzdGVkRGF0YU1hbmFnZXIuTE9DQUxfU1RPUkFHRV9LRVkpO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUGVyc2lzdGVkRGF0YU1hbmFnZXIucHJvdG90eXBlLmhhc0NhbWVyYVBlcm1pc3Npb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmhhc1Blcm1pc3Npb247XG4gICAgfTtcbiAgICBQZXJzaXN0ZWREYXRhTWFuYWdlci5wcm90b3R5cGUuZ2V0TGFzdFVzZWRDYW1lcmFJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sYXN0VXNlZENhbWVyYUlkO1xuICAgIH07XG4gICAgUGVyc2lzdGVkRGF0YU1hbmFnZXIucHJvdG90eXBlLnNldEhhc1Blcm1pc3Npb24gPSBmdW5jdGlvbiAoaGFzUGVybWlzc2lvbikge1xuICAgICAgICB0aGlzLmRhdGEuaGFzUGVybWlzc2lvbiA9IGhhc1Blcm1pc3Npb247XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9O1xuICAgIFBlcnNpc3RlZERhdGFNYW5hZ2VyLnByb3RvdHlwZS5zZXRMYXN0VXNlZENhbWVyYUlkID0gZnVuY3Rpb24gKGxhc3RVc2VkQ2FtZXJhSWQpIHtcbiAgICAgICAgdGhpcy5kYXRhLmxhc3RVc2VkQ2FtZXJhSWQgPSBsYXN0VXNlZENhbWVyYUlkO1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfTtcbiAgICBQZXJzaXN0ZWREYXRhTWFuYWdlci5wcm90b3R5cGUucmVzZXRMYXN0VXNlZENhbWVyYUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEubGFzdFVzZWRDYW1lcmFJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9O1xuICAgIFBlcnNpc3RlZERhdGFNYW5hZ2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gUGVyc2lzdGVkRGF0YUZhY3RvcnkuY3JlYXRlRGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfTtcbiAgICBQZXJzaXN0ZWREYXRhTWFuYWdlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFBlcnNpc3RlZERhdGFNYW5hZ2VyLkxPQ0FMX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpKTtcbiAgICB9O1xuICAgIFBlcnNpc3RlZERhdGFNYW5hZ2VyLkxPQ0FMX1NUT1JBR0VfS0VZID0gXCJIVE1MNV9RUkNPREVfREFUQVwiO1xuICAgIHJldHVybiBQZXJzaXN0ZWREYXRhTWFuYWdlcjtcbn0oKSk7XG5leHBvcnQgeyBQZXJzaXN0ZWREYXRhTWFuYWdlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RvcmFnZS5qcy5tYXAiXSwibmFtZXMiOlsiUGVyc2lzdGVkRGF0YUZhY3RvcnkiLCJjcmVhdGVEZWZhdWx0IiwiaGFzUGVybWlzc2lvbiIsImxhc3RVc2VkQ2FtZXJhSWQiLCJQZXJzaXN0ZWREYXRhTWFuYWdlciIsImRhdGEiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiTE9DQUxfU1RPUkFHRV9LRVkiLCJyZXNldCIsIkpTT04iLCJwYXJzZSIsInByb3RvdHlwZSIsImhhc0NhbWVyYVBlcm1pc3Npb25zIiwiZ2V0TGFzdFVzZWRDYW1lcmFJZCIsInNldEhhc1Blcm1pc3Npb24iLCJmbHVzaCIsInNldExhc3RVc2VkQ2FtZXJhSWQiLCJyZXNldExhc3RVc2VkQ2FtZXJhSWQiLCJzZXRJdGVtIiwic3RyaW5naWZ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/storage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/strings.js":
/*!**************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/strings.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5QrcodeScannerStrings: () => (/* binding */ Html5QrcodeScannerStrings),\n/* harmony export */   Html5QrcodeStrings: () => (/* binding */ Html5QrcodeStrings),\n/* harmony export */   LibraryInfoStrings: () => (/* binding */ LibraryInfoStrings)\n/* harmony export */ });\nvar Html5QrcodeStrings = function() {\n    function Html5QrcodeStrings() {}\n    Html5QrcodeStrings.codeParseError = function(exception) {\n        return \"QR code parse error, error = \".concat(exception);\n    };\n    Html5QrcodeStrings.errorGettingUserMedia = function(error) {\n        return \"Error getting userMedia, error = \".concat(error);\n    };\n    Html5QrcodeStrings.onlyDeviceSupportedError = function() {\n        return \"The device doesn't support navigator.mediaDevices , only \" + \"supported cameraIdOrConfig in this case is deviceId parameter \" + \"(string).\";\n    };\n    Html5QrcodeStrings.cameraStreamingNotSupported = function() {\n        return \"Camera streaming not supported by the browser.\";\n    };\n    Html5QrcodeStrings.unableToQuerySupportedDevices = function() {\n        return \"Unable to query supported devices, unknown error.\";\n    };\n    Html5QrcodeStrings.insecureContextCameraQueryError = function() {\n        return \"Camera access is only supported in secure context like https \" + \"or localhost.\";\n    };\n    Html5QrcodeStrings.scannerPaused = function() {\n        return \"Scanner paused\";\n    };\n    return Html5QrcodeStrings;\n}();\n\nvar Html5QrcodeScannerStrings = function() {\n    function Html5QrcodeScannerStrings() {}\n    Html5QrcodeScannerStrings.scanningStatus = function() {\n        return \"Scanning\";\n    };\n    Html5QrcodeScannerStrings.idleStatus = function() {\n        return \"Idle\";\n    };\n    Html5QrcodeScannerStrings.errorStatus = function() {\n        return \"Error\";\n    };\n    Html5QrcodeScannerStrings.permissionStatus = function() {\n        return \"Permission\";\n    };\n    Html5QrcodeScannerStrings.noCameraFoundErrorStatus = function() {\n        return \"No Cameras\";\n    };\n    Html5QrcodeScannerStrings.lastMatch = function(decodedText) {\n        return \"Last Match: \".concat(decodedText);\n    };\n    Html5QrcodeScannerStrings.codeScannerTitle = function() {\n        return \"Code Scanner\";\n    };\n    Html5QrcodeScannerStrings.cameraPermissionTitle = function() {\n        return \"Request Camera Permissions\";\n    };\n    Html5QrcodeScannerStrings.cameraPermissionRequesting = function() {\n        return \"Requesting camera permissions...\";\n    };\n    Html5QrcodeScannerStrings.noCameraFound = function() {\n        return \"No camera found\";\n    };\n    Html5QrcodeScannerStrings.scanButtonStopScanningText = function() {\n        return \"Stop Scanning\";\n    };\n    Html5QrcodeScannerStrings.scanButtonStartScanningText = function() {\n        return \"Start Scanning\";\n    };\n    Html5QrcodeScannerStrings.torchOnButton = function() {\n        return \"Switch On Torch\";\n    };\n    Html5QrcodeScannerStrings.torchOffButton = function() {\n        return \"Switch Off Torch\";\n    };\n    Html5QrcodeScannerStrings.torchOnFailedMessage = function() {\n        return \"Failed to turn on torch\";\n    };\n    Html5QrcodeScannerStrings.torchOffFailedMessage = function() {\n        return \"Failed to turn off torch\";\n    };\n    Html5QrcodeScannerStrings.scanButtonScanningStarting = function() {\n        return \"Launching Camera...\";\n    };\n    Html5QrcodeScannerStrings.textIfCameraScanSelected = function() {\n        return \"Scan an Image File\";\n    };\n    Html5QrcodeScannerStrings.textIfFileScanSelected = function() {\n        return \"Scan using camera directly\";\n    };\n    Html5QrcodeScannerStrings.selectCamera = function() {\n        return \"Select Camera\";\n    };\n    Html5QrcodeScannerStrings.fileSelectionChooseImage = function() {\n        return \"Choose Image\";\n    };\n    Html5QrcodeScannerStrings.fileSelectionChooseAnother = function() {\n        return \"Choose Another\";\n    };\n    Html5QrcodeScannerStrings.fileSelectionNoImageSelected = function() {\n        return \"No image choosen\";\n    };\n    Html5QrcodeScannerStrings.anonymousCameraPrefix = function() {\n        return \"Anonymous Camera\";\n    };\n    Html5QrcodeScannerStrings.dragAndDropMessage = function() {\n        return \"Or drop an image to scan\";\n    };\n    Html5QrcodeScannerStrings.dragAndDropMessageOnlyImages = function() {\n        return \"Or drop an image to scan (other files not supported)\";\n    };\n    Html5QrcodeScannerStrings.zoom = function() {\n        return \"zoom\";\n    };\n    Html5QrcodeScannerStrings.loadingImage = function() {\n        return \"Loading image...\";\n    };\n    Html5QrcodeScannerStrings.cameraScanAltText = function() {\n        return \"Camera based scan\";\n    };\n    Html5QrcodeScannerStrings.fileScanAltText = function() {\n        return \"Fule based scan\";\n    };\n    return Html5QrcodeScannerStrings;\n}();\n\nvar LibraryInfoStrings = function() {\n    function LibraryInfoStrings() {}\n    LibraryInfoStrings.poweredBy = function() {\n        return \"Powered by \";\n    };\n    LibraryInfoStrings.reportIssues = function() {\n        return \"Report issues\";\n    };\n    return LibraryInfoStrings;\n}();\n //# sourceMappingURL=strings.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9zdHJpbmdzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLElBQUlBLHFCQUFzQjtJQUN0QixTQUFTQSxzQkFDVDtJQUNBQSxtQkFBbUJDLGNBQWMsR0FBRyxTQUFVQyxTQUFTO1FBQ25ELE9BQU8sZ0NBQWdDQyxNQUFNLENBQUNEO0lBQ2xEO0lBQ0FGLG1CQUFtQkkscUJBQXFCLEdBQUcsU0FBVUMsS0FBSztRQUN0RCxPQUFPLG9DQUFvQ0YsTUFBTSxDQUFDRTtJQUN0RDtJQUNBTCxtQkFBbUJNLHdCQUF3QixHQUFHO1FBQzFDLE9BQU8sOERBQ0QsbUVBQ0E7SUFDVjtJQUNBTixtQkFBbUJPLDJCQUEyQixHQUFHO1FBQzdDLE9BQU87SUFDWDtJQUNBUCxtQkFBbUJRLDZCQUE2QixHQUFHO1FBQy9DLE9BQU87SUFDWDtJQUNBUixtQkFBbUJTLCtCQUErQixHQUFHO1FBQ2pELE9BQU8sa0VBQ0Q7SUFDVjtJQUNBVCxtQkFBbUJVLGFBQWEsR0FBRztRQUMvQixPQUFPO0lBQ1g7SUFDQSxPQUFPVjtBQUNYO0FBQzhCO0FBQzlCLElBQUlXLDRCQUE2QjtJQUM3QixTQUFTQSw2QkFDVDtJQUNBQSwwQkFBMEJDLGNBQWMsR0FBRztRQUN2QyxPQUFPO0lBQ1g7SUFDQUQsMEJBQTBCRSxVQUFVLEdBQUc7UUFDbkMsT0FBTztJQUNYO0lBQ0FGLDBCQUEwQkcsV0FBVyxHQUFHO1FBQ3BDLE9BQU87SUFDWDtJQUNBSCwwQkFBMEJJLGdCQUFnQixHQUFHO1FBQ3pDLE9BQU87SUFDWDtJQUNBSiwwQkFBMEJLLHdCQUF3QixHQUFHO1FBQ2pELE9BQU87SUFDWDtJQUNBTCwwQkFBMEJNLFNBQVMsR0FBRyxTQUFVQyxXQUFXO1FBQ3ZELE9BQU8sZUFBZWYsTUFBTSxDQUFDZTtJQUNqQztJQUNBUCwwQkFBMEJRLGdCQUFnQixHQUFHO1FBQ3pDLE9BQU87SUFDWDtJQUNBUiwwQkFBMEJTLHFCQUFxQixHQUFHO1FBQzlDLE9BQU87SUFDWDtJQUNBVCwwQkFBMEJVLDBCQUEwQixHQUFHO1FBQ25ELE9BQU87SUFDWDtJQUNBViwwQkFBMEJXLGFBQWEsR0FBRztRQUN0QyxPQUFPO0lBQ1g7SUFDQVgsMEJBQTBCWSwwQkFBMEIsR0FBRztRQUNuRCxPQUFPO0lBQ1g7SUFDQVosMEJBQTBCYSwyQkFBMkIsR0FBRztRQUNwRCxPQUFPO0lBQ1g7SUFDQWIsMEJBQTBCYyxhQUFhLEdBQUc7UUFDdEMsT0FBTztJQUNYO0lBQ0FkLDBCQUEwQmUsY0FBYyxHQUFHO1FBQ3ZDLE9BQU87SUFDWDtJQUNBZiwwQkFBMEJnQixvQkFBb0IsR0FBRztRQUM3QyxPQUFPO0lBQ1g7SUFDQWhCLDBCQUEwQmlCLHFCQUFxQixHQUFHO1FBQzlDLE9BQU87SUFDWDtJQUNBakIsMEJBQTBCa0IsMEJBQTBCLEdBQUc7UUFDbkQsT0FBTztJQUNYO0lBQ0FsQiwwQkFBMEJtQix3QkFBd0IsR0FBRztRQUNqRCxPQUFPO0lBQ1g7SUFDQW5CLDBCQUEwQm9CLHNCQUFzQixHQUFHO1FBQy9DLE9BQU87SUFDWDtJQUNBcEIsMEJBQTBCcUIsWUFBWSxHQUFHO1FBQ3JDLE9BQU87SUFDWDtJQUNBckIsMEJBQTBCc0Isd0JBQXdCLEdBQUc7UUFDakQsT0FBTztJQUNYO0lBQ0F0QiwwQkFBMEJ1QiwwQkFBMEIsR0FBRztRQUNuRCxPQUFPO0lBQ1g7SUFDQXZCLDBCQUEwQndCLDRCQUE0QixHQUFHO1FBQ3JELE9BQU87SUFDWDtJQUNBeEIsMEJBQTBCeUIscUJBQXFCLEdBQUc7UUFDOUMsT0FBTztJQUNYO0lBQ0F6QiwwQkFBMEIwQixrQkFBa0IsR0FBRztRQUMzQyxPQUFPO0lBQ1g7SUFDQTFCLDBCQUEwQjJCLDRCQUE0QixHQUFHO1FBQ3JELE9BQU87SUFDWDtJQUNBM0IsMEJBQTBCNEIsSUFBSSxHQUFHO1FBQzdCLE9BQU87SUFDWDtJQUNBNUIsMEJBQTBCNkIsWUFBWSxHQUFHO1FBQ3JDLE9BQU87SUFDWDtJQUNBN0IsMEJBQTBCOEIsaUJBQWlCLEdBQUc7UUFDMUMsT0FBTztJQUNYO0lBQ0E5QiwwQkFBMEIrQixlQUFlLEdBQUc7UUFDeEMsT0FBTztJQUNYO0lBQ0EsT0FBTy9CO0FBQ1g7QUFDcUM7QUFDckMsSUFBSWdDLHFCQUFzQjtJQUN0QixTQUFTQSxzQkFDVDtJQUNBQSxtQkFBbUJDLFNBQVMsR0FBRztRQUMzQixPQUFPO0lBQ1g7SUFDQUQsbUJBQW1CRSxZQUFZLEdBQUc7UUFDOUIsT0FBTztJQUNYO0lBQ0EsT0FBT0Y7QUFDWDtBQUM4QixDQUM5QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb3Bvcy8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3N0cmluZ3MuanM/ZTUyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSHRtbDVRcmNvZGVTdHJpbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNVFyY29kZVN0cmluZ3MoKSB7XG4gICAgfVxuICAgIEh0bWw1UXJjb2RlU3RyaW5ncy5jb2RlUGFyc2VFcnJvciA9IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFwiUVIgY29kZSBwYXJzZSBlcnJvciwgZXJyb3IgPSBcIi5jb25jYXQoZXhjZXB0aW9uKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU3RyaW5ncy5lcnJvckdldHRpbmdVc2VyTWVkaWEgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFwiRXJyb3IgZ2V0dGluZyB1c2VyTWVkaWEsIGVycm9yID0gXCIuY29uY2F0KGVycm9yKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU3RyaW5ncy5vbmx5RGV2aWNlU3VwcG9ydGVkRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlRoZSBkZXZpY2UgZG9lc24ndCBzdXBwb3J0IG5hdmlnYXRvci5tZWRpYURldmljZXMgLCBvbmx5IFwiXG4gICAgICAgICAgICArIFwic3VwcG9ydGVkIGNhbWVyYUlkT3JDb25maWcgaW4gdGhpcyBjYXNlIGlzIGRldmljZUlkIHBhcmFtZXRlciBcIlxuICAgICAgICAgICAgKyBcIihzdHJpbmcpLlwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTdHJpbmdzLmNhbWVyYVN0cmVhbWluZ05vdFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2FtZXJhIHN0cmVhbWluZyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLlwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTdHJpbmdzLnVuYWJsZVRvUXVlcnlTdXBwb3J0ZWREZXZpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJVbmFibGUgdG8gcXVlcnkgc3VwcG9ydGVkIGRldmljZXMsIHVua25vd24gZXJyb3IuXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVN0cmluZ3MuaW5zZWN1cmVDb250ZXh0Q2FtZXJhUXVlcnlFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2FtZXJhIGFjY2VzcyBpcyBvbmx5IHN1cHBvcnRlZCBpbiBzZWN1cmUgY29udGV4dCBsaWtlIGh0dHBzIFwiXG4gICAgICAgICAgICArIFwib3IgbG9jYWxob3N0LlwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTdHJpbmdzLnNjYW5uZXJQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNjYW5uZXIgcGF1c2VkXCI7XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbDVRcmNvZGVTdHJpbmdzO1xufSgpKTtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlU3RyaW5ncyB9O1xudmFyIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MoKSB7XG4gICAgfVxuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Muc2Nhbm5pbmdTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNjYW5uaW5nXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmlkbGVTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIklkbGVcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZXJyb3JTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkVycm9yXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnBlcm1pc3Npb25TdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlBlcm1pc3Npb25cIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Mubm9DYW1lcmFGb3VuZEVycm9yU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJObyBDYW1lcmFzXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmxhc3RNYXRjaCA9IGZ1bmN0aW9uIChkZWNvZGVkVGV4dCkge1xuICAgICAgICByZXR1cm4gXCJMYXN0IE1hdGNoOiBcIi5jb25jYXQoZGVjb2RlZFRleHQpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5jb2RlU2Nhbm5lclRpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJDb2RlIFNjYW5uZXJcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuY2FtZXJhUGVybWlzc2lvblRpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJSZXF1ZXN0IENhbWVyYSBQZXJtaXNzaW9uc1wiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5jYW1lcmFQZXJtaXNzaW9uUmVxdWVzdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiUmVxdWVzdGluZyBjYW1lcmEgcGVybWlzc2lvbnMuLi5cIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Mubm9DYW1lcmFGb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiTm8gY2FtZXJhIGZvdW5kXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnNjYW5CdXR0b25TdG9wU2Nhbm5pbmdUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJTdG9wIFNjYW5uaW5nXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnNjYW5CdXR0b25TdGFydFNjYW5uaW5nVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3RhcnQgU2Nhbm5pbmdcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudG9yY2hPbkJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3dpdGNoIE9uIFRvcmNoXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnRvcmNoT2ZmQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJTd2l0Y2ggT2ZmIFRvcmNoXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnRvcmNoT25GYWlsZWRNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJGYWlsZWQgdG8gdHVybiBvbiB0b3JjaFwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50b3JjaE9mZkZhaWxlZE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkZhaWxlZCB0byB0dXJuIG9mZiB0b3JjaFwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5zY2FuQnV0dG9uU2Nhbm5pbmdTdGFydGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiTGF1bmNoaW5nIENhbWVyYS4uLlwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50ZXh0SWZDYW1lcmFTY2FuU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNjYW4gYW4gSW1hZ2UgRmlsZVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50ZXh0SWZGaWxlU2NhblNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJTY2FuIHVzaW5nIGNhbWVyYSBkaXJlY3RseVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5zZWxlY3RDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNlbGVjdCBDYW1lcmFcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZmlsZVNlbGVjdGlvbkNob29zZUltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJDaG9vc2UgSW1hZ2VcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZmlsZVNlbGVjdGlvbkNob29zZUFub3RoZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkNob29zZSBBbm90aGVyXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmZpbGVTZWxlY3Rpb25Ob0ltYWdlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIk5vIGltYWdlIGNob29zZW5cIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuYW5vbnltb3VzQ2FtZXJhUHJlZml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJBbm9ueW1vdXMgQ2FtZXJhXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmRyYWdBbmREcm9wTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiT3IgZHJvcCBhbiBpbWFnZSB0byBzY2FuXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmRyYWdBbmREcm9wTWVzc2FnZU9ubHlJbWFnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIk9yIGRyb3AgYW4gaW1hZ2UgdG8gc2NhbiAob3RoZXIgZmlsZXMgbm90IHN1cHBvcnRlZClcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Muem9vbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiem9vbVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5sb2FkaW5nSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkxvYWRpbmcgaW1hZ2UuLi5cIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuY2FtZXJhU2NhbkFsdFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkNhbWVyYSBiYXNlZCBzY2FuXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmZpbGVTY2FuQWx0VGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiRnVsZSBiYXNlZCBzY2FuXCI7XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncztcbn0oKSk7XG5leHBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzIH07XG52YXIgTGlicmFyeUluZm9TdHJpbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaWJyYXJ5SW5mb1N0cmluZ3MoKSB7XG4gICAgfVxuICAgIExpYnJhcnlJbmZvU3RyaW5ncy5wb3dlcmVkQnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlBvd2VyZWQgYnkgXCI7XG4gICAgfTtcbiAgICBMaWJyYXJ5SW5mb1N0cmluZ3MucmVwb3J0SXNzdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJSZXBvcnQgaXNzdWVzXCI7XG4gICAgfTtcbiAgICByZXR1cm4gTGlicmFyeUluZm9TdHJpbmdzO1xufSgpKTtcbmV4cG9ydCB7IExpYnJhcnlJbmZvU3RyaW5ncyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5ncy5qcy5tYXAiXSwibmFtZXMiOlsiSHRtbDVRcmNvZGVTdHJpbmdzIiwiY29kZVBhcnNlRXJyb3IiLCJleGNlcHRpb24iLCJjb25jYXQiLCJlcnJvckdldHRpbmdVc2VyTWVkaWEiLCJlcnJvciIsIm9ubHlEZXZpY2VTdXBwb3J0ZWRFcnJvciIsImNhbWVyYVN0cmVhbWluZ05vdFN1cHBvcnRlZCIsInVuYWJsZVRvUXVlcnlTdXBwb3J0ZWREZXZpY2VzIiwiaW5zZWN1cmVDb250ZXh0Q2FtZXJhUXVlcnlFcnJvciIsInNjYW5uZXJQYXVzZWQiLCJIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzIiwic2Nhbm5pbmdTdGF0dXMiLCJpZGxlU3RhdHVzIiwiZXJyb3JTdGF0dXMiLCJwZXJtaXNzaW9uU3RhdHVzIiwibm9DYW1lcmFGb3VuZEVycm9yU3RhdHVzIiwibGFzdE1hdGNoIiwiZGVjb2RlZFRleHQiLCJjb2RlU2Nhbm5lclRpdGxlIiwiY2FtZXJhUGVybWlzc2lvblRpdGxlIiwiY2FtZXJhUGVybWlzc2lvblJlcXVlc3RpbmciLCJub0NhbWVyYUZvdW5kIiwic2NhbkJ1dHRvblN0b3BTY2FubmluZ1RleHQiLCJzY2FuQnV0dG9uU3RhcnRTY2FubmluZ1RleHQiLCJ0b3JjaE9uQnV0dG9uIiwidG9yY2hPZmZCdXR0b24iLCJ0b3JjaE9uRmFpbGVkTWVzc2FnZSIsInRvcmNoT2ZmRmFpbGVkTWVzc2FnZSIsInNjYW5CdXR0b25TY2FubmluZ1N0YXJ0aW5nIiwidGV4dElmQ2FtZXJhU2NhblNlbGVjdGVkIiwidGV4dElmRmlsZVNjYW5TZWxlY3RlZCIsInNlbGVjdENhbWVyYSIsImZpbGVTZWxlY3Rpb25DaG9vc2VJbWFnZSIsImZpbGVTZWxlY3Rpb25DaG9vc2VBbm90aGVyIiwiZmlsZVNlbGVjdGlvbk5vSW1hZ2VTZWxlY3RlZCIsImFub255bW91c0NhbWVyYVByZWZpeCIsImRyYWdBbmREcm9wTWVzc2FnZSIsImRyYWdBbmREcm9wTWVzc2FnZU9ubHlJbWFnZXMiLCJ6b29tIiwibG9hZGluZ0ltYWdlIiwiY2FtZXJhU2NhbkFsdFRleHQiLCJmaWxlU2NhbkFsdFRleHQiLCJMaWJyYXJ5SW5mb1N0cmluZ3MiLCJwb3dlcmVkQnkiLCJyZXBvcnRJc3N1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/strings.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/ui.js":
/*!*********************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LibraryInfoContainer: () => (/* binding */ LibraryInfoContainer)\n/* harmony export */ });\n/* harmony import */ var _image_assets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-assets */ \"(ssr)/./node_modules/html5-qrcode/esm/image-assets.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./strings */ \"(ssr)/./node_modules/html5-qrcode/esm/strings.js\");\n\n\nvar LibraryInfoDiv = function() {\n    function LibraryInfoDiv() {\n        this.infoDiv = document.createElement(\"div\");\n    }\n    LibraryInfoDiv.prototype.renderInto = function(parent) {\n        this.infoDiv.style.position = \"absolute\";\n        this.infoDiv.style.top = \"10px\";\n        this.infoDiv.style.right = \"10px\";\n        this.infoDiv.style.zIndex = \"2\";\n        this.infoDiv.style.display = \"none\";\n        this.infoDiv.style.padding = \"5pt\";\n        this.infoDiv.style.border = \"1px solid #171717\";\n        this.infoDiv.style.fontSize = \"10pt\";\n        this.infoDiv.style.background = \"rgb(0 0 0 / 69%)\";\n        this.infoDiv.style.borderRadius = \"5px\";\n        this.infoDiv.style.textAlign = \"center\";\n        this.infoDiv.style.fontWeight = \"400\";\n        this.infoDiv.style.color = \"white\";\n        this.infoDiv.innerText = _strings__WEBPACK_IMPORTED_MODULE_1__.LibraryInfoStrings.poweredBy();\n        var projectLink = document.createElement(\"a\");\n        projectLink.innerText = \"ScanApp\";\n        projectLink.href = \"https://scanapp.org\";\n        projectLink.target = \"new\";\n        projectLink.style.color = \"white\";\n        this.infoDiv.appendChild(projectLink);\n        var breakElemFirst = document.createElement(\"br\");\n        var breakElemSecond = document.createElement(\"br\");\n        this.infoDiv.appendChild(breakElemFirst);\n        this.infoDiv.appendChild(breakElemSecond);\n        var reportIssueLink = document.createElement(\"a\");\n        reportIssueLink.innerText = _strings__WEBPACK_IMPORTED_MODULE_1__.LibraryInfoStrings.reportIssues();\n        reportIssueLink.href = \"https://github.com/mebjas/html5-qrcode/issues\";\n        reportIssueLink.target = \"new\";\n        reportIssueLink.style.color = \"white\";\n        this.infoDiv.appendChild(reportIssueLink);\n        parent.appendChild(this.infoDiv);\n    };\n    LibraryInfoDiv.prototype.show = function() {\n        this.infoDiv.style.display = \"block\";\n    };\n    LibraryInfoDiv.prototype.hide = function() {\n        this.infoDiv.style.display = \"none\";\n    };\n    return LibraryInfoDiv;\n}();\nvar LibraryInfoIcon = function() {\n    function LibraryInfoIcon(onTapIn, onTapOut) {\n        this.isShowingInfoIcon = true;\n        this.onTapIn = onTapIn;\n        this.onTapOut = onTapOut;\n        this.infoIcon = document.createElement(\"img\");\n    }\n    LibraryInfoIcon.prototype.renderInto = function(parent) {\n        var _this = this;\n        this.infoIcon.alt = \"Info icon\";\n        this.infoIcon.src = _image_assets__WEBPACK_IMPORTED_MODULE_0__.ASSET_INFO_ICON_16PX;\n        this.infoIcon.style.position = \"absolute\";\n        this.infoIcon.style.top = \"4px\";\n        this.infoIcon.style.right = \"4px\";\n        this.infoIcon.style.opacity = \"0.6\";\n        this.infoIcon.style.cursor = \"pointer\";\n        this.infoIcon.style.zIndex = \"2\";\n        this.infoIcon.style.width = \"16px\";\n        this.infoIcon.style.height = \"16px\";\n        this.infoIcon.onmouseover = function(_) {\n            return _this.onHoverIn();\n        };\n        this.infoIcon.onmouseout = function(_) {\n            return _this.onHoverOut();\n        };\n        this.infoIcon.onclick = function(_) {\n            return _this.onClick();\n        };\n        parent.appendChild(this.infoIcon);\n    };\n    LibraryInfoIcon.prototype.onHoverIn = function() {\n        if (this.isShowingInfoIcon) {\n            this.infoIcon.style.opacity = \"1\";\n        }\n    };\n    LibraryInfoIcon.prototype.onHoverOut = function() {\n        if (this.isShowingInfoIcon) {\n            this.infoIcon.style.opacity = \"0.6\";\n        }\n    };\n    LibraryInfoIcon.prototype.onClick = function() {\n        if (this.isShowingInfoIcon) {\n            this.isShowingInfoIcon = false;\n            this.onTapIn();\n            this.infoIcon.src = _image_assets__WEBPACK_IMPORTED_MODULE_0__.ASSET_CLOSE_ICON_16PX;\n            this.infoIcon.style.opacity = \"1\";\n        } else {\n            this.isShowingInfoIcon = true;\n            this.onTapOut();\n            this.infoIcon.src = _image_assets__WEBPACK_IMPORTED_MODULE_0__.ASSET_INFO_ICON_16PX;\n            this.infoIcon.style.opacity = \"0.6\";\n        }\n    };\n    return LibraryInfoIcon;\n}();\nvar LibraryInfoContainer = function() {\n    function LibraryInfoContainer() {\n        var _this = this;\n        this.infoDiv = new LibraryInfoDiv();\n        this.infoIcon = new LibraryInfoIcon(function() {\n            _this.infoDiv.show();\n        }, function() {\n            _this.infoDiv.hide();\n        });\n    }\n    LibraryInfoContainer.prototype.renderInto = function(parent) {\n        this.infoDiv.renderInto(parent);\n        this.infoIcon.renderInto(parent);\n    };\n    return LibraryInfoContainer;\n}();\n //# sourceMappingURL=ui.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkU7QUFDOUI7QUFDL0MsSUFBSUcsaUJBQWtCO0lBQ2xCLFNBQVNBO1FBQ0wsSUFBSSxDQUFDQyxPQUFPLEdBQUdDLFNBQVNDLGFBQWEsQ0FBQztJQUMxQztJQUNBSCxlQUFlSSxTQUFTLENBQUNDLFVBQVUsR0FBRyxTQUFVQyxNQUFNO1FBQ2xELElBQUksQ0FBQ0wsT0FBTyxDQUFDTSxLQUFLLENBQUNDLFFBQVEsR0FBRztRQUM5QixJQUFJLENBQUNQLE9BQU8sQ0FBQ00sS0FBSyxDQUFDRSxHQUFHLEdBQUc7UUFDekIsSUFBSSxDQUFDUixPQUFPLENBQUNNLEtBQUssQ0FBQ0csS0FBSyxHQUFHO1FBQzNCLElBQUksQ0FBQ1QsT0FBTyxDQUFDTSxLQUFLLENBQUNJLE1BQU0sR0FBRztRQUM1QixJQUFJLENBQUNWLE9BQU8sQ0FBQ00sS0FBSyxDQUFDSyxPQUFPLEdBQUc7UUFDN0IsSUFBSSxDQUFDWCxPQUFPLENBQUNNLEtBQUssQ0FBQ00sT0FBTyxHQUFHO1FBQzdCLElBQUksQ0FBQ1osT0FBTyxDQUFDTSxLQUFLLENBQUNPLE1BQU0sR0FBRztRQUM1QixJQUFJLENBQUNiLE9BQU8sQ0FBQ00sS0FBSyxDQUFDUSxRQUFRLEdBQUc7UUFDOUIsSUFBSSxDQUFDZCxPQUFPLENBQUNNLEtBQUssQ0FBQ1MsVUFBVSxHQUFHO1FBQ2hDLElBQUksQ0FBQ2YsT0FBTyxDQUFDTSxLQUFLLENBQUNVLFlBQVksR0FBRztRQUNsQyxJQUFJLENBQUNoQixPQUFPLENBQUNNLEtBQUssQ0FBQ1csU0FBUyxHQUFHO1FBQy9CLElBQUksQ0FBQ2pCLE9BQU8sQ0FBQ00sS0FBSyxDQUFDWSxVQUFVLEdBQUc7UUFDaEMsSUFBSSxDQUFDbEIsT0FBTyxDQUFDTSxLQUFLLENBQUNhLEtBQUssR0FBRztRQUMzQixJQUFJLENBQUNuQixPQUFPLENBQUNvQixTQUFTLEdBQUd0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ckMsT0FBTyxDQUFDK0IsSUFBSTtRQUN0QjtJQUNKO0lBQ0FvQixxQkFBcUJoRCxTQUFTLENBQUNDLFVBQVUsR0FBRyxTQUFVQyxNQUFNO1FBQ3hELElBQUksQ0FBQ0wsT0FBTyxDQUFDSSxVQUFVLENBQUNDO1FBQ3hCLElBQUksQ0FBQytCLFFBQVEsQ0FBQ2hDLFVBQVUsQ0FBQ0M7SUFDN0I7SUFDQSxPQUFPOEM7QUFDWDtBQUNnQyxDQUNoQyw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb3Bvcy8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3VpLmpzPzk3NGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQVNTRVRfQ0xPU0VfSUNPTl8xNlBYLCBBU1NFVF9JTkZPX0lDT05fMTZQWCB9IGZyb20gXCIuL2ltYWdlLWFzc2V0c1wiO1xuaW1wb3J0IHsgTGlicmFyeUluZm9TdHJpbmdzIH0gZnJvbSBcIi4vc3RyaW5nc1wiO1xudmFyIExpYnJhcnlJbmZvRGl2ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaWJyYXJ5SW5mb0RpdigpIHtcbiAgICAgICAgdGhpcy5pbmZvRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB9XG4gICAgTGlicmFyeUluZm9EaXYucHJvdG90eXBlLnJlbmRlckludG8gPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLnRvcCA9IFwiMTBweFwiO1xuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUucmlnaHQgPSBcIjEwcHhcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLnpJbmRleCA9IFwiMlwiO1xuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUucGFkZGluZyA9IFwiNXB0XCI7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS5ib3JkZXIgPSBcIjFweCBzb2xpZCAjMTcxNzE3XCI7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS5mb250U2l6ZSA9IFwiMTBwdFwiO1xuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUuYmFja2dyb3VuZCA9IFwicmdiKDAgMCAwIC8gNjklKVwiO1xuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUuYm9yZGVyUmFkaXVzID0gXCI1cHhcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS5mb250V2VpZ2h0ID0gXCI0MDBcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLmNvbG9yID0gXCJ3aGl0ZVwiO1xuICAgICAgICB0aGlzLmluZm9EaXYuaW5uZXJUZXh0ID0gTGlicmFyeUluZm9TdHJpbmdzLnBvd2VyZWRCeSgpO1xuICAgICAgICB2YXIgcHJvamVjdExpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgcHJvamVjdExpbmsuaW5uZXJUZXh0ID0gXCJTY2FuQXBwXCI7XG4gICAgICAgIHByb2plY3RMaW5rLmhyZWYgPSBcImh0dHBzOi8vc2NhbmFwcC5vcmdcIjtcbiAgICAgICAgcHJvamVjdExpbmsudGFyZ2V0ID0gXCJuZXdcIjtcbiAgICAgICAgcHJvamVjdExpbmsuc3R5bGUuY29sb3IgPSBcIndoaXRlXCI7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5hcHBlbmRDaGlsZChwcm9qZWN0TGluayk7XG4gICAgICAgIHZhciBicmVha0VsZW1GaXJzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcbiAgICAgICAgdmFyIGJyZWFrRWxlbVNlY29uZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcbiAgICAgICAgdGhpcy5pbmZvRGl2LmFwcGVuZENoaWxkKGJyZWFrRWxlbUZpcnN0KTtcbiAgICAgICAgdGhpcy5pbmZvRGl2LmFwcGVuZENoaWxkKGJyZWFrRWxlbVNlY29uZCk7XG4gICAgICAgIHZhciByZXBvcnRJc3N1ZUxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgcmVwb3J0SXNzdWVMaW5rLmlubmVyVGV4dCA9IExpYnJhcnlJbmZvU3RyaW5ncy5yZXBvcnRJc3N1ZXMoKTtcbiAgICAgICAgcmVwb3J0SXNzdWVMaW5rLmhyZWYgPSBcImh0dHBzOi8vZ2l0aHViLmNvbS9tZWJqYXMvaHRtbDUtcXJjb2RlL2lzc3Vlc1wiO1xuICAgICAgICByZXBvcnRJc3N1ZUxpbmsudGFyZ2V0ID0gXCJuZXdcIjtcbiAgICAgICAgcmVwb3J0SXNzdWVMaW5rLnN0eWxlLmNvbG9yID0gXCJ3aGl0ZVwiO1xuICAgICAgICB0aGlzLmluZm9EaXYuYXBwZW5kQ2hpbGQocmVwb3J0SXNzdWVMaW5rKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuaW5mb0Rpdik7XG4gICAgfTtcbiAgICBMaWJyYXJ5SW5mb0Rpdi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfTtcbiAgICBMaWJyYXJ5SW5mb0Rpdi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9O1xuICAgIHJldHVybiBMaWJyYXJ5SW5mb0Rpdjtcbn0oKSk7XG52YXIgTGlicmFyeUluZm9JY29uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaWJyYXJ5SW5mb0ljb24ob25UYXBJbiwgb25UYXBPdXQpIHtcbiAgICAgICAgdGhpcy5pc1Nob3dpbmdJbmZvSWNvbiA9IHRydWU7XG4gICAgICAgIHRoaXMub25UYXBJbiA9IG9uVGFwSW47XG4gICAgICAgIHRoaXMub25UYXBPdXQgPSBvblRhcE91dDtcbiAgICAgICAgdGhpcy5pbmZvSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgfVxuICAgIExpYnJhcnlJbmZvSWNvbi5wcm90b3R5cGUucmVuZGVySW50byA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5hbHQgPSBcIkluZm8gaWNvblwiO1xuICAgICAgICB0aGlzLmluZm9JY29uLnNyYyA9IEFTU0VUX0lORk9fSUNPTl8xNlBYO1xuICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLnRvcCA9IFwiNHB4XCI7XG4gICAgICAgIHRoaXMuaW5mb0ljb24uc3R5bGUucmlnaHQgPSBcIjRweFwiO1xuICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLm9wYWNpdHkgPSBcIjAuNlwiO1xuICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xuICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLnpJbmRleCA9IFwiMlwiO1xuICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLndpZHRoID0gXCIxNnB4XCI7XG4gICAgICAgIHRoaXMuaW5mb0ljb24uc3R5bGUuaGVpZ2h0ID0gXCIxNnB4XCI7XG4gICAgICAgIHRoaXMuaW5mb0ljb24ub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gX3RoaXMub25Ib3ZlckluKCk7IH07XG4gICAgICAgIHRoaXMuaW5mb0ljb24ub25tb3VzZW91dCA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfdGhpcy5vbkhvdmVyT3V0KCk7IH07XG4gICAgICAgIHRoaXMuaW5mb0ljb24ub25jbGljayA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfdGhpcy5vbkNsaWNrKCk7IH07XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmluZm9JY29uKTtcbiAgICB9O1xuICAgIExpYnJhcnlJbmZvSWNvbi5wcm90b3R5cGUub25Ib3ZlckluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Nob3dpbmdJbmZvSWNvbikge1xuICAgICAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS5vcGFjaXR5ID0gXCIxXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpYnJhcnlJbmZvSWNvbi5wcm90b3R5cGUub25Ib3Zlck91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaG93aW5nSW5mb0ljb24pIHtcbiAgICAgICAgICAgIHRoaXMuaW5mb0ljb24uc3R5bGUub3BhY2l0eSA9IFwiMC42XCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpYnJhcnlJbmZvSWNvbi5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaG93aW5nSW5mb0ljb24pIHtcbiAgICAgICAgICAgIHRoaXMuaXNTaG93aW5nSW5mb0ljb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub25UYXBJbigpO1xuICAgICAgICAgICAgdGhpcy5pbmZvSWNvbi5zcmMgPSBBU1NFVF9DTE9TRV9JQ09OXzE2UFg7XG4gICAgICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLm9wYWNpdHkgPSBcIjFcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNTaG93aW5nSW5mb0ljb24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vblRhcE91dCgpO1xuICAgICAgICAgICAgdGhpcy5pbmZvSWNvbi5zcmMgPSBBU1NFVF9JTkZPX0lDT05fMTZQWDtcbiAgICAgICAgICAgIHRoaXMuaW5mb0ljb24uc3R5bGUub3BhY2l0eSA9IFwiMC42XCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMaWJyYXJ5SW5mb0ljb247XG59KCkpO1xudmFyIExpYnJhcnlJbmZvQ29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaWJyYXJ5SW5mb0NvbnRhaW5lcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pbmZvRGl2ID0gbmV3IExpYnJhcnlJbmZvRGl2KCk7XG4gICAgICAgIHRoaXMuaW5mb0ljb24gPSBuZXcgTGlicmFyeUluZm9JY29uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmluZm9EaXYuc2hvdygpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pbmZvRGl2LmhpZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIExpYnJhcnlJbmZvQ29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXJJbnRvID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB0aGlzLmluZm9EaXYucmVuZGVySW50byhwYXJlbnQpO1xuICAgICAgICB0aGlzLmluZm9JY29uLnJlbmRlckludG8ocGFyZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBMaWJyYXJ5SW5mb0NvbnRhaW5lcjtcbn0oKSk7XG5leHBvcnQgeyBMaWJyYXJ5SW5mb0NvbnRhaW5lciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWkuanMubWFwIl0sIm5hbWVzIjpbIkFTU0VUX0NMT1NFX0lDT05fMTZQWCIsIkFTU0VUX0lORk9fSUNPTl8xNlBYIiwiTGlicmFyeUluZm9TdHJpbmdzIiwiTGlicmFyeUluZm9EaXYiLCJpbmZvRGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwicHJvdG90eXBlIiwicmVuZGVySW50byIsInBhcmVudCIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJyaWdodCIsInpJbmRleCIsImRpc3BsYXkiLCJwYWRkaW5nIiwiYm9yZGVyIiwiZm9udFNpemUiLCJiYWNrZ3JvdW5kIiwiYm9yZGVyUmFkaXVzIiwidGV4dEFsaWduIiwiZm9udFdlaWdodCIsImNvbG9yIiwiaW5uZXJUZXh0IiwicG93ZXJlZEJ5IiwicHJvamVjdExpbmsiLCJocmVmIiwidGFyZ2V0IiwiYXBwZW5kQ2hpbGQiLCJicmVha0VsZW1GaXJzdCIsImJyZWFrRWxlbVNlY29uZCIsInJlcG9ydElzc3VlTGluayIsInJlcG9ydElzc3VlcyIsInNob3ciLCJoaWRlIiwiTGlicmFyeUluZm9JY29uIiwib25UYXBJbiIsIm9uVGFwT3V0IiwiaXNTaG93aW5nSW5mb0ljb24iLCJpbmZvSWNvbiIsIl90aGlzIiwiYWx0Iiwic3JjIiwib3BhY2l0eSIsImN1cnNvciIsIndpZHRoIiwiaGVpZ2h0Iiwib25tb3VzZW92ZXIiLCJfIiwib25Ib3ZlckluIiwib25tb3VzZW91dCIsIm9uSG92ZXJPdXQiLCJvbmNsaWNrIiwib25DbGljayIsIkxpYnJhcnlJbmZvQ29udGFpbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/ui.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui/scanner/base.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseUiElementFactory: () => (/* binding */ BaseUiElementFactory),\n/* harmony export */   PublicUiElementIdAndClasses: () => (/* binding */ PublicUiElementIdAndClasses)\n/* harmony export */ });\nvar PublicUiElementIdAndClasses = function() {\n    function PublicUiElementIdAndClasses() {}\n    PublicUiElementIdAndClasses.ALL_ELEMENT_CLASS = \"html5-qrcode-element\";\n    PublicUiElementIdAndClasses.CAMERA_PERMISSION_BUTTON_ID = \"html5-qrcode-button-camera-permission\";\n    PublicUiElementIdAndClasses.CAMERA_START_BUTTON_ID = \"html5-qrcode-button-camera-start\";\n    PublicUiElementIdAndClasses.CAMERA_STOP_BUTTON_ID = \"html5-qrcode-button-camera-stop\";\n    PublicUiElementIdAndClasses.TORCH_BUTTON_ID = \"html5-qrcode-button-torch\";\n    PublicUiElementIdAndClasses.CAMERA_SELECTION_SELECT_ID = \"html5-qrcode-select-camera\";\n    PublicUiElementIdAndClasses.FILE_SELECTION_BUTTON_ID = \"html5-qrcode-button-file-selection\";\n    PublicUiElementIdAndClasses.ZOOM_SLIDER_ID = \"html5-qrcode-input-range-zoom\";\n    PublicUiElementIdAndClasses.SCAN_TYPE_CHANGE_ANCHOR_ID = \"html5-qrcode-anchor-scan-type-change\";\n    PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON = \"html5-qrcode-button-torch-on\";\n    PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF = \"html5-qrcode-button-torch-off\";\n    return PublicUiElementIdAndClasses;\n}();\n\nvar BaseUiElementFactory = function() {\n    function BaseUiElementFactory() {}\n    BaseUiElementFactory.createElement = function(elementType, elementId) {\n        var element = document.createElement(elementType);\n        element.id = elementId;\n        element.classList.add(PublicUiElementIdAndClasses.ALL_ELEMENT_CLASS);\n        if (elementType === \"button\") {\n            element.setAttribute(\"type\", \"button\");\n        }\n        return element;\n    };\n    return BaseUiElementFactory;\n}();\n //# sourceMappingURL=base.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxJQUFJQSw4QkFBK0I7SUFDL0IsU0FBU0EsK0JBQ1Q7SUFDQUEsNEJBQTRCQyxpQkFBaUIsR0FBRztJQUNoREQsNEJBQTRCRSwyQkFBMkIsR0FBRztJQUMxREYsNEJBQTRCRyxzQkFBc0IsR0FBRztJQUNyREgsNEJBQTRCSSxxQkFBcUIsR0FBRztJQUNwREosNEJBQTRCSyxlQUFlLEdBQUc7SUFDOUNMLDRCQUE0Qk0sMEJBQTBCLEdBQUc7SUFDekROLDRCQUE0Qk8sd0JBQXdCLEdBQUc7SUFDdkRQLDRCQUE0QlEsY0FBYyxHQUFHO0lBQzdDUiw0QkFBNEJTLDBCQUEwQixHQUFHO0lBQ3pEVCw0QkFBNEJVLDJCQUEyQixHQUFHO0lBQzFEViw0QkFBNEJXLDRCQUE0QixHQUFHO0lBQzNELE9BQU9YO0FBQ1g7QUFDdUM7QUFDdkMsSUFBSVksdUJBQXdCO0lBQ3hCLFNBQVNBLHdCQUNUO0lBQ0FBLHFCQUFxQkMsYUFBYSxHQUFHLFNBQVVDLFdBQVcsRUFBRUMsU0FBUztRQUNqRSxJQUFJQyxVQUFXQyxTQUFTSixhQUFhLENBQUNDO1FBQ3RDRSxRQUFRRSxFQUFFLEdBQUdIO1FBQ2JDLFFBQVFHLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDcEIsNEJBQTRCQyxpQkFBaUI7UUFDbkUsSUFBSWEsZ0JBQWdCLFVBQVU7WUFDMUJFLFFBQVFLLFlBQVksQ0FBQyxRQUFRO1FBQ2pDO1FBQ0EsT0FBT0w7SUFDWDtJQUNBLE9BQU9KO0FBQ1g7QUFDZ0MsQ0FDaEMsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9wb3MvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL2Jhc2UuanM/MWJiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMoKSB7XG4gICAgfVxuICAgIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5BTExfRUxFTUVOVF9DTEFTUyA9IFwiaHRtbDUtcXJjb2RlLWVsZW1lbnRcIjtcbiAgICBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuQ0FNRVJBX1BFUk1JU1NJT05fQlVUVE9OX0lEID0gXCJodG1sNS1xcmNvZGUtYnV0dG9uLWNhbWVyYS1wZXJtaXNzaW9uXCI7XG4gICAgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLkNBTUVSQV9TVEFSVF9CVVRUT05fSUQgPSBcImh0bWw1LXFyY29kZS1idXR0b24tY2FtZXJhLXN0YXJ0XCI7XG4gICAgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLkNBTUVSQV9TVE9QX0JVVFRPTl9JRCA9IFwiaHRtbDUtcXJjb2RlLWJ1dHRvbi1jYW1lcmEtc3RvcFwiO1xuICAgIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5UT1JDSF9CVVRUT05fSUQgPSBcImh0bWw1LXFyY29kZS1idXR0b24tdG9yY2hcIjtcbiAgICBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuQ0FNRVJBX1NFTEVDVElPTl9TRUxFQ1RfSUQgPSBcImh0bWw1LXFyY29kZS1zZWxlY3QtY2FtZXJhXCI7XG4gICAgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLkZJTEVfU0VMRUNUSU9OX0JVVFRPTl9JRCA9IFwiaHRtbDUtcXJjb2RlLWJ1dHRvbi1maWxlLXNlbGVjdGlvblwiO1xuICAgIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5aT09NX1NMSURFUl9JRCA9IFwiaHRtbDUtcXJjb2RlLWlucHV0LXJhbmdlLXpvb21cIjtcbiAgICBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuU0NBTl9UWVBFX0NIQU5HRV9BTkNIT1JfSUQgPSBcImh0bWw1LXFyY29kZS1hbmNob3Itc2Nhbi10eXBlLWNoYW5nZVwiO1xuICAgIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5UT1JDSF9CVVRUT05fQ0xBU1NfVE9SQ0hfT04gPSBcImh0bWw1LXFyY29kZS1idXR0b24tdG9yY2gtb25cIjtcbiAgICBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuVE9SQ0hfQlVUVE9OX0NMQVNTX1RPUkNIX09GRiA9IFwiaHRtbDUtcXJjb2RlLWJ1dHRvbi10b3JjaC1vZmZcIjtcbiAgICByZXR1cm4gUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzO1xufSgpKTtcbmV4cG9ydCB7IFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3NlcyB9O1xudmFyIEJhc2VVaUVsZW1lbnRGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlVWlFbGVtZW50RmFjdG9yeSgpIHtcbiAgICB9XG4gICAgQmFzZVVpRWxlbWVudEZhY3RvcnkuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgZWxlbWVudElkKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUpKTtcbiAgICAgICAgZWxlbWVudC5pZCA9IGVsZW1lbnRJZDtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5BTExfRUxFTUVOVF9DTEFTUyk7XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gXCJidXR0b25cIikge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiYnV0dG9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VVaUVsZW1lbnRGYWN0b3J5O1xufSgpKTtcbmV4cG9ydCB7IEJhc2VVaUVsZW1lbnRGYWN0b3J5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcCJdLCJuYW1lcyI6WyJQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMiLCJBTExfRUxFTUVOVF9DTEFTUyIsIkNBTUVSQV9QRVJNSVNTSU9OX0JVVFRPTl9JRCIsIkNBTUVSQV9TVEFSVF9CVVRUT05fSUQiLCJDQU1FUkFfU1RPUF9CVVRUT05fSUQiLCJUT1JDSF9CVVRUT05fSUQiLCJDQU1FUkFfU0VMRUNUSU9OX1NFTEVDVF9JRCIsIkZJTEVfU0VMRUNUSU9OX0JVVFRPTl9JRCIsIlpPT01fU0xJREVSX0lEIiwiU0NBTl9UWVBFX0NIQU5HRV9BTkNIT1JfSUQiLCJUT1JDSF9CVVRUT05fQ0xBU1NfVE9SQ0hfT04iLCJUT1JDSF9CVVRUT05fQ0xBU1NfVE9SQ0hfT0ZGIiwiQmFzZVVpRWxlbWVudEZhY3RvcnkiLCJjcmVhdGVFbGVtZW50IiwiZWxlbWVudFR5cGUiLCJlbGVtZW50SWQiLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJpZCIsImNsYXNzTGlzdCIsImFkZCIsInNldEF0dHJpYnV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js":
/*!*************************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraSelectionUi: () => (/* binding */ CameraSelectionUi)\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/base.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../strings */ \"(ssr)/./node_modules/html5-qrcode/esm/strings.js\");\n\n\nvar CameraSelectionUi = function() {\n    function CameraSelectionUi(cameras) {\n        this.selectElement = _base__WEBPACK_IMPORTED_MODULE_0__.BaseUiElementFactory.createElement(\"select\", _base__WEBPACK_IMPORTED_MODULE_0__.PublicUiElementIdAndClasses.CAMERA_SELECTION_SELECT_ID);\n        this.cameras = cameras;\n        this.options = [];\n    }\n    CameraSelectionUi.prototype.render = function(parentElement) {\n        var cameraSelectionContainer = document.createElement(\"span\");\n        cameraSelectionContainer.style.marginRight = \"10px\";\n        var numCameras = this.cameras.length;\n        if (numCameras === 0) {\n            throw new Error(\"No cameras found\");\n        }\n        if (numCameras === 1) {\n            cameraSelectionContainer.style.display = \"none\";\n        } else {\n            var selectCameraString = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScannerStrings.selectCamera();\n            cameraSelectionContainer.innerText = \"\".concat(selectCameraString, \" (\").concat(this.cameras.length, \")  \");\n        }\n        var anonymousCameraId = 1;\n        for(var _i = 0, _a = this.cameras; _i < _a.length; _i++){\n            var camera = _a[_i];\n            var value = camera.id;\n            var name_1 = camera.label == null ? value : camera.label;\n            if (!name_1 || name_1 === \"\") {\n                name_1 = [\n                    _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScannerStrings.anonymousCameraPrefix(),\n                    anonymousCameraId++\n                ].join(\" \");\n            }\n            var option = document.createElement(\"option\");\n            option.value = value;\n            option.innerText = name_1;\n            this.options.push(option);\n            this.selectElement.appendChild(option);\n        }\n        cameraSelectionContainer.appendChild(this.selectElement);\n        parentElement.appendChild(cameraSelectionContainer);\n    };\n    CameraSelectionUi.prototype.disable = function() {\n        this.selectElement.disabled = true;\n    };\n    CameraSelectionUi.prototype.isDisabled = function() {\n        return this.selectElement.disabled === true;\n    };\n    CameraSelectionUi.prototype.enable = function() {\n        this.selectElement.disabled = false;\n    };\n    CameraSelectionUi.prototype.getValue = function() {\n        return this.selectElement.value;\n    };\n    CameraSelectionUi.prototype.hasValue = function(value) {\n        for(var _i = 0, _a = this.options; _i < _a.length; _i++){\n            var option = _a[_i];\n            if (option.value === value) {\n                return true;\n            }\n        }\n        return false;\n    };\n    CameraSelectionUi.prototype.setValue = function(value) {\n        if (!this.hasValue(value)) {\n            throw new Error(\"\".concat(value, \" is not present in the camera list.\"));\n        }\n        this.selectElement.value = value;\n    };\n    CameraSelectionUi.prototype.hasSingleItem = function() {\n        return this.cameras.length === 1;\n    };\n    CameraSelectionUi.prototype.numCameras = function() {\n        return this.cameras.length;\n    };\n    CameraSelectionUi.create = function(parentElement, cameras) {\n        var cameraSelectUi = new CameraSelectionUi(cameras);\n        cameraSelectUi.render(parentElement);\n        return cameraSelectUi;\n    };\n    return CameraSelectionUi;\n}();\n //# sourceMappingURL=camera-selection-ui.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL2NhbWVyYS1zZWxlY3Rpb24tdWkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJFO0FBQ2pCO0FBQzFELElBQUlHLG9CQUFxQjtJQUNyQixTQUFTQSxrQkFBa0JDLE9BQU87UUFDOUIsSUFBSSxDQUFDQyxhQUFhLEdBQUdMLHVEQUFvQkEsQ0FDcENNLGFBQWEsQ0FBQyxVQUFVTCw4REFBMkJBLENBQUNNLDBCQUEwQjtRQUNuRixJQUFJLENBQUNILE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNJLE9BQU8sR0FBRyxFQUFFO0lBQ3JCO0lBQ0FMLGtCQUFrQk0sU0FBUyxDQUFDQyxNQUFNLEdBQUcsU0FBVUMsYUFBYTtRQUN4RCxJQUFJQywyQkFBMkJDLFNBQVNQLGFBQWEsQ0FBQztRQUN0RE0seUJBQXlCRSxLQUFLLENBQUNDLFdBQVcsR0FBRztRQUM3QyxJQUFJQyxhQUFhLElBQUksQ0FBQ1osT0FBTyxDQUFDYSxNQUFNO1FBQ3BDLElBQUlELGVBQWUsR0FBRztZQUNsQixNQUFNLElBQUlFLE1BQU07UUFDcEI7UUFDQSxJQUFJRixlQUFlLEdBQUc7WUFDbEJKLHlCQUF5QkUsS0FBSyxDQUFDSyxPQUFPLEdBQUc7UUFDN0MsT0FDSztZQUNELElBQUlDLHFCQUFxQmxCLCtEQUF5QkEsQ0FBQ21CLFlBQVk7WUFDL0RULHlCQUF5QlUsU0FBUyxHQUM1QixHQUFHQyxNQUFNLENBQUNILG9CQUFvQixNQUFNRyxNQUFNLENBQUMsSUFBSSxDQUFDbkIsT0FBTyxDQUFDYSxNQUFNLEVBQUU7UUFDMUU7UUFDQSxJQUFJTyxvQkFBb0I7UUFDeEIsSUFBSyxJQUFJQyxLQUFLLEdBQUdDLEtBQUssSUFBSSxDQUFDdEIsT0FBTyxFQUFFcUIsS0FBS0MsR0FBR1QsTUFBTSxFQUFFUSxLQUFNO1lBQ3RELElBQUlFLFNBQVNELEVBQUUsQ0FBQ0QsR0FBRztZQUNuQixJQUFJRyxRQUFRRCxPQUFPRSxFQUFFO1lBQ3JCLElBQUlDLFNBQVNILE9BQU9JLEtBQUssSUFBSSxPQUFPSCxRQUFRRCxPQUFPSSxLQUFLO1lBQ3hELElBQUksQ0FBQ0QsVUFBVUEsV0FBVyxJQUFJO2dCQUMxQkEsU0FBUztvQkFDTDVCLCtEQUF5QkEsQ0FBQzhCLHFCQUFxQjtvQkFDL0NSO2lCQUNILENBQUNTLElBQUksQ0FBQztZQUNYO1lBQ0EsSUFBSUMsU0FBU3JCLFNBQVNQLGFBQWEsQ0FBQztZQUNwQzRCLE9BQU9OLEtBQUssR0FBR0E7WUFDZk0sT0FBT1osU0FBUyxHQUFHUTtZQUNuQixJQUFJLENBQUN0QixPQUFPLENBQUMyQixJQUFJLENBQUNEO1lBQ2xCLElBQUksQ0FBQzdCLGFBQWEsQ0FBQytCLFdBQVcsQ0FBQ0Y7UUFDbkM7UUFDQXRCLHlCQUF5QndCLFdBQVcsQ0FBQyxJQUFJLENBQUMvQixhQUFhO1FBQ3ZETSxjQUFjeUIsV0FBVyxDQUFDeEI7SUFDOUI7SUFDQVQsa0JBQWtCTSxTQUFTLENBQUM0QixPQUFPLEdBQUc7UUFDbEMsSUFBSSxDQUFDaEMsYUFBYSxDQUFDaUMsUUFBUSxHQUFHO0lBQ2xDO0lBQ0FuQyxrQkFBa0JNLFNBQVMsQ0FBQzhCLFVBQVUsR0FBRztRQUNyQyxPQUFPLElBQUksQ0FBQ2xDLGFBQWEsQ0FBQ2lDLFFBQVEsS0FBSztJQUMzQztJQUNBbkMsa0JBQWtCTSxTQUFTLENBQUMrQixNQUFNLEdBQUc7UUFDakMsSUFBSSxDQUFDbkMsYUFBYSxDQUFDaUMsUUFBUSxHQUFHO0lBQ2xDO0lBQ0FuQyxrQkFBa0JNLFNBQVMsQ0FBQ2dDLFFBQVEsR0FBRztRQUNuQyxPQUFPLElBQUksQ0FBQ3BDLGFBQWEsQ0FBQ3VCLEtBQUs7SUFDbkM7SUFDQXpCLGtCQUFrQk0sU0FBUyxDQUFDaUMsUUFBUSxHQUFHLFNBQVVkLEtBQUs7UUFDbEQsSUFBSyxJQUFJSCxLQUFLLEdBQUdDLEtBQUssSUFBSSxDQUFDbEIsT0FBTyxFQUFFaUIsS0FBS0MsR0FBR1QsTUFBTSxFQUFFUSxLQUFNO1lBQ3RELElBQUlTLFNBQVNSLEVBQUUsQ0FBQ0QsR0FBRztZQUNuQixJQUFJUyxPQUFPTixLQUFLLEtBQUtBLE9BQU87Z0JBQ3hCLE9BQU87WUFDWDtRQUNKO1FBQ0EsT0FBTztJQUNYO0lBQ0F6QixrQkFBa0JNLFNBQVMsQ0FBQ2tDLFFBQVEsR0FBRyxTQUFVZixLQUFLO1FBQ2xELElBQUksQ0FBQyxJQUFJLENBQUNjLFFBQVEsQ0FBQ2QsUUFBUTtZQUN2QixNQUFNLElBQUlWLE1BQU0sR0FBR0ssTUFBTSxDQUFDSyxPQUFPO1FBQ3JDO1FBQ0EsSUFBSSxDQUFDdkIsYUFBYSxDQUFDdUIsS0FBSyxHQUFHQTtJQUMvQjtJQUNBekIsa0JBQWtCTSxTQUFTLENBQUNtQyxhQUFhLEdBQUc7UUFDeEMsT0FBTyxJQUFJLENBQUN4QyxPQUFPLENBQUNhLE1BQU0sS0FBSztJQUNuQztJQUNBZCxrQkFBa0JNLFNBQVMsQ0FBQ08sVUFBVSxHQUFHO1FBQ3JDLE9BQU8sSUFBSSxDQUFDWixPQUFPLENBQUNhLE1BQU07SUFDOUI7SUFDQWQsa0JBQWtCMEMsTUFBTSxHQUFHLFNBQVVsQyxhQUFhLEVBQUVQLE9BQU87UUFDdkQsSUFBSTBDLGlCQUFpQixJQUFJM0Msa0JBQWtCQztRQUMzQzBDLGVBQWVwQyxNQUFNLENBQUNDO1FBQ3RCLE9BQU9tQztJQUNYO0lBQ0EsT0FBTzNDO0FBQ1g7QUFDNkIsQ0FDN0IsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9wb3MvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL2NhbWVyYS1zZWxlY3Rpb24tdWkuanM/NjQyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlVWlFbGVtZW50RmFjdG9yeSwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzIH0gZnJvbSBcIi4vYmFzZVwiO1xuaW1wb3J0IHsgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncyB9IGZyb20gXCIuLi8uLi9zdHJpbmdzXCI7XG52YXIgQ2FtZXJhU2VsZWN0aW9uVWkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbWVyYVNlbGVjdGlvblVpKGNhbWVyYXMpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RFbGVtZW50ID0gQmFzZVVpRWxlbWVudEZhY3RvcnlcbiAgICAgICAgICAgIC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5DQU1FUkFfU0VMRUNUSU9OX1NFTEVDVF9JRCk7XG4gICAgICAgIHRoaXMuY2FtZXJhcyA9IGNhbWVyYXM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBDYW1lcmFTZWxlY3Rpb25VaS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNhbWVyYVNlbGVjdGlvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBjYW1lcmFTZWxlY3Rpb25Db250YWluZXIuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjEwcHhcIjtcbiAgICAgICAgdmFyIG51bUNhbWVyYXMgPSB0aGlzLmNhbWVyYXMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtQ2FtZXJhcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2FtZXJhcyBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtQ2FtZXJhcyA9PT0gMSkge1xuICAgICAgICAgICAgY2FtZXJhU2VsZWN0aW9uQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RDYW1lcmFTdHJpbmcgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnNlbGVjdENhbWVyYSgpO1xuICAgICAgICAgICAgY2FtZXJhU2VsZWN0aW9uQ29udGFpbmVyLmlubmVyVGV4dFxuICAgICAgICAgICAgICAgID0gXCJcIi5jb25jYXQoc2VsZWN0Q2FtZXJhU3RyaW5nLCBcIiAoXCIpLmNvbmNhdCh0aGlzLmNhbWVyYXMubGVuZ3RoLCBcIikgIFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5vbnltb3VzQ2FtZXJhSWQgPSAxO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jYW1lcmFzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNhbWVyYSA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNhbWVyYS5pZDtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBjYW1lcmEubGFiZWwgPT0gbnVsbCA/IHZhbHVlIDogY2FtZXJhLmxhYmVsO1xuICAgICAgICAgICAgaWYgKCFuYW1lXzEgfHwgbmFtZV8xID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgbmFtZV8xID0gW1xuICAgICAgICAgICAgICAgICAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmFub255bW91c0NhbWVyYVByZWZpeCgpLFxuICAgICAgICAgICAgICAgICAgICBhbm9ueW1vdXNDYW1lcmFJZCsrXG4gICAgICAgICAgICAgICAgXS5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgb3B0aW9uLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBvcHRpb24uaW5uZXJUZXh0ID0gbmFtZV8xO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnB1c2gob3B0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0RWxlbWVudC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhbWVyYVNlbGVjdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdEVsZW1lbnQpO1xuICAgICAgICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGNhbWVyYVNlbGVjdGlvbkNvbnRhaW5lcik7XG4gICAgfTtcbiAgICBDYW1lcmFTZWxlY3Rpb25VaS5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RFbGVtZW50LmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIENhbWVyYVNlbGVjdGlvblVpLnByb3RvdHlwZS5pc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RFbGVtZW50LmRpc2FibGVkID09PSB0cnVlO1xuICAgIH07XG4gICAgQ2FtZXJhU2VsZWN0aW9uVWkucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RFbGVtZW50LmRpc2FibGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICBDYW1lcmFTZWxlY3Rpb25VaS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdEVsZW1lbnQudmFsdWU7XG4gICAgfTtcbiAgICBDYW1lcmFTZWxlY3Rpb25VaS5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMub3B0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAob3B0aW9uLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIENhbWVyYVNlbGVjdGlvblVpLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQodmFsdWUsIFwiIGlzIG5vdCBwcmVzZW50IGluIHRoZSBjYW1lcmEgbGlzdC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0RWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG4gICAgQ2FtZXJhU2VsZWN0aW9uVWkucHJvdG90eXBlLmhhc1NpbmdsZUl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbWVyYXMubGVuZ3RoID09PSAxO1xuICAgIH07XG4gICAgQ2FtZXJhU2VsZWN0aW9uVWkucHJvdG90eXBlLm51bUNhbWVyYXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbWVyYXMubGVuZ3RoO1xuICAgIH07XG4gICAgQ2FtZXJhU2VsZWN0aW9uVWkuY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIGNhbWVyYXMpIHtcbiAgICAgICAgdmFyIGNhbWVyYVNlbGVjdFVpID0gbmV3IENhbWVyYVNlbGVjdGlvblVpKGNhbWVyYXMpO1xuICAgICAgICBjYW1lcmFTZWxlY3RVaS5yZW5kZXIocGFyZW50RWxlbWVudCk7XG4gICAgICAgIHJldHVybiBjYW1lcmFTZWxlY3RVaTtcbiAgICB9O1xuICAgIHJldHVybiBDYW1lcmFTZWxlY3Rpb25VaTtcbn0oKSk7XG5leHBvcnQgeyBDYW1lcmFTZWxlY3Rpb25VaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FtZXJhLXNlbGVjdGlvbi11aS5qcy5tYXAiXSwibmFtZXMiOlsiQmFzZVVpRWxlbWVudEZhY3RvcnkiLCJQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMiLCJIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzIiwiQ2FtZXJhU2VsZWN0aW9uVWkiLCJjYW1lcmFzIiwic2VsZWN0RWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJDQU1FUkFfU0VMRUNUSU9OX1NFTEVDVF9JRCIsIm9wdGlvbnMiLCJwcm90b3R5cGUiLCJyZW5kZXIiLCJwYXJlbnRFbGVtZW50IiwiY2FtZXJhU2VsZWN0aW9uQ29udGFpbmVyIiwiZG9jdW1lbnQiLCJzdHlsZSIsIm1hcmdpblJpZ2h0IiwibnVtQ2FtZXJhcyIsImxlbmd0aCIsIkVycm9yIiwiZGlzcGxheSIsInNlbGVjdENhbWVyYVN0cmluZyIsInNlbGVjdENhbWVyYSIsImlubmVyVGV4dCIsImNvbmNhdCIsImFub255bW91c0NhbWVyYUlkIiwiX2kiLCJfYSIsImNhbWVyYSIsInZhbHVlIiwiaWQiLCJuYW1lXzEiLCJsYWJlbCIsImFub255bW91c0NhbWVyYVByZWZpeCIsImpvaW4iLCJvcHRpb24iLCJwdXNoIiwiYXBwZW5kQ2hpbGQiLCJkaXNhYmxlIiwiZGlzYWJsZWQiLCJpc0Rpc2FibGVkIiwiZW5hYmxlIiwiZ2V0VmFsdWUiLCJoYXNWYWx1ZSIsInNldFZhbHVlIiwiaGFzU2luZ2xlSXRlbSIsImNyZWF0ZSIsImNhbWVyYVNlbGVjdFVpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js":
/*!********************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraZoomUi: () => (/* binding */ CameraZoomUi)\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/base.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../strings */ \"(ssr)/./node_modules/html5-qrcode/esm/strings.js\");\n\n\nvar CameraZoomUi = function() {\n    function CameraZoomUi() {\n        this.onChangeCallback = null;\n        this.zoomElementContainer = document.createElement(\"div\");\n        this.rangeInput = _base__WEBPACK_IMPORTED_MODULE_0__.BaseUiElementFactory.createElement(\"input\", _base__WEBPACK_IMPORTED_MODULE_0__.PublicUiElementIdAndClasses.ZOOM_SLIDER_ID);\n        this.rangeInput.type = \"range\";\n        this.rangeText = document.createElement(\"span\");\n        this.rangeInput.min = \"1\";\n        this.rangeInput.max = \"5\";\n        this.rangeInput.value = \"1\";\n        this.rangeInput.step = \"0.1\";\n    }\n    CameraZoomUi.prototype.render = function(parentElement, renderOnCreate) {\n        this.zoomElementContainer.style.display = renderOnCreate ? \"block\" : \"none\";\n        this.zoomElementContainer.style.padding = \"5px 10px\";\n        this.zoomElementContainer.style.textAlign = \"center\";\n        parentElement.appendChild(this.zoomElementContainer);\n        this.rangeInput.style.display = \"inline-block\";\n        this.rangeInput.style.width = \"50%\";\n        this.rangeInput.style.height = \"5px\";\n        this.rangeInput.style.background = \"#d3d3d3\";\n        this.rangeInput.style.outline = \"none\";\n        this.rangeInput.style.opacity = \"0.7\";\n        var zoomString = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScannerStrings.zoom();\n        this.rangeText.innerText = \"\".concat(this.rangeInput.value, \"x \").concat(zoomString);\n        this.rangeText.style.marginRight = \"10px\";\n        var $this = this;\n        this.rangeInput.addEventListener(\"input\", function() {\n            return $this.onValueChange();\n        });\n        this.rangeInput.addEventListener(\"change\", function() {\n            return $this.onValueChange();\n        });\n        this.zoomElementContainer.appendChild(this.rangeInput);\n        this.zoomElementContainer.appendChild(this.rangeText);\n    };\n    CameraZoomUi.prototype.onValueChange = function() {\n        var zoomString = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScannerStrings.zoom();\n        this.rangeText.innerText = \"\".concat(this.rangeInput.value, \"x \").concat(zoomString);\n        if (this.onChangeCallback) {\n            this.onChangeCallback(parseFloat(this.rangeInput.value));\n        }\n    };\n    CameraZoomUi.prototype.setValues = function(minValue, maxValue, defaultValue, step) {\n        this.rangeInput.min = minValue.toString();\n        this.rangeInput.max = maxValue.toString();\n        this.rangeInput.step = step.toString();\n        this.rangeInput.value = defaultValue.toString();\n        this.onValueChange();\n    };\n    CameraZoomUi.prototype.show = function() {\n        this.zoomElementContainer.style.display = \"block\";\n    };\n    CameraZoomUi.prototype.hide = function() {\n        this.zoomElementContainer.style.display = \"none\";\n    };\n    CameraZoomUi.prototype.setOnCameraZoomValueChangeCallback = function(onChangeCallback) {\n        this.onChangeCallback = onChangeCallback;\n    };\n    CameraZoomUi.prototype.removeOnCameraZoomValueChangeCallback = function() {\n        this.onChangeCallback = null;\n    };\n    CameraZoomUi.create = function(parentElement, renderOnCreate) {\n        var cameraZoomUi = new CameraZoomUi();\n        cameraZoomUi.render(parentElement, renderOnCreate);\n        return cameraZoomUi;\n    };\n    return CameraZoomUi;\n}();\n //# sourceMappingURL=camera-zoom-ui.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL2NhbWVyYS16b29tLXVpLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyRTtBQUNqQjtBQUMxRCxJQUFJRyxlQUFnQjtJQUNoQixTQUFTQTtRQUNMLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxvQkFBb0IsR0FBR0MsU0FBU0MsYUFBYSxDQUFDO1FBQ25ELElBQUksQ0FBQ0MsVUFBVSxHQUFHUix1REFBb0JBLENBQUNPLGFBQWEsQ0FBQyxTQUFTTiw4REFBMkJBLENBQUNRLGNBQWM7UUFDeEcsSUFBSSxDQUFDRCxVQUFVLENBQUNFLElBQUksR0FBRztRQUN2QixJQUFJLENBQUNDLFNBQVMsR0FBR0wsU0FBU0MsYUFBYSxDQUFDO1FBQ3hDLElBQUksQ0FBQ0MsVUFBVSxDQUFDSSxHQUFHLEdBQUc7UUFDdEIsSUFBSSxDQUFDSixVQUFVLENBQUNLLEdBQUcsR0FBRztRQUN0QixJQUFJLENBQUNMLFVBQVUsQ0FBQ00sS0FBSyxHQUFHO1FBQ3hCLElBQUksQ0FBQ04sVUFBVSxDQUFDTyxJQUFJLEdBQUc7SUFDM0I7SUFDQVosYUFBYWEsU0FBUyxDQUFDQyxNQUFNLEdBQUcsU0FBVUMsYUFBYSxFQUFFQyxjQUFjO1FBQ25FLElBQUksQ0FBQ2Qsb0JBQW9CLENBQUNlLEtBQUssQ0FBQ0MsT0FBTyxHQUNqQ0YsaUJBQWlCLFVBQVU7UUFDakMsSUFBSSxDQUFDZCxvQkFBb0IsQ0FBQ2UsS0FBSyxDQUFDRSxPQUFPLEdBQUc7UUFDMUMsSUFBSSxDQUFDakIsb0JBQW9CLENBQUNlLEtBQUssQ0FBQ0csU0FBUyxHQUFHO1FBQzVDTCxjQUFjTSxXQUFXLENBQUMsSUFBSSxDQUFDbkIsb0JBQW9CO1FBQ25ELElBQUksQ0FBQ0csVUFBVSxDQUFDWSxLQUFLLENBQUNDLE9BQU8sR0FBRztRQUNoQyxJQUFJLENBQUNiLFVBQVUsQ0FBQ1ksS0FBSyxDQUFDSyxLQUFLLEdB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b3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb3Bvcy8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3VpL3NjYW5uZXIvY2FtZXJhLXpvb20tdWkuanM/NzE0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlVWlFbGVtZW50RmFjdG9yeSwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzIH0gZnJvbSBcIi4vYmFzZVwiO1xuaW1wb3J0IHsgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncyB9IGZyb20gXCIuLi8uLi9zdHJpbmdzXCI7XG52YXIgQ2FtZXJhWm9vbVVpID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW1lcmFab29tVWkoKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuem9vbUVsZW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnJhbmdlSW5wdXQgPSBCYXNlVWlFbGVtZW50RmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLlpPT01fU0xJREVSX0lEKTtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnR5cGUgPSBcInJhbmdlXCI7XG4gICAgICAgIHRoaXMucmFuZ2VUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5taW4gPSBcIjFcIjtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0Lm1heCA9IFwiNVwiO1xuICAgICAgICB0aGlzLnJhbmdlSW5wdXQudmFsdWUgPSBcIjFcIjtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnN0ZXAgPSBcIjAuMVwiO1xuICAgIH1cbiAgICBDYW1lcmFab29tVWkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCByZW5kZXJPbkNyZWF0ZSkge1xuICAgICAgICB0aGlzLnpvb21FbGVtZW50Q29udGFpbmVyLnN0eWxlLmRpc3BsYXlcbiAgICAgICAgICAgID0gcmVuZGVyT25DcmVhdGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy56b29tRWxlbWVudENvbnRhaW5lci5zdHlsZS5wYWRkaW5nID0gXCI1cHggMTBweFwiO1xuICAgICAgICB0aGlzLnpvb21FbGVtZW50Q29udGFpbmVyLnN0eWxlLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy56b29tRWxlbWVudENvbnRhaW5lcik7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnN0eWxlLndpZHRoID0gXCI1MCVcIjtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnN0eWxlLmhlaWdodCA9IFwiNXB4XCI7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5zdHlsZS5iYWNrZ3JvdW5kID0gXCIjZDNkM2QzXCI7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5zdHlsZS5vdXRsaW5lID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5zdHlsZS5vcGFjaXR5ID0gXCIwLjdcIjtcbiAgICAgICAgdmFyIHpvb21TdHJpbmcgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnpvb20oKTtcbiAgICAgICAgdGhpcy5yYW5nZVRleHQuaW5uZXJUZXh0ID0gXCJcIi5jb25jYXQodGhpcy5yYW5nZUlucHV0LnZhbHVlLCBcInggXCIpLmNvbmNhdCh6b29tU3RyaW5nKTtcbiAgICAgICAgdGhpcy5yYW5nZVRleHQuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjEwcHhcIjtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiAkdGhpcy5vblZhbHVlQ2hhbmdlKCk7IH0pO1xuICAgICAgICB0aGlzLnJhbmdlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiAkdGhpcy5vblZhbHVlQ2hhbmdlKCk7IH0pO1xuICAgICAgICB0aGlzLnpvb21FbGVtZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucmFuZ2VJbnB1dCk7XG4gICAgICAgIHRoaXMuem9vbUVsZW1lbnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5yYW5nZVRleHQpO1xuICAgIH07XG4gICAgQ2FtZXJhWm9vbVVpLnByb3RvdHlwZS5vblZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgem9vbVN0cmluZyA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Muem9vbSgpO1xuICAgICAgICB0aGlzLnJhbmdlVGV4dC5pbm5lclRleHQgPSBcIlwiLmNvbmNhdCh0aGlzLnJhbmdlSW5wdXQudmFsdWUsIFwieCBcIikuY29uY2F0KHpvb21TdHJpbmcpO1xuICAgICAgICBpZiAodGhpcy5vbkNoYW5nZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2socGFyc2VGbG9hdCh0aGlzLnJhbmdlSW5wdXQudmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FtZXJhWm9vbVVpLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAobWluVmFsdWUsIG1heFZhbHVlLCBkZWZhdWx0VmFsdWUsIHN0ZXApIHtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0Lm1pbiA9IG1pblZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5tYXggPSBtYXhWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLnJhbmdlSW5wdXQuc3RlcCA9IHN0ZXAudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnZhbHVlID0gZGVmYXVsdFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMub25WYWx1ZUNoYW5nZSgpO1xuICAgIH07XG4gICAgQ2FtZXJhWm9vbVVpLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnpvb21FbGVtZW50Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfTtcbiAgICBDYW1lcmFab29tVWkucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuem9vbUVsZW1lbnRDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH07XG4gICAgQ2FtZXJhWm9vbVVpLnByb3RvdHlwZS5zZXRPbkNhbWVyYVpvb21WYWx1ZUNoYW5nZUNhbGxiYWNrID0gZnVuY3Rpb24gKG9uQ2hhbmdlQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gb25DaGFuZ2VDYWxsYmFjaztcbiAgICB9O1xuICAgIENhbWVyYVpvb21VaS5wcm90b3R5cGUucmVtb3ZlT25DYW1lcmFab29tVmFsdWVDaGFuZ2VDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gbnVsbDtcbiAgICB9O1xuICAgIENhbWVyYVpvb21VaS5jcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgcmVuZGVyT25DcmVhdGUpIHtcbiAgICAgICAgdmFyIGNhbWVyYVpvb21VaSA9IG5ldyBDYW1lcmFab29tVWkoKTtcbiAgICAgICAgY2FtZXJhWm9vbVVpLnJlbmRlcihwYXJlbnRFbGVtZW50LCByZW5kZXJPbkNyZWF0ZSk7XG4gICAgICAgIHJldHVybiBjYW1lcmFab29tVWk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FtZXJhWm9vbVVpO1xufSgpKTtcbmV4cG9ydCB7IENhbWVyYVpvb21VaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FtZXJhLXpvb20tdWkuanMubWFwIl0sIm5hbWVzIjpbIkJhc2VVaUVsZW1lbnRGYWN0b3J5IiwiUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzIiwiSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncyIsIkNhbWVyYVpvb21VaSIsIm9uQ2hhbmdlQ2FsbGJhY2siLCJ6b29tRWxlbWVudENvbnRhaW5lciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInJhbmdlSW5wdXQiLCJaT09NX1NMSURFUl9JRCIsInR5cGUiLCJyYW5nZVRleHQiLCJtaW4iLCJtYXgiLCJ2YWx1ZSIsInN0ZXAiLCJwcm90b3R5cGUiLCJyZW5kZXIiLCJwYXJlbnRFbGVtZW50IiwicmVuZGVyT25DcmVhdGUiLCJzdHlsZSIsImRpc3BsYXkiLCJwYWRkaW5nIiwidGV4dEFsaWduIiwiYXBwZW5kQ2hpbGQiLCJ3aWR0aCIsImhlaWdodCIsImJhY2tncm91bmQiLCJvdXRsaW5lIiwib3BhY2l0eSIsInpvb21TdHJpbmciLCJ6b29tIiwiaW5uZXJUZXh0IiwiY29uY2F0IiwibWFyZ2luUmlnaHQiLCIkdGhpcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblZhbHVlQ2hhbmdlIiwicGFyc2VGbG9hdCIsInNldFZhbHVlcyIsIm1pblZhbHVlIiwibWF4VmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJ0b1N0cmluZyIsInNob3ciLCJoaWRlIiwic2V0T25DYW1lcmFab29tVmFsdWVDaGFuZ2VDYWxsYmFjayIsInJlbW92ZU9uQ2FtZXJhWm9vbVZhbHVlQ2hhbmdlQ2FsbGJhY2siLCJjcmVhdGUiLCJjYW1lcmFab29tVWkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js":
/*!***********************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileSelectionUi: () => (/* binding */ FileSelectionUi)\n/* harmony export */ });\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../strings */ \"(ssr)/./node_modules/html5-qrcode/esm/strings.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/base.js\");\n\n\nvar FileSelectionUi = function() {\n    function FileSelectionUi(parentElement, showOnRender, onFileSelected) {\n        this.fileBasedScanRegion = this.createFileBasedScanRegion();\n        this.fileBasedScanRegion.style.display = showOnRender ? \"block\" : \"none\";\n        parentElement.appendChild(this.fileBasedScanRegion);\n        var fileScanLabel = document.createElement(\"label\");\n        fileScanLabel.setAttribute(\"for\", this.getFileScanInputId());\n        fileScanLabel.style.display = \"inline-block\";\n        this.fileBasedScanRegion.appendChild(fileScanLabel);\n        this.fileSelectionButton = _base__WEBPACK_IMPORTED_MODULE_1__.BaseUiElementFactory.createElement(\"button\", _base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.FILE_SELECTION_BUTTON_ID);\n        this.setInitialValueToButton();\n        this.fileSelectionButton.addEventListener(\"click\", function(_) {\n            fileScanLabel.click();\n        });\n        fileScanLabel.append(this.fileSelectionButton);\n        this.fileScanInput = _base__WEBPACK_IMPORTED_MODULE_1__.BaseUiElementFactory.createElement(\"input\", this.getFileScanInputId());\n        this.fileScanInput.type = \"file\";\n        this.fileScanInput.accept = \"image/*\";\n        this.fileScanInput.style.display = \"none\";\n        fileScanLabel.appendChild(this.fileScanInput);\n        var $this = this;\n        this.fileScanInput.addEventListener(\"change\", function(e) {\n            if (e == null || e.target == null) {\n                return;\n            }\n            var target = e.target;\n            if (target.files && target.files.length === 0) {\n                return;\n            }\n            var fileList = target.files;\n            var file = fileList[0];\n            var fileName = file.name;\n            $this.setImageNameToButton(fileName);\n            onFileSelected(file);\n        });\n        var dragAndDropMessage = this.createDragAndDropMessage();\n        this.fileBasedScanRegion.appendChild(dragAndDropMessage);\n        this.fileBasedScanRegion.addEventListener(\"dragenter\", function(event) {\n            $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionActiveBorder();\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.fileBasedScanRegion.addEventListener(\"dragleave\", function(event) {\n            $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionDefaultBorder();\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.fileBasedScanRegion.addEventListener(\"dragover\", function(event) {\n            $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionActiveBorder();\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.fileBasedScanRegion.addEventListener(\"drop\", function(event) {\n            event.stopPropagation();\n            event.preventDefault();\n            $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionDefaultBorder();\n            var dataTransfer = event.dataTransfer;\n            if (dataTransfer) {\n                var files = dataTransfer.files;\n                if (!files || files.length === 0) {\n                    return;\n                }\n                var isAnyFileImage = false;\n                for(var i = 0; i < files.length; ++i){\n                    var file = files.item(i);\n                    if (!file) {\n                        continue;\n                    }\n                    var imageType = /image.*/;\n                    if (!file.type.match(imageType)) {\n                        continue;\n                    }\n                    isAnyFileImage = true;\n                    var fileName = file.name;\n                    $this.setImageNameToButton(fileName);\n                    onFileSelected(file);\n                    dragAndDropMessage.innerText = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.dragAndDropMessage();\n                    break;\n                }\n                if (!isAnyFileImage) {\n                    dragAndDropMessage.innerText = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.dragAndDropMessageOnlyImages();\n                }\n            }\n        });\n    }\n    FileSelectionUi.prototype.hide = function() {\n        this.fileBasedScanRegion.style.display = \"none\";\n        this.fileScanInput.disabled = true;\n    };\n    FileSelectionUi.prototype.show = function() {\n        this.fileBasedScanRegion.style.display = \"block\";\n        this.fileScanInput.disabled = false;\n    };\n    FileSelectionUi.prototype.isShowing = function() {\n        return this.fileBasedScanRegion.style.display === \"block\";\n    };\n    FileSelectionUi.prototype.resetValue = function() {\n        this.fileScanInput.value = \"\";\n        this.setInitialValueToButton();\n    };\n    FileSelectionUi.prototype.createFileBasedScanRegion = function() {\n        var fileBasedScanRegion = document.createElement(\"div\");\n        fileBasedScanRegion.style.textAlign = \"center\";\n        fileBasedScanRegion.style.margin = \"auto\";\n        fileBasedScanRegion.style.width = \"80%\";\n        fileBasedScanRegion.style.maxWidth = \"600px\";\n        fileBasedScanRegion.style.border = this.fileBasedScanRegionDefaultBorder();\n        fileBasedScanRegion.style.padding = \"10px\";\n        fileBasedScanRegion.style.marginBottom = \"10px\";\n        return fileBasedScanRegion;\n    };\n    FileSelectionUi.prototype.fileBasedScanRegionDefaultBorder = function() {\n        return \"6px dashed #ebebeb\";\n    };\n    FileSelectionUi.prototype.fileBasedScanRegionActiveBorder = function() {\n        return \"6px dashed rgb(153 151 151)\";\n    };\n    FileSelectionUi.prototype.createDragAndDropMessage = function() {\n        var dragAndDropMessage = document.createElement(\"div\");\n        dragAndDropMessage.innerText = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.dragAndDropMessage();\n        dragAndDropMessage.style.fontWeight = \"400\";\n        return dragAndDropMessage;\n    };\n    FileSelectionUi.prototype.setImageNameToButton = function(imageFileName) {\n        var MAX_CHARS = 20;\n        if (imageFileName.length > MAX_CHARS) {\n            var start8Chars = imageFileName.substring(0, 8);\n            var length_1 = imageFileName.length;\n            var last8Chars = imageFileName.substring(length_1 - 8, length_1);\n            imageFileName = \"\".concat(start8Chars, \"....\").concat(last8Chars);\n        }\n        var newText = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.fileSelectionChooseAnother() + \" - \" + imageFileName;\n        this.fileSelectionButton.innerText = newText;\n    };\n    FileSelectionUi.prototype.setInitialValueToButton = function() {\n        var initialText = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.fileSelectionChooseImage() + \" - \" + _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.fileSelectionNoImageSelected();\n        this.fileSelectionButton.innerText = initialText;\n    };\n    FileSelectionUi.prototype.getFileScanInputId = function() {\n        return \"html5-qrcode-private-filescan-input\";\n    };\n    FileSelectionUi.create = function(parentElement, showOnRender, onFileSelected) {\n        var button = new FileSelectionUi(parentElement, showOnRender, onFileSelected);\n        return button;\n    };\n    return FileSelectionUi;\n}();\n //# sourceMappingURL=file-selection-ui.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL2ZpbGUtc2VsZWN0aW9uLXVpLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwRDtBQUNpQjtBQUMzRSxJQUFJRyxrQkFBbUI7SUFDbkIsU0FBU0EsZ0JBQWdCQyxhQUFhLEVBQUVDLFlBQVksRUFBRUMsY0FBYztRQUNoRSxJQUFJLENBQUNDLG1CQUFtQixHQUFHLElBQUksQ0FBQ0MseUJBQXlCO1FBQ3pELElBQUksQ0FBQ0QsbUJBQW1CLENBQUNFLEtBQUssQ0FBQ0MsT0FBTyxHQUNoQ0wsZUFBZSxVQUFVO1FBQy9CRCxjQUFjTyxXQUFXLENBQUMsSUFBSSxDQUFDSixtQkFBbUI7UUFDbEQsSUFBSUssZ0JBQWdCQyxTQUFTQyxhQUFhLENBQUM7UUFDM0NGLGNBQWNHLFlBQVksQ0FBQyxPQUFPLElBQUksQ0FBQ0Msa0JBQWtCO1FBQ3pESixjQUFjSCxLQUFLLENBQUNDLE9BQU8sR0FBRztRQUM5QixJQUFJLENBQUNILG1CQUFtQixDQUFDSSxXQUFXLENBQUNDO1FBQ3JDLElBQUksQ0FBQ0ssbUJBQW1CLEdBQ2xCaEIsdURBQW9CQSxDQUFDYSxhQUFhLENBQUMsVUFBVVosOERBQTJCQSxDQUFDZ0Isd0JBQXdCO1FBQ3ZHLElBQUksQ0FBQ0MsdUJBQXVCO1FBQzVCLElBQUksQ0FBQ0YsbUJBQW1CLENBQUNHLGdCQUFnQixDQUFDLFNBQVMsU0FBVUMsQ0FBQztZQUMxRFQsY0FBY1UsS0FBSztRQUN2QjtRQUNBVixjQUFjVyxNQUFNLENBQUMsSUFBSSxDQUFDTixtQkFBbUI7UUFDN0MsSUFBSSxDQUFDTyxhQUFhLEdBQ1p2Qix1REFBb0JBLENBQUNhLGFBQWEsQ0FBQyxTQUFTLElBQUksQ0FBQ0Usa0JBQWtCO1FBQ3pFLElBQUksQ0FBQ1EsYUFBYSxDQUFDQyxJQUFJLEdBQUc7UUFDMUIsSUFBSSxDQUFDRCxhQUFhLENBQUNFLE1BQU0sR0FBRztRQUM1QixJQUFJLENBQUNGLGFBQWEsQ0FBQ2YsS0FBSyxDQUFDQyxPQUFPLEdBQUc7UUFDbkNFLGNBQWNELFdBQVcsQ0FBQyxJQUFJLENBQUNhLGFBQWE7UUFDNUMsSUFBSUcsUUFBUSxJQUFJO1FBQ2hCLElBQUksQ0FBQ0gsYUFBYSxDQUFDSixnQkFBZ0IsQ0FBQyxVQUFVLFNBQVVRLENBQUM7WUFDckQsSUFBSUEsS0FBSyxRQUFRQSxFQUFFQyxNQUFNLElBQUksTUFBTTtnQkFDL0I7WUFDSjtZQUNBLElBQUlBLFNBQVNELEVBQUVDLE1BQU07WUFDckIsSUFBSUEsT0FBT0MsS0FBSyxJQUFJRCxPQUFPQyxLQUFLLENBQUNDLE1BQU0sS0FBSyxHQUFHO2dCQUMzQztZQUNKO1lBQ0EsSUFBSUMsV0FBV0gsT0FBT0MsS0FBSztZQUMzQixJQUFJRyxPQUFPRCxRQUFRLENBQUMsRUFBRTtZQUN0QixJQUFJRSxXQUFXRCxLQUFLRSxJQUFJO1lBQ3hCUixNQUFNUyxvQkFBb0IsQ0FBQ0Y7WUFDM0I1QixlQUFlMkI7UUFDbkI7UUFDQSxJQUFJSSxxQkFBcUIsSUFBSSxDQUFDQyx3QkFBd0I7UUFDdEQsSUFBSSxDQUFDL0IsbUJBQW1CLENBQUNJLFdBQVcsQ0FBQzBCO1FBQ3JDLElBQUksQ0FBQzlCLG1CQUFtQixDQUFDYSxnQkFBZ0IsQ0FBQyxhQUFhLFNBQVVtQixLQUFLO1lBQ2xFWixNQUFNcEIsbUJBQW1CLENBQUNFLEtBQUssQ0FBQytCLE1BQU0sR0FDaENiLE1BQU1jLCtCQUErQjtZQUMzQ0YsTUFBTUcsZUFBZTtZQUNyQkgsTUFBTUksY0FBYztRQUN4QjtRQUNBLElBQUksQ0FBQ3BDLG1CQUFtQixDQUFDYSxnQkFBZ0IsQ0FBQyxhQUFhLFNBQVVtQixLQUFLO1lBQ2xFWixNQUFNcEIsbUJBQW1CLENBQUNFLEtBQUssQ0FBQytCLE1BQU0sR0FDaENiLE1BQU1pQixnQ0FBZ0M7WUFDNUNMLE1BQU1HLGVBQWU7WUFDckJILE1BQU1JLGNBQWM7UUFDeEI7UUFDQSxJQUFJLENBQUNwQyxtQkFBbUIsQ0FBQ2EsZ0JBQWdCLENBQUMsWUFBWSxTQUFVbUIsS0FBSztZQUNqRVosTUFBTXBCLG1CQUFtQixDQUFDRSxLQUFLLENBQUMrQixNQUFNLEdBQ2hDYixNQUFNYywrQkFBK0I7WUFDM0NGLE1BQU1HLGVBQWU7WUFDckJILE1BQU1JLGNBQWM7UUFDeEI7UUFDQSxJQUFJLENBQUNwQyxtQkFBbUIsQ0FBQ2EsZ0JBQWdCLENBQUMsUUFBUSxTQUFVbUIsS0FBSztZQUM3REEsTUFBTUcsZUFBZTtZQUNyQkgsTUFBTUksY0FBYztZQUNwQmhCLE1BQU1wQixtQkFBbUIsQ0FBQ0UsS0FBSyxDQUFDK0IsTUFBTSxHQUNoQ2IsTUFBTWlCLGdDQUFnQztZQUM1QyxJQUFJQyxlQUFlTixNQUFNTSxZQUFZO1lBQ3JDLElBQUlBLGNBQWM7Z0JBQ2QsSUFBSWYsUUFBUWUsYUFBYWYsS0FBSztnQkFDOUIsSUFBSSxDQUFDQSxTQUFTQSxNQUFNQyxNQUFNLEtBQUssR0FBRztvQkFDOUI7Z0JBQ0o7Z0JBQ0EsSUFBSWUsaUJBQWlCO2dCQUNyQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSWpCLE1BQU1DLE1BQU0sRUFBRSxFQUFFZ0IsRUFBRztvQkFDbkMsSUFBSWQsT0FBT0gsTUFBTWtCLElBQUksQ0FBQ0Q7b0JBQ3RCLElBQUksQ0FBQ2QsTUFBTTt3QkFDUDtvQkFDSjtvQkFDQSxJQUFJZ0IsWUFBWTtvQkFDaEIsSUFBSSxDQUFDaEIsS0FBS1IsSUFBSSxDQUFDeUIsS0FBSyxDQUFDRCxZQUFZO3dCQUM3QjtvQkFDSjtvQkFDQUgsaUJBQWlCO29CQUNqQixJQUFJWixXQUFXRCxLQUFLRSxJQUFJO29CQUN4QlIsTUFBTVMsb0JBQW9CLENBQUNGO29CQUMzQjVCLGVBQWUyQjtvQkFDZkksbUJBQW1CYyxTQUFTLEdBQ3RCbkQsK0RBQXlCQSxDQUFDcUMsa0JBQWtCO29CQUNsRDtnQkFDSjtnQkFDQSxJQUFJLENBQUNTLGdCQUFnQjtvQkFDakJULG1CQUFtQmMsU0FBUyxHQUN0Qm5ELCtEQUF5QkEsQ0FDdEJvRCw0QkFBNEI7Z0JBQ3pDO1lBQ0o7UUFDSjtJQUNKO0lBQ0FqRCxnQkFBZ0JrRCxTQUFTLENBQUNDLElBQUksR0FBRztRQUM3QixJQUFJLENBQUMvQyxtQkFBbUIsQ0FBQ0UsS0FBSyxDQUFDQyxPQUFPLEdBQUc7UUFDekMsSUFBSSxDQUFDYyxhQUFhLENBQUMrQixRQUFRLEdBQUc7SUFDbEM7SUFDQXBELGdCQUFnQmtELFNBQVMsQ0FBQ0csSUFBSSxHQUFHO1FBQzdCLElBQUksQ0FBQ2pELG1CQUFtQixDQUFDRSxLQUFLLENBQUNDLE9BQU8sR0FBRztRQUN6QyxJQUFJLENBQUNjLGFBQWEsQ0FBQytCLFFBQVEsR0FBRztJQUNsQztJQUNBcEQsZ0JBQWdCa0QsU0FBUyxDQUFDSSxTQUFTLEdBQUc7UUFDbEMsT0FBTyxJQUFJLENBQUNsRCxtQkFBbUIsQ0FBQ0UsS0FBSyxDQUFDQyxPQUFPLEtBQUs7SUFDdEQ7SUFDQVAsZ0JBQWdCa0QsU0FBUyxDQUFDSyxVQUFVLEdBQUc7UUFDbkMsSUFBSSxDQUFDbEMsYUFBYSxDQUFDbUMsS0FBSyxHQUFHO1FBQzNCLElBQUksQ0FBQ3hDLHVCQUF1QjtJQUNoQztJQUNBaEIsZ0JBQWdCa0QsU0FBUyxDQUFDN0MseUJBQXlCLEdBQUc7UUFDbEQsSUFBSUQsc0JBQXNCTSxTQUFTQyxhQUFhLENBQUM7UUFDakRQLG9CQUFvQkUsS0FBSyxDQUFDbUQsU0FBUyxHQUFHO1FBQ3RDckQsb0JBQW9CRSxLQUFLLENBQUNvRCxNQUFNLEdBQUc7UUFDbkN0RCxvQkFBb0JFLEtBQUssQ0FBQ3FELEtBQUssR0FBRztRQUNsQ3ZELG9CQUFvQkUsS0FBSyxDQUFDc0QsUUFBUSxHQUFHO1FBQ3JDeEQsb0JBQW9CRSxLQUFLLENBQUMrQixNQUFNLEdBQzFCLElBQUksQ0FBQ0ksZ0NBQWdDO1FBQzNDckMsb0JBQW9CRSxLQUFLLENBQUN1RCxPQUFPLEdBQUc7UUFDcEN6RCxvQkFBb0JFLEtBQUssQ0FBQ3dELFlBQVksR0FBRztRQUN6QyxPQUFPMUQ7SUFDWDtJQUNBSixnQkFBZ0JrRCxTQUFTLENBQUNULGdDQUFnQyxHQUFHO1FBQ3pELE9BQU87SUFDWDtJQUNBekMsZ0JBQWdCa0QsU0FBUyxDQUFDWiwrQkFBK0IsR0FBRztRQUN4RCxPQUFPO0lBQ1g7SUFDQXRDLGdCQUFnQmtELFNBQVMsQ0FBQ2Ysd0JBQXdCLEdBQUc7UUFDakQsSUFBSUQscUJBQXFCeEIsU0FBU0MsYUFBYSxDQUFDO1FBQ2hEdUIsbUJBQW1CYyxTQUFTLEdBQ3RCbkQsK0RBQXlCQSxDQUFDcUMsa0JBQWtCO1FBQ2xEQSxtQkFBbUI1QixLQUFLLENBQUN5RCxVQUFVLEdBQUc7UUFDdEMsT0FBTzdCO0lBQ1g7SUFDQWxDLGdCQUFnQmtELFNBQVMsQ0FBQ2pCLG9CQUFvQixHQUFHLFNBQVUrQixhQUFhO1FBQ3BFLElBQUlDLFlBQVk7UUFDaEIsSUFBSUQsY0FBY3BDLE1BQU0sR0FBR3FDLFdBQVc7WUFDbEMsSUFBSUMsY0FBY0YsY0FBY0csU0FBUyxDQUFDLEdBQUc7WUFDN0MsSUFBSUMsV0FBV0osY0FBY3BDLE1BQU07WUFDbkMsSUFBSXlDLGFBQWFMLGNBQWNHLFNBQVMsQ0FBQ0MsV0FBVyxHQUFHQTtZQUN2REosZ0JBQWdCLEdBQUdNLE1BQU0sQ0FBQ0osYUFBYSxRQUFRSSxNQUFNLENBQUNEO1FBQzFEO1FBQ0EsSUFBSUUsVUFBVTFFLCtEQUF5QkEsQ0FBQzJFLDBCQUEwQixLQUM1RCxRQUNBUjtRQUNOLElBQUksQ0FBQ2xELG1CQUFtQixDQUFDa0MsU0FBUyxHQUFHdUI7SUFDekM7SUFDQXZFLGdCQUFnQmtELFNBQVMsQ0FBQ2xDLHVCQUF1QixHQUFHO1FBQ2hELElBQUl5RCxjQUFjNUUsK0RBQXlCQSxDQUFDNkUsd0JBQXdCLEtBQzlELFFBQ0E3RSwrREFBeUJBLENBQUM4RSw0QkFBNEI7UUFDNUQsSUFBSSxDQUFDN0QsbUJBQW1CLENBQUNrQyxTQUFTLEdBQUd5QjtJQUN6QztJQUNBekUsZ0JBQWdCa0QsU0FBUyxDQUFDckMsa0JBQWtCLEdBQUc7UUFDM0MsT0FBTztJQUNYO0lBQ0FiLGdCQUFnQjRFLE1BQU0sR0FBRyxTQUFVM0UsYUFBYSxFQUFFQyxZQUFZLEVBQUVDLGNBQWM7UUFDMUUsSUFBSTBFLFNBQVMsSUFBSTdFLGdCQUFnQkMsZUFBZUMsY0FBY0M7UUFDOUQsT0FBTzBFO0lBQ1g7SUFDQSxPQUFPN0U7QUFDWDtBQUMyQixDQUMzQiw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb3Bvcy8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3VpL3NjYW5uZXIvZmlsZS1zZWxlY3Rpb24tdWkuanM/MWI2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzIH0gZnJvbSBcIi4uLy4uL3N0cmluZ3NcIjtcbmltcG9ydCB7IEJhc2VVaUVsZW1lbnRGYWN0b3J5LCBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMgfSBmcm9tIFwiLi9iYXNlXCI7XG52YXIgRmlsZVNlbGVjdGlvblVpID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWxlU2VsZWN0aW9uVWkocGFyZW50RWxlbWVudCwgc2hvd09uUmVuZGVyLCBvbkZpbGVTZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24gPSB0aGlzLmNyZWF0ZUZpbGVCYXNlZFNjYW5SZWdpb24oKTtcbiAgICAgICAgdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uLnN0eWxlLmRpc3BsYXlcbiAgICAgICAgICAgID0gc2hvd09uUmVuZGVyID8gXCJibG9ja1wiIDogXCJub25lXCI7XG4gICAgICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uKTtcbiAgICAgICAgdmFyIGZpbGVTY2FuTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgIGZpbGVTY2FuTGFiZWwuc2V0QXR0cmlidXRlKFwiZm9yXCIsIHRoaXMuZ2V0RmlsZVNjYW5JbnB1dElkKCkpO1xuICAgICAgICBmaWxlU2NhbkxhYmVsLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICB0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uYXBwZW5kQ2hpbGQoZmlsZVNjYW5MYWJlbCk7XG4gICAgICAgIHRoaXMuZmlsZVNlbGVjdGlvbkJ1dHRvblxuICAgICAgICAgICAgPSBCYXNlVWlFbGVtZW50RmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5GSUxFX1NFTEVDVElPTl9CVVRUT05fSUQpO1xuICAgICAgICB0aGlzLnNldEluaXRpYWxWYWx1ZVRvQnV0dG9uKCk7XG4gICAgICAgIHRoaXMuZmlsZVNlbGVjdGlvbkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGZpbGVTY2FuTGFiZWwuY2xpY2soKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbGVTY2FuTGFiZWwuYXBwZW5kKHRoaXMuZmlsZVNlbGVjdGlvbkJ1dHRvbik7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbnB1dFxuICAgICAgICAgICAgPSBCYXNlVWlFbGVtZW50RmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgdGhpcy5nZXRGaWxlU2NhbklucHV0SWQoKSk7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbnB1dC50eXBlID0gXCJmaWxlXCI7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbnB1dC5hY2NlcHQgPSBcImltYWdlLypcIjtcbiAgICAgICAgdGhpcy5maWxlU2NhbklucHV0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgZmlsZVNjYW5MYWJlbC5hcHBlbmRDaGlsZCh0aGlzLmZpbGVTY2FuSW5wdXQpO1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUgPT0gbnVsbCB8fCBlLnRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRhcmdldC5maWxlcyAmJiB0YXJnZXQuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpbGVMaXN0ID0gdGFyZ2V0LmZpbGVzO1xuICAgICAgICAgICAgdmFyIGZpbGUgPSBmaWxlTGlzdFswXTtcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IGZpbGUubmFtZTtcbiAgICAgICAgICAgICR0aGlzLnNldEltYWdlTmFtZVRvQnV0dG9uKGZpbGVOYW1lKTtcbiAgICAgICAgICAgIG9uRmlsZVNlbGVjdGVkKGZpbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRyYWdBbmREcm9wTWVzc2FnZSA9IHRoaXMuY3JlYXRlRHJhZ0FuZERyb3BNZXNzYWdlKCk7XG4gICAgICAgIHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbi5hcHBlbmRDaGlsZChkcmFnQW5kRHJvcE1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbnRlclwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICR0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUuYm9yZGVyXG4gICAgICAgICAgICAgICAgPSAkdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uQWN0aXZlQm9yZGVyKCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdsZWF2ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICR0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUuYm9yZGVyXG4gICAgICAgICAgICAgICAgPSAkdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uRGVmYXVsdEJvcmRlcigpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICR0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUuYm9yZGVyXG4gICAgICAgICAgICAgICAgPSAkdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uQWN0aXZlQm9yZGVyKCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAkdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uLnN0eWxlLmJvcmRlclxuICAgICAgICAgICAgICAgID0gJHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbkRlZmF1bHRCb3JkZXIoKTtcbiAgICAgICAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBldmVudC5kYXRhVHJhbnNmZXI7XG4gICAgICAgICAgICBpZiAoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgICAgICAgICAgICAgIGlmICghZmlsZXMgfHwgZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGlzQW55RmlsZUltYWdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IGZpbGVzLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlVHlwZSA9IC9pbWFnZS4qLztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlLnR5cGUubWF0Y2goaW1hZ2VUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNBbnlGaWxlSW1hZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBmaWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnNldEltYWdlTmFtZVRvQnV0dG9uKGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgb25GaWxlU2VsZWN0ZWQoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdBbmREcm9wTWVzc2FnZS5pbm5lclRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgID0gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5kcmFnQW5kRHJvcE1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNBbnlGaWxlSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0FuZERyb3BNZXNzYWdlLmlubmVyVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRyYWdBbmREcm9wTWVzc2FnZU9ubHlJbWFnZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBGaWxlU2VsZWN0aW9uVWkucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbnB1dC5kaXNhYmxlZCA9IHRydWU7XG4gICAgfTtcbiAgICBGaWxlU2VsZWN0aW9uVWkucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW5wdXQuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIEZpbGVTZWxlY3Rpb25VaS5wcm90b3R5cGUuaXNTaG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uLnN0eWxlLmRpc3BsYXkgPT09IFwiYmxvY2tcIjtcbiAgICB9O1xuICAgIEZpbGVTZWxlY3Rpb25VaS5wcm90b3R5cGUucmVzZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maWxlU2NhbklucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5zZXRJbml0aWFsVmFsdWVUb0J1dHRvbigpO1xuICAgIH07XG4gICAgRmlsZVNlbGVjdGlvblVpLnByb3RvdHlwZS5jcmVhdGVGaWxlQmFzZWRTY2FuUmVnaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmlsZUJhc2VkU2NhblJlZ2lvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5tYXJnaW4gPSBcImF1dG9cIjtcbiAgICAgICAgZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS53aWR0aCA9IFwiODAlXCI7XG4gICAgICAgIGZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUubWF4V2lkdGggPSBcIjYwMHB4XCI7XG4gICAgICAgIGZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUuYm9yZGVyXG4gICAgICAgICAgICA9IHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbkRlZmF1bHRCb3JkZXIoKTtcbiAgICAgICAgZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5wYWRkaW5nID0gXCIxMHB4XCI7XG4gICAgICAgIGZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUubWFyZ2luQm90dG9tID0gXCIxMHB4XCI7XG4gICAgICAgIHJldHVybiBmaWxlQmFzZWRTY2FuUmVnaW9uO1xuICAgIH07XG4gICAgRmlsZVNlbGVjdGlvblVpLnByb3RvdHlwZS5maWxlQmFzZWRTY2FuUmVnaW9uRGVmYXVsdEJvcmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiNnB4IGRhc2hlZCAjZWJlYmViXCI7XG4gICAgfTtcbiAgICBGaWxlU2VsZWN0aW9uVWkucHJvdG90eXBlLmZpbGVCYXNlZFNjYW5SZWdpb25BY3RpdmVCb3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIjZweCBkYXNoZWQgcmdiKDE1MyAxNTEgMTUxKVwiO1xuICAgIH07XG4gICAgRmlsZVNlbGVjdGlvblVpLnByb3RvdHlwZS5jcmVhdGVEcmFnQW5kRHJvcE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkcmFnQW5kRHJvcE1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkcmFnQW5kRHJvcE1lc3NhZ2UuaW5uZXJUZXh0XG4gICAgICAgICAgICA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZHJhZ0FuZERyb3BNZXNzYWdlKCk7XG4gICAgICAgIGRyYWdBbmREcm9wTWVzc2FnZS5zdHlsZS5mb250V2VpZ2h0ID0gXCI0MDBcIjtcbiAgICAgICAgcmV0dXJuIGRyYWdBbmREcm9wTWVzc2FnZTtcbiAgICB9O1xuICAgIEZpbGVTZWxlY3Rpb25VaS5wcm90b3R5cGUuc2V0SW1hZ2VOYW1lVG9CdXR0b24gPSBmdW5jdGlvbiAoaW1hZ2VGaWxlTmFtZSkge1xuICAgICAgICB2YXIgTUFYX0NIQVJTID0gMjA7XG4gICAgICAgIGlmIChpbWFnZUZpbGVOYW1lLmxlbmd0aCA+IE1BWF9DSEFSUykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0OENoYXJzID0gaW1hZ2VGaWxlTmFtZS5zdWJzdHJpbmcoMCwgOCk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSBpbWFnZUZpbGVOYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsYXN0OENoYXJzID0gaW1hZ2VGaWxlTmFtZS5zdWJzdHJpbmcobGVuZ3RoXzEgLSA4LCBsZW5ndGhfMSk7XG4gICAgICAgICAgICBpbWFnZUZpbGVOYW1lID0gXCJcIi5jb25jYXQoc3RhcnQ4Q2hhcnMsIFwiLi4uLlwiKS5jb25jYXQobGFzdDhDaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1RleHQgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmZpbGVTZWxlY3Rpb25DaG9vc2VBbm90aGVyKClcbiAgICAgICAgICAgICsgXCIgLSBcIlxuICAgICAgICAgICAgKyBpbWFnZUZpbGVOYW1lO1xuICAgICAgICB0aGlzLmZpbGVTZWxlY3Rpb25CdXR0b24uaW5uZXJUZXh0ID0gbmV3VGV4dDtcbiAgICB9O1xuICAgIEZpbGVTZWxlY3Rpb25VaS5wcm90b3R5cGUuc2V0SW5pdGlhbFZhbHVlVG9CdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbml0aWFsVGV4dCA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZmlsZVNlbGVjdGlvbkNob29zZUltYWdlKClcbiAgICAgICAgICAgICsgXCIgLSBcIlxuICAgICAgICAgICAgKyBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmZpbGVTZWxlY3Rpb25Ob0ltYWdlU2VsZWN0ZWQoKTtcbiAgICAgICAgdGhpcy5maWxlU2VsZWN0aW9uQnV0dG9uLmlubmVyVGV4dCA9IGluaXRpYWxUZXh0O1xuICAgIH07XG4gICAgRmlsZVNlbGVjdGlvblVpLnByb3RvdHlwZS5nZXRGaWxlU2NhbklucHV0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcImh0bWw1LXFyY29kZS1wcml2YXRlLWZpbGVzY2FuLWlucHV0XCI7XG4gICAgfTtcbiAgICBGaWxlU2VsZWN0aW9uVWkuY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIHNob3dPblJlbmRlciwgb25GaWxlU2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IG5ldyBGaWxlU2VsZWN0aW9uVWkocGFyZW50RWxlbWVudCwgc2hvd09uUmVuZGVyLCBvbkZpbGVTZWxlY3RlZCk7XG4gICAgICAgIHJldHVybiBidXR0b247XG4gICAgfTtcbiAgICByZXR1cm4gRmlsZVNlbGVjdGlvblVpO1xufSgpKTtcbmV4cG9ydCB7IEZpbGVTZWxlY3Rpb25VaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZS1zZWxlY3Rpb24tdWkuanMubWFwIl0sIm5hbWVzIjpbIkh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MiLCJCYXNlVWlFbGVtZW50RmFjdG9yeSIsIlB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3NlcyIsIkZpbGVTZWxlY3Rpb25VaSIsInBhcmVudEVsZW1lbnQiLCJzaG93T25SZW5kZXIiLCJvbkZpbGVTZWxlY3RlZCIsImZpbGVCYXNlZFNjYW5SZWdpb24iLCJjcmVhdGVGaWxlQmFzZWRTY2FuUmVnaW9uIiwic3R5bGUiLCJkaXNwbGF5IiwiYXBwZW5kQ2hpbGQiLCJmaWxlU2NhbkxhYmVsIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiZ2V0RmlsZVNjYW5JbnB1dElkIiwiZmlsZVNlbGVjdGlvbkJ1dHRvbiIsIkZJTEVfU0VMRUNUSU9OX0JVVFRPTl9JRCIsInNldEluaXRpYWxWYWx1ZVRvQnV0dG9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl8iLCJjbGljayIsImFwcGVuZCIsImZpbGVTY2FuSW5wdXQiLCJ0eXBlIiwiYWNjZXB0IiwiJHRoaXMiLCJlIiwidGFyZ2V0IiwiZmlsZXMiLCJsZW5ndGgiLCJmaWxlTGlzdCIsImZpbGUiLCJmaWxlTmFtZSIsIm5hbWUiLCJzZXRJbWFnZU5hbWVUb0J1dHRvbiIsImRyYWdBbmREcm9wTWVzc2FnZSIsImNyZWF0ZURyYWdBbmREcm9wTWVzc2FnZSIsImV2ZW50IiwiYm9yZGVyIiwiZmlsZUJhc2VkU2NhblJlZ2lvbkFjdGl2ZUJvcmRlciIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiZmlsZUJhc2VkU2NhblJlZ2lvbkRlZmF1bHRCb3JkZXIiLCJkYXRhVHJhbnNmZXIiLCJpc0FueUZpbGVJbWFnZSIsImkiLCJpdGVtIiwiaW1hZ2VUeXBlIiwibWF0Y2giLCJpbm5lclRleHQiLCJkcmFnQW5kRHJvcE1lc3NhZ2VPbmx5SW1hZ2VzIiwicHJvdG90eXBlIiwiaGlkZSIsImRpc2FibGVkIiwic2hvdyIsImlzU2hvd2luZyIsInJlc2V0VmFsdWUiLCJ2YWx1ZSIsInRleHRBbGlnbiIsIm1hcmdpbiIsIndpZHRoIiwibWF4V2lkdGgiLCJwYWRkaW5nIiwibWFyZ2luQm90dG9tIiwiZm9udFdlaWdodCIsImltYWdlRmlsZU5hbWUiLCJNQVhfQ0hBUlMiLCJzdGFydDhDaGFycyIsInN1YnN0cmluZyIsImxlbmd0aF8xIiwibGFzdDhDaGFycyIsImNvbmNhdCIsIm5ld1RleHQiLCJmaWxlU2VsZWN0aW9uQ2hvb3NlQW5vdGhlciIsImluaXRpYWxUZXh0IiwiZmlsZVNlbGVjdGlvbkNob29zZUltYWdlIiwiZmlsZVNlbGVjdGlvbk5vSW1hZ2VTZWxlY3RlZCIsImNyZWF0ZSIsImJ1dHRvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js":
/*!************************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScanTypeSelector: () => (/* binding */ ScanTypeSelector)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ \"(ssr)/./node_modules/html5-qrcode/esm/core.js\");\n\nvar ScanTypeSelector = function() {\n    function ScanTypeSelector(supportedScanTypes) {\n        this.supportedScanTypes = this.validateAndReturnScanTypes(supportedScanTypes);\n    }\n    ScanTypeSelector.prototype.getDefaultScanType = function() {\n        return this.supportedScanTypes[0];\n    };\n    ScanTypeSelector.prototype.hasMoreThanOneScanType = function() {\n        return this.supportedScanTypes.length > 1;\n    };\n    ScanTypeSelector.prototype.isCameraScanRequired = function() {\n        for(var _i = 0, _a = this.supportedScanTypes; _i < _a.length; _i++){\n            var scanType = _a[_i];\n            if (ScanTypeSelector.isCameraScanType(scanType)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    ScanTypeSelector.isCameraScanType = function(scanType) {\n        return scanType === _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScanType.SCAN_TYPE_CAMERA;\n    };\n    ScanTypeSelector.isFileScanType = function(scanType) {\n        return scanType === _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScanType.SCAN_TYPE_FILE;\n    };\n    ScanTypeSelector.prototype.validateAndReturnScanTypes = function(supportedScanTypes) {\n        if (!supportedScanTypes || supportedScanTypes.length === 0) {\n            return _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE;\n        }\n        var maxExpectedValues = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE.length;\n        if (supportedScanTypes.length > maxExpectedValues) {\n            throw \"Max \".concat(maxExpectedValues, \" values expected for \") + \"supportedScanTypes\";\n        }\n        for(var _i = 0, supportedScanTypes_1 = supportedScanTypes; _i < supportedScanTypes_1.length; _i++){\n            var scanType = supportedScanTypes_1[_i];\n            if (!_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE.includes(scanType)) {\n                throw \"Unsupported scan type \".concat(scanType);\n            }\n        }\n        return supportedScanTypes;\n    };\n    return ScanTypeSelector;\n}();\n //# sourceMappingURL=scan-type-selector.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL3NjYW4tdHlwZS1zZWxlY3Rvci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1RTtBQUN2RSxJQUFJRSxtQkFBb0I7SUFDcEIsU0FBU0EsaUJBQWlCQyxrQkFBa0I7UUFDeEMsSUFBSSxDQUFDQSxrQkFBa0IsR0FBRyxJQUFJLENBQUNDLDBCQUEwQixDQUFDRDtJQUM5RDtJQUNBRCxpQkFBaUJHLFNBQVMsQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDNUMsT0FBTyxJQUFJLENBQUNILGtCQUFrQixDQUFDLEVBQUU7SUFDckM7SUFDQUQsaUJBQWlCRyxTQUFTLENBQUNFLHNCQUFzQixHQUFHO1FBQ2hELE9BQU8sSUFBSSxDQUFDSixrQkFBa0IsQ0FBQ0ssTUFBTSxHQUFHO0lBQzVDO0lBQ0FOLGlCQUFpQkcsU0FBUyxDQUFDSSxvQkFBb0IsR0FBRztRQUM5QyxJQUFLLElBQUlDLEtBQUssR0FBR0MsS0FBSyxJQUFJLENBQUNSLGtCQUFrQixFQUFFTyxLQUFLQyxHQUFHSCxNQUFNLEVBQUVFLEtBQU07WUFDakUsSUFBSUUsV0FBV0QsRUFBRSxDQUFDRCxHQUFHO1lBQ3JCLElBQUlSLGlCQUFpQlcsZ0JBQWdCLENBQUNELFdBQVc7Z0JBQzdDLE9BQU87WUFDWDtRQUNKO1FBQ0EsT0FBTztJQUNYO0lBQ0FWLGlCQUFpQlcsZ0JBQWdCLEdBQUcsU0FBVUQsUUFBUTtRQUNsRCxPQUFPQSxhQUFhWixzREFBbUJBLENBQUNjLGdCQUFnQjtJQUM1RDtJQUNBWixpQkFBaUJhLGNBQWMsR0FBRyxTQUFVSCxRQUFRO1FBQ2hELE9BQU9BLGFBQWFaLHNEQUFtQkEsQ0FBQ2dCLGNBQWM7SUFDMUQ7SUFDQWQsaUJBQWlCRyxTQUFTLENBQUNELDBCQUEwQixHQUFHLFNBQVVELGtCQUFrQjtRQUNoRixJQUFJLENBQUNBLHNCQUFzQkEsbUJBQW1CSyxNQUFNLEtBQUssR0FBRztZQUN4RCxPQUFPUCx1REFBb0JBLENBQUNnQiwyQkFBMkI7UUFDM0Q7UUFDQSxJQUFJQyxvQkFBb0JqQix1REFBb0JBLENBQUNnQiwyQkFBMkIsQ0FBQ1QsTUFBTTtRQUMvRSxJQUFJTCxtQkFBbUJLLE1BQU0sR0FBR1UsbUJBQW1CO1lBQy9DLE1BQU0sT0FBT0MsTUFBTSxDQUFDRCxtQkFBbUIsMkJBQ2pDO1FBQ1Y7UUFDQSxJQUFLLElBQUlSLEtBQUssR0FBR1UsdUJBQXVCakIsb0JBQW9CTyxLQUFLVSxxQkFBcUJaLE1BQU0sRUFBRUUsS0FBTTtZQUNoRyxJQUFJRSxXQUFXUSxvQkFBb0IsQ0FBQ1YsR0FBRztZQUN2QyxJQUFJLENBQUNULHVEQUFvQkEsQ0FBQ2dCLDJCQUEyQixDQUNoREksUUFBUSxDQUFDVCxXQUFXO2dCQUNyQixNQUFNLHlCQUF5Qk8sTUFBTSxDQUFDUDtZQUMxQztRQUNKO1FBQ0EsT0FBT1Q7SUFDWDtJQUNBLE9BQU9EO0FBQ1g7QUFDNEIsQ0FDNUIsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9wb3MvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL3NjYW4tdHlwZS1zZWxlY3Rvci5qcz9iMzRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEh0bWw1UXJjb2RlU2NhblR5cGUsIEh0bWw1UXJjb2RlQ29uc3RhbnRzIH0gZnJvbSBcIi4uLy4uL2NvcmVcIjtcbnZhciBTY2FuVHlwZVNlbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2FuVHlwZVNlbGVjdG9yKHN1cHBvcnRlZFNjYW5UeXBlcykge1xuICAgICAgICB0aGlzLnN1cHBvcnRlZFNjYW5UeXBlcyA9IHRoaXMudmFsaWRhdGVBbmRSZXR1cm5TY2FuVHlwZXMoc3VwcG9ydGVkU2NhblR5cGVzKTtcbiAgICB9XG4gICAgU2NhblR5cGVTZWxlY3Rvci5wcm90b3R5cGUuZ2V0RGVmYXVsdFNjYW5UeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRTY2FuVHlwZXNbMF07XG4gICAgfTtcbiAgICBTY2FuVHlwZVNlbGVjdG9yLnByb3RvdHlwZS5oYXNNb3JlVGhhbk9uZVNjYW5UeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRTY2FuVHlwZXMubGVuZ3RoID4gMTtcbiAgICB9O1xuICAgIFNjYW5UeXBlU2VsZWN0b3IucHJvdG90eXBlLmlzQ2FtZXJhU2NhblJlcXVpcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zdXBwb3J0ZWRTY2FuVHlwZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2NhblR5cGUgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoU2NhblR5cGVTZWxlY3Rvci5pc0NhbWVyYVNjYW5UeXBlKHNjYW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNjYW5UeXBlU2VsZWN0b3IuaXNDYW1lcmFTY2FuVHlwZSA9IGZ1bmN0aW9uIChzY2FuVHlwZSkge1xuICAgICAgICByZXR1cm4gc2NhblR5cGUgPT09IEh0bWw1UXJjb2RlU2NhblR5cGUuU0NBTl9UWVBFX0NBTUVSQTtcbiAgICB9O1xuICAgIFNjYW5UeXBlU2VsZWN0b3IuaXNGaWxlU2NhblR5cGUgPSBmdW5jdGlvbiAoc2NhblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHNjYW5UeXBlID09PSBIdG1sNVFyY29kZVNjYW5UeXBlLlNDQU5fVFlQRV9GSUxFO1xuICAgIH07XG4gICAgU2NhblR5cGVTZWxlY3Rvci5wcm90b3R5cGUudmFsaWRhdGVBbmRSZXR1cm5TY2FuVHlwZXMgPSBmdW5jdGlvbiAoc3VwcG9ydGVkU2NhblR5cGVzKSB7XG4gICAgICAgIGlmICghc3VwcG9ydGVkU2NhblR5cGVzIHx8IHN1cHBvcnRlZFNjYW5UeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1NVUFBPUlRFRF9TQ0FOX1RZUEU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heEV4cGVjdGVkVmFsdWVzID0gSHRtbDVRcmNvZGVDb25zdGFudHMuREVGQVVMVF9TVVBQT1JURURfU0NBTl9UWVBFLmxlbmd0aDtcbiAgICAgICAgaWYgKHN1cHBvcnRlZFNjYW5UeXBlcy5sZW5ndGggPiBtYXhFeHBlY3RlZFZhbHVlcykge1xuICAgICAgICAgICAgdGhyb3cgXCJNYXggXCIuY29uY2F0KG1heEV4cGVjdGVkVmFsdWVzLCBcIiB2YWx1ZXMgZXhwZWN0ZWQgZm9yIFwiKVxuICAgICAgICAgICAgICAgICsgXCJzdXBwb3J0ZWRTY2FuVHlwZXNcIjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN1cHBvcnRlZFNjYW5UeXBlc18xID0gc3VwcG9ydGVkU2NhblR5cGVzOyBfaSA8IHN1cHBvcnRlZFNjYW5UeXBlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNjYW5UeXBlID0gc3VwcG9ydGVkU2NhblR5cGVzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKCFIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1NVUFBPUlRFRF9TQ0FOX1RZUEVcbiAgICAgICAgICAgICAgICAuaW5jbHVkZXMoc2NhblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJVbnN1cHBvcnRlZCBzY2FuIHR5cGUgXCIuY29uY2F0KHNjYW5UeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwcG9ydGVkU2NhblR5cGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFNjYW5UeXBlU2VsZWN0b3I7XG59KCkpO1xuZXhwb3J0IHsgU2NhblR5cGVTZWxlY3RvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nhbi10eXBlLXNlbGVjdG9yLmpzLm1hcCJdLCJuYW1lcyI6WyJIdG1sNVFyY29kZVNjYW5UeXBlIiwiSHRtbDVRcmNvZGVDb25zdGFudHMiLCJTY2FuVHlwZVNlbGVjdG9yIiwic3VwcG9ydGVkU2NhblR5cGVzIiwidmFsaWRhdGVBbmRSZXR1cm5TY2FuVHlwZXMiLCJwcm90b3R5cGUiLCJnZXREZWZhdWx0U2NhblR5cGUiLCJoYXNNb3JlVGhhbk9uZVNjYW5UeXBlIiwibGVuZ3RoIiwiaXNDYW1lcmFTY2FuUmVxdWlyZWQiLCJfaSIsIl9hIiwic2NhblR5cGUiLCJpc0NhbWVyYVNjYW5UeXBlIiwiU0NBTl9UWVBFX0NBTUVSQSIsImlzRmlsZVNjYW5UeXBlIiwiU0NBTl9UWVBFX0ZJTEUiLCJERUZBVUxUX1NVUFBPUlRFRF9TQ0FOX1RZUEUiLCJtYXhFeHBlY3RlZFZhbHVlcyIsImNvbmNhdCIsInN1cHBvcnRlZFNjYW5UeXBlc18xIiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/torch-button.js":
/*!******************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui/scanner/torch-button.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TorchButton: () => (/* binding */ TorchButton)\n/* harmony export */ });\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../strings */ \"(ssr)/./node_modules/html5-qrcode/esm/strings.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/base.js\");\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\n\n\nvar TorchController = function() {\n    function TorchController(torchCapability, buttonController, onTorchActionFailureCallback) {\n        this.isTorchOn = false;\n        this.torchCapability = torchCapability;\n        this.buttonController = buttonController;\n        this.onTorchActionFailureCallback = onTorchActionFailureCallback;\n    }\n    TorchController.prototype.isTorchEnabled = function() {\n        return this.isTorchOn;\n    };\n    TorchController.prototype.flipState = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var isTorchOnExpected, error_1;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        this.buttonController.disable();\n                        isTorchOnExpected = !this.isTorchOn;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([\n                            1,\n                            3,\n                            ,\n                            4\n                        ]);\n                        return [\n                            4,\n                            this.torchCapability.apply(isTorchOnExpected)\n                        ];\n                    case 2:\n                        _a.sent();\n                        this.updateUiBasedOnLatestSettings(this.torchCapability.value(), isTorchOnExpected);\n                        return [\n                            3,\n                            4\n                        ];\n                    case 3:\n                        error_1 = _a.sent();\n                        this.propagateFailure(isTorchOnExpected, error_1);\n                        this.buttonController.enable();\n                        return [\n                            3,\n                            4\n                        ];\n                    case 4:\n                        return [\n                            2\n                        ];\n                }\n            });\n        });\n    };\n    TorchController.prototype.updateUiBasedOnLatestSettings = function(isTorchOn, isTorchOnExpected) {\n        if (isTorchOn === isTorchOnExpected) {\n            this.buttonController.setText(isTorchOnExpected ? _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOffButton() : _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOnButton());\n            this.isTorchOn = isTorchOnExpected;\n        } else {\n            this.propagateFailure(isTorchOnExpected);\n        }\n        this.buttonController.enable();\n    };\n    TorchController.prototype.propagateFailure = function(isTorchOnExpected, error) {\n        var errorMessage = isTorchOnExpected ? _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOnFailedMessage() : _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOffFailedMessage();\n        if (error) {\n            errorMessage += \"; Error = \" + error;\n        }\n        this.onTorchActionFailureCallback(errorMessage);\n    };\n    TorchController.prototype.reset = function() {\n        this.isTorchOn = false;\n    };\n    return TorchController;\n}();\nvar TorchButton = function() {\n    function TorchButton(torchCapability, onTorchActionFailureCallback) {\n        this.onTorchActionFailureCallback = onTorchActionFailureCallback;\n        this.torchButton = _base__WEBPACK_IMPORTED_MODULE_1__.BaseUiElementFactory.createElement(\"button\", _base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_ID);\n        this.torchController = new TorchController(torchCapability, this, onTorchActionFailureCallback);\n    }\n    TorchButton.prototype.render = function(parentElement, torchButtonOptions) {\n        var _this = this;\n        this.torchButton.innerText = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOnButton();\n        this.torchButton.style.display = torchButtonOptions.display;\n        this.torchButton.style.marginLeft = torchButtonOptions.marginLeft;\n        var $this = this;\n        this.torchButton.addEventListener(\"click\", function(_) {\n            return __awaiter(_this, void 0, void 0, function() {\n                return __generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            return [\n                                4,\n                                $this.torchController.flipState()\n                            ];\n                        case 1:\n                            _a.sent();\n                            if ($this.torchController.isTorchEnabled()) {\n                                $this.torchButton.classList.remove(_base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF);\n                                $this.torchButton.classList.add(_base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON);\n                            } else {\n                                $this.torchButton.classList.remove(_base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON);\n                                $this.torchButton.classList.add(_base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF);\n                            }\n                            return [\n                                2\n                            ];\n                    }\n                });\n            });\n        });\n        parentElement.appendChild(this.torchButton);\n    };\n    TorchButton.prototype.updateTorchCapability = function(torchCapability) {\n        this.torchController = new TorchController(torchCapability, this, this.onTorchActionFailureCallback);\n    };\n    TorchButton.prototype.getTorchButton = function() {\n        return this.torchButton;\n    };\n    TorchButton.prototype.hide = function() {\n        this.torchButton.style.display = \"none\";\n    };\n    TorchButton.prototype.show = function() {\n        this.torchButton.style.display = \"inline-block\";\n    };\n    TorchButton.prototype.disable = function() {\n        this.torchButton.disabled = true;\n    };\n    TorchButton.prototype.enable = function() {\n        this.torchButton.disabled = false;\n    };\n    TorchButton.prototype.setText = function(text) {\n        this.torchButton.innerText = text;\n    };\n    TorchButton.prototype.reset = function() {\n        this.torchButton.innerText = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOnButton();\n        this.torchController.reset();\n    };\n    TorchButton.create = function(parentElement, torchCapability, torchButtonOptions, onTorchActionFailureCallback) {\n        var button = new TorchButton(torchCapability, onTorchActionFailureCallback);\n        button.render(parentElement, torchButtonOptions);\n        return button;\n    };\n    return TorchButton;\n}();\n //# sourceMappingURL=torch-button.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL3RvcmNoLWJ1dHRvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDQSxJQUFJTyxjQUFjLFNBQUssSUFBSSxTQUFJLENBQUNBLFdBQVcsSUFBSyxTQUFVbEIsT0FBTyxFQUFFbUIsSUFBSTtJQUNuRSxJQUFJQyxJQUFJO1FBQUVDLE9BQU87UUFBR0MsTUFBTTtZQUFhLElB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QUFPLEdBQUc7SUFDckM7SUFDQVgsWUFBWWxCLFNBQVMsQ0FBQzBDLElBQUksR0FBRztRQUN6QixJQUFJLENBQUN2QixXQUFXLENBQUNTLEtBQUssQ0FBQ0MsT0FBTyxHQUFHO0lBQ3JDO0lBQ0FYLFlBQVlsQixTQUFTLENBQUNNLE9BQU8sR0FBRztRQUM1QixJQUFJLENBQUNhLFdBQVcsQ0FBQ3dCLFFBQVEsR0FBRztJQUNoQztJQUNBekIsWUFBWWxCLFNBQVMsQ0FBQ1MsTUFBTSxHQUFHO1FBQzNCLElBQUksQ0FBQ1UsV0FBVyxDQUFDd0IsUUFBUSxHQUFHO0lBQ2hDO0lBQ0F6QixZQUFZbEIsU0FBUyxDQUFDVSxPQUFPLEdBQUcsU0FBVWtDLElBQUk7UUFDMUMsSUFBSSxDQUFDekIsV0FBVyxDQUFDUSxTQUFTLEdBQUdpQjtJQUNqQztJQUNBMUIsWUFBWWxCLFNBQVMsQ0FBQ2lCLEtBQUssR0FBRztRQUMxQixJQUFJLENBQUNFLFdBQVcsQ0FBQ1EsU0FBUyxHQUFHbkMsK0RBQXlCQSxDQUFDb0IsYUFBYTtRQUNwRSxJQUFJLENBQUNVLGVBQWUsQ0FBQ0wsS0FBSztJQUM5QjtJQUNBQyxZQUFZMkIsTUFBTSxHQUFHLFNBQVVyQixhQUFhLEVBQUU1QixlQUFlLEVBQUU2QixrQkFBa0IsRUFBRTNCLDRCQUE0QjtRQUMzRyxJQUFJZ0QsU0FBUyxJQUFJNUIsWUFBWXRCLGlCQUFpQkU7UUFDOUNnRCxPQUFPdkIsTUFBTSxDQUFDQyxlQUFlQztRQUM3QixPQUFPcUI7SUFDWDtJQUNBLE9BQU81QjtBQUNYO0FBQ3VCLENBQ3ZCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL21pY3JvcG9zLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdWkvc2Nhbm5lci90b3JjaC1idXR0b24uanM/YTliZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5pbXBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzIH0gZnJvbSBcIi4uLy4uL3N0cmluZ3NcIjtcbmltcG9ydCB7IEJhc2VVaUVsZW1lbnRGYWN0b3J5LCBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMgfSBmcm9tIFwiLi9iYXNlXCI7XG52YXIgVG9yY2hDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb3JjaENvbnRyb2xsZXIodG9yY2hDYXBhYmlsaXR5LCBidXR0b25Db250cm9sbGVyLCBvblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaXNUb3JjaE9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMudG9yY2hDYXBhYmlsaXR5ID0gdG9yY2hDYXBhYmlsaXR5O1xuICAgICAgICB0aGlzLmJ1dHRvbkNvbnRyb2xsZXIgPSBidXR0b25Db250cm9sbGVyO1xuICAgICAgICB0aGlzLm9uVG9yY2hBY3Rpb25GYWlsdXJlQ2FsbGJhY2sgPSBvblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrO1xuICAgIH1cbiAgICBUb3JjaENvbnRyb2xsZXIucHJvdG90eXBlLmlzVG9yY2hFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1RvcmNoT247XG4gICAgfTtcbiAgICBUb3JjaENvbnRyb2xsZXIucHJvdG90eXBlLmZsaXBTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlzVG9yY2hPbkV4cGVjdGVkLCBlcnJvcl8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25Db250cm9sbGVyLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVG9yY2hPbkV4cGVjdGVkID0gIXRoaXMuaXNUb3JjaE9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLnRvcmNoQ2FwYWJpbGl0eS5hcHBseShpc1RvcmNoT25FeHBlY3RlZCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVVpQmFzZWRPbkxhdGVzdFNldHRpbmdzKHRoaXMudG9yY2hDYXBhYmlsaXR5LnZhbHVlKCksIGlzVG9yY2hPbkV4cGVjdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZUZhaWx1cmUoaXNUb3JjaE9uRXhwZWN0ZWQsIGVycm9yXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25Db250cm9sbGVyLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRvcmNoQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlVWlCYXNlZE9uTGF0ZXN0U2V0dGluZ3MgPSBmdW5jdGlvbiAoaXNUb3JjaE9uLCBpc1RvcmNoT25FeHBlY3RlZCkge1xuICAgICAgICBpZiAoaXNUb3JjaE9uID09PSBpc1RvcmNoT25FeHBlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5idXR0b25Db250cm9sbGVyLnNldFRleHQoaXNUb3JjaE9uRXhwZWN0ZWRcbiAgICAgICAgICAgICAgICA/IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudG9yY2hPZmZCdXR0b24oKVxuICAgICAgICAgICAgICAgIDogSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50b3JjaE9uQnV0dG9uKCkpO1xuICAgICAgICAgICAgdGhpcy5pc1RvcmNoT24gPSBpc1RvcmNoT25FeHBlY3RlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlRmFpbHVyZShpc1RvcmNoT25FeHBlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idXR0b25Db250cm9sbGVyLmVuYWJsZSgpO1xuICAgIH07XG4gICAgVG9yY2hDb250cm9sbGVyLnByb3RvdHlwZS5wcm9wYWdhdGVGYWlsdXJlID0gZnVuY3Rpb24gKGlzVG9yY2hPbkV4cGVjdGVkLCBlcnJvcikge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gaXNUb3JjaE9uRXhwZWN0ZWRcbiAgICAgICAgICAgID8gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50b3JjaE9uRmFpbGVkTWVzc2FnZSgpXG4gICAgICAgICAgICA6IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudG9yY2hPZmZGYWlsZWRNZXNzYWdlKCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IFwiOyBFcnJvciA9IFwiICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrKGVycm9yTWVzc2FnZSk7XG4gICAgfTtcbiAgICBUb3JjaENvbnRyb2xsZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzVG9yY2hPbiA9IGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIFRvcmNoQ29udHJvbGxlcjtcbn0oKSk7XG52YXIgVG9yY2hCdXR0b24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvcmNoQnV0dG9uKHRvcmNoQ2FwYWJpbGl0eSwgb25Ub3JjaEFjdGlvbkZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9uVG9yY2hBY3Rpb25GYWlsdXJlQ2FsbGJhY2sgPSBvblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrO1xuICAgICAgICB0aGlzLnRvcmNoQnV0dG9uXG4gICAgICAgICAgICA9IEJhc2VVaUVsZW1lbnRGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLlRPUkNIX0JVVFRPTl9JRCk7XG4gICAgICAgIHRoaXMudG9yY2hDb250cm9sbGVyID0gbmV3IFRvcmNoQ29udHJvbGxlcih0b3JjaENhcGFiaWxpdHksIHRoaXMsIG9uVG9yY2hBY3Rpb25GYWlsdXJlQ2FsbGJhY2spO1xuICAgIH1cbiAgICBUb3JjaEJ1dHRvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIHRvcmNoQnV0dG9uT3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRvcmNoQnV0dG9uLmlubmVyVGV4dFxuICAgICAgICAgICAgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnRvcmNoT25CdXR0b24oKTtcbiAgICAgICAgdGhpcy50b3JjaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gdG9yY2hCdXR0b25PcHRpb25zLmRpc3BsYXk7XG4gICAgICAgIHRoaXMudG9yY2hCdXR0b24uc3R5bGUubWFyZ2luTGVmdCA9IHRvcmNoQnV0dG9uT3B0aW9ucy5tYXJnaW5MZWZ0O1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRvcmNoQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoXykgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsICR0aGlzLnRvcmNoQ29udHJvbGxlci5mbGlwU3RhdGUoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdGhpcy50b3JjaENvbnRyb2xsZXIuaXNUb3JjaEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRvcmNoQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLlRPUkNIX0JVVFRPTl9DTEFTU19UT1JDSF9PRkYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRvcmNoQnV0dG9uLmNsYXNzTGlzdC5hZGQoUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLlRPUkNIX0JVVFRPTl9DTEFTU19UT1JDSF9PTik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50b3JjaEJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5UT1JDSF9CVVRUT05fQ0xBU1NfVE9SQ0hfT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRvcmNoQnV0dG9uLmNsYXNzTGlzdC5hZGQoUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLlRPUkNIX0JVVFRPTl9DTEFTU19UT1JDSF9PRkYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudG9yY2hCdXR0b24pO1xuICAgIH07XG4gICAgVG9yY2hCdXR0b24ucHJvdG90eXBlLnVwZGF0ZVRvcmNoQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICh0b3JjaENhcGFiaWxpdHkpIHtcbiAgICAgICAgdGhpcy50b3JjaENvbnRyb2xsZXIgPSBuZXcgVG9yY2hDb250cm9sbGVyKHRvcmNoQ2FwYWJpbGl0eSwgdGhpcywgdGhpcy5vblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFRvcmNoQnV0dG9uLnByb3RvdHlwZS5nZXRUb3JjaEJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9yY2hCdXR0b247XG4gICAgfTtcbiAgICBUb3JjaEJ1dHRvbi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b3JjaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfTtcbiAgICBUb3JjaEJ1dHRvbi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b3JjaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICB9O1xuICAgIFRvcmNoQnV0dG9uLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRvcmNoQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFRvcmNoQnV0dG9uLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudG9yY2hCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIFRvcmNoQnV0dG9uLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdGhpcy50b3JjaEJ1dHRvbi5pbm5lclRleHQgPSB0ZXh0O1xuICAgIH07XG4gICAgVG9yY2hCdXR0b24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRvcmNoQnV0dG9uLmlubmVyVGV4dCA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudG9yY2hPbkJ1dHRvbigpO1xuICAgICAgICB0aGlzLnRvcmNoQ29udHJvbGxlci5yZXNldCgpO1xuICAgIH07XG4gICAgVG9yY2hCdXR0b24uY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIHRvcmNoQ2FwYWJpbGl0eSwgdG9yY2hCdXR0b25PcHRpb25zLCBvblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBidXR0b24gPSBuZXcgVG9yY2hCdXR0b24odG9yY2hDYXBhYmlsaXR5LCBvblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrKTtcbiAgICAgICAgYnV0dG9uLnJlbmRlcihwYXJlbnRFbGVtZW50LCB0b3JjaEJ1dHRvbk9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH07XG4gICAgcmV0dXJuIFRvcmNoQnV0dG9uO1xufSgpKTtcbmV4cG9ydCB7IFRvcmNoQnV0dG9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b3JjaC1idXR0b24uanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fZ2VuZXJhdG9yIiwiYm9keSIsIl8iLCJsYWJlbCIsInNlbnQiLCJ0IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm4iLCJ2Iiwib3AiLCJUeXBlRXJyb3IiLCJjYWxsIiwicG9wIiwibGVuZ3RoIiwicHVzaCIsIkh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MiLCJCYXNlVWlFbGVtZW50RmFjdG9yeSIsIlB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3NlcyIsIlRvcmNoQ29udHJvbGxlciIsInRvcmNoQ2FwYWJpbGl0eSIsImJ1dHRvbkNvbnRyb2xsZXIiLCJvblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrIiwiaXNUb3JjaE9uIiwicHJvdG90eXBlIiwiaXNUb3JjaEVuYWJsZWQiLCJmbGlwU3RhdGUiLCJpc1RvcmNoT25FeHBlY3RlZCIsImVycm9yXzEiLCJfYSIsImRpc2FibGUiLCJ1cGRhdGVVaUJhc2VkT25MYXRlc3RTZXR0aW5ncyIsInByb3BhZ2F0ZUZhaWx1cmUiLCJlbmFibGUiLCJzZXRUZXh0IiwidG9yY2hPZmZCdXR0b24iLCJ0b3JjaE9uQnV0dG9uIiwiZXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJ0b3JjaE9uRmFpbGVkTWVzc2FnZSIsInRvcmNoT2ZmRmFpbGVkTWVzc2FnZSIsInJlc2V0IiwiVG9yY2hCdXR0b24iLCJ0b3JjaEJ1dHRvbiIsImNyZWF0ZUVsZW1lbnQiLCJUT1JDSF9CVVRUT05fSUQiLCJ0b3JjaENvbnRyb2xsZXIiLCJyZW5kZXIiLCJwYXJlbnRFbGVtZW50IiwidG9yY2hCdXR0b25PcHRpb25zIiwiX3RoaXMiLCJpbm5lclRleHQiLCJzdHlsZSIsImRpc3BsYXkiLCJtYXJnaW5MZWZ0IiwiJHRoaXMiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiVE9SQ0hfQlVUVE9OX0NMQVNTX1RPUkNIX09GRiIsImFkZCIsIlRPUkNIX0JVVFRPTl9DTEFTU19UT1JDSF9PTiIsImFwcGVuZENoaWxkIiwidXBkYXRlVG9yY2hDYXBhYmlsaXR5IiwiZ2V0VG9yY2hCdXR0b24iLCJoaWRlIiwic2hvdyIsImRpc2FibGVkIiwidGV4dCIsImNyZWF0ZSIsImJ1dHRvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/ui/scanner/torch-button.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/utils.js":
/*!************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/utils.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VideoConstraintsUtil: () => (/* binding */ VideoConstraintsUtil)\n/* harmony export */ });\nvar VideoConstraintsUtil = function() {\n    function VideoConstraintsUtil() {}\n    VideoConstraintsUtil.isMediaStreamConstraintsValid = function(videoConstraints, logger) {\n        if (typeof videoConstraints !== \"object\") {\n            var typeofVideoConstraints = typeof videoConstraints;\n            logger.logError(\"videoConstraints should be of type object, the \" + \"object passed is of type \".concat(typeofVideoConstraints, \".\"), true);\n            return false;\n        }\n        var bannedKeys = [\n            \"autoGainControl\",\n            \"channelCount\",\n            \"echoCancellation\",\n            \"latency\",\n            \"noiseSuppression\",\n            \"sampleRate\",\n            \"sampleSize\",\n            \"volume\"\n        ];\n        var bannedkeysSet = new Set(bannedKeys);\n        var keysInVideoConstraints = Object.keys(videoConstraints);\n        for(var _i = 0, keysInVideoConstraints_1 = keysInVideoConstraints; _i < keysInVideoConstraints_1.length; _i++){\n            var key = keysInVideoConstraints_1[_i];\n            if (bannedkeysSet.has(key)) {\n                logger.logError(\"\".concat(key, \" is not supported videoConstaints.\"), true);\n                return false;\n            }\n        }\n        return true;\n    };\n    return VideoConstraintsUtil;\n}();\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsdUJBQXdCO0lBQ3hCLFNBQVNBLHdCQUNUO0lBQ0FBLHFCQUFxQkMsNkJBQTZCLEdBQUcsU0FBVUMsZ0JBQWdCLEVBQUVDLE1BQU07UUFDbkYsSUFBSSxPQUFPRCxxQkFBcUIsVUFBVTtZQUN0QyxJQUFJRSx5QkFBeUIsT0FBT0Y7WUFDcENDLE9BQU9FLFFBQVEsQ0FBQyxvREFDViw0QkFBNEJDLE1BQU0sQ0FBQ0Ysd0JBQXdCLE1BQU07WUFDdkUsT0FBTztRQUNYO1FBQ0EsSUFBSUcsYUFBYTtZQUNiO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDSDtRQUNELElBQUlDLGdCQUFnQixJQUFJQyxJQUFJRjtRQUM1QixJQUFJRyx5QkFBeUJDLE9BQU9DLElBQUksQ0FBQ1Y7UUFDekMsSUFBSyxJQUFJVyxLQUFLLEdBQUdDLDJCQUEyQkosd0JBQXdCRyxLQUFLQyx5QkFBeUJDLE1BQU0sRUFBRUYsS0FBTTtZQUM1RyxJQUFJRyxNQUFNRix3QkFBd0IsQ0FBQ0QsR0FBRztZQUN0QyxJQUFJTCxjQUFjUyxHQUFHLENBQUNELE1BQU07Z0JBQ3hCYixPQUFPRSxRQUFRLENBQUMsR0FBR0MsTUFBTSxDQUFDVSxLQUFLLHVDQUF1QztnQkFDdEUsT0FBTztZQUNYO1FBQ0o7UUFDQSxPQUFPO0lBQ1g7SUFDQSxPQUFPaEI7QUFDWDtBQUNnQyxDQUNoQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb3Bvcy8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3V0aWxzLmpzPzkzNjUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFZpZGVvQ29uc3RyYWludHNVdGlsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWRlb0NvbnN0cmFpbnRzVXRpbCgpIHtcbiAgICB9XG4gICAgVmlkZW9Db25zdHJhaW50c1V0aWwuaXNNZWRpYVN0cmVhbUNvbnN0cmFpbnRzVmFsaWQgPSBmdW5jdGlvbiAodmlkZW9Db25zdHJhaW50cywgbG9nZ2VyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmlkZW9Db25zdHJhaW50cyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdmFyIHR5cGVvZlZpZGVvQ29uc3RyYWludHMgPSB0eXBlb2YgdmlkZW9Db25zdHJhaW50cztcbiAgICAgICAgICAgIGxvZ2dlci5sb2dFcnJvcihcInZpZGVvQ29uc3RyYWludHMgc2hvdWxkIGJlIG9mIHR5cGUgb2JqZWN0LCB0aGUgXCJcbiAgICAgICAgICAgICAgICArIFwib2JqZWN0IHBhc3NlZCBpcyBvZiB0eXBlIFwiLmNvbmNhdCh0eXBlb2ZWaWRlb0NvbnN0cmFpbnRzLCBcIi5cIiksIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYW5uZWRLZXlzID0gW1xuICAgICAgICAgICAgXCJhdXRvR2FpbkNvbnRyb2xcIixcbiAgICAgICAgICAgIFwiY2hhbm5lbENvdW50XCIsXG4gICAgICAgICAgICBcImVjaG9DYW5jZWxsYXRpb25cIixcbiAgICAgICAgICAgIFwibGF0ZW5jeVwiLFxuICAgICAgICAgICAgXCJub2lzZVN1cHByZXNzaW9uXCIsXG4gICAgICAgICAgICBcInNhbXBsZVJhdGVcIixcbiAgICAgICAgICAgIFwic2FtcGxlU2l6ZVwiLFxuICAgICAgICAgICAgXCJ2b2x1bWVcIlxuICAgICAgICBdO1xuICAgICAgICB2YXIgYmFubmVka2V5c1NldCA9IG5ldyBTZXQoYmFubmVkS2V5cyk7XG4gICAgICAgIHZhciBrZXlzSW5WaWRlb0NvbnN0cmFpbnRzID0gT2JqZWN0LmtleXModmlkZW9Db25zdHJhaW50cyk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwga2V5c0luVmlkZW9Db25zdHJhaW50c18xID0ga2V5c0luVmlkZW9Db25zdHJhaW50czsgX2kgPCBrZXlzSW5WaWRlb0NvbnN0cmFpbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c0luVmlkZW9Db25zdHJhaW50c18xW19pXTtcbiAgICAgICAgICAgIGlmIChiYW5uZWRrZXlzU2V0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZ0Vycm9yKFwiXCIuY29uY2F0KGtleSwgXCIgaXMgbm90IHN1cHBvcnRlZCB2aWRlb0NvbnN0YWludHMuXCIpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gVmlkZW9Db25zdHJhaW50c1V0aWw7XG59KCkpO1xuZXhwb3J0IHsgVmlkZW9Db25zdHJhaW50c1V0aWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJWaWRlb0NvbnN0cmFpbnRzVXRpbCIsImlzTWVkaWFTdHJlYW1Db25zdHJhaW50c1ZhbGlkIiwidmlkZW9Db25zdHJhaW50cyIsImxvZ2dlciIsInR5cGVvZlZpZGVvQ29uc3RyYWludHMiLCJsb2dFcnJvciIsImNvbmNhdCIsImJhbm5lZEtleXMiLCJiYW5uZWRrZXlzU2V0IiwiU2V0Iiwia2V5c0luVmlkZW9Db25zdHJhaW50cyIsIk9iamVjdCIsImtleXMiLCJfaSIsImtleXNJblZpZGVvQ29uc3RyYWludHNfMSIsImxlbmd0aCIsImtleSIsImhhcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZXingHtml5QrcodeDecoder: () => (/* binding */ ZXingHtml5QrcodeDecoder)\n/* harmony export */ });\n/* harmony import */ var _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../third_party/zxing-js.umd */ \"(ssr)/./node_modules/html5-qrcode/third_party/zxing-js.umd.js\");\n/* harmony import */ var _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ \"(ssr)/./node_modules/html5-qrcode/esm/core.js\");\n\n\nvar ZXingHtml5QrcodeDecoder = function() {\n    function ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger) {\n        this.formatMap = new Map([\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.QR_CODE,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.QR_CODE\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.AZTEC,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.AZTEC\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.CODABAR,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.CODABAR\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.CODE_39,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.CODE_39\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.CODE_93,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.CODE_93\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.CODE_128,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.CODE_128\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.DATA_MATRIX,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.DATA_MATRIX\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.MAXICODE,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.MAXICODE\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.ITF,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.ITF\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.EAN_13,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.EAN_13\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.EAN_8,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.EAN_8\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.PDF_417,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.PDF_417\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.RSS_14,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.RSS_14\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.RSS_EXPANDED,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.RSS_EXPANDED\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.UPC_A,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.UPC_A\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.UPC_E,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.UPC_E\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.UPC_EAN_EXTENSION\n            ]\n        ]);\n        this.reverseFormatMap = this.createReverseFormatMap();\n        if (!_third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__) {\n            throw \"Use html5qrcode.min.js without edit, ZXing not found.\";\n        }\n        this.verbose = verbose;\n        this.logger = logger;\n        var formats = this.createZXingFormats(requestedFormats);\n        var hints = new Map();\n        hints.set(_third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.DecodeHintType.POSSIBLE_FORMATS, formats);\n        hints.set(_third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.DecodeHintType.TRY_HARDER, false);\n        this.hints = hints;\n    }\n    ZXingHtml5QrcodeDecoder.prototype.decodeAsync = function(canvas) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(_this.decode(canvas));\n            } catch (error) {\n                reject(error);\n            }\n        });\n    };\n    ZXingHtml5QrcodeDecoder.prototype.decode = function(canvas) {\n        var zxingDecoder = new _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.MultiFormatReader(this.verbose, this.hints);\n        var luminanceSource = new _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.HTMLCanvasElementLuminanceSource(canvas);\n        var binaryBitmap = new _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BinaryBitmap(new _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.HybridBinarizer(luminanceSource));\n        var result = zxingDecoder.decode(binaryBitmap);\n        return {\n            text: result.text,\n            format: _core__WEBPACK_IMPORTED_MODULE_1__.QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(result.format)),\n            debugData: this.createDebugData()\n        };\n    };\n    ZXingHtml5QrcodeDecoder.prototype.createReverseFormatMap = function() {\n        var result = new Map();\n        this.formatMap.forEach(function(value, key, _) {\n            result.set(value, key);\n        });\n        return result;\n    };\n    ZXingHtml5QrcodeDecoder.prototype.toHtml5QrcodeSupportedFormats = function(zxingFormat) {\n        if (!this.reverseFormatMap.has(zxingFormat)) {\n            throw \"reverseFormatMap doesn't have \".concat(zxingFormat);\n        }\n        return this.reverseFormatMap.get(zxingFormat);\n    };\n    ZXingHtml5QrcodeDecoder.prototype.createZXingFormats = function(requestedFormats) {\n        var zxingFormats = [];\n        for(var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++){\n            var requestedFormat = requestedFormats_1[_i];\n            if (this.formatMap.has(requestedFormat)) {\n                zxingFormats.push(this.formatMap.get(requestedFormat));\n            } else {\n                this.logger.logError(\"\".concat(requestedFormat, \" is not supported by\") + \"ZXingHtml5QrcodeShim\");\n            }\n        }\n        return zxingFormats;\n    };\n    ZXingHtml5QrcodeDecoder.prototype.createDebugData = function() {\n        return {\n            decoderName: \"zxing-js\"\n        };\n    };\n    return ZXingHtml5QrcodeDecoder;\n}();\n //# sourceMappingURL=zxing-html5-qrcode-decoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS96eGluZy1odG1sNS1xcmNvZGUtZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXFEO0FBQ29CO0FBQ3pFLElBQUlHLDBCQUEyQjtJQUMzQixTQUFTQSx3QkFBd0JDLGdCQUFnQixFQUFFQyxPQUFPLEVBQUVDLE1BQU07UUFDOUQsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSUMsSUFBSTtZQUNyQjtnQkFBQ04sOERBQTJCQSxDQUFDTyxPQUFPO2dCQUFFVCxvRUFBbUIsQ0FBQ1MsT0FBTzthQUFDO1lBQ2xFO2dCQUFDUCw4REFBMkJBLENBQUNTLEtBQUs7Z0JBQUVYLG9FQUFtQixDQUFDVyxLQUFLO2FBQUM7WUFDOUQ7Z0JBQUNULDhEQUEyQkEsQ0FBQ1UsT0FBTztnQkFBRVosb0VBQW1CLENBQUNZLE9BQU87YUFBQztZQUNsRTtnQkFBQ1YsOERBQTJCQSxDQUFDVyxPQUFPO2dCQUFFYixvRUFBbUIsQ0FBQ2EsT0FBTzthQUFDO1lBQ2xFO2dCQUFDWCw4REFBMkJBLENBQUNZLE9BQU87Z0JBQUVkLG9FQUFtQixDQUFDYyxPQUFPO2FBQUM7WUFDbEU7Z0JBQ0laLDhEQUEyQkEsQ0FBQ2EsUUFBUTtnQkFDcENmLG9FQUFtQixDQUFDZSxRQUFRO2FBQy9CO1lBQ0Q7Z0JBQ0liLDhEQUEyQkEsQ0FBQ2MsV0FBVztnQkFDdkNoQixvRUFBbUIsQ0FBQ2dCLFdBQVc7YUFDbEM7WUFDRDtnQkFDSWQsOERBQTJCQSxDQUFDZSxRQUFRO2dCQUNwQ2pCLG9FQUFtQixDQUFDaUIsUUFBUTthQUMvQjtZQUNEO2dCQUFDZiw4REFBMkJBLENBQUNnQixHQUFHO2dCQUFFbEIsb0VBQW1CLENBQUNrQixHQUFHO2FBQUM7WUFDMUQ7Z0JBQUNoQiw4REFBMkJBLENBQUNpQixNQUFNO2dCQUFFbkIsb0VBQW1CLENBQUNtQixNQUFNO2FBQUM7WUFDaEU7Z0JBQUNqQiw4REFBMkJBLENBQUNrQixLQUFLO2dCQUFF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QUNOLGtCQUFrQixHQUFHLFNBQVUxQixnQkFBZ0I7UUFDN0UsSUFBSStELGVBQWUsRUFBRTtRQUNyQixJQUFLLElBQUlDLEtBQUssR0FBR0MscUJBQXFCakUsa0JBQWtCZ0UsS0FBS0MsbUJBQW1CQyxNQUFNLEVBQUVGLEtBQU07WUFDMUYsSUFBSUcsa0JBQWtCRixrQkFBa0IsQ0FBQ0QsR0FBRztZQUM1QyxJQUFJLElBQUksQ0FBQzdELFNBQVMsQ0FBQ3lELEdBQUcsQ0FBQ08sa0JBQWtCO2dCQUNyQ0osYUFBYUssSUFBSSxDQUFDLElBQUksQ0FBQ2pFLFNBQVMsQ0FBQzJELEdBQUcsQ0FBQ0s7WUFDekMsT0FDSztnQkFDRCxJQUFJLENBQUNqRSxNQUFNLENBQUNtRSxRQUFRLENBQUMsR0FBR1IsTUFBTSxDQUFDTSxpQkFBaUIsMEJBQzFDO1lBQ1Y7UUFDSjtRQUNBLE9BQU9KO0lBQ1g7SUFDQWhFLHdCQUF3QmlDLFNBQVMsQ0FBQ3NCLGVBQWUsR0FBRztRQUNoRCxPQUFPO1lBQUVnQixhQUFhO1FBQVc7SUFDckM7SUFDQSxPQUFPdkU7QUFDWDtBQUNtQyxDQUNuQyxzREFBc0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb3Bvcy8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3p4aW5nLWh0bWw1LXFyY29kZS1kZWNvZGVyLmpzP2M0ZjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgWlhpbmcgZnJvbSBcIi4uL3RoaXJkX3BhcnR5L3p4aW5nLWpzLnVtZFwiO1xuaW1wb3J0IHsgUXJjb2RlUmVzdWx0Rm9ybWF0LCBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMgfSBmcm9tIFwiLi9jb3JlXCI7XG52YXIgWlhpbmdIdG1sNVFyY29kZURlY29kZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFpYaW5nSHRtbDVRcmNvZGVEZWNvZGVyKHJlcXVlc3RlZEZvcm1hdHMsIHZlcmJvc2UsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmZvcm1hdE1hcCA9IG5ldyBNYXAoW1xuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5RUl9DT0RFLCBaWGluZy5CYXJjb2RlRm9ybWF0LlFSX0NPREVdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5BWlRFQywgWlhpbmcuQmFyY29kZUZvcm1hdC5BWlRFQ10sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREFCQVIsIFpYaW5nLkJhcmNvZGVGb3JtYXQuQ09EQUJBUl0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfMzksIFpYaW5nLkJhcmNvZGVGb3JtYXQuQ09ERV8zOV0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfOTMsIFpYaW5nLkJhcmNvZGVGb3JtYXQuQ09ERV85M10sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfMTI4LFxuICAgICAgICAgICAgICAgIFpYaW5nLkJhcmNvZGVGb3JtYXQuQ09ERV8xMjhcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkRBVEFfTUFUUklYLFxuICAgICAgICAgICAgICAgIFpYaW5nLkJhcmNvZGVGb3JtYXQuREFUQV9NQVRSSVhcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLk1BWElDT0RFLFxuICAgICAgICAgICAgICAgIFpYaW5nLkJhcmNvZGVGb3JtYXQuTUFYSUNPREVcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLklURiwgWlhpbmcuQmFyY29kZUZvcm1hdC5JVEZdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5FQU5fMTMsIFpYaW5nLkJhcmNvZGVGb3JtYXQuRUFOXzEzXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuRUFOXzgsIFpYaW5nLkJhcmNvZGVGb3JtYXQuRUFOXzhdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5QREZfNDE3LCBaWGluZy5CYXJjb2RlRm9ybWF0LlBERl80MTddLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5SU1NfMTQsIFpYaW5nLkJhcmNvZGVGb3JtYXQuUlNTXzE0XSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUlNTX0VYUEFOREVELFxuICAgICAgICAgICAgICAgIFpYaW5nLkJhcmNvZGVGb3JtYXQuUlNTX0VYUEFOREVEXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5VUENfQSwgWlhpbmcuQmFyY29kZUZvcm1hdC5VUENfQV0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19FLCBaWGluZy5CYXJjb2RlRm9ybWF0LlVQQ19FXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuVVBDX0VBTl9FWFRFTlNJT04sXG4gICAgICAgICAgICAgICAgWlhpbmcuQmFyY29kZUZvcm1hdC5VUENfRUFOX0VYVEVOU0lPTlxuICAgICAgICAgICAgXVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5yZXZlcnNlRm9ybWF0TWFwID0gdGhpcy5jcmVhdGVSZXZlcnNlRm9ybWF0TWFwKCk7XG4gICAgICAgIGlmICghWlhpbmcpIHtcbiAgICAgICAgICAgIHRocm93IFwiVXNlIGh0bWw1cXJjb2RlLm1pbi5qcyB3aXRob3V0IGVkaXQsIFpYaW5nIG5vdCBmb3VuZC5cIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcmJvc2UgPSB2ZXJib3NlO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgdmFyIGZvcm1hdHMgPSB0aGlzLmNyZWF0ZVpYaW5nRm9ybWF0cyhyZXF1ZXN0ZWRGb3JtYXRzKTtcbiAgICAgICAgdmFyIGhpbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBoaW50cy5zZXQoWlhpbmcuRGVjb2RlSGludFR5cGUuUE9TU0lCTEVfRk9STUFUUywgZm9ybWF0cyk7XG4gICAgICAgIGhpbnRzLnNldChaWGluZy5EZWNvZGVIaW50VHlwZS5UUllfSEFSREVSLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuaGludHMgPSBoaW50cztcbiAgICB9XG4gICAgWlhpbmdIdG1sNVFyY29kZURlY29kZXIucHJvdG90eXBlLmRlY29kZUFzeW5jID0gZnVuY3Rpb24gKGNhbnZhcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzLmRlY29kZShjYW52YXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgWlhpbmdIdG1sNVFyY29kZURlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgICAgdmFyIHp4aW5nRGVjb2RlciA9IG5ldyBaWGluZy5NdWx0aUZvcm1hdFJlYWRlcih0aGlzLnZlcmJvc2UsIHRoaXMuaGludHMpO1xuICAgICAgICB2YXIgbHVtaW5hbmNlU291cmNlID0gbmV3IFpYaW5nLkhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlKGNhbnZhcyk7XG4gICAgICAgIHZhciBiaW5hcnlCaXRtYXAgPSBuZXcgWlhpbmcuQmluYXJ5Qml0bWFwKG5ldyBaWGluZy5IeWJyaWRCaW5hcml6ZXIobHVtaW5hbmNlU291cmNlKSk7XG4gICAgICAgIHZhciByZXN1bHQgPSB6eGluZ0RlY29kZXIuZGVjb2RlKGJpbmFyeUJpdG1hcCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiByZXN1bHQudGV4dCxcbiAgICAgICAgICAgIGZvcm1hdDogUXJjb2RlUmVzdWx0Rm9ybWF0LmNyZWF0ZSh0aGlzLnRvSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzKHJlc3VsdC5mb3JtYXQpKSxcbiAgICAgICAgICAgIGRlYnVnRGF0YTogdGhpcy5jcmVhdGVEZWJ1Z0RhdGEoKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgWlhpbmdIdG1sNVFyY29kZURlY29kZXIucHJvdG90eXBlLmNyZWF0ZVJldmVyc2VGb3JtYXRNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZm9ybWF0TWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXksIF8pIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQodmFsdWUsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgWlhpbmdIdG1sNVFyY29kZURlY29kZXIucHJvdG90eXBlLnRvSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzID0gZnVuY3Rpb24gKHp4aW5nRm9ybWF0KSB7XG4gICAgICAgIGlmICghdGhpcy5yZXZlcnNlRm9ybWF0TWFwLmhhcyh6eGluZ0Zvcm1hdCkpIHtcbiAgICAgICAgICAgIHRocm93IFwicmV2ZXJzZUZvcm1hdE1hcCBkb2Vzbid0IGhhdmUgXCIuY29uY2F0KHp4aW5nRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlRm9ybWF0TWFwLmdldCh6eGluZ0Zvcm1hdCk7XG4gICAgfTtcbiAgICBaWGluZ0h0bWw1UXJjb2RlRGVjb2Rlci5wcm90b3R5cGUuY3JlYXRlWlhpbmdGb3JtYXRzID0gZnVuY3Rpb24gKHJlcXVlc3RlZEZvcm1hdHMpIHtcbiAgICAgICAgdmFyIHp4aW5nRm9ybWF0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHJlcXVlc3RlZEZvcm1hdHNfMSA9IHJlcXVlc3RlZEZvcm1hdHM7IF9pIDwgcmVxdWVzdGVkRm9ybWF0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RlZEZvcm1hdCA9IHJlcXVlc3RlZEZvcm1hdHNfMVtfaV07XG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtYXRNYXAuaGFzKHJlcXVlc3RlZEZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICB6eGluZ0Zvcm1hdHMucHVzaCh0aGlzLmZvcm1hdE1hcC5nZXQocmVxdWVzdGVkRm9ybWF0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2dFcnJvcihcIlwiLmNvbmNhdChyZXF1ZXN0ZWRGb3JtYXQsIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnlcIilcbiAgICAgICAgICAgICAgICAgICAgKyBcIlpYaW5nSHRtbDVRcmNvZGVTaGltXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB6eGluZ0Zvcm1hdHM7XG4gICAgfTtcbiAgICBaWGluZ0h0bWw1UXJjb2RlRGVjb2Rlci5wcm90b3R5cGUuY3JlYXRlRGVidWdEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBkZWNvZGVyTmFtZTogXCJ6eGluZy1qc1wiIH07XG4gICAgfTtcbiAgICByZXR1cm4gWlhpbmdIdG1sNVFyY29kZURlY29kZXI7XG59KCkpO1xuZXhwb3J0IHsgWlhpbmdIdG1sNVFyY29kZURlY29kZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXp4aW5nLWh0bWw1LXFyY29kZS1kZWNvZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJaWGluZyIsIlFyY29kZVJlc3VsdEZvcm1hdCIsIkh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cyIsIlpYaW5nSHRtbDVRcmNvZGVEZWNvZGVyIiwicmVxdWVzdGVkRm9ybWF0cyIsInZlcmJvc2UiLCJsb2dnZXIiLCJmb3JtYXRNYXAiLCJNYXAiLCJRUl9DT0RFIiwiQmFyY29kZUZvcm1hdCIsIkFaVEVDIiwiQ09EQUJBUiIsIkNPREVfMzkiLCJDT0RFXzkzIiwiQ09ERV8xMjgiLCJEQVRBX01BVFJJWCIsIk1BWElDT0RFIiwiSVRGIiwiRUFOXzEzIiwiRUFOXzgiLCJQREZfNDE3IiwiUlNTXzE0IiwiUlNTX0VYUEFOREVEIiwiVVBDX0EiLCJVUENfRSIsIlVQQ19FQU5fRVhURU5TSU9OIiwicmV2ZXJzZUZvcm1hdE1hcCIsImNyZWF0ZVJldmVyc2VGb3JtYXRNYXAiLCJmb3JtYXRzIiwiY3JlYXRlWlhpbmdGb3JtYXRzIiwiaGludHMiLCJzZXQiLCJEZWNvZGVIaW50VHlwZSIsIlBPU1NJQkxFX0ZPUk1BVFMiLCJUUllfSEFSREVSIiwicHJvdG90eXBlIiwiZGVjb2RlQXN5bmMiLCJjYW52YXMiLCJfdGhpcyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZGVjb2RlIiwiZXJyb3IiLCJ6eGluZ0RlY29kZXIiLCJNdWx0aUZvcm1hdFJlYWRlciIsImx1bWluYW5jZVNvdXJjZSIsIkhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlIiwiYmluYXJ5Qml0bWFwIiwiQmluYXJ5Qml0bWFwIiwiSHlicmlkQmluYXJpemVyIiwicmVzdWx0IiwidGV4dCIsImZvcm1hdCIsImNyZWF0ZSIsInRvSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzIiwiZGVidWdEYXRhIiwiY3JlYXRlRGVidWdEYXRhIiwiZm9yRWFjaCIsInZhbHVlIiwia2V5IiwiXyIsInp4aW5nRm9ybWF0IiwiaGFzIiwiY29uY2F0IiwiZ2V0IiwienhpbmdGb3JtYXRzIiwiX2kiLCJyZXF1ZXN0ZWRGb3JtYXRzXzEiLCJsZW5ndGgiLCJyZXF1ZXN0ZWRGb3JtYXQiLCJwdXNoIiwibG9nRXJyb3IiLCJkZWNvZGVyTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html5-qrcode/third_party/zxing-js.umd.js":
/*!***************************************************************!*\
  !*** ./node_modules/html5-qrcode/third_party/zxing-js.umd.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function(global1, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    function isNullOrUndefined(obj) {\n        return obj === null || obj === undefined;\n    }\n    /*\n     * Copyright 2008 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /* global Reflect, Promise */ var extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    function __extends(d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }\n    function fixProto(target, prototype) {\n        var setPrototypeOf = Object.setPrototypeOf;\n        setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n    }\n    function fixStack(target, fn) {\n        if (fn === void 0) {\n            fn = target.constructor;\n        }\n        var captureStackTrace = Error.captureStackTrace;\n        captureStackTrace && captureStackTrace(target, fn);\n    }\n    var CustomError = function(_super) {\n        __extends(CustomError, _super);\n        function CustomError(message) {\n            var _newTarget = this.constructor;\n            var _this = _super.call(this, message) || this;\n            Object.defineProperty(_this, \"name\", {\n                value: _newTarget.name,\n                enumerable: false\n            });\n            fixProto(_this, _newTarget.prototype);\n            fixStack(_this);\n            return _this;\n        }\n        return CustomError;\n    }(Error);\n    /**\n     * Custom Error class of type Exception.\n     */ class Exception extends CustomError {\n        /**\n         * Allows Exception to be constructed directly\n         * with some message and prototype definition.\n         */ constructor(message = undefined){\n            super(message);\n            this.message = message;\n        }\n        getKind() {\n            const ex = this.constructor;\n            return ex.kind;\n        }\n    }\n    /**\n     * It's typed as string so it can be extended and overriden.\n     */ Exception.kind = \"Exception\";\n    /**\n     * Custom Error class of type Exception.\n     */ class ArgumentException extends Exception {\n    }\n    ArgumentException.kind = \"ArgumentException\";\n    /**\n     * Custom Error class of type Exception.\n     */ class IllegalArgumentException extends Exception {\n    }\n    IllegalArgumentException.kind = \"IllegalArgumentException\";\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ class BinaryBitmap {\n        constructor(binarizer){\n            this.binarizer = binarizer;\n            if (binarizer === null) {\n                throw new IllegalArgumentException(\"Binarizer must be non-null.\");\n            }\n        }\n        /**\n         * @return The width of the bitmap.\n         */ getWidth() {\n            return this.binarizer.getWidth();\n        }\n        /**\n         * @return The height of the bitmap.\n         */ getHeight() {\n            return this.binarizer.getHeight();\n        }\n        /**\n         * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return\n         * cached data. Callers should assume this method is expensive and call it as seldom as possible.\n         * This method is intended for decoding 1D barcodes and may choose to apply sharpening.\n         *\n         * @param y The row to fetch, which must be in [0, bitmap height)\n         * @param row An optional preallocated array. If null or too small, it will be ignored.\n         *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.\n         * @return The array of bits for this row (true means black).\n         * @throws NotFoundException if row can't be binarized\n         */ getBlackRow(y /*int*/ , row) {\n            return this.binarizer.getBlackRow(y, row);\n        }\n        /**\n         * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive\n         * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or\n         * may not apply sharpening. Therefore, a row from this matrix may not be identical to one\n         * fetched using getBlackRow(), so don't mix and match between them.\n         *\n         * @return The 2D array of bits for the image (true means black).\n         * @throws NotFoundException if image can't be binarized to make a matrix\n         */ getBlackMatrix() {\n            // The matrix is created on demand the first time it is requested, then cached. There are two\n            // reasons for this:\n            // 1. This work will never be done if the caller only installs 1D Reader objects, or if a\n            //    1D Reader finds a barcode before the 2D Readers run.\n            // 2. This work will only be done once even if the caller installs multiple 2D Readers.\n            if (this.matrix === null || this.matrix === undefined) {\n                this.matrix = this.binarizer.getBlackMatrix();\n            }\n            return this.matrix;\n        }\n        /**\n         * @return Whether this bitmap can be cropped.\n         */ isCropSupported() {\n            return this.binarizer.getLuminanceSource().isCropSupported();\n        }\n        /**\n         * Returns a new object with cropped image data. Implementations may keep a reference to the\n         * original data rather than a copy. Only callable if isCropSupported() is true.\n         *\n         * @param left The left coordinate, which must be in [0,getWidth())\n         * @param top The top coordinate, which must be in [0,getHeight())\n         * @param width The width of the rectangle to crop.\n         * @param height The height of the rectangle to crop.\n         * @return A cropped version of this object.\n         */ crop(left /*int*/ , top /*int*/ , width /*int*/ , height /*int*/ ) {\n            const newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);\n            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n        }\n        /**\n         * @return Whether this bitmap supports counter-clockwise rotation.\n         */ isRotateSupported() {\n            return this.binarizer.getLuminanceSource().isRotateSupported();\n        }\n        /**\n         * Returns a new object with rotated image data by 90 degrees counterclockwise.\n         * Only callable if {@link #isRotateSupported()} is true.\n         *\n         * @return A rotated version of this object.\n         */ rotateCounterClockwise() {\n            const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();\n            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n        }\n        /**\n         * Returns a new object with rotated image data by 45 degrees counterclockwise.\n         * Only callable if {@link #isRotateSupported()} is true.\n         *\n         * @return A rotated version of this object.\n         */ rotateCounterClockwise45() {\n            const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();\n            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n        }\n        /*@Override*/ toString() {\n            try {\n                return this.getBlackMatrix().toString();\n            } catch (e /*: NotFoundException*/ ) {\n                return \"\";\n            }\n        }\n    }\n    /**\n     * Custom Error class of type Exception.\n     */ class ChecksumException extends Exception {\n        static getChecksumInstance() {\n            return new ChecksumException();\n        }\n    }\n    ChecksumException.kind = \"ChecksumException\";\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * This class hierarchy provides a set of methods to convert luminance data to 1 bit data.\n     * It allows the algorithm to vary polymorphically, for example allowing a very expensive\n     * thresholding technique for servers and a fast one for mobile. It also permits the implementation\n     * to vary, e.g. a JNI version for Android and a Java fallback version for other platforms.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */ class Binarizer {\n        constructor(source){\n            this.source = source;\n        }\n        getLuminanceSource() {\n            return this.source;\n        }\n        getWidth() {\n            return this.source.getWidth();\n        }\n        getHeight() {\n            return this.source.getHeight();\n        }\n    }\n    class System {\n        // public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)\n        /**\n         * Makes a copy of a array.\n         */ static arraycopy(src, srcPos, dest, destPos, length) {\n            // TODO: better use split or set?\n            while(length--){\n                dest[destPos++] = src[srcPos++];\n            }\n        }\n        /**\n         * Returns the current time in milliseconds.\n         */ static currentTimeMillis() {\n            return Date.now();\n        }\n    }\n    /**\n     * Custom Error class of type Exception.\n     */ class IndexOutOfBoundsException extends Exception {\n    }\n    IndexOutOfBoundsException.kind = \"IndexOutOfBoundsException\";\n    /**\n     * Custom Error class of type Exception.\n     */ class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException {\n        constructor(index = undefined, message = undefined){\n            super(message);\n            this.index = index;\n            this.message = message;\n        }\n    }\n    ArrayIndexOutOfBoundsException.kind = \"ArrayIndexOutOfBoundsException\";\n    class Arrays {\n        /**\n         * Assigns the specified int value to each element of the specified array\n         * of ints.\n         *\n         * @param a the array to be filled\n         * @param val the value to be stored in all elements of the array\n         */ static fill(a, val) {\n            for(let i = 0, len = a.length; i < len; i++)a[i] = val;\n        }\n        /**\n         * Assigns the specified int value to each element of the specified\n         * range of the specified array of ints.  The range to be filled\n         * extends from index {@code fromIndex}, inclusive, to index\n         * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n         * range to be filled is empty.)\n         *\n         * @param a the array to be filled\n         * @param fromIndex the index of the first element (inclusive) to be\n         *        filled with the specified value\n         * @param toIndex the index of the last element (exclusive) to be\n         *        filled with the specified value\n         * @param val the value to be stored in all elements of the array\n         * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n         * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n         *         {@code toIndex > a.length}\n         */ static fillWithin(a, fromIndex, toIndex, val) {\n            Arrays.rangeCheck(a.length, fromIndex, toIndex);\n            for(let i = fromIndex; i < toIndex; i++)a[i] = val;\n        }\n        /**\n         * Checks that {@code fromIndex} and {@code toIndex} are in\n         * the range and throws an exception if they aren't.\n         */ static rangeCheck(arrayLength, fromIndex, toIndex) {\n            if (fromIndex > toIndex) {\n                throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n            }\n            if (fromIndex < 0) {\n                throw new ArrayIndexOutOfBoundsException(fromIndex);\n            }\n            if (toIndex > arrayLength) {\n                throw new ArrayIndexOutOfBoundsException(toIndex);\n            }\n        }\n        static asList(...args) {\n            return args;\n        }\n        static create(rows, cols, value) {\n            let arr = Array.from({\n                length: rows\n            });\n            return arr.map((x)=>Array.from({\n                    length: cols\n                }).fill(value));\n        }\n        static createInt32Array(rows, cols, value) {\n            let arr = Array.from({\n                length: rows\n            });\n            return arr.map((x)=>Int32Array.from({\n                    length: cols\n                }).fill(value));\n        }\n        static equals(first, second) {\n            if (!first) {\n                return false;\n            }\n            if (!second) {\n                return false;\n            }\n            if (!first.length) {\n                return false;\n            }\n            if (!second.length) {\n                return false;\n            }\n            if (first.length !== second.length) {\n                return false;\n            }\n            for(let i = 0, length = first.length; i < length; i++){\n                if (first[i] !== second[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static hashCode(a) {\n            if (a === null) {\n                return 0;\n            }\n            let result = 1;\n            for (const element of a){\n                result = 31 * result + element;\n            }\n            return result;\n        }\n        static fillUint8Array(a, value) {\n            for(let i = 0; i !== a.length; i++){\n                a[i] = value;\n            }\n        }\n        static copyOf(original, newLength) {\n            return original.slice(0, newLength);\n        }\n        static copyOfUint8Array(original, newLength) {\n            if (original.length <= newLength) {\n                const newArray = new Uint8Array(newLength);\n                newArray.set(original);\n                return newArray;\n            }\n            return original.slice(0, newLength);\n        }\n        static copyOfRange(original, from, to) {\n            const newLength = to - from;\n            const copy = new Int32Array(newLength);\n            System.arraycopy(original, from, copy, 0, newLength);\n            return copy;\n        }\n        /*\n        * Returns the index of of the element in a sorted array or (-n-1) where n is the insertion point\n        * for the new element.\n        * Parameters:\n        *     ar - A sorted array\n        *     el - An element to search for\n        *     comparator - A comparator function. The function takes two arguments: (a, b) and returns:\n        *        a negative number  if a is less than b;\n        *        0 if a is equal to b;\n        *        a positive number of a is greater than b.\n        * The array may contain duplicate elements. If there are more than one equal elements in the array,\n        * the returned value can be the index of any one of the equal elements.\n        *\n        * http://jsfiddle.net/aryzhov/pkfst550/\n        */ static binarySearch(ar, el, comparator) {\n            if (undefined === comparator) {\n                comparator = Arrays.numberComparator;\n            }\n            let m = 0;\n            let n = ar.length - 1;\n            while(m <= n){\n                const k = n + m >> 1;\n                const cmp = comparator(el, ar[k]);\n                if (cmp > 0) {\n                    m = k + 1;\n                } else if (cmp < 0) {\n                    n = k - 1;\n                } else {\n                    return k;\n                }\n            }\n            return -m - 1;\n        }\n        static numberComparator(a, b) {\n            return a - b;\n        }\n    }\n    /**\n     * Ponyfill for Java's Integer class.\n     */ class Integer {\n        static numberOfTrailingZeros(i) {\n            let y;\n            if (i === 0) return 32;\n            let n = 31;\n            y = i << 16;\n            if (y !== 0) {\n                n -= 16;\n                i = y;\n            }\n            y = i << 8;\n            if (y !== 0) {\n                n -= 8;\n                i = y;\n            }\n            y = i << 4;\n            if (y !== 0) {\n                n -= 4;\n                i = y;\n            }\n            y = i << 2;\n            if (y !== 0) {\n                n -= 2;\n                i = y;\n            }\n            return n - (i << 1 >>> 31);\n        }\n        static numberOfLeadingZeros(i) {\n            // HD, Figure 5-6\n            if (i === 0) {\n                return 32;\n            }\n            let n = 1;\n            if (i >>> 16 === 0) {\n                n += 16;\n                i <<= 16;\n            }\n            if (i >>> 24 === 0) {\n                n += 8;\n                i <<= 8;\n            }\n            if (i >>> 28 === 0) {\n                n += 4;\n                i <<= 4;\n            }\n            if (i >>> 30 === 0) {\n                n += 2;\n                i <<= 2;\n            }\n            n -= i >>> 31;\n            return n;\n        }\n        static toHexString(i) {\n            return i.toString(16);\n        }\n        static toBinaryString(intNumber) {\n            return String(parseInt(String(intNumber), 2));\n        }\n        // Returns the number of one-bits in the two's complement binary representation of the specified int value. This function is sometimes referred to as the population count.\n        // Returns:\n        // the number of one-bits in the two's complement binary representation of the specified int value.\n        static bitCount(i) {\n            // HD, Figure 5-2\n            i = i - (i >>> 1 & 0x55555555);\n            i = (i & 0x33333333) + (i >>> 2 & 0x33333333);\n            i = i + (i >>> 4) & 0x0f0f0f0f;\n            i = i + (i >>> 8);\n            i = i + (i >>> 16);\n            return i & 0x3f;\n        }\n        static truncDivision(dividend, divisor) {\n            return Math.trunc(dividend / divisor);\n        }\n        /**\n         * Converts A string to an integer.\n         * @param s A string to convert into a number.\n         * @param radix A value between 2 and 36 that specifies the base of the number in numString. If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal. All other strings are considered decimal.\n         */ static parseInt(num, radix = undefined) {\n            return parseInt(num, radix);\n        }\n    }\n    Integer.MIN_VALUE_32_BITS = -2147483648;\n    Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;\n    /**\n     * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>\n     *\n     * @author Sean Owen\n     */ class BitArray {\n        // For testing only\n        constructor(size /*int*/ , bits){\n            if (undefined === size) {\n                this.size = 0;\n                this.bits = new Int32Array(1);\n            } else {\n                this.size = size;\n                if (undefined === bits || null === bits) {\n                    this.bits = BitArray.makeArray(size);\n                } else {\n                    this.bits = bits;\n                }\n            }\n        }\n        getSize() {\n            return this.size;\n        }\n        getSizeInBytes() {\n            return Math.floor((this.size + 7) / 8);\n        }\n        ensureCapacity(size /*int*/ ) {\n            if (size > this.bits.length * 32) {\n                const newBits = BitArray.makeArray(size);\n                System.arraycopy(this.bits, 0, newBits, 0, this.bits.length);\n                this.bits = newBits;\n            }\n        }\n        /**\n         * @param i bit to get\n         * @return true iff bit i is set\n         */ get(i /*int*/ ) {\n            return (this.bits[Math.floor(i / 32)] & 1 << (i & 0x1F)) !== 0;\n        }\n        /**\n         * Sets bit i.\n         *\n         * @param i bit to set\n         */ set(i /*int*/ ) {\n            this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);\n        }\n        /**\n         * Flips bit i.\n         *\n         * @param i bit to set\n         */ flip(i /*int*/ ) {\n            this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);\n        }\n        /**\n         * @param from first bit to check\n         * @return index of first bit that is set, starting from the given index, or size if none are set\n         *  at or beyond this given index\n         * @see #getNextUnset(int)\n         */ getNextSet(from /*int*/ ) {\n            const size = this.size;\n            if (from >= size) {\n                return size;\n            }\n            const bits = this.bits;\n            let bitsOffset = Math.floor(from / 32);\n            let currentBits = bits[bitsOffset];\n            // mask off lesser bits first\n            currentBits &= ~((1 << (from & 0x1F)) - 1);\n            const length = bits.length;\n            while(currentBits === 0){\n                if (++bitsOffset === length) {\n                    return size;\n                }\n                currentBits = bits[bitsOffset];\n            }\n            const result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);\n            return result > size ? size : result;\n        }\n        /**\n         * @param from index to start looking for unset bit\n         * @return index of next unset bit, or {@code size} if none are unset until the end\n         * @see #getNextSet(int)\n         */ getNextUnset(from /*int*/ ) {\n            const size = this.size;\n            if (from >= size) {\n                return size;\n            }\n            const bits = this.bits;\n            let bitsOffset = Math.floor(from / 32);\n            let currentBits = ~bits[bitsOffset];\n            // mask off lesser bits first\n            currentBits &= ~((1 << (from & 0x1F)) - 1);\n            const length = bits.length;\n            while(currentBits === 0){\n                if (++bitsOffset === length) {\n                    return size;\n                }\n                currentBits = ~bits[bitsOffset];\n            }\n            const result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);\n            return result > size ? size : result;\n        }\n        /**\n         * Sets a block of 32 bits, starting at bit i.\n         *\n         * @param i first bit to set\n         * @param newBits the new value of the next 32 bits. Note again that the least-significant bit\n         * corresponds to bit i, the next-least-significant to i+1, and so on.\n         */ setBulk(i /*int*/ , newBits /*int*/ ) {\n            this.bits[Math.floor(i / 32)] = newBits;\n        }\n        /**\n         * Sets a range of bits.\n         *\n         * @param start start of range, inclusive.\n         * @param end end of range, exclusive\n         */ setRange(start /*int*/ , end /*int*/ ) {\n            if (end < start || start < 0 || end > this.size) {\n                throw new IllegalArgumentException();\n            }\n            if (end === start) {\n                return;\n            }\n            end--; // will be easier to treat this as the last actually set bit -- inclusive\n            const firstInt = Math.floor(start / 32);\n            const lastInt = Math.floor(end / 32);\n            const bits = this.bits;\n            for(let i = firstInt; i <= lastInt; i++){\n                const firstBit = i > firstInt ? 0 : start & 0x1F;\n                const lastBit = i < lastInt ? 31 : end & 0x1F;\n                // Ones from firstBit to lastBit, inclusive\n                const mask = (2 << lastBit) - (1 << firstBit);\n                bits[i] |= mask;\n            }\n        }\n        /**\n         * Clears all bits (sets to false).\n         */ clear() {\n            const max = this.bits.length;\n            const bits = this.bits;\n            for(let i = 0; i < max; i++){\n                bits[i] = 0;\n            }\n        }\n        /**\n         * Efficient method to check if a range of bits is set, or not set.\n         *\n         * @param start start of range, inclusive.\n         * @param end end of range, exclusive\n         * @param value if true, checks that bits in range are set, otherwise checks that they are not set\n         * \n         * @return true iff all bits are set or not set in range, according to value argument\n         * @throws IllegalArgumentException if end is less than start or the range is not contained in the array\n         */ isRange(start /*int*/ , end /*int*/ , value) {\n            if (end < start || start < 0 || end > this.size) {\n                throw new IllegalArgumentException();\n            }\n            if (end === start) {\n                return true; // empty range matches\n            }\n            end--; // will be easier to treat this as the last actually set bit -- inclusive\n            const firstInt = Math.floor(start / 32);\n            const lastInt = Math.floor(end / 32);\n            const bits = this.bits;\n            for(let i = firstInt; i <= lastInt; i++){\n                const firstBit = i > firstInt ? 0 : start & 0x1F;\n                const lastBit = i < lastInt ? 31 : end & 0x1F;\n                // Ones from firstBit to lastBit, inclusive\n                const mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF;\n                // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits\n                // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,\n                // equals the mask, or we're looking for 0s and the masked portion is not all 0s\n                if ((bits[i] & mask) !== (value ? mask : 0)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        appendBit(bit) {\n            this.ensureCapacity(this.size + 1);\n            if (bit) {\n                this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);\n            }\n            this.size++;\n        }\n        /**\n         * Appends the least-significant bits, from value, in order from most-significant to\n         * least-significant. For example, appending 6 bits from 0x000001E will append the bits\n         * 0, 1, 1, 1, 1, 0 in that order.\n         *\n         * @param value {@code int} containing bits to append\n         * @param numBits bits from value to append\n         */ appendBits(value /*int*/ , numBits /*int*/ ) {\n            if (numBits < 0 || numBits > 32) {\n                throw new IllegalArgumentException(\"Num bits must be between 0 and 32\");\n            }\n            this.ensureCapacity(this.size + numBits);\n            // const appendBit = this.appendBit;\n            for(let numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--){\n                this.appendBit((value >> numBitsLeft - 1 & 0x01) === 1);\n            }\n        }\n        appendBitArray(other) {\n            const otherSize = other.size;\n            this.ensureCapacity(this.size + otherSize);\n            // const appendBit = this.appendBit;\n            for(let i = 0; i < otherSize; i++){\n                this.appendBit(other.get(i));\n            }\n        }\n        xor(other) {\n            if (this.size !== other.size) {\n                throw new IllegalArgumentException(\"Sizes don't match\");\n            }\n            const bits = this.bits;\n            for(let i = 0, length = bits.length; i < length; i++){\n                // The last int could be incomplete (i.e. not have 32 bits in\n                // it) but there is no problem since 0 XOR 0 == 0.\n                bits[i] ^= other.bits[i];\n            }\n        }\n        /**\n         *\n         * @param bitOffset first bit to start writing\n         * @param array array to write into. Bytes are written most-significant byte first. This is the opposite\n         *  of the internal representation, which is exposed by {@link #getBitArray()}\n         * @param offset position in array to start writing\n         * @param numBytes how many bytes to write\n         */ toBytes(bitOffset /*int*/ , array, offset /*int*/ , numBytes /*int*/ ) {\n            for(let i = 0; i < numBytes; i++){\n                let theByte = 0;\n                for(let j = 0; j < 8; j++){\n                    if (this.get(bitOffset)) {\n                        theByte |= 1 << 7 - j;\n                    }\n                    bitOffset++;\n                }\n                array[offset + i] = /*(byte)*/ theByte;\n            }\n        }\n        /**\n         * @return underlying array of ints. The first element holds the first 32 bits, and the least\n         *         significant bit is bit 0.\n         */ getBitArray() {\n            return this.bits;\n        }\n        /**\n         * Reverses all bits in the array.\n         */ reverse() {\n            const newBits = new Int32Array(this.bits.length);\n            // reverse all int's first\n            const len = Math.floor((this.size - 1) / 32);\n            const oldBitsLen = len + 1;\n            const bits = this.bits;\n            for(let i = 0; i < oldBitsLen; i++){\n                let x = bits[i];\n                x = x >> 1 & 0x55555555 | (x & 0x55555555) << 1;\n                x = x >> 2 & 0x33333333 | (x & 0x33333333) << 2;\n                x = x >> 4 & 0x0f0f0f0f | (x & 0x0f0f0f0f) << 4;\n                x = x >> 8 & 0x00ff00ff | (x & 0x00ff00ff) << 8;\n                x = x >> 16 & 0x0000ffff | (x & 0x0000ffff) << 16;\n                newBits[len - i] = /*(int)*/ x;\n            }\n            // now correct the int's if the bit size isn't a multiple of 32\n            if (this.size !== oldBitsLen * 32) {\n                const leftOffset = oldBitsLen * 32 - this.size;\n                let currentInt = newBits[0] >>> leftOffset;\n                for(let i = 1; i < oldBitsLen; i++){\n                    const nextInt = newBits[i];\n                    currentInt |= nextInt << 32 - leftOffset;\n                    newBits[i - 1] = currentInt;\n                    currentInt = nextInt >>> leftOffset;\n                }\n                newBits[oldBitsLen - 1] = currentInt;\n            }\n            this.bits = newBits;\n        }\n        static makeArray(size /*int*/ ) {\n            return new Int32Array(Math.floor((size + 31) / 32));\n        }\n        /*@Override*/ equals(o) {\n            if (!(o instanceof BitArray)) {\n                return false;\n            }\n            const other = o;\n            return this.size === other.size && Arrays.equals(this.bits, other.bits);\n        }\n        /*@Override*/ hashCode() {\n            return 31 * this.size + Arrays.hashCode(this.bits);\n        }\n        /*@Override*/ toString() {\n            let result = \"\";\n            for(let i = 0, size = this.size; i < size; i++){\n                if ((i & 0x07) === 0) {\n                    result += \" \";\n                }\n                result += this.get(i) ? \"X\" : \".\";\n            }\n            return result;\n        }\n        /*@Override*/ clone() {\n            return new BitArray(this.size, this.bits.slice());\n        }\n    }\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*namespace com.google.zxing {*/ /**\n     * Encapsulates a type of hint that a caller may pass to a barcode reader to help it\n     * more quickly or accurately decode it. It is up to implementations to decide what,\n     * if anything, to do with the information that is supplied.\n     *\n     * @author Sean Owen\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @see Reader#decode(BinaryBitmap,java.util.Map)\n     */ var DecodeHintType;\n    (function(DecodeHintType) {\n        /**\n         * Unspecified, application-specific hint. Maps to an unspecified {@link Object}.\n         */ DecodeHintType[DecodeHintType[\"OTHER\"] = 0] = \"OTHER\"; /*(Object.class)*/ \n        /**\n         * Image is a pure monochrome image of a barcode. Doesn't matter what it maps to;\n         * use {@link Boolean#TRUE}.\n         */ DecodeHintType[DecodeHintType[\"PURE_BARCODE\"] = 1] = \"PURE_BARCODE\"; /*(Void.class)*/ \n        /**\n         * Image is known to be of one of a few possible formats.\n         * Maps to a {@link List} of {@link BarcodeFormat}s.\n         */ DecodeHintType[DecodeHintType[\"POSSIBLE_FORMATS\"] = 2] = \"POSSIBLE_FORMATS\"; /*(List.class)*/ \n        /**\n         * Spend more time to try to find a barcode; optimize for accuracy, not speed.\n         * Doesn't matter what it maps to; use {@link Boolean#TRUE}.\n         */ DecodeHintType[DecodeHintType[\"TRY_HARDER\"] = 3] = \"TRY_HARDER\"; /*(Void.class)*/ \n        /**\n         * Specifies what character encoding to use when decoding, where applicable (type String)\n         */ DecodeHintType[DecodeHintType[\"CHARACTER_SET\"] = 4] = \"CHARACTER_SET\"; /*(String.class)*/ \n        /**\n         * Allowed lengths of encoded data -- reject anything else. Maps to an {@code Int32Array}.\n         */ DecodeHintType[DecodeHintType[\"ALLOWED_LENGTHS\"] = 5] = \"ALLOWED_LENGTHS\"; /*(Int32Array.class)*/ \n        /**\n         * Assume Code 39 codes employ a check digit. Doesn't matter what it maps to;\n         * use {@link Boolean#TRUE}.\n         */ DecodeHintType[DecodeHintType[\"ASSUME_CODE_39_CHECK_DIGIT\"] = 6] = \"ASSUME_CODE_39_CHECK_DIGIT\"; /*(Void.class)*/ \n        /**\n         * Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.\n         * For example this affects FNC1 handling for Code 128 (aka GS1-128). Doesn't matter what it maps to;\n         * use {@link Boolean#TRUE}.\n         */ DecodeHintType[DecodeHintType[\"ASSUME_GS1\"] = 7] = \"ASSUME_GS1\"; /*(Void.class)*/ \n        /**\n         * If true, return the start and end digits in a Codabar barcode instead of stripping them. They\n         * are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them\n         * to not be. Doesn't matter what it maps to; use {@link Boolean#TRUE}.\n         */ DecodeHintType[DecodeHintType[\"RETURN_CODABAR_START_END\"] = 8] = \"RETURN_CODABAR_START_END\"; /*(Void.class)*/ \n        /**\n         * The caller needs to be notified via callback when a possible {@link ResultPoint}\n         * is found. Maps to a {@link ResultPointCallback}.\n         */ DecodeHintType[DecodeHintType[\"NEED_RESULT_POINT_CALLBACK\"] = 9] = \"NEED_RESULT_POINT_CALLBACK\"; /*(ResultPointCallback.class)*/ \n        /**\n         * Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.\n         * Maps to an {@code Int32Array} of the allowed extension lengths, for example [2], [5], or [2, 5].\n         * If it is optional to have an extension, do not set this hint. If this is set,\n         * and a UPC or EAN barcode is found but an extension is not, then no result will be returned\n         * at all.\n         */ DecodeHintType[DecodeHintType[\"ALLOWED_EAN_EXTENSIONS\"] = 10] = \"ALLOWED_EAN_EXTENSIONS\"; /*(Int32Array.class)*/ \n    // End of enumeration values.\n    /**\n         * Data type the hint is expecting.\n         * Among the possible values the {@link Void} stands out as being used for\n         * hints that do not expect a value to be supplied (flag hints). Such hints\n         * will possibly have their value ignored, or replaced by a\n         * {@link Boolean#TRUE}. Hint suppliers should probably use\n         * {@link Boolean#TRUE} as directed by the actual hint documentation.\n         */ // private valueType: Class<?>\n    // DecodeHintType(valueType: Class<?>) {\n    //   this.valueType = valueType\n    // }\n    // public getValueType(): Class<?> {\n    //   return valueType\n    // }\n    })(DecodeHintType || (DecodeHintType = {}));\n    var DecodeHintType$1 = DecodeHintType;\n    /**\n     * Custom Error class of type Exception.\n     */ class FormatException extends Exception {\n        static getFormatInstance() {\n            return new FormatException();\n        }\n    }\n    FormatException.kind = \"FormatException\";\n    /*import java.util.HashMap;*/ /*import java.util.Map;*/ var CharacterSetValueIdentifiers;\n    (function(CharacterSetValueIdentifiers) {\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp437\"] = 0] = \"Cp437\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_1\"] = 1] = \"ISO8859_1\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_2\"] = 2] = \"ISO8859_2\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_3\"] = 3] = \"ISO8859_3\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_4\"] = 4] = \"ISO8859_4\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_5\"] = 5] = \"ISO8859_5\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_6\"] = 6] = \"ISO8859_6\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_7\"] = 7] = \"ISO8859_7\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_8\"] = 8] = \"ISO8859_8\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_9\"] = 9] = \"ISO8859_9\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_10\"] = 10] = \"ISO8859_10\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_11\"] = 11] = \"ISO8859_11\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_13\"] = 12] = \"ISO8859_13\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_14\"] = 13] = \"ISO8859_14\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_15\"] = 14] = \"ISO8859_15\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_16\"] = 15] = \"ISO8859_16\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"SJIS\"] = 16] = \"SJIS\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1250\"] = 17] = \"Cp1250\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1251\"] = 18] = \"Cp1251\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1252\"] = 19] = \"Cp1252\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1256\"] = 20] = \"Cp1256\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"UnicodeBigUnmarked\"] = 21] = \"UnicodeBigUnmarked\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"UTF8\"] = 22] = \"UTF8\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ASCII\"] = 23] = \"ASCII\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Big5\"] = 24] = \"Big5\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"GB18030\"] = 25] = \"GB18030\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"EUC_KR\"] = 26] = \"EUC_KR\";\n    })(CharacterSetValueIdentifiers || (CharacterSetValueIdentifiers = {}));\n    /**\n     * Encapsulates a Character Set ECI, according to \"Extended Channel Interpretations\" 5.3.1.1\n     * of ISO 18004.\n     *\n     * @author Sean Owen\n     */ class CharacterSetECI {\n        constructor(valueIdentifier, valuesParam, name, ...otherEncodingNames){\n            this.valueIdentifier = valueIdentifier;\n            this.name = name;\n            if (typeof valuesParam === \"number\") {\n                this.values = Int32Array.from([\n                    valuesParam\n                ]);\n            } else {\n                this.values = valuesParam;\n            }\n            this.otherEncodingNames = otherEncodingNames;\n            CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);\n            CharacterSetECI.NAME_TO_ECI.set(name, this);\n            const values = this.values;\n            for(let i = 0, length = values.length; i !== length; i++){\n                const v = values[i];\n                CharacterSetECI.VALUES_TO_ECI.set(v, this);\n            }\n            for (const otherName of otherEncodingNames){\n                CharacterSetECI.NAME_TO_ECI.set(otherName, this);\n            }\n        }\n        // CharacterSetECI(value: number /*int*/) {\n        //   this(new Int32Array {value})\n        // }\n        // CharacterSetECI(value: number /*int*/, String... otherEncodingNames) {\n        //   this.values = new Int32Array {value}\n        //   this.otherEncodingNames = otherEncodingNames\n        // }\n        // CharacterSetECI(values: Int32Array, String... otherEncodingNames) {\n        //   this.values = values\n        //   this.otherEncodingNames = otherEncodingNames\n        // }\n        getValueIdentifier() {\n            return this.valueIdentifier;\n        }\n        getName() {\n            return this.name;\n        }\n        getValue() {\n            return this.values[0];\n        }\n        /**\n         * @param value character set ECI value\n         * @return {@code CharacterSetECI} representing ECI of given value, or null if it is legal but\n         *   unsupported\n         * @throws FormatException if ECI value is invalid\n         */ static getCharacterSetECIByValue(value /*int*/ ) {\n            if (value < 0 || value >= 900) {\n                throw new FormatException(\"incorect value\");\n            }\n            const characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);\n            if (undefined === characterSet) {\n                throw new FormatException(\"incorect value\");\n            }\n            return characterSet;\n        }\n        /**\n         * @param name character set ECI encoding name\n         * @return CharacterSetECI representing ECI for character encoding, or null if it is legal\n         *   but unsupported\n         */ static getCharacterSetECIByName(name) {\n            const characterSet = CharacterSetECI.NAME_TO_ECI.get(name);\n            if (undefined === characterSet) {\n                throw new FormatException(\"incorect value\");\n            }\n            return characterSet;\n        }\n        equals(o) {\n            if (!(o instanceof CharacterSetECI)) {\n                return false;\n            }\n            const other = o;\n            return this.getName() === other.getName();\n        }\n    }\n    CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = new Map();\n    CharacterSetECI.VALUES_TO_ECI = new Map();\n    CharacterSetECI.NAME_TO_ECI = new Map();\n    // Enum name is a Java encoding valid for java.lang and java.io\n    // TYPESCRIPTPORT: changed the main label for ISO as the TextEncoder did not recognized them in the form from java\n    // (eg ISO8859_1 must be ISO88591 or ISO8859-1 or ISO-8859-1)\n    // later on: well, except 16 wich does not work with ISO885916 so used ISO-8859-1 form for default\n    CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([\n        0,\n        2\n    ]), \"Cp437\");\n    CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([\n        1,\n        3\n    ]), \"ISO-8859-1\", \"ISO88591\", \"ISO8859_1\");\n    CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, \"ISO-8859-2\", \"ISO88592\", \"ISO8859_2\");\n    CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, \"ISO-8859-3\", \"ISO88593\", \"ISO8859_3\");\n    CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, \"ISO-8859-4\", \"ISO88594\", \"ISO8859_4\");\n    CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, \"ISO-8859-5\", \"ISO88595\", \"ISO8859_5\");\n    CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, \"ISO-8859-6\", \"ISO88596\", \"ISO8859_6\");\n    CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, \"ISO-8859-7\", \"ISO88597\", \"ISO8859_7\");\n    CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, \"ISO-8859-8\", \"ISO88598\", \"ISO8859_8\");\n    CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, \"ISO-8859-9\", \"ISO88599\", \"ISO8859_9\");\n    CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, \"ISO-8859-10\", \"ISO885910\", \"ISO8859_10\");\n    CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, \"ISO-8859-11\", \"ISO885911\", \"ISO8859_11\");\n    CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, \"ISO-8859-13\", \"ISO885913\", \"ISO8859_13\");\n    CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, \"ISO-8859-14\", \"ISO885914\", \"ISO8859_14\");\n    CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, \"ISO-8859-15\", \"ISO885915\", \"ISO8859_15\");\n    CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, \"ISO-8859-16\", \"ISO885916\", \"ISO8859_16\");\n    CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, \"SJIS\", \"Shift_JIS\");\n    CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, \"Cp1250\", \"windows-1250\");\n    CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, \"Cp1251\", \"windows-1251\");\n    CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, \"Cp1252\", \"windows-1252\");\n    CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, \"Cp1256\", \"windows-1256\");\n    CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, \"UnicodeBigUnmarked\", \"UTF-16BE\", \"UnicodeBig\");\n    CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, \"UTF8\", \"UTF-8\");\n    CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([\n        27,\n        170\n    ]), \"ASCII\", \"US-ASCII\");\n    CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, \"Big5\");\n    CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, \"GB18030\", \"GB2312\", \"EUC_CN\", \"GBK\");\n    CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, \"EUC_KR\", \"EUC-KR\");\n    /**\n     * Custom Error class of type Exception.\n     */ class UnsupportedOperationException extends Exception {\n    }\n    UnsupportedOperationException.kind = \"UnsupportedOperationException\";\n    /**\n     * Responsible for en/decoding strings.\n     */ class StringEncoding {\n        /**\n         * Decodes some Uint8Array to a string format.\n         */ static decode(bytes, encoding) {\n            const encodingName = this.encodingName(encoding);\n            if (this.customDecoder) {\n                return this.customDecoder(bytes, encodingName);\n            }\n            // Increases browser support.\n            if (typeof TextDecoder === \"undefined\" || this.shouldDecodeOnFallback(encodingName)) {\n                return this.decodeFallback(bytes, encodingName);\n            }\n            return new TextDecoder(encodingName).decode(bytes);\n        }\n        /**\n         * Checks if the decoding method should use the fallback for decoding\n         * once Node TextDecoder doesn't support all encoding formats.\n         *\n         * @param encodingName\n         */ static shouldDecodeOnFallback(encodingName) {\n            return !StringEncoding.isBrowser() && encodingName === \"ISO-8859-1\";\n        }\n        /**\n         * Encodes some string into a Uint8Array.\n         */ static encode(s, encoding) {\n            const encodingName = this.encodingName(encoding);\n            if (this.customEncoder) {\n                return this.customEncoder(s, encodingName);\n            }\n            // Increases browser support.\n            if (typeof TextEncoder === \"undefined\") {\n                return this.encodeFallback(s);\n            }\n            // TextEncoder only encodes to UTF8 by default as specified by encoding.spec.whatwg.org\n            return new TextEncoder().encode(s);\n        }\n        static isBrowser() {\n            return  false && 0;\n        }\n        /**\n         * Returns the string value from some encoding character set.\n         */ static encodingName(encoding) {\n            return typeof encoding === \"string\" ? encoding : encoding.getName();\n        }\n        /**\n         * Returns character set from some encoding character set.\n         */ static encodingCharacterSet(encoding) {\n            if (encoding instanceof CharacterSetECI) {\n                return encoding;\n            }\n            return CharacterSetECI.getCharacterSetECIByName(encoding);\n        }\n        /**\n         * Runs a fallback for the native decoding funcion.\n         */ static decodeFallback(bytes, encoding) {\n            const characterSet = this.encodingCharacterSet(encoding);\n            if (StringEncoding.isDecodeFallbackSupported(characterSet)) {\n                let s = \"\";\n                for(let i = 0, length = bytes.length; i < length; i++){\n                    let h = bytes[i].toString(16);\n                    if (h.length < 2) {\n                        h = \"0\" + h;\n                    }\n                    s += \"%\" + h;\n                }\n                return decodeURIComponent(s);\n            }\n            if (characterSet.equals(CharacterSetECI.UnicodeBigUnmarked)) {\n                return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\n            }\n            throw new UnsupportedOperationException(`Encoding ${this.encodingName(encoding)} not supported by fallback.`);\n        }\n        static isDecodeFallbackSupported(characterSet) {\n            return characterSet.equals(CharacterSetECI.UTF8) || characterSet.equals(CharacterSetECI.ISO8859_1) || characterSet.equals(CharacterSetECI.ASCII);\n        }\n        /**\n         * Runs a fallback for the native encoding funcion.\n         *\n         * @see https://stackoverflow.com/a/17192845/4367683\n         */ static encodeFallback(s) {\n            const encodedURIstring = btoa(unescape(encodeURIComponent(s)));\n            const charList = encodedURIstring.split(\"\");\n            const uintArray = [];\n            for(let i = 0; i < charList.length; i++){\n                uintArray.push(charList[i].charCodeAt(0));\n            }\n            return new Uint8Array(uintArray);\n        }\n    }\n    /*\n     * Copyright (C) 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * Common string-related functions.\n     *\n     * @author Sean Owen\n     * @author Alex Dupre\n     */ class StringUtils {\n        // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||\n        // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);\n        static castAsNonUtf8Char(code, encoding = null) {\n            // ISO 8859-1 is the Java default as UTF-8 is JavaScripts\n            // you can see this method as a Java version of String.fromCharCode\n            const e = encoding ? encoding.getName() : this.ISO88591;\n            // use passed format (fromCharCode will return UTF8 encoding)\n            return StringEncoding.decode(new Uint8Array([\n                code\n            ]), e);\n        }\n        /**\n         * @param bytes bytes encoding a string, whose encoding should be guessed\n         * @param hints decode hints if applicable\n         * @return name of guessed encoding; at the moment will only guess one of:\n         *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform\n         *  default encoding if none of these can possibly be correct\n         */ static guessEncoding(bytes, hints) {\n            if (hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType$1.CHARACTER_SET)) {\n                return hints.get(DecodeHintType$1.CHARACTER_SET).toString();\n            }\n            // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,\n            // which should be by far the most common encodings.\n            const length = bytes.length;\n            let canBeISO88591 = true;\n            let canBeShiftJIS = true;\n            let canBeUTF8 = true;\n            let utf8BytesLeft = 0;\n            // int utf8LowChars = 0\n            let utf2BytesChars = 0;\n            let utf3BytesChars = 0;\n            let utf4BytesChars = 0;\n            let sjisBytesLeft = 0;\n            // int sjisLowChars = 0\n            let sjisKatakanaChars = 0;\n            // int sjisDoubleBytesChars = 0\n            let sjisCurKatakanaWordLength = 0;\n            let sjisCurDoubleBytesWordLength = 0;\n            let sjisMaxKatakanaWordLength = 0;\n            let sjisMaxDoubleBytesWordLength = 0;\n            // int isoLowChars = 0\n            // int isoHighChars = 0\n            let isoHighOther = 0;\n            const utf8bom = bytes.length > 3 && bytes[0] === /*(byte) */ 0xEF && bytes[1] === /*(byte) */ 0xBB && bytes[2] === /*(byte) */ 0xBF;\n            for(let i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++){\n                const value = bytes[i] & 0xFF;\n                // UTF-8 stuff\n                if (canBeUTF8) {\n                    if (utf8BytesLeft > 0) {\n                        if ((value & 0x80) === 0) {\n                            canBeUTF8 = false;\n                        } else {\n                            utf8BytesLeft--;\n                        }\n                    } else if ((value & 0x80) !== 0) {\n                        if ((value & 0x40) === 0) {\n                            canBeUTF8 = false;\n                        } else {\n                            utf8BytesLeft++;\n                            if ((value & 0x20) === 0) {\n                                utf2BytesChars++;\n                            } else {\n                                utf8BytesLeft++;\n                                if ((value & 0x10) === 0) {\n                                    utf3BytesChars++;\n                                } else {\n                                    utf8BytesLeft++;\n                                    if ((value & 0x08) === 0) {\n                                        utf4BytesChars++;\n                                    } else {\n                                        canBeUTF8 = false;\n                                    }\n                                }\n                            }\n                        }\n                    } // else {\n                // utf8LowChars++\n                // }\n                }\n                // ISO-8859-1 stuff\n                if (canBeISO88591) {\n                    if (value > 0x7F && value < 0xA0) {\n                        canBeISO88591 = false;\n                    } else if (value > 0x9F) {\n                        if (value < 0xC0 || value === 0xD7 || value === 0xF7) {\n                            isoHighOther++;\n                        } // else {\n                    // isoHighChars++\n                    // }\n                    } // else {\n                // isoLowChars++\n                // }\n                }\n                // Shift_JIS stuff\n                if (canBeShiftJIS) {\n                    if (sjisBytesLeft > 0) {\n                        if (value < 0x40 || value === 0x7F || value > 0xFC) {\n                            canBeShiftJIS = false;\n                        } else {\n                            sjisBytesLeft--;\n                        }\n                    } else if (value === 0x80 || value === 0xA0 || value > 0xEF) {\n                        canBeShiftJIS = false;\n                    } else if (value > 0xA0 && value < 0xE0) {\n                        sjisKatakanaChars++;\n                        sjisCurDoubleBytesWordLength = 0;\n                        sjisCurKatakanaWordLength++;\n                        if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {\n                            sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;\n                        }\n                    } else if (value > 0x7F) {\n                        sjisBytesLeft++;\n                        // sjisDoubleBytesChars++\n                        sjisCurKatakanaWordLength = 0;\n                        sjisCurDoubleBytesWordLength++;\n                        if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {\n                            sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;\n                        }\n                    } else {\n                        // sjisLowChars++\n                        sjisCurKatakanaWordLength = 0;\n                        sjisCurDoubleBytesWordLength = 0;\n                    }\n                }\n            }\n            if (canBeUTF8 && utf8BytesLeft > 0) {\n                canBeUTF8 = false;\n            }\n            if (canBeShiftJIS && sjisBytesLeft > 0) {\n                canBeShiftJIS = false;\n            }\n            // Easy -- if there is BOM or at least 1 valid not-single byte character (and no evidence it can't be UTF-8), done\n            if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {\n                return StringUtils.UTF8;\n            }\n            // Easy -- if assuming Shift_JIS or at least 3 valid consecutive not-ascii characters (and no evidence it can't be), done\n            if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {\n                return StringUtils.SHIFT_JIS;\n            }\n            // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough for short words. The crude heuristic is:\n            // - If we saw\n            //   - only two consecutive katakana chars in the whole text, or\n            //   - at least 10% of bytes that could be \"upper\" not-alphanumeric Latin1,\n            // - then we conclude Shift_JIS, else ISO-8859-1\n            if (canBeISO88591 && canBeShiftJIS) {\n                return sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2 || isoHighOther * 10 >= length ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;\n            }\n            // Otherwise, try in order ISO-8859-1, Shift JIS, UTF-8 and fall back to default platform encoding\n            if (canBeISO88591) {\n                return StringUtils.ISO88591;\n            }\n            if (canBeShiftJIS) {\n                return StringUtils.SHIFT_JIS;\n            }\n            if (canBeUTF8) {\n                return StringUtils.UTF8;\n            }\n            // Otherwise, we take a wild guess with platform encoding\n            return StringUtils.PLATFORM_DEFAULT_ENCODING;\n        }\n        /**\n         *\n         * @see https://stackoverflow.com/a/13439711/4367683\n         *\n         * @param append The new string to append.\n         * @param args Argumets values to be formated.\n         */ static format(append, ...args) {\n            let i = -1;\n            function callback(exp, p0, p1, p2, p3, p4) {\n                if (exp === \"%%\") return \"%\";\n                if (args[++i] === undefined) return undefined;\n                exp = p2 ? parseInt(p2.substr(1)) : undefined;\n                let base = p3 ? parseInt(p3.substr(1)) : undefined;\n                let val;\n                switch(p4){\n                    case \"s\":\n                        val = args[i];\n                        break;\n                    case \"c\":\n                        val = args[i][0];\n                        break;\n                    case \"f\":\n                        val = parseFloat(args[i]).toFixed(exp);\n                        break;\n                    case \"p\":\n                        val = parseFloat(args[i]).toPrecision(exp);\n                        break;\n                    case \"e\":\n                        val = parseFloat(args[i]).toExponential(exp);\n                        break;\n                    case \"x\":\n                        val = parseInt(args[i]).toString(base ? base : 16);\n                        break;\n                    case \"d\":\n                        val = parseFloat(parseInt(args[i], base ? base : 10).toPrecision(exp)).toFixed(0);\n                        break;\n                }\n                val = typeof val === \"object\" ? JSON.stringify(val) : (+val).toString(base);\n                let size = parseInt(p1); /* padding size */ \n                let ch = p1 && p1[0] + \"\" === \"0\" ? \"0\" : \" \"; /* isnull? */ \n                while(val.length < size)val = p0 !== undefined ? val + ch : ch + val; /* isminus? */ \n                return val;\n            }\n            let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\n            return append.replace(regex, callback);\n        }\n        /**\n         *\n         */ static getBytes(str, encoding) {\n            return StringEncoding.encode(str, encoding);\n        }\n        /**\n         * Returns the charcode at the specified index or at index zero.\n         */ static getCharCode(str, index = 0) {\n            return str.charCodeAt(index);\n        }\n        /**\n         * Returns char for given charcode\n         */ static getCharAt(charCode) {\n            return String.fromCharCode(charCode);\n        }\n    }\n    StringUtils.SHIFT_JIS = CharacterSetECI.SJIS.getName(); // \"SJIS\"\n    StringUtils.GB2312 = \"GB2312\";\n    StringUtils.ISO88591 = CharacterSetECI.ISO8859_1.getName(); // \"ISO8859_1\"\n    StringUtils.EUC_JP = \"EUC_JP\";\n    StringUtils.UTF8 = CharacterSetECI.UTF8.getName(); // \"UTF8\"\n    StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8; // \"UTF8\"//Charset.defaultCharset().name()\n    StringUtils.ASSUME_SHIFT_JIS = false;\n    class StringBuilder {\n        constructor(value = \"\"){\n            this.value = value;\n        }\n        enableDecoding(encoding) {\n            this.encoding = encoding;\n            return this;\n        }\n        append(s) {\n            if (typeof s === \"string\") {\n                this.value += s.toString();\n            } else if (this.encoding) {\n                // use passed format (fromCharCode will return UTF8 encoding)\n                this.value += StringUtils.castAsNonUtf8Char(s, this.encoding);\n            } else {\n                // correctly converts from UTF-8, but not other encodings\n                this.value += String.fromCharCode(s);\n            }\n            return this;\n        }\n        appendChars(str, offset, len) {\n            for(let i = offset; offset < offset + len; i++){\n                this.append(str[i]);\n            }\n            return this;\n        }\n        length() {\n            return this.value.length;\n        }\n        charAt(n) {\n            return this.value.charAt(n);\n        }\n        deleteCharAt(n) {\n            this.value = this.value.substr(0, n) + this.value.substring(n + 1);\n        }\n        setCharAt(n, c) {\n            this.value = this.value.substr(0, n) + c + this.value.substr(n + 1);\n        }\n        substring(start, end) {\n            return this.value.substring(start, end);\n        }\n        /**\n         * @note helper method for RSS Expanded\n         */ setLengthToZero() {\n            this.value = \"\";\n        }\n        toString() {\n            return this.value;\n        }\n        insert(n, c) {\n            this.value = this.value.substr(0, n) + c + this.value.substr(n + c.length);\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common\n     * module, x is the column position, and y is the row position. The ordering is always x, y.\n     * The origin is at the top-left.</p>\n     *\n     * <p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins\n     * with a new int. This is done intentionally so that we can copy out a row into a BitArray very\n     * efficiently.</p>\n     *\n     * <p>The ordering of bits is row-major. Within each int, the least significant bits are used first,\n     * meaning they represent lower x values. This is compatible with BitArray's implementation.</p>\n     *\n     * @author Sean Owen\n     * @author dswitkin@google.com (Daniel Switkin)\n     */ class BitMatrix {\n        /**\n         * Creates an empty square {@link BitMatrix}.\n         *\n         * @param dimension height and width\n         */ // public constructor(dimension: number /*int*/) {\n        //   this(dimension, dimension)\n        // }\n        /**\n         * Creates an empty {@link BitMatrix}.\n         *\n         * @param width bit matrix width\n         * @param height bit matrix height\n         */ // public constructor(width: number /*int*/, height: number /*int*/) {\n        //   if (width < 1 || height < 1) {\n        //     throw new IllegalArgumentException(\"Both dimensions must be greater than 0\")\n        //   }\n        //   this.width = width\n        //   this.height = height\n        //   this.rowSize = (width + 31) / 32\n        //   bits = new int[rowSize * height];\n        // }\n        constructor(width /*int*/ , height /*int*/ , rowSize /*int*/ , bits){\n            this.width = width;\n            this.height = height;\n            this.rowSize = rowSize;\n            this.bits = bits;\n            if (undefined === height || null === height) {\n                height = width;\n            }\n            this.height = height;\n            if (width < 1 || height < 1) {\n                throw new IllegalArgumentException(\"Both dimensions must be greater than 0\");\n            }\n            if (undefined === rowSize || null === rowSize) {\n                rowSize = Math.floor((width + 31) / 32);\n            }\n            this.rowSize = rowSize;\n            if (undefined === bits || null === bits) {\n                this.bits = new Int32Array(this.rowSize * this.height);\n            }\n        }\n        /**\n         * Interprets a 2D array of booleans as a {@link BitMatrix}, where \"true\" means an \"on\" bit.\n         *\n         * @function parse\n         * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows\n         * @return {@link BitMatrix} representation of image\n         */ static parseFromBooleanArray(image) {\n            const height = image.length;\n            const width = image[0].length;\n            const bits = new BitMatrix(width, height);\n            for(let i = 0; i < height; i++){\n                const imageI = image[i];\n                for(let j = 0; j < width; j++){\n                    if (imageI[j]) {\n                        bits.set(j, i);\n                    }\n                }\n            }\n            return bits;\n        }\n        /**\n         *\n         * @function parse\n         * @param stringRepresentation\n         * @param setString\n         * @param unsetString\n         */ static parseFromString(stringRepresentation, setString, unsetString) {\n            if (stringRepresentation === null) {\n                throw new IllegalArgumentException(\"stringRepresentation cannot be null\");\n            }\n            const bits = new Array(stringRepresentation.length);\n            let bitsPos = 0;\n            let rowStartPos = 0;\n            let rowLength = -1;\n            let nRows = 0;\n            let pos = 0;\n            while(pos < stringRepresentation.length){\n                if (stringRepresentation.charAt(pos) === \"\\n\" || stringRepresentation.charAt(pos) === \"\\r\") {\n                    if (bitsPos > rowStartPos) {\n                        if (rowLength === -1) {\n                            rowLength = bitsPos - rowStartPos;\n                        } else if (bitsPos - rowStartPos !== rowLength) {\n                            throw new IllegalArgumentException(\"row lengths do not match\");\n                        }\n                        rowStartPos = bitsPos;\n                        nRows++;\n                    }\n                    pos++;\n                } else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {\n                    pos += setString.length;\n                    bits[bitsPos] = true;\n                    bitsPos++;\n                } else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {\n                    pos += unsetString.length;\n                    bits[bitsPos] = false;\n                    bitsPos++;\n                } else {\n                    throw new IllegalArgumentException(\"illegal character encountered: \" + stringRepresentation.substring(pos));\n                }\n            }\n            // no EOL at end?\n            if (bitsPos > rowStartPos) {\n                if (rowLength === -1) {\n                    rowLength = bitsPos - rowStartPos;\n                } else if (bitsPos - rowStartPos !== rowLength) {\n                    throw new IllegalArgumentException(\"row lengths do not match\");\n                }\n                nRows++;\n            }\n            const matrix = new BitMatrix(rowLength, nRows);\n            for(let i = 0; i < bitsPos; i++){\n                if (bits[i]) {\n                    matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));\n                }\n            }\n            return matrix;\n        }\n        /**\n         * <p>Gets the requested bit, where true means black.</p>\n         *\n         * @param x The horizontal component (i.e. which column)\n         * @param y The vertical component (i.e. which row)\n         * @return value of given bit in matrix\n         */ get(x /*int*/ , y /*int*/ ) {\n            const offset = y * this.rowSize + Math.floor(x / 32);\n            return (this.bits[offset] >>> (x & 0x1f) & 1) !== 0;\n        }\n        /**\n         * <p>Sets the given bit to true.</p>\n         *\n         * @param x The horizontal component (i.e. which column)\n         * @param y The vertical component (i.e. which row)\n         */ set(x /*int*/ , y /*int*/ ) {\n            const offset = y * this.rowSize + Math.floor(x / 32);\n            this.bits[offset] |= 1 << (x & 0x1f) & 0xFFFFFFFF;\n        }\n        unset(x /*int*/ , y /*int*/ ) {\n            const offset = y * this.rowSize + Math.floor(x / 32);\n            this.bits[offset] &= ~(1 << (x & 0x1f) & 0xFFFFFFFF);\n        }\n        /**\n         * <p>Flips the given bit.</p>\n         *\n         * @param x The horizontal component (i.e. which column)\n         * @param y The vertical component (i.e. which row)\n         */ flip(x /*int*/ , y /*int*/ ) {\n            const offset = y * this.rowSize + Math.floor(x / 32);\n            this.bits[offset] ^= 1 << (x & 0x1f) & 0xFFFFFFFF;\n        }\n        /**\n         * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding\n         * mask bit is set.\n         *\n         * @param mask XOR mask\n         */ xor(mask) {\n            if (this.width !== mask.getWidth() || this.height !== mask.getHeight() || this.rowSize !== mask.getRowSize()) {\n                throw new IllegalArgumentException(\"input matrix dimensions do not match\");\n            }\n            const rowArray = new BitArray(Math.floor(this.width / 32) + 1);\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            for(let y = 0, height = this.height; y < height; y++){\n                const offset = y * rowSize;\n                const row = mask.getRow(y, rowArray).getBitArray();\n                for(let x = 0; x < rowSize; x++){\n                    bits[offset + x] ^= row[x];\n                }\n            }\n        }\n        /**\n         * Clears all bits (sets to false).\n         */ clear() {\n            const bits = this.bits;\n            const max = bits.length;\n            for(let i = 0; i < max; i++){\n                bits[i] = 0;\n            }\n        }\n        /**\n         * <p>Sets a square region of the bit matrix to true.</p>\n         *\n         * @param left The horizontal position to begin at (inclusive)\n         * @param top The vertical position to begin at (inclusive)\n         * @param width The width of the region\n         * @param height The height of the region\n         */ setRegion(left /*int*/ , top /*int*/ , width /*int*/ , height /*int*/ ) {\n            if (top < 0 || left < 0) {\n                throw new IllegalArgumentException(\"Left and top must be nonnegative\");\n            }\n            if (height < 1 || width < 1) {\n                throw new IllegalArgumentException(\"Height and width must be at least 1\");\n            }\n            const right = left + width;\n            const bottom = top + height;\n            if (bottom > this.height || right > this.width) {\n                throw new IllegalArgumentException(\"The region must fit inside the matrix\");\n            }\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            for(let y = top; y < bottom; y++){\n                const offset = y * rowSize;\n                for(let x = left; x < right; x++){\n                    bits[offset + Math.floor(x / 32)] |= 1 << (x & 0x1f) & 0xFFFFFFFF;\n                }\n            }\n        }\n        /**\n         * A fast method to retrieve one row of data from the matrix as a BitArray.\n         *\n         * @param y The row to retrieve\n         * @param row An optional caller-allocated BitArray, will be allocated if null or too small\n         * @return The resulting BitArray - this reference should always be used even when passing\n         *         your own row\n         */ getRow(y /*int*/ , row) {\n            if (row === null || row === undefined || row.getSize() < this.width) {\n                row = new BitArray(this.width);\n            } else {\n                row.clear();\n            }\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            const offset = y * rowSize;\n            for(let x = 0; x < rowSize; x++){\n                row.setBulk(x * 32, bits[offset + x]);\n            }\n            return row;\n        }\n        /**\n         * @param y row to set\n         * @param row {@link BitArray} to copy from\n         */ setRow(y /*int*/ , row) {\n            System.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);\n        }\n        /**\n         * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees\n         */ rotate180() {\n            const width = this.getWidth();\n            const height = this.getHeight();\n            let topRow = new BitArray(width);\n            let bottomRow = new BitArray(width);\n            for(let i = 0, length = Math.floor((height + 1) / 2); i < length; i++){\n                topRow = this.getRow(i, topRow);\n                bottomRow = this.getRow(height - 1 - i, bottomRow);\n                topRow.reverse();\n                bottomRow.reverse();\n                this.setRow(i, bottomRow);\n                this.setRow(height - 1 - i, topRow);\n            }\n        }\n        /**\n         * This is useful in detecting the enclosing rectangle of a 'pure' barcode.\n         *\n         * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white\n         */ getEnclosingRectangle() {\n            const width = this.width;\n            const height = this.height;\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            let left = width;\n            let top = height;\n            let right = -1;\n            let bottom = -1;\n            for(let y = 0; y < height; y++){\n                for(let x32 = 0; x32 < rowSize; x32++){\n                    const theBits = bits[y * rowSize + x32];\n                    if (theBits !== 0) {\n                        if (y < top) {\n                            top = y;\n                        }\n                        if (y > bottom) {\n                            bottom = y;\n                        }\n                        if (x32 * 32 < left) {\n                            let bit = 0;\n                            while((theBits << 31 - bit & 0xFFFFFFFF) === 0){\n                                bit++;\n                            }\n                            if (x32 * 32 + bit < left) {\n                                left = x32 * 32 + bit;\n                            }\n                        }\n                        if (x32 * 32 + 31 > right) {\n                            let bit = 31;\n                            while(theBits >>> bit === 0){\n                                bit--;\n                            }\n                            if (x32 * 32 + bit > right) {\n                                right = x32 * 32 + bit;\n                            }\n                        }\n                    }\n                }\n            }\n            if (right < left || bottom < top) {\n                return null;\n            }\n            return Int32Array.from([\n                left,\n                top,\n                right - left + 1,\n                bottom - top + 1\n            ]);\n        }\n        /**\n         * This is useful in detecting a corner of a 'pure' barcode.\n         *\n         * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white\n         */ getTopLeftOnBit() {\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            let bitsOffset = 0;\n            while(bitsOffset < bits.length && bits[bitsOffset] === 0){\n                bitsOffset++;\n            }\n            if (bitsOffset === bits.length) {\n                return null;\n            }\n            const y = bitsOffset / rowSize;\n            let x = bitsOffset % rowSize * 32;\n            const theBits = bits[bitsOffset];\n            let bit = 0;\n            while((theBits << 31 - bit & 0xFFFFFFFF) === 0){\n                bit++;\n            }\n            x += bit;\n            return Int32Array.from([\n                x,\n                y\n            ]);\n        }\n        getBottomRightOnBit() {\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            let bitsOffset = bits.length - 1;\n            while(bitsOffset >= 0 && bits[bitsOffset] === 0){\n                bitsOffset--;\n            }\n            if (bitsOffset < 0) {\n                return null;\n            }\n            const y = Math.floor(bitsOffset / rowSize);\n            let x = Math.floor(bitsOffset % rowSize) * 32;\n            const theBits = bits[bitsOffset];\n            let bit = 31;\n            while(theBits >>> bit === 0){\n                bit--;\n            }\n            x += bit;\n            return Int32Array.from([\n                x,\n                y\n            ]);\n        }\n        /**\n         * @return The width of the matrix\n         */ getWidth() {\n            return this.width;\n        }\n        /**\n         * @return The height of the matrix\n         */ getHeight() {\n            return this.height;\n        }\n        /**\n         * @return The row size of the matrix\n         */ getRowSize() {\n            return this.rowSize;\n        }\n        /*@Override*/ equals(o) {\n            if (!(o instanceof BitMatrix)) {\n                return false;\n            }\n            const other = o;\n            return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize && Arrays.equals(this.bits, other.bits);\n        }\n        /*@Override*/ hashCode() {\n            let hash = this.width;\n            hash = 31 * hash + this.width;\n            hash = 31 * hash + this.height;\n            hash = 31 * hash + this.rowSize;\n            hash = 31 * hash + Arrays.hashCode(this.bits);\n            return hash;\n        }\n        /**\n         * @return string representation using \"X\" for set and \" \" for unset bits\n         */ /*@Override*/ // public toString(): string {\n        //   return toString(\": \"X, \"  \")\n        // }\n        /**\n         * @param setString representation of a set bit\n         * @param unsetString representation of an unset bit\n         * @return string representation of entire matrix utilizing given strings\n         */ // public toString(setString: string = \"X \", unsetString: string = \"  \"): string {\n        //   return this.buildToString(setString, unsetString, \"\\n\")\n        // }\n        /**\n         * @param setString representation of a set bit\n         * @param unsetString representation of an unset bit\n         * @param lineSeparator newline character in string representation\n         * @return string representation of entire matrix utilizing given strings and line separator\n         * @deprecated call {@link #toString(String,String)} only, which uses \\n line separator always\n         */ // @Deprecated\n        toString(setString = \"X \", unsetString = \"  \", lineSeparator = \"\\n\") {\n            return this.buildToString(setString, unsetString, lineSeparator);\n        }\n        buildToString(setString, unsetString, lineSeparator) {\n            let result = new StringBuilder();\n            // result.append(lineSeparator);\n            for(let y = 0, height = this.height; y < height; y++){\n                for(let x = 0, width = this.width; x < width; x++){\n                    result.append(this.get(x, y) ? setString : unsetString);\n                }\n                result.append(lineSeparator);\n            }\n            return result.toString();\n        }\n        /*@Override*/ clone() {\n            return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());\n        }\n    }\n    /**\n     * Custom Error class of type Exception.\n     */ class NotFoundException extends Exception {\n        static getNotFoundInstance() {\n            return new NotFoundException();\n        }\n    }\n    NotFoundException.kind = \"NotFoundException\";\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable\n     * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding\n     * algorithm. However, because it picks a global black point, it cannot handle difficult shadows\n     * and gradients.\n     *\n     * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     */ class GlobalHistogramBinarizer extends Binarizer {\n        constructor(source){\n            super(source);\n            this.luminances = GlobalHistogramBinarizer.EMPTY;\n            this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);\n        }\n        // Applies simple sharpening to the row data to improve performance of the 1D Readers.\n        /*@Override*/ getBlackRow(y /*int*/ , row) {\n            const source = this.getLuminanceSource();\n            const width = source.getWidth();\n            if (row === undefined || row === null || row.getSize() < width) {\n                row = new BitArray(width);\n            } else {\n                row.clear();\n            }\n            this.initArrays(width);\n            const localLuminances = source.getRow(y, this.luminances);\n            const localBuckets = this.buckets;\n            for(let x = 0; x < width; x++){\n                localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n            }\n            const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n            if (width < 3) {\n                // Special case for very small images\n                for(let x = 0; x < width; x++){\n                    if ((localLuminances[x] & 0xff) < blackPoint) {\n                        row.set(x);\n                    }\n                }\n            } else {\n                let left = localLuminances[0] & 0xff;\n                let center = localLuminances[1] & 0xff;\n                for(let x = 1; x < width - 1; x++){\n                    const right = localLuminances[x + 1] & 0xff;\n                    // A simple -1 4 -1 box filter with a weight of 2.\n                    if ((center * 4 - left - right) / 2 < blackPoint) {\n                        row.set(x);\n                    }\n                    left = center;\n                    center = right;\n                }\n            }\n            return row;\n        }\n        // Does not sharpen the data, as this call is intended to only be used by 2D Readers.\n        /*@Override*/ getBlackMatrix() {\n            const source = this.getLuminanceSource();\n            const width = source.getWidth();\n            const height = source.getHeight();\n            const matrix = new BitMatrix(width, height);\n            // Quickly calculates the histogram by sampling four rows from the image. This proved to be\n            // more robust on the blackbox tests than sampling a diagonal as we used to do.\n            this.initArrays(width);\n            const localBuckets = this.buckets;\n            for(let y = 1; y < 5; y++){\n                const row = Math.floor(height * y / 5);\n                const localLuminances = source.getRow(row, this.luminances);\n                const right = Math.floor(width * 4 / 5);\n                for(let x = Math.floor(width / 5); x < right; x++){\n                    const pixel = localLuminances[x] & 0xff;\n                    localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n                }\n            }\n            const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n            // We delay reading the entire image luminance until the black point estimation succeeds.\n            // Although we end up reading four rows twice, it is consistent with our motto of\n            // \"fail quickly\" which is necessary for continuous scanning.\n            const localLuminances = source.getMatrix();\n            for(let y = 0; y < height; y++){\n                const offset = y * width;\n                for(let x = 0; x < width; x++){\n                    const pixel = localLuminances[offset + x] & 0xff;\n                    if (pixel < blackPoint) {\n                        matrix.set(x, y);\n                    }\n                }\n            }\n            return matrix;\n        }\n        /*@Override*/ createBinarizer(source) {\n            return new GlobalHistogramBinarizer(source);\n        }\n        initArrays(luminanceSize /*int*/ ) {\n            if (this.luminances.length < luminanceSize) {\n                this.luminances = new Uint8ClampedArray(luminanceSize);\n            }\n            const buckets = this.buckets;\n            for(let x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++){\n                buckets[x] = 0;\n            }\n        }\n        static estimateBlackPoint(buckets) {\n            // Find the tallest peak in the histogram.\n            const numBuckets = buckets.length;\n            let maxBucketCount = 0;\n            let firstPeak = 0;\n            let firstPeakSize = 0;\n            for(let x = 0; x < numBuckets; x++){\n                if (buckets[x] > firstPeakSize) {\n                    firstPeak = x;\n                    firstPeakSize = buckets[x];\n                }\n                if (buckets[x] > maxBucketCount) {\n                    maxBucketCount = buckets[x];\n                }\n            }\n            // Find the second-tallest peak which is somewhat far from the tallest peak.\n            let secondPeak = 0;\n            let secondPeakScore = 0;\n            for(let x = 0; x < numBuckets; x++){\n                const distanceToBiggest = x - firstPeak;\n                // Encourage more distant second peaks by multiplying by square of distance.\n                const score = buckets[x] * distanceToBiggest * distanceToBiggest;\n                if (score > secondPeakScore) {\n                    secondPeak = x;\n                    secondPeakScore = score;\n                }\n            }\n            // Make sure firstPeak corresponds to the black peak.\n            if (firstPeak > secondPeak) {\n                const temp = firstPeak;\n                firstPeak = secondPeak;\n                secondPeak = temp;\n            }\n            // If there is too little contrast in the image to pick a meaningful black point, throw rather\n            // than waste time trying to decode the image, and risk false positives.\n            if (secondPeak - firstPeak <= numBuckets / 16) {\n                throw new NotFoundException();\n            }\n            // Find a valley between them that is low and closer to the white peak.\n            let bestValley = secondPeak - 1;\n            let bestValleyScore = -1;\n            for(let x = secondPeak - 1; x > firstPeak; x--){\n                const fromFirst = x - firstPeak;\n                const score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);\n                if (score > bestValleyScore) {\n                    bestValley = x;\n                    bestValleyScore = score;\n                }\n            }\n            return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;\n        }\n    }\n    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;\n    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;\n    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;\n    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([\n        0\n    ]);\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * This class implements a local thresholding algorithm, which while slower than the\n     * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for\n     * high frequency images of barcodes with black data on white backgrounds. For this application,\n     * it does a much better job than a global blackpoint with severe shadows and gradients.\n     * However it tends to produce artifacts on lower frequency images and is therefore not\n     * a good general purpose binarizer for uses outside ZXing.\n     *\n     * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,\n     * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already\n     * inherently local, and only fails for horizontal gradients. We can revisit that problem later,\n     * but for now it was not a win to use local blocks for 1D.\n     *\n     * This Binarizer is the default for the unit tests and the recommended class for library users.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */ class HybridBinarizer extends GlobalHistogramBinarizer {\n        constructor(source){\n            super(source);\n            this.matrix = null;\n        }\n        /**\n         * Calculates the final BitMatrix once for all requests. This could be called once from the\n         * constructor instead, but there are some advantages to doing it lazily, such as making\n         * profiling easier, and not doing heavy lifting when callers don't expect it.\n         */ /*@Override*/ getBlackMatrix() {\n            if (this.matrix !== null) {\n                return this.matrix;\n            }\n            const source = this.getLuminanceSource();\n            const width = source.getWidth();\n            const height = source.getHeight();\n            if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {\n                const luminances = source.getMatrix();\n                let subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;\n                if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n                    subWidth++;\n                }\n                let subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;\n                if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n                    subHeight++;\n                }\n                const blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);\n                const newMatrix = new BitMatrix(width, height);\n                HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);\n                this.matrix = newMatrix;\n            } else {\n                // If the image is too small, fall back to the global histogram approach.\n                this.matrix = super.getBlackMatrix();\n            }\n            return this.matrix;\n        }\n        /*@Override*/ createBinarizer(source) {\n            return new HybridBinarizer(source);\n        }\n        /**\n         * For each block in the image, calculate the average black point using a 5x5 grid\n         * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\n         * on the last pixels in the row/column which are also used in the previous block).\n         */ static calculateThresholdForBlock(luminances, subWidth /*int*/ , subHeight /*int*/ , width /*int*/ , height /*int*/ , blackPoints, matrix) {\n            const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n            const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n            for(let y = 0; y < subHeight; y++){\n                let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n                if (yoffset > maxYOffset) {\n                    yoffset = maxYOffset;\n                }\n                const top = HybridBinarizer.cap(y, 2, subHeight - 3);\n                for(let x = 0; x < subWidth; x++){\n                    let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n                    if (xoffset > maxXOffset) {\n                        xoffset = maxXOffset;\n                    }\n                    const left = HybridBinarizer.cap(x, 2, subWidth - 3);\n                    let sum = 0;\n                    for(let z = -2; z <= 2; z++){\n                        const blackRow = blackPoints[top + z];\n                        sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n                    }\n                    const average = sum / 25;\n                    HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n                }\n            }\n        }\n        static cap(value /*int*/ , min /*int*/ , max /*int*/ ) {\n            return value < min ? min : value > max ? max : value;\n        }\n        /**\n         * Applies a single threshold to a block of pixels.\n         */ static thresholdBlock(luminances, xoffset /*int*/ , yoffset /*int*/ , threshold /*int*/ , stride /*int*/ , matrix) {\n            for(let y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride){\n                for(let x = 0; x < HybridBinarizer.BLOCK_SIZE; x++){\n                    // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.\n                    if ((luminances[offset + x] & 0xFF) <= threshold) {\n                        matrix.set(xoffset + x, yoffset + y);\n                    }\n                }\n            }\n        }\n        /**\n         * Calculates a single black point for each block of pixels and saves it away.\n         * See the following thread for a discussion of this algorithm:\n         *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0\n         */ static calculateBlackPoints(luminances, subWidth /*int*/ , subHeight /*int*/ , width /*int*/ , height /*int*/ ) {\n            const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n            const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n            // tslint:disable-next-line:whitespace\n            const blackPoints = new Array(subHeight); // subWidth\n            for(let y = 0; y < subHeight; y++){\n                blackPoints[y] = new Int32Array(subWidth);\n                let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n                if (yoffset > maxYOffset) {\n                    yoffset = maxYOffset;\n                }\n                for(let x = 0; x < subWidth; x++){\n                    let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n                    if (xoffset > maxXOffset) {\n                        xoffset = maxXOffset;\n                    }\n                    let sum = 0;\n                    let min = 0xFF;\n                    let max = 0;\n                    for(let yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width){\n                        for(let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++){\n                            const pixel = luminances[offset + xx] & 0xFF;\n                            sum += pixel;\n                            // still looking for good contrast\n                            if (pixel < min) {\n                                min = pixel;\n                            }\n                            if (pixel > max) {\n                                max = pixel;\n                            }\n                        }\n                        // short-circuit min/max tests once dynamic range is met\n                        if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {\n                            // finish the rest of the rows quickly\n                            for(yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width){\n                                for(let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++){\n                                    sum += luminances[offset + xx] & 0xFF;\n                                }\n                            }\n                        }\n                    }\n                    // The default estimate is the average of the values in the block.\n                    let average = sum >> HybridBinarizer.BLOCK_SIZE_POWER * 2;\n                    if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {\n                        // If variation within the block is low, assume this is a block with only light or only\n                        // dark pixels. In that case we do not want to use the average, as it would divide this\n                        // low contrast area into black and white pixels, essentially creating data out of noise.\n                        //\n                        // The default assumption is that the block is light/background. Since no estimate for\n                        // the level of dark pixels exists locally, use half the min for the block.\n                        average = min / 2;\n                        if (y > 0 && x > 0) {\n                            // Correct the \"white background\" assumption for blocks that have neighbors by comparing\n                            // the pixels in this block to the previously calculated black points. This is based on\n                            // the fact that dark barcode symbology is always surrounded by some amount of light\n                            // background for which reasonable black point estimates were made. The bp estimated at\n                            // the boundaries is used for the interior.\n                            // The (min < bp) is arbitrary but works better than other heuristics that were tried.\n                            const averageNeighborBlackPoint = (blackPoints[y - 1][x] + 2 * blackPoints[y][x - 1] + blackPoints[y - 1][x - 1]) / 4;\n                            if (min < averageNeighborBlackPoint) {\n                                average = averageNeighborBlackPoint;\n                            }\n                        }\n                    }\n                    blackPoints[y][x] = average;\n                }\n            }\n            return blackPoints;\n        }\n    }\n    // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.\n    // So this is the smallest dimension in each axis we can accept.\n    HybridBinarizer.BLOCK_SIZE_POWER = 3;\n    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00\n    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11\n    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;\n    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*namespace com.google.zxing {*/ /**\n     * The purpose of this class hierarchy is to abstract different bitmap implementations across\n     * platforms into a standard interface for requesting greyscale luminance values. The interface\n     * only provides immutable methods; therefore crop and rotation create copies. This is to ensure\n     * that one Reader does not modify the original luminance source and leave it in an unknown state\n     * for other Readers in the chain.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */ class LuminanceSource {\n        constructor(width /*int*/ , height /*int*/ ){\n            this.width = width;\n            this.height = height;\n        }\n        /**\n         * @return The width of the bitmap.\n         */ getWidth() {\n            return this.width;\n        }\n        /**\n         * @return The height of the bitmap.\n         */ getHeight() {\n            return this.height;\n        }\n        /**\n         * @return Whether this subclass supports cropping.\n         */ isCropSupported() {\n            return false;\n        }\n        /**\n         * Returns a new object with cropped image data. Implementations may keep a reference to the\n         * original data rather than a copy. Only callable if isCropSupported() is true.\n         *\n         * @param left The left coordinate, which must be in [0,getWidth())\n         * @param top The top coordinate, which must be in [0,getHeight())\n         * @param width The width of the rectangle to crop.\n         * @param height The height of the rectangle to crop.\n         * @return A cropped version of this object.\n         */ crop(left /*int*/ , top /*int*/ , width /*int*/ , height /*int*/ ) {\n            throw new UnsupportedOperationException(\"This luminance source does not support cropping.\");\n        }\n        /**\n         * @return Whether this subclass supports counter-clockwise rotation.\n         */ isRotateSupported() {\n            return false;\n        }\n        /**\n         * Returns a new object with rotated image data by 90 degrees counterclockwise.\n         * Only callable if {@link #isRotateSupported()} is true.\n         *\n         * @return A rotated version of this object.\n         */ rotateCounterClockwise() {\n            throw new UnsupportedOperationException(\"This luminance source does not support rotation by 90 degrees.\");\n        }\n        /**\n         * Returns a new object with rotated image data by 45 degrees counterclockwise.\n         * Only callable if {@link #isRotateSupported()} is true.\n         *\n         * @return A rotated version of this object.\n         */ rotateCounterClockwise45() {\n            throw new UnsupportedOperationException(\"This luminance source does not support rotation by 45 degrees.\");\n        }\n        /*@Override*/ toString() {\n            const row = new Uint8ClampedArray(this.width);\n            let result = new StringBuilder();\n            for(let y = 0; y < this.height; y++){\n                const sourceRow = this.getRow(y, row);\n                for(let x = 0; x < this.width; x++){\n                    const luminance = sourceRow[x] & 0xFF;\n                    let c;\n                    if (luminance < 0x40) {\n                        c = \"#\";\n                    } else if (luminance < 0x80) {\n                        c = \"+\";\n                    } else if (luminance < 0xC0) {\n                        c = \".\";\n                    } else {\n                        c = \" \";\n                    }\n                    result.append(c);\n                }\n                result.append(\"\\n\");\n            }\n            return result.toString();\n        }\n    }\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*namespace com.google.zxing {*/ /**\n     * A wrapper implementation of {@link LuminanceSource} which inverts the luminances it returns -- black becomes\n     * white and vice versa, and each value becomes (255-value).\n     *\n     * @author Sean Owen\n     */ class InvertedLuminanceSource extends LuminanceSource {\n        constructor(delegate){\n            super(delegate.getWidth(), delegate.getHeight());\n            this.delegate = delegate;\n        }\n        /*@Override*/ getRow(y /*int*/ , row) {\n            const sourceRow = this.delegate.getRow(y, row);\n            const width = this.getWidth();\n            for(let i = 0; i < width; i++){\n                sourceRow[i] = /*(byte)*/ 255 - (sourceRow[i] & 0xFF);\n            }\n            return sourceRow;\n        }\n        /*@Override*/ getMatrix() {\n            const matrix = this.delegate.getMatrix();\n            const length = this.getWidth() * this.getHeight();\n            const invertedMatrix = new Uint8ClampedArray(length);\n            for(let i = 0; i < length; i++){\n                invertedMatrix[i] = /*(byte)*/ 255 - (matrix[i] & 0xFF);\n            }\n            return invertedMatrix;\n        }\n        /*@Override*/ isCropSupported() {\n            return this.delegate.isCropSupported();\n        }\n        /*@Override*/ crop(left /*int*/ , top /*int*/ , width /*int*/ , height /*int*/ ) {\n            return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));\n        }\n        /*@Override*/ isRotateSupported() {\n            return this.delegate.isRotateSupported();\n        }\n        /**\n         * @return original delegate {@link LuminanceSource} since invert undoes itself\n         */ /*@Override*/ invert() {\n            return this.delegate;\n        }\n        /*@Override*/ rotateCounterClockwise() {\n            return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());\n        }\n        /*@Override*/ rotateCounterClockwise45() {\n            return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());\n        }\n    }\n    /**\n     * @deprecated Moving to @zxing/browser\n     */ class HTMLCanvasElementLuminanceSource extends LuminanceSource {\n        constructor(canvas){\n            super(canvas.width, canvas.height);\n            this.canvas = canvas;\n            this.tempCanvasElement = null;\n            this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);\n        }\n        static makeBufferFromCanvasImageData(canvas) {\n            const imageData = canvas.getContext(\"2d\").getImageData(0, 0, canvas.width, canvas.height);\n            return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);\n        }\n        static toGrayscaleBuffer(imageBuffer, width, height) {\n            const grayscaleBuffer = new Uint8ClampedArray(width * height);\n            for(let i = 0, j = 0, length = imageBuffer.length; i < length; i += 4, j++){\n                let gray;\n                const alpha = imageBuffer[i + 3];\n                // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent\n                // black (0 alpha, and then 0 RGB). They are often used, of course as the \"white\" area in a\n                // barcode image. Force any such pixel to be white:\n                if (alpha === 0) {\n                    gray = 0xFF;\n                } else {\n                    const pixelR = imageBuffer[i];\n                    const pixelG = imageBuffer[i + 1];\n                    const pixelB = imageBuffer[i + 2];\n                    // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),\n                    // (306*R) >> 10 is approximately equal to R*0.299, and so on.\n                    // 0x200 >> 10 is 0.5, it implements rounding.\n                    gray = 306 * pixelR + 601 * pixelG + 117 * pixelB + 0x200 >> 10;\n                }\n                grayscaleBuffer[j] = gray;\n            }\n            return grayscaleBuffer;\n        }\n        getRow(y /*int*/ , row) {\n            if (y < 0 || y >= this.getHeight()) {\n                throw new IllegalArgumentException(\"Requested row is outside the image: \" + y);\n            }\n            const width = this.getWidth();\n            const start = y * width;\n            if (row === null) {\n                row = this.buffer.slice(start, start + width);\n            } else {\n                if (row.length < width) {\n                    row = new Uint8ClampedArray(width);\n                }\n                // The underlying raster of image consists of bytes with the luminance values\n                // TODO: can avoid set/slice?\n                row.set(this.buffer.slice(start, start + width));\n            }\n            return row;\n        }\n        getMatrix() {\n            return this.buffer;\n        }\n        isCropSupported() {\n            return true;\n        }\n        crop(left /*int*/ , top /*int*/ , width /*int*/ , height /*int*/ ) {\n            super.crop(left, top, width, height);\n            return this;\n        }\n        /**\n         * This is always true, since the image is a gray-scale image.\n         *\n         * @return true\n         */ isRotateSupported() {\n            return true;\n        }\n        rotateCounterClockwise() {\n            this.rotate(-90);\n            return this;\n        }\n        rotateCounterClockwise45() {\n            this.rotate(-45);\n            return this;\n        }\n        getTempCanvasElement() {\n            if (null === this.tempCanvasElement) {\n                const tempCanvasElement = this.canvas.ownerDocument.createElement(\"canvas\");\n                tempCanvasElement.width = this.canvas.width;\n                tempCanvasElement.height = this.canvas.height;\n                this.tempCanvasElement = tempCanvasElement;\n            }\n            return this.tempCanvasElement;\n        }\n        rotate(angle) {\n            const tempCanvasElement = this.getTempCanvasElement();\n            const tempContext = tempCanvasElement.getContext(\"2d\");\n            const angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;\n            // Calculate and set new dimensions for temp canvas\n            const width = this.canvas.width;\n            const height = this.canvas.height;\n            const newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);\n            const newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);\n            tempCanvasElement.width = newWidth;\n            tempCanvasElement.height = newHeight;\n            // Draw at center of temp canvas to prevent clipping of image data\n            tempContext.translate(newWidth / 2, newHeight / 2);\n            tempContext.rotate(angleRadians);\n            tempContext.drawImage(this.canvas, width / -2, height / -2);\n            this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);\n            return this;\n        }\n        invert() {\n            return new InvertedLuminanceSource(this);\n        }\n    }\n    HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * Video input device metadata containing the id and label of the device if available.\n     */ class VideoInputDevice {\n        /**\n         * Creates an instance of VideoInputDevice.\n         *\n         * @param {string} deviceId the video input device id\n         * @param {string} label the label of the device if available\n         */ constructor(deviceId, label, groupId){\n            this.deviceId = deviceId;\n            this.label = label;\n            /** @inheritdoc */ this.kind = \"videoinput\";\n            this.groupId = groupId || undefined;\n        }\n        /** @inheritdoc */ toJSON() {\n            return {\n                kind: this.kind,\n                groupId: this.groupId,\n                deviceId: this.deviceId,\n                label: this.label\n            };\n        }\n    }\n    var __awaiter = (globalThis || global || self || window || undefined) && (globalThis || global || self || window || undefined).__awaiter || function(thisArg, _arguments, P, generator) {\n        function adopt(value) {\n            return value instanceof P ? value : new P(function(resolve) {\n                resolve(value);\n            });\n        }\n        return new (P || (P = Promise))(function(resolve, reject) {\n            function fulfilled(value) {\n                try {\n                    step(generator.next(value));\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            function rejected(value) {\n                try {\n                    step(generator[\"throw\"](value));\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n            }\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n    };\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * Base class for browser code reader.\n     */ class BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserCodeReader.\n         * @param {Reader} reader The reader instance to decode the barcode\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent successful decode tries\n         *\n         * @memberOf BrowserCodeReader\n         */ constructor(reader, timeBetweenScansMillis = 500, _hints){\n            this.reader = reader;\n            this.timeBetweenScansMillis = timeBetweenScansMillis;\n            this._hints = _hints;\n            /**\n             * This will break the loop.\n             */ this._stopContinuousDecode = false;\n            /**\n             * This will break the loop.\n             */ this._stopAsyncDecode = false;\n            /**\n             * Delay time between decode attempts made by the scanner.\n             */ this._timeBetweenDecodingAttempts = 0;\n        }\n        /**\n         * If navigator is present.\n         */ get hasNavigator() {\n            return typeof navigator !== \"undefined\";\n        }\n        /**\n         * If mediaDevices under navigator is supported.\n         */ get isMediaDevicesSuported() {\n            return this.hasNavigator && !!navigator.mediaDevices;\n        }\n        /**\n         * If enumerateDevices under navigator is supported.\n         */ get canEnumerateDevices() {\n            return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);\n        }\n        /** Time between two decoding tries in milli seconds. */ get timeBetweenDecodingAttempts() {\n            return this._timeBetweenDecodingAttempts;\n        }\n        /**\n         * Change the time span the decoder waits between two decoding tries.\n         *\n         * @param {number} millis Time between two decoding tries in milli seconds.\n         */ set timeBetweenDecodingAttempts(millis) {\n            this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;\n        }\n        /**\n         * Sets the hints.\n         */ set hints(hints) {\n            this._hints = hints || null;\n        }\n        /**\n         * Sets the hints.\n         */ get hints() {\n            return this._hints;\n        }\n        /**\n         * Lists all the available video input devices.\n         */ listVideoInputDevices() {\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!this.hasNavigator) {\n                    throw new Error(\"Can't enumerate devices, navigator is not present.\");\n                }\n                if (!this.canEnumerateDevices) {\n                    throw new Error(\"Can't enumerate devices, method not supported.\");\n                }\n                const devices = yield navigator.mediaDevices.enumerateDevices();\n                const videoDevices = [];\n                for (const device of devices){\n                    const kind = device.kind === \"video\" ? \"videoinput\" : device.kind;\n                    if (kind !== \"videoinput\") {\n                        continue;\n                    }\n                    const deviceId = device.deviceId || device.id;\n                    const label = device.label || `Video device ${videoDevices.length + 1}`;\n                    const groupId = device.groupId;\n                    const videoDevice = {\n                        deviceId,\n                        label,\n                        kind,\n                        groupId\n                    };\n                    videoDevices.push(videoDevice);\n                }\n                return videoDevices;\n            });\n        }\n        /**\n         * Obtain the list of available devices with type 'videoinput'.\n         *\n         * @returns {Promise<VideoInputDevice[]>} an array of available video input devices\n         *\n         * @memberOf BrowserCodeReader\n         *\n         * @deprecated Use `listVideoInputDevices` instead.\n         */ getVideoInputDevices() {\n            return __awaiter(this, void 0, void 0, function*() {\n                const devices = yield this.listVideoInputDevices();\n                return devices.map((d)=>new VideoInputDevice(d.deviceId, d.label));\n            });\n        }\n        /**\n         * Let's you find a device using it's Id.\n         */ findDeviceById(deviceId) {\n            return __awaiter(this, void 0, void 0, function*() {\n                const devices = yield this.listVideoInputDevices();\n                if (!devices) {\n                    return null;\n                }\n                return devices.find((x)=>x.deviceId === deviceId);\n            });\n        }\n        /**\n         * Decodes the barcode from the device specified by deviceId while showing the video in the specified video element.\n         *\n         * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         *\n         * @deprecated Use `decodeOnceFromVideoDevice` instead.\n         */ decodeFromInputVideoDevice(deviceId, videoSource) {\n            return __awaiter(this, void 0, void 0, function*() {\n                return yield this.decodeOnceFromVideoDevice(deviceId, videoSource);\n            });\n        }\n        /**\n         * In one attempt, tries to decode the barcode from the device specified by deviceId while showing the video in the specified video element.\n         *\n         * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */ decodeOnceFromVideoDevice(deviceId, videoSource) {\n            return __awaiter(this, void 0, void 0, function*() {\n                this.reset();\n                let videoConstraints;\n                if (!deviceId) {\n                    videoConstraints = {\n                        facingMode: \"environment\"\n                    };\n                } else {\n                    videoConstraints = {\n                        deviceId: {\n                            exact: deviceId\n                        }\n                    };\n                }\n                const constraints = {\n                    video: videoConstraints\n                };\n                return yield this.decodeOnceFromConstraints(constraints, videoSource);\n            });\n        }\n        /**\n         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n         *\n         * @param constraints the media stream constraints to get s valid media stream to decode from\n         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */ decodeOnceFromConstraints(constraints, videoSource) {\n            return __awaiter(this, void 0, void 0, function*() {\n                const stream = yield navigator.mediaDevices.getUserMedia(constraints);\n                return yield this.decodeOnceFromStream(stream, videoSource);\n            });\n        }\n        /**\n         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n         *\n         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from\n         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */ decodeOnceFromStream(stream, videoSource) {\n            return __awaiter(this, void 0, void 0, function*() {\n                this.reset();\n                const video = yield this.attachStreamToVideo(stream, videoSource);\n                const result = yield this.decodeOnce(video);\n                return result;\n            });\n        }\n        /**\n         * Continuously decodes the barcode from the device specified by device while showing the video in the specified video element.\n         *\n         * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n         * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<void>}\n         *\n         * @memberOf BrowserCodeReader\n         *\n         * @deprecated Use `decodeFromVideoDevice` instead.\n         */ decodeFromInputVideoDeviceContinuously(deviceId, videoSource, callbackFn) {\n            return __awaiter(this, void 0, void 0, function*() {\n                return yield this.decodeFromVideoDevice(deviceId, videoSource, callbackFn);\n            });\n        }\n        /**\n         * Continuously tries to decode the barcode from the device specified by device while showing the video in the specified video element.\n         *\n         * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n         * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<void>}\n         *\n         * @memberOf BrowserCodeReader\n         */ decodeFromVideoDevice(deviceId, videoSource, callbackFn) {\n            return __awaiter(this, void 0, void 0, function*() {\n                let videoConstraints;\n                if (!deviceId) {\n                    videoConstraints = {\n                        facingMode: \"environment\"\n                    };\n                } else {\n                    videoConstraints = {\n                        deviceId: {\n                            exact: deviceId\n                        }\n                    };\n                }\n                const constraints = {\n                    video: videoConstraints\n                };\n                return yield this.decodeFromConstraints(constraints, videoSource, callbackFn);\n            });\n        }\n        /**\n         * Continuously tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n         *\n         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from\n         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */ decodeFromConstraints(constraints, videoSource, callbackFn) {\n            return __awaiter(this, void 0, void 0, function*() {\n                const stream = yield navigator.mediaDevices.getUserMedia(constraints);\n                return yield this.decodeFromStream(stream, videoSource, callbackFn);\n            });\n        }\n        /**\n         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n         *\n         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from\n         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */ decodeFromStream(stream, videoSource, callbackFn) {\n            return __awaiter(this, void 0, void 0, function*() {\n                this.reset();\n                const video = yield this.attachStreamToVideo(stream, videoSource);\n                return yield this.decodeContinuously(video, callbackFn);\n            });\n        }\n        /**\n         * Breaks the decoding loop.\n         */ stopAsyncDecode() {\n            this._stopAsyncDecode = true;\n        }\n        /**\n         * Breaks the decoding loop.\n         */ stopContinuousDecode() {\n            this._stopContinuousDecode = true;\n        }\n        /**\n         * Sets the new stream and request a new decoding-with-delay.\n         *\n         * @param stream The stream to be shown in the video element.\n         * @param decodeFn A callback for the decode method.\n         */ attachStreamToVideo(stream, videoSource) {\n            return __awaiter(this, void 0, void 0, function*() {\n                const videoElement = this.prepareVideoElement(videoSource);\n                this.addVideoSource(videoElement, stream);\n                this.videoElement = videoElement;\n                this.stream = stream;\n                yield this.playVideoOnLoadAsync(videoElement);\n                return videoElement;\n            });\n        }\n        /**\n         *\n         * @param videoElement\n         */ playVideoOnLoadAsync(videoElement) {\n            return new Promise((resolve, reject)=>this.playVideoOnLoad(videoElement, ()=>resolve()));\n        }\n        /**\n         * Binds listeners and callbacks to the videoElement.\n         *\n         * @param element\n         * @param callbackFn\n         */ playVideoOnLoad(element, callbackFn) {\n            this.videoEndedListener = ()=>this.stopStreams();\n            this.videoCanPlayListener = ()=>this.tryPlayVideo(element);\n            element.addEventListener(\"ended\", this.videoEndedListener);\n            element.addEventListener(\"canplay\", this.videoCanPlayListener);\n            element.addEventListener(\"playing\", callbackFn);\n            // if canplay was already fired, we won't know when to play, so just give it a try\n            this.tryPlayVideo(element);\n        }\n        /**\n         * Checks if the given video element is currently playing.\n         */ isVideoPlaying(video) {\n            return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;\n        }\n        /**\n         * Just tries to play the video and logs any errors.\n         * The play call is only made is the video is not already playing.\n         */ tryPlayVideo(videoElement) {\n            return __awaiter(this, void 0, void 0, function*() {\n                if (this.isVideoPlaying(videoElement)) {\n                    console.warn(\"Trying to play video that is already playing.\");\n                    return;\n                }\n                try {\n                    yield videoElement.play();\n                } catch (_a) {\n                    console.warn(\"It was not possible to play the video.\");\n                }\n            });\n        }\n        /**\n         * Searches and validates a media element.\n         */ getMediaElement(mediaElementId, type) {\n            const mediaElement = document.getElementById(mediaElementId);\n            if (!mediaElement) {\n                throw new ArgumentException(`element with id '${mediaElementId}' not found`);\n            }\n            if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {\n                throw new ArgumentException(`element with id '${mediaElementId}' must be an ${type} element`);\n            }\n            return mediaElement;\n        }\n        /**\n         * Decodes the barcode from an image.\n         *\n         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.\n         * @param {string} [url]\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */ decodeFromImage(source, url) {\n            if (!source && !url) {\n                throw new ArgumentException(\"either imageElement with a src set or an url must be provided\");\n            }\n            if (url && !source) {\n                return this.decodeFromImageUrl(url);\n            }\n            return this.decodeFromImageElement(source);\n        }\n        /**\n         * Decodes the barcode from a video.\n         *\n         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.\n         * @param {string} [url]\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */ decodeFromVideo(source, url) {\n            if (!source && !url) {\n                throw new ArgumentException(\"Either an element with a src set or an URL must be provided\");\n            }\n            if (url && !source) {\n                return this.decodeFromVideoUrl(url);\n            }\n            return this.decodeFromVideoElement(source);\n        }\n        /**\n         * Decodes continuously the barcode from a video.\n         *\n         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.\n         * @param {string} [url]\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         *\n         * @experimental\n         */ decodeFromVideoContinuously(source, url, callbackFn) {\n            if (undefined === source && undefined === url) {\n                throw new ArgumentException(\"Either an element with a src set or an URL must be provided\");\n            }\n            if (url && !source) {\n                return this.decodeFromVideoUrlContinuously(url, callbackFn);\n            }\n            return this.decodeFromVideoElementContinuously(source, callbackFn);\n        }\n        /**\n         * Decodes something from an image HTML element.\n         */ decodeFromImageElement(source) {\n            if (!source) {\n                throw new ArgumentException(\"An image element must be provided.\");\n            }\n            this.reset();\n            const element = this.prepareImageElement(source);\n            this.imageElement = element;\n            let task;\n            if (this.isImageLoaded(element)) {\n                task = this.decodeOnce(element, false, true);\n            } else {\n                task = this._decodeOnLoadImage(element);\n            }\n            return task;\n        }\n        /**\n         * Decodes something from an image HTML element.\n         */ decodeFromVideoElement(source) {\n            const element = this._decodeFromVideoElementSetup(source);\n            return this._decodeOnLoadVideo(element);\n        }\n        /**\n         * Decodes something from an image HTML element.\n         */ decodeFromVideoElementContinuously(source, callbackFn) {\n            const element = this._decodeFromVideoElementSetup(source);\n            return this._decodeOnLoadVideoContinuously(element, callbackFn);\n        }\n        /**\n         * Sets up the video source so it can be decoded when loaded.\n         *\n         * @param source The video source element.\n         */ _decodeFromVideoElementSetup(source) {\n            if (!source) {\n                throw new ArgumentException(\"A video element must be provided.\");\n            }\n            this.reset();\n            const element = this.prepareVideoElement(source);\n            // defines the video element before starts decoding\n            this.videoElement = element;\n            return element;\n        }\n        /**\n         * Decodes an image from a URL.\n         */ decodeFromImageUrl(url) {\n            if (!url) {\n                throw new ArgumentException(\"An URL must be provided.\");\n            }\n            this.reset();\n            const element = this.prepareImageElement();\n            this.imageElement = element;\n            const decodeTask = this._decodeOnLoadImage(element);\n            element.src = url;\n            return decodeTask;\n        }\n        /**\n         * Decodes an image from a URL.\n         */ decodeFromVideoUrl(url) {\n            if (!url) {\n                throw new ArgumentException(\"An URL must be provided.\");\n            }\n            this.reset();\n            // creates a new element\n            const element = this.prepareVideoElement();\n            const decodeTask = this.decodeFromVideoElement(element);\n            element.src = url;\n            return decodeTask;\n        }\n        /**\n         * Decodes an image from a URL.\n         *\n         * @experimental\n         */ decodeFromVideoUrlContinuously(url, callbackFn) {\n            if (!url) {\n                throw new ArgumentException(\"An URL must be provided.\");\n            }\n            this.reset();\n            // creates a new element\n            const element = this.prepareVideoElement();\n            const decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);\n            element.src = url;\n            return decodeTask;\n        }\n        _decodeOnLoadImage(element) {\n            return new Promise((resolve, reject)=>{\n                this.imageLoadedListener = ()=>this.decodeOnce(element, false, true).then(resolve, reject);\n                element.addEventListener(\"load\", this.imageLoadedListener);\n            });\n        }\n        _decodeOnLoadVideo(videoElement) {\n            return __awaiter(this, void 0, void 0, function*() {\n                // plays the video\n                yield this.playVideoOnLoadAsync(videoElement);\n                // starts decoding after played the video\n                return yield this.decodeOnce(videoElement);\n            });\n        }\n        _decodeOnLoadVideoContinuously(videoElement, callbackFn) {\n            return __awaiter(this, void 0, void 0, function*() {\n                // plays the video\n                yield this.playVideoOnLoadAsync(videoElement);\n                // starts decoding after played the video\n                this.decodeContinuously(videoElement, callbackFn);\n            });\n        }\n        isImageLoaded(img) {\n            // During the onload event, IE correctly identifies any images that\n            // weren’t downloaded as not complete. Others should too. Gecko-based\n            // browsers act like NS4 in that they report this incorrectly.\n            if (!img.complete) {\n                return false;\n            }\n            // However, they do have two very useful properties: naturalWidth and\n            // naturalHeight. These give the true size of the image. If it failed\n            // to load, either of these should be zero.\n            if (img.naturalWidth === 0) {\n                return false;\n            }\n            // No other way of checking: assume it’s ok.\n            return true;\n        }\n        prepareImageElement(imageSource) {\n            let imageElement;\n            if (typeof imageSource === \"undefined\") {\n                imageElement = document.createElement(\"img\");\n                imageElement.width = 200;\n                imageElement.height = 200;\n            }\n            if (typeof imageSource === \"string\") {\n                imageElement = this.getMediaElement(imageSource, \"img\");\n            }\n            if (imageSource instanceof HTMLImageElement) {\n                imageElement = imageSource;\n            }\n            return imageElement;\n        }\n        /**\n         * Sets a HTMLVideoElement for scanning or creates a new one.\n         *\n         * @param videoSource The HTMLVideoElement to be set.\n         */ prepareVideoElement(videoSource) {\n            let videoElement;\n            if (!videoSource && typeof document !== \"undefined\") {\n                videoElement = document.createElement(\"video\");\n                videoElement.width = 200;\n                videoElement.height = 200;\n            }\n            if (typeof videoSource === \"string\") {\n                videoElement = this.getMediaElement(videoSource, \"video\");\n            }\n            if (videoSource instanceof HTMLVideoElement) {\n                videoElement = videoSource;\n            }\n            // Needed for iOS 11\n            videoElement.setAttribute(\"autoplay\", \"true\");\n            videoElement.setAttribute(\"muted\", \"true\");\n            videoElement.setAttribute(\"playsinline\", \"true\");\n            return videoElement;\n        }\n        /**\n         * Tries to decode from the video input until it finds some value.\n         */ decodeOnce(element, retryIfNotFound = true, retryIfChecksumOrFormatError = true) {\n            this._stopAsyncDecode = false;\n            const loop = (resolve, reject)=>{\n                if (this._stopAsyncDecode) {\n                    reject(new NotFoundException(\"Video stream has ended before any code could be detected.\"));\n                    this._stopAsyncDecode = undefined;\n                    return;\n                }\n                try {\n                    const result = this.decode(element);\n                    resolve(result);\n                } catch (e) {\n                    const ifNotFound = retryIfNotFound && e instanceof NotFoundException;\n                    const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;\n                    const ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;\n                    if (ifNotFound || ifChecksumOrFormat) {\n                        // trying again\n                        return setTimeout(loop, this._timeBetweenDecodingAttempts, resolve, reject);\n                    }\n                    reject(e);\n                }\n            };\n            return new Promise((resolve, reject)=>loop(resolve, reject));\n        }\n        /**\n         * Continuously decodes from video input.\n         */ decodeContinuously(element, callbackFn) {\n            this._stopContinuousDecode = false;\n            const loop = ()=>{\n                if (this._stopContinuousDecode) {\n                    this._stopContinuousDecode = undefined;\n                    return;\n                }\n                try {\n                    const result = this.decode(element);\n                    callbackFn(result, null);\n                    setTimeout(loop, this.timeBetweenScansMillis);\n                } catch (e) {\n                    callbackFn(null, e);\n                    const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;\n                    const isNotFound = e instanceof NotFoundException;\n                    if (isChecksumOrFormatError || isNotFound) {\n                        // trying again\n                        setTimeout(loop, this._timeBetweenDecodingAttempts);\n                    }\n                }\n            };\n            loop();\n        }\n        /**\n         * Gets the BinaryBitmap for ya! (and decodes it)\n         */ decode(element) {\n            // get binary bitmap for decode function\n            const binaryBitmap = this.createBinaryBitmap(element);\n            return this.decodeBitmap(binaryBitmap);\n        }\n        /**\n         * Returns true if media element is indeed a {@link HtmlVideoElement}.\n         */ _isHTMLVideoElement(mediaElement) {\n            const potentialVideo = mediaElement;\n            return potentialVideo.videoWidth !== 0;\n        }\n        /**\n         * Overwriting this allows you to manipulate the next frame in anyway\n         * you want before decode.\n         */ drawFrameOnCanvas(srcElement, dimensions, canvasElementContext) {\n            if (!dimensions) {\n                dimensions = {\n                    sx: 0,\n                    sy: 0,\n                    sWidth: srcElement.videoWidth,\n                    sHeight: srcElement.videoHeight,\n                    dx: 0,\n                    dy: 0,\n                    dWidth: srcElement.videoWidth,\n                    dHeight: srcElement.videoHeight\n                };\n            }\n            if (!canvasElementContext) {\n                canvasElementContext = this.captureCanvasContext;\n            }\n            canvasElementContext.drawImage(srcElement, dimensions.sx, dimensions.sy, dimensions.sWidth, dimensions.sHeight, dimensions.dx, dimensions.dy, dimensions.dWidth, dimensions.dHeight);\n        }\n        /**\n         * Ovewriting this allows you to manipulate the snapshot image in anyway\n         *  you want before decode.\n         */ drawImageOnCanvas(srcElement, dimensions, canvasElementContext = this.captureCanvasContext) {\n            if (!dimensions) {\n                dimensions = {\n                    sx: 0,\n                    sy: 0,\n                    sWidth: srcElement.naturalWidth,\n                    sHeight: srcElement.naturalHeight,\n                    dx: 0,\n                    dy: 0,\n                    dWidth: srcElement.naturalWidth,\n                    dHeight: srcElement.naturalHeight\n                };\n            }\n            if (!canvasElementContext) {\n                canvasElementContext = this.captureCanvasContext;\n            }\n            canvasElementContext.drawImage(srcElement, dimensions.sx, dimensions.sy, dimensions.sWidth, dimensions.sHeight, dimensions.dx, dimensions.dy, dimensions.dWidth, dimensions.dHeight);\n        }\n        /**\n         * Creates a binaryBitmap based in some image source.\n         *\n         * @param mediaElement HTML element containing drawable image source.\n         */ createBinaryBitmap(mediaElement) {\n            const ctx = this.getCaptureCanvasContext(mediaElement);\n            if (this._isHTMLVideoElement(mediaElement)) {\n                this.drawFrameOnCanvas(mediaElement);\n            } else {\n                this.drawImageOnCanvas(mediaElement);\n            }\n            const canvas = this.getCaptureCanvas(mediaElement);\n            const luminanceSource = new HTMLCanvasElementLuminanceSource(canvas);\n            const hybridBinarizer = new HybridBinarizer(luminanceSource);\n            return new BinaryBitmap(hybridBinarizer);\n        }\n        getCaptureCanvasContext(mediaElement) {\n            if (!this.captureCanvasContext) {\n                const elem = this.getCaptureCanvas(mediaElement);\n                const ctx = elem.getContext(\"2d\");\n                this.captureCanvasContext = ctx;\n            }\n            return this.captureCanvasContext;\n        }\n        getCaptureCanvas(mediaElement) {\n            if (!this.captureCanvas) {\n                const elem = this.createCaptureCanvas(mediaElement);\n                this.captureCanvas = elem;\n            }\n            return this.captureCanvas;\n        }\n        /**\n         * Call the encapsulated readers decode\n         */ decodeBitmap(binaryBitmap) {\n            return this.reader.decode(binaryBitmap, this._hints);\n        }\n        /**\n         * 🖌 Prepares the canvas for capture and scan frames.\n         */ createCaptureCanvas(mediaElement) {\n            if (typeof document === \"undefined\") {\n                this._destroyCaptureCanvas();\n                return null;\n            }\n            const canvasElement = document.createElement(\"canvas\");\n            let width;\n            let height;\n            if (typeof mediaElement !== \"undefined\") {\n                if (mediaElement instanceof HTMLVideoElement) {\n                    width = mediaElement.videoWidth;\n                    height = mediaElement.videoHeight;\n                } else if (mediaElement instanceof HTMLImageElement) {\n                    width = mediaElement.naturalWidth || mediaElement.width;\n                    height = mediaElement.naturalHeight || mediaElement.height;\n                }\n            }\n            canvasElement.style.width = width + \"px\";\n            canvasElement.style.height = height + \"px\";\n            canvasElement.width = width;\n            canvasElement.height = height;\n            return canvasElement;\n        }\n        /**\n         * Stops the continuous scan and cleans the stream.\n         */ stopStreams() {\n            if (this.stream) {\n                this.stream.getVideoTracks().forEach((t)=>t.stop());\n                this.stream = undefined;\n            }\n            if (this._stopAsyncDecode === false) {\n                this.stopAsyncDecode();\n            }\n            if (this._stopContinuousDecode === false) {\n                this.stopContinuousDecode();\n            }\n        }\n        /**\n         * Resets the code reader to the initial state. Cancels any ongoing barcode scanning from video or camera.\n         *\n         * @memberOf BrowserCodeReader\n         */ reset() {\n            // stops the camera, preview and scan 🔴\n            this.stopStreams();\n            // clean and forget about HTML elements\n            this._destroyVideoElement();\n            this._destroyImageElement();\n            this._destroyCaptureCanvas();\n        }\n        _destroyVideoElement() {\n            if (!this.videoElement) {\n                return;\n            }\n            // first gives freedon to the element 🕊\n            if (typeof this.videoEndedListener !== \"undefined\") {\n                this.videoElement.removeEventListener(\"ended\", this.videoEndedListener);\n            }\n            if (typeof this.videoPlayingEventListener !== \"undefined\") {\n                this.videoElement.removeEventListener(\"playing\", this.videoPlayingEventListener);\n            }\n            if (typeof this.videoCanPlayListener !== \"undefined\") {\n                this.videoElement.removeEventListener(\"loadedmetadata\", this.videoCanPlayListener);\n            }\n            // then forgets about that element 😢\n            this.cleanVideoSource(this.videoElement);\n            this.videoElement = undefined;\n        }\n        _destroyImageElement() {\n            if (!this.imageElement) {\n                return;\n            }\n            // first gives freedon to the element 🕊\n            if (undefined !== this.imageLoadedListener) {\n                this.imageElement.removeEventListener(\"load\", this.imageLoadedListener);\n            }\n            // then forget about that element 😢\n            this.imageElement.src = undefined;\n            this.imageElement.removeAttribute(\"src\");\n            this.imageElement = undefined;\n        }\n        /**\n         * Cleans canvas references 🖌\n         */ _destroyCaptureCanvas() {\n            // then forget about that element 😢\n            this.captureCanvasContext = undefined;\n            this.captureCanvas = undefined;\n        }\n        /**\n         * Defines what the videoElement src will be.\n         *\n         * @param videoElement\n         * @param stream\n         */ addVideoSource(videoElement, stream) {\n            // Older browsers may not have `srcObject`\n            try {\n                // @note Throws Exception if interrupted by a new loaded request\n                videoElement.srcObject = stream;\n            } catch (err) {\n                // @note Avoid using this in new browsers, as it is going away.\n                videoElement.src = URL.createObjectURL(stream);\n            }\n        }\n        /**\n         * Unbinds a HTML video src property.\n         *\n         * @param videoElement\n         */ cleanVideoSource(videoElement) {\n            try {\n                videoElement.srcObject = null;\n            } catch (err) {\n                videoElement.src = \"\";\n            }\n            this.videoElement.removeAttribute(\"src\");\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>Encapsulates the result of decoding a barcode within an image.</p>\n     *\n     * @author Sean Owen\n     */ class Result {\n        // public constructor(private text: string,\n        //               Uint8Array rawBytes,\n        //               ResultPoconst resultPoints: Int32Array,\n        //               BarcodeFormat format) {\n        //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())\n        // }\n        // public constructor(text: string,\n        //               Uint8Array rawBytes,\n        //               ResultPoconst resultPoints: Int32Array,\n        //               BarcodeFormat format,\n        //               long timestamp) {\n        //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,\n        //        resultPoints, format, timestamp)\n        // }\n        constructor(text, rawBytes, numBits = rawBytes == null ? 0 : 8 * rawBytes.length, resultPoints, format, timestamp = System.currentTimeMillis()){\n            this.text = text;\n            this.rawBytes = rawBytes;\n            this.numBits = numBits;\n            this.resultPoints = resultPoints;\n            this.format = format;\n            this.timestamp = timestamp;\n            this.text = text;\n            this.rawBytes = rawBytes;\n            if (undefined === numBits || null === numBits) {\n                this.numBits = rawBytes === null || rawBytes === undefined ? 0 : 8 * rawBytes.length;\n            } else {\n                this.numBits = numBits;\n            }\n            this.resultPoints = resultPoints;\n            this.format = format;\n            this.resultMetadata = null;\n            if (undefined === timestamp || null === timestamp) {\n                this.timestamp = System.currentTimeMillis();\n            } else {\n                this.timestamp = timestamp;\n            }\n        }\n        /**\n         * @return raw text encoded by the barcode\n         */ getText() {\n            return this.text;\n        }\n        /**\n         * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}\n         */ getRawBytes() {\n            return this.rawBytes;\n        }\n        /**\n         * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n         * @since 3.3.0\n         */ getNumBits() {\n            return this.numBits;\n        }\n        /**\n         * @return points related to the barcode in the image. These are typically points\n         *         identifying finder patterns or the corners of the barcode. The exact meaning is\n         *         specific to the type of barcode that was decoded.\n         */ getResultPoints() {\n            return this.resultPoints;\n        }\n        /**\n         * @return {@link BarcodeFormat} representing the format of the barcode that was decoded\n         */ getBarcodeFormat() {\n            return this.format;\n        }\n        /**\n         * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be\n         *   {@code null}. This contains optional metadata about what was detected about the barcode,\n         *   like orientation.\n         */ getResultMetadata() {\n            return this.resultMetadata;\n        }\n        putMetadata(type, value) {\n            if (this.resultMetadata === null) {\n                this.resultMetadata = new Map();\n            }\n            this.resultMetadata.set(type, value);\n        }\n        putAllMetadata(metadata) {\n            if (metadata !== null) {\n                if (this.resultMetadata === null) {\n                    this.resultMetadata = metadata;\n                } else {\n                    this.resultMetadata = new Map(metadata);\n                }\n            }\n        }\n        addResultPoints(newPoints) {\n            const oldPoints = this.resultPoints;\n            if (oldPoints === null) {\n                this.resultPoints = newPoints;\n            } else if (newPoints !== null && newPoints.length > 0) {\n                const allPoints = new Array(oldPoints.length + newPoints.length);\n                System.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);\n                System.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);\n                this.resultPoints = allPoints;\n            }\n        }\n        getTimestamp() {\n            return this.timestamp;\n        }\n        /*@Override*/ toString() {\n            return this.text;\n        }\n    }\n    /*\n     * Direct port to TypeScript of ZXing by Adrian Toșcă\n     */ /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*namespace com.google.zxing {*/ /**\n     * Enumerates barcode formats known to this package. Please keep alphabetized.\n     *\n     * @author Sean Owen\n     */ var BarcodeFormat;\n    (function(BarcodeFormat) {\n        /** Aztec 2D barcode format. */ BarcodeFormat[BarcodeFormat[\"AZTEC\"] = 0] = \"AZTEC\";\n        /** CODABAR 1D format. */ BarcodeFormat[BarcodeFormat[\"CODABAR\"] = 1] = \"CODABAR\";\n        /** Code 39 1D format. */ BarcodeFormat[BarcodeFormat[\"CODE_39\"] = 2] = \"CODE_39\";\n        /** Code 93 1D format. */ BarcodeFormat[BarcodeFormat[\"CODE_93\"] = 3] = \"CODE_93\";\n        /** Code 128 1D format. */ BarcodeFormat[BarcodeFormat[\"CODE_128\"] = 4] = \"CODE_128\";\n        /** Data Matrix 2D barcode format. */ BarcodeFormat[BarcodeFormat[\"DATA_MATRIX\"] = 5] = \"DATA_MATRIX\";\n        /** EAN-8 1D format. */ BarcodeFormat[BarcodeFormat[\"EAN_8\"] = 6] = \"EAN_8\";\n        /** EAN-13 1D format. */ BarcodeFormat[BarcodeFormat[\"EAN_13\"] = 7] = \"EAN_13\";\n        /** ITF (Interleaved Two of Five) 1D format. */ BarcodeFormat[BarcodeFormat[\"ITF\"] = 8] = \"ITF\";\n        /** MaxiCode 2D barcode format. */ BarcodeFormat[BarcodeFormat[\"MAXICODE\"] = 9] = \"MAXICODE\";\n        /** PDF417 format. */ BarcodeFormat[BarcodeFormat[\"PDF_417\"] = 10] = \"PDF_417\";\n        /** QR Code 2D barcode format. */ BarcodeFormat[BarcodeFormat[\"QR_CODE\"] = 11] = \"QR_CODE\";\n        /** RSS 14 */ BarcodeFormat[BarcodeFormat[\"RSS_14\"] = 12] = \"RSS_14\";\n        /** RSS EXPANDED */ BarcodeFormat[BarcodeFormat[\"RSS_EXPANDED\"] = 13] = \"RSS_EXPANDED\";\n        /** UPC-A 1D format. */ BarcodeFormat[BarcodeFormat[\"UPC_A\"] = 14] = \"UPC_A\";\n        /** UPC-E 1D format. */ BarcodeFormat[BarcodeFormat[\"UPC_E\"] = 15] = \"UPC_E\";\n        /** UPC/EAN extension format. Not a stand-alone format. */ BarcodeFormat[BarcodeFormat[\"UPC_EAN_EXTENSION\"] = 16] = \"UPC_EAN_EXTENSION\";\n    })(BarcodeFormat || (BarcodeFormat = {}));\n    var BarcodeFormat$1 = BarcodeFormat;\n    /*namespace com.google.zxing {*/ /**\n     * Represents some type of metadata about the result of the decoding that the decoder\n     * wishes to communicate back to the caller.\n     *\n     * @author Sean Owen\n     */ var ResultMetadataType;\n    (function(ResultMetadataType) {\n        /**\n         * Unspecified, application-specific metadata. Maps to an unspecified {@link Object}.\n         */ ResultMetadataType[ResultMetadataType[\"OTHER\"] = 0] = \"OTHER\";\n        /**\n         * Denotes the likely approximate orientation of the barcode in the image. This value\n         * is given as degrees rotated clockwise from the normal, upright orientation.\n         * For example a 1D barcode which was found by reading top-to-bottom would be\n         * said to have orientation \"90\". This key maps to an {@link Integer} whose\n         * value is in the range [0,360).\n         */ ResultMetadataType[ResultMetadataType[\"ORIENTATION\"] = 1] = \"ORIENTATION\";\n        /**\n         * <p>2D barcode formats typically encode text, but allow for a sort of 'byte mode'\n         * which is sometimes used to encode binary data. While {@link Result} makes available\n         * the complete raw bytes in the barcode for these formats, it does not offer the bytes\n         * from the byte segments alone.</p>\n         *\n         * <p>This maps to a {@link java.util.List} of byte arrays corresponding to the\n         * raw bytes in the byte segments in the barcode, in order.</p>\n         */ ResultMetadataType[ResultMetadataType[\"BYTE_SEGMENTS\"] = 2] = \"BYTE_SEGMENTS\";\n        /**\n         * Error correction level used, if applicable. The value type depends on the\n         * format, but is typically a String.\n         */ ResultMetadataType[ResultMetadataType[\"ERROR_CORRECTION_LEVEL\"] = 3] = \"ERROR_CORRECTION_LEVEL\";\n        /**\n         * For some periodicals, indicates the issue number as an {@link Integer}.\n         */ ResultMetadataType[ResultMetadataType[\"ISSUE_NUMBER\"] = 4] = \"ISSUE_NUMBER\";\n        /**\n         * For some products, indicates the suggested retail price in the barcode as a\n         * formatted {@link String}.\n         */ ResultMetadataType[ResultMetadataType[\"SUGGESTED_PRICE\"] = 5] = \"SUGGESTED_PRICE\";\n        /**\n         * For some products, the possible country of manufacture as a {@link String} denoting the\n         * ISO country code. Some map to multiple possible countries, like \"US/CA\".\n         */ ResultMetadataType[ResultMetadataType[\"POSSIBLE_COUNTRY\"] = 6] = \"POSSIBLE_COUNTRY\";\n        /**\n         * For some products, the extension text\n         */ ResultMetadataType[ResultMetadataType[\"UPC_EAN_EXTENSION\"] = 7] = \"UPC_EAN_EXTENSION\";\n        /**\n         * PDF417-specific metadata\n         */ ResultMetadataType[ResultMetadataType[\"PDF417_EXTRA_METADATA\"] = 8] = \"PDF417_EXTRA_METADATA\";\n        /**\n         * If the code format supports structured append and the current scanned code is part of one then the\n         * sequence number is given with it.\n         */ ResultMetadataType[ResultMetadataType[\"STRUCTURED_APPEND_SEQUENCE\"] = 9] = \"STRUCTURED_APPEND_SEQUENCE\";\n        /**\n         * If the code format supports structured append and the current scanned code is part of one then the\n         * parity is given with it.\n         */ ResultMetadataType[ResultMetadataType[\"STRUCTURED_APPEND_PARITY\"] = 10] = \"STRUCTURED_APPEND_PARITY\";\n    })(ResultMetadataType || (ResultMetadataType = {}));\n    var ResultMetadataType$1 = ResultMetadataType;\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*namespace com.google.zxing.common {*/ /*import java.util.List;*/ /**\n     * <p>Encapsulates the result of decoding a matrix of bits. This typically\n     * applies to 2D barcode formats. For now it contains the raw bytes obtained,\n     * as well as a String interpretation of those bytes, if applicable.</p>\n     *\n     * @author Sean Owen\n     */ class DecoderResult {\n        // public constructor(rawBytes: Uint8Array,\n        //                      text: string,\n        //                      List<Uint8Array> byteSegments,\n        //                      String ecLevel) {\n        //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)\n        // }\n        constructor(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber = -1, structuredAppendParity = -1){\n            this.rawBytes = rawBytes;\n            this.text = text;\n            this.byteSegments = byteSegments;\n            this.ecLevel = ecLevel;\n            this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;\n            this.structuredAppendParity = structuredAppendParity;\n            this.numBits = rawBytes === undefined || rawBytes === null ? 0 : 8 * rawBytes.length;\n        }\n        /**\n         * @return raw bytes representing the result, or {@code null} if not applicable\n         */ getRawBytes() {\n            return this.rawBytes;\n        }\n        /**\n         * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n         * @since 3.3.0\n         */ getNumBits() {\n            return this.numBits;\n        }\n        /**\n         * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}\n         * @since 3.3.0\n         */ setNumBits(numBits /*int*/ ) {\n            this.numBits = numBits;\n        }\n        /**\n         * @return text representation of the result\n         */ getText() {\n            return this.text;\n        }\n        /**\n         * @return list of byte segments in the result, or {@code null} if not applicable\n         */ getByteSegments() {\n            return this.byteSegments;\n        }\n        /**\n         * @return name of error correction level used, or {@code null} if not applicable\n         */ getECLevel() {\n            return this.ecLevel;\n        }\n        /**\n         * @return number of errors corrected, or {@code null} if not applicable\n         */ getErrorsCorrected() {\n            return this.errorsCorrected;\n        }\n        setErrorsCorrected(errorsCorrected /*Integer*/ ) {\n            this.errorsCorrected = errorsCorrected;\n        }\n        /**\n         * @return number of erasures corrected, or {@code null} if not applicable\n         */ getErasures() {\n            return this.erasures;\n        }\n        setErasures(erasures /*Integer*/ ) {\n            this.erasures = erasures;\n        }\n        /**\n         * @return arbitrary additional metadata\n         */ getOther() {\n            return this.other;\n        }\n        setOther(other) {\n            this.other = other;\n        }\n        hasStructuredAppend() {\n            return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;\n        }\n        getStructuredAppendParity() {\n            return this.structuredAppendParity;\n        }\n        getStructuredAppendSequenceNumber() {\n            return this.structuredAppendSequenceNumber;\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>This class contains utility methods for performing mathematical operations over\n     * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>\n     *\n     * <p>Throughout this package, elements of the GF are represented as an {@code int}\n     * for convenience and speed (but at the cost of memory).\n     * </p>\n     *\n     * @author Sean Owen\n     * @author David Olivier\n     */ class AbstractGenericGF {\n        /**\n         * @return 2 to the power of a in GF(size)\n         */ exp(a) {\n            return this.expTable[a];\n        }\n        /**\n         * @return base 2 log of a in GF(size)\n         */ log(a /*int*/ ) {\n            if (a === 0) {\n                throw new IllegalArgumentException();\n            }\n            return this.logTable[a];\n        }\n        /**\n         * Implements both addition and subtraction -- they are the same in GF(size).\n         *\n         * @return sum/difference of a and b\n         */ static addOrSubtract(a /*int*/ , b /*int*/ ) {\n            return a ^ b;\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>Represents a polynomial whose coefficients are elements of a GF.\n     * Instances of this class are immutable.</p>\n     *\n     * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\n     * port of his C++ Reed-Solomon implementation.</p>\n     *\n     * @author Sean Owen\n     */ class GenericGFPoly {\n        /**\n         * @param field the {@link GenericGF} instance representing the field to use\n         * to perform computations\n         * @param coefficients coefficients as ints representing elements of GF(size), arranged\n         * from most significant (highest-power term) coefficient to least significant\n         * @throws IllegalArgumentException if argument is null or empty,\n         * or if leading coefficient is 0 and this is not a\n         * constant polynomial (that is, it is not the monomial \"0\")\n         */ constructor(field, coefficients){\n            if (coefficients.length === 0) {\n                throw new IllegalArgumentException();\n            }\n            this.field = field;\n            const coefficientsLength = coefficients.length;\n            if (coefficientsLength > 1 && coefficients[0] === 0) {\n                // Leading term must be non-zero for anything except the constant polynomial \"0\"\n                let firstNonZero = 1;\n                while(firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0){\n                    firstNonZero++;\n                }\n                if (firstNonZero === coefficientsLength) {\n                    this.coefficients = Int32Array.from([\n                        0\n                    ]);\n                } else {\n                    this.coefficients = new Int32Array(coefficientsLength - firstNonZero);\n                    System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);\n                }\n            } else {\n                this.coefficients = coefficients;\n            }\n        }\n        getCoefficients() {\n            return this.coefficients;\n        }\n        /**\n         * @return degree of this polynomial\n         */ getDegree() {\n            return this.coefficients.length - 1;\n        }\n        /**\n         * @return true iff this polynomial is the monomial \"0\"\n         */ isZero() {\n            return this.coefficients[0] === 0;\n        }\n        /**\n         * @return coefficient of x^degree term in this polynomial\n         */ getCoefficient(degree /*int*/ ) {\n            return this.coefficients[this.coefficients.length - 1 - degree];\n        }\n        /**\n         * @return evaluation of this polynomial at a given point\n         */ evaluateAt(a /*int*/ ) {\n            if (a === 0) {\n                // Just return the x^0 coefficient\n                return this.getCoefficient(0);\n            }\n            const coefficients = this.coefficients;\n            let result;\n            if (a === 1) {\n                // Just the sum of the coefficients\n                result = 0;\n                for(let i = 0, length = coefficients.length; i !== length; i++){\n                    const coefficient = coefficients[i];\n                    result = AbstractGenericGF.addOrSubtract(result, coefficient);\n                }\n                return result;\n            }\n            result = coefficients[0];\n            const size = coefficients.length;\n            const field = this.field;\n            for(let i = 1; i < size; i++){\n                result = AbstractGenericGF.addOrSubtract(field.multiply(a, result), coefficients[i]);\n            }\n            return result;\n        }\n        addOrSubtract(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException(\"GenericGFPolys do not have same GenericGF field\");\n            }\n            if (this.isZero()) {\n                return other;\n            }\n            if (other.isZero()) {\n                return this;\n            }\n            let smallerCoefficients = this.coefficients;\n            let largerCoefficients = other.coefficients;\n            if (smallerCoefficients.length > largerCoefficients.length) {\n                const temp = smallerCoefficients;\n                smallerCoefficients = largerCoefficients;\n                largerCoefficients = temp;\n            }\n            let sumDiff = new Int32Array(largerCoefficients.length);\n            const lengthDiff = largerCoefficients.length - smallerCoefficients.length;\n            // Copy high-order terms only found in higher-degree polynomial's coefficients\n            System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);\n            for(let i = lengthDiff; i < largerCoefficients.length; i++){\n                sumDiff[i] = AbstractGenericGF.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n            }\n            return new GenericGFPoly(this.field, sumDiff);\n        }\n        multiply(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException(\"GenericGFPolys do not have same GenericGF field\");\n            }\n            if (this.isZero() || other.isZero()) {\n                return this.field.getZero();\n            }\n            const aCoefficients = this.coefficients;\n            const aLength = aCoefficients.length;\n            const bCoefficients = other.coefficients;\n            const bLength = bCoefficients.length;\n            const product = new Int32Array(aLength + bLength - 1);\n            const field = this.field;\n            for(let i = 0; i < aLength; i++){\n                const aCoeff = aCoefficients[i];\n                for(let j = 0; j < bLength; j++){\n                    product[i + j] = AbstractGenericGF.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));\n                }\n            }\n            return new GenericGFPoly(field, product);\n        }\n        multiplyScalar(scalar /*int*/ ) {\n            if (scalar === 0) {\n                return this.field.getZero();\n            }\n            if (scalar === 1) {\n                return this;\n            }\n            const size = this.coefficients.length;\n            const field = this.field;\n            const product = new Int32Array(size);\n            const coefficients = this.coefficients;\n            for(let i = 0; i < size; i++){\n                product[i] = field.multiply(coefficients[i], scalar);\n            }\n            return new GenericGFPoly(field, product);\n        }\n        multiplyByMonomial(degree /*int*/ , coefficient /*int*/ ) {\n            if (degree < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (coefficient === 0) {\n                return this.field.getZero();\n            }\n            const coefficients = this.coefficients;\n            const size = coefficients.length;\n            const product = new Int32Array(size + degree);\n            const field = this.field;\n            for(let i = 0; i < size; i++){\n                product[i] = field.multiply(coefficients[i], coefficient);\n            }\n            return new GenericGFPoly(field, product);\n        }\n        divide(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException(\"GenericGFPolys do not have same GenericGF field\");\n            }\n            if (other.isZero()) {\n                throw new IllegalArgumentException(\"Divide by 0\");\n            }\n            const field = this.field;\n            let quotient = field.getZero();\n            let remainder = this;\n            const denominatorLeadingTerm = other.getCoefficient(other.getDegree());\n            const inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);\n            while(remainder.getDegree() >= other.getDegree() && !remainder.isZero()){\n                const degreeDifference = remainder.getDegree() - other.getDegree();\n                const scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);\n                const term = other.multiplyByMonomial(degreeDifference, scale);\n                const iterationQuotient = field.buildMonomial(degreeDifference, scale);\n                quotient = quotient.addOrSubtract(iterationQuotient);\n                remainder = remainder.addOrSubtract(term);\n            }\n            return [\n                quotient,\n                remainder\n            ];\n        }\n        /*@Override*/ toString() {\n            let result = \"\";\n            for(let degree = this.getDegree(); degree >= 0; degree--){\n                let coefficient = this.getCoefficient(degree);\n                if (coefficient !== 0) {\n                    if (coefficient < 0) {\n                        result += \" - \";\n                        coefficient = -coefficient;\n                    } else {\n                        if (result.length > 0) {\n                            result += \" + \";\n                        }\n                    }\n                    if (degree === 0 || coefficient !== 1) {\n                        const alphaPower = this.field.log(coefficient);\n                        if (alphaPower === 0) {\n                            result += \"1\";\n                        } else if (alphaPower === 1) {\n                            result += \"a\";\n                        } else {\n                            result += \"a^\";\n                            result += alphaPower;\n                        }\n                    }\n                    if (degree !== 0) {\n                        if (degree === 1) {\n                            result += \"x\";\n                        } else {\n                            result += \"x^\";\n                            result += degree;\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n    }\n    /**\n     * Custom Error class of type Exception.\n     */ class ArithmeticException extends Exception {\n    }\n    ArithmeticException.kind = \"ArithmeticException\";\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>This class contains utility methods for performing mathematical operations over\n     * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>\n     *\n     * <p>Throughout this package, elements of the GF are represented as an {@code int}\n     * for convenience and speed (but at the cost of memory).\n     * </p>\n     *\n     * @author Sean Owen\n     * @author David Olivier\n     */ class GenericGF extends AbstractGenericGF {\n        /**\n         * Create a representation of GF(size) using the given primitive polynomial.\n         *\n         * @param primitive irreducible polynomial whose coefficients are represented by\n         *  the bits of an int, where the least-significant bit represents the constant\n         *  coefficient\n         * @param size the size of the field\n         * @param b the factor b in the generator polynomial can be 0- or 1-based\n         *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).\n         *  In most cases it should be 1, but for QR code it is 0.\n         */ constructor(primitive /*int*/ , size /*int*/ , generatorBase /*int*/ ){\n            super();\n            this.primitive = primitive;\n            this.size = size;\n            this.generatorBase = generatorBase;\n            const expTable = new Int32Array(size);\n            let x = 1;\n            for(let i = 0; i < size; i++){\n                expTable[i] = x;\n                x *= 2; // we're assuming the generator alpha is 2\n                if (x >= size) {\n                    x ^= primitive;\n                    x &= size - 1;\n                }\n            }\n            this.expTable = expTable;\n            const logTable = new Int32Array(size);\n            for(let i = 0; i < size - 1; i++){\n                logTable[expTable[i]] = i;\n            }\n            this.logTable = logTable;\n            // logTable[0] == 0 but this should never be used\n            this.zero = new GenericGFPoly(this, Int32Array.from([\n                0\n            ]));\n            this.one = new GenericGFPoly(this, Int32Array.from([\n                1\n            ]));\n        }\n        getZero() {\n            return this.zero;\n        }\n        getOne() {\n            return this.one;\n        }\n        /**\n         * @return the monomial representing coefficient * x^degree\n         */ buildMonomial(degree /*int*/ , coefficient /*int*/ ) {\n            if (degree < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (coefficient === 0) {\n                return this.zero;\n            }\n            const coefficients = new Int32Array(degree + 1);\n            coefficients[0] = coefficient;\n            return new GenericGFPoly(this, coefficients);\n        }\n        /**\n         * @return multiplicative inverse of a\n         */ inverse(a /*int*/ ) {\n            if (a === 0) {\n                throw new ArithmeticException();\n            }\n            return this.expTable[this.size - this.logTable[a] - 1];\n        }\n        /**\n         * @return product of a and b in GF(size)\n         */ multiply(a /*int*/ , b /*int*/ ) {\n            if (a === 0 || b === 0) {\n                return 0;\n            }\n            return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];\n        }\n        getSize() {\n            return this.size;\n        }\n        getGeneratorBase() {\n            return this.generatorBase;\n        }\n        /*@Override*/ toString() {\n            return \"GF(0x\" + Integer.toHexString(this.primitive) + \",\" + this.size + \")\";\n        }\n        equals(o) {\n            return o === this;\n        }\n    }\n    GenericGF.AZTEC_DATA_12 = new GenericGF(0x1069, 4096, 1); // x^12 + x^6 + x^5 + x^3 + 1\n    GenericGF.AZTEC_DATA_10 = new GenericGF(0x409, 1024, 1); // x^10 + x^3 + 1\n    GenericGF.AZTEC_DATA_6 = new GenericGF(0x43, 64, 1); // x^6 + x + 1\n    GenericGF.AZTEC_PARAM = new GenericGF(0x13, 16, 1); // x^4 + x + 1\n    GenericGF.QR_CODE_FIELD_256 = new GenericGF(0x011d, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1\n    GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(0x012d, 256, 1); // x^8 + x^5 + x^3 + x^2 + 1\n    GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;\n    GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;\n    /**\n     * Custom Error class of type Exception.\n     */ class ReedSolomonException extends Exception {\n    }\n    ReedSolomonException.kind = \"ReedSolomonException\";\n    /**\n     * Custom Error class of type Exception.\n     */ class IllegalStateException extends Exception {\n    }\n    IllegalStateException.kind = \"IllegalStateException\";\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>Implements Reed-Solomon decoding, as the name implies.</p>\n     *\n     * <p>The algorithm will not be explained here, but the following references were helpful\n     * in creating this implementation:</p>\n     *\n     * <ul>\n     * <li>Bruce Maggs.\n     * <a href=\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps\">\n     * \"Decoding Reed-Solomon Codes\"</a> (see discussion of Forney's Formula)</li>\n     * <li>J.I. Hall. <a href=\"www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf\">\n     * \"Chapter 5. Generalized Reed-Solomon Codes\"</a>\n     * (see discussion of Euclidean algorithm)</li>\n     * </ul>\n     *\n     * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\n     * port of his C++ Reed-Solomon implementation.</p>\n     *\n     * @author Sean Owen\n     * @author William Rucklidge\n     * @author sanfordsquires\n     */ class ReedSolomonDecoder {\n        constructor(field){\n            this.field = field;\n        }\n        /**\n         * <p>Decodes given set of received codewords, which include both data and error-correction\n         * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,\n         * in the input.</p>\n         *\n         * @param received data and error-correction codewords\n         * @param twoS number of error-correction codewords available\n         * @throws ReedSolomonException if decoding fails for any reason\n         */ decode(received, twoS /*int*/ ) {\n            const field = this.field;\n            const poly = new GenericGFPoly(field, received);\n            const syndromeCoefficients = new Int32Array(twoS);\n            let noError = true;\n            for(let i = 0; i < twoS; i++){\n                const evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));\n                syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;\n                if (evalResult !== 0) {\n                    noError = false;\n                }\n            }\n            if (noError) {\n                return;\n            }\n            const syndrome = new GenericGFPoly(field, syndromeCoefficients);\n            const sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);\n            const sigma = sigmaOmega[0];\n            const omega = sigmaOmega[1];\n            const errorLocations = this.findErrorLocations(sigma);\n            const errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);\n            for(let i = 0; i < errorLocations.length; i++){\n                const position = received.length - 1 - field.log(errorLocations[i]);\n                if (position < 0) {\n                    throw new ReedSolomonException(\"Bad error location\");\n                }\n                received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i]);\n            }\n        }\n        runEuclideanAlgorithm(a, b, R /*int*/ ) {\n            // Assume a's degree is >= b's\n            if (a.getDegree() < b.getDegree()) {\n                const temp = a;\n                a = b;\n                b = temp;\n            }\n            const field = this.field;\n            let rLast = a;\n            let r = b;\n            let tLast = field.getZero();\n            let t = field.getOne();\n            // Run Euclidean algorithm until r's degree is less than R/2\n            while(r.getDegree() >= (R / 2 | 0)){\n                let rLastLast = rLast;\n                let tLastLast = tLast;\n                rLast = r;\n                tLast = t;\n                // Divide rLastLast by rLast, with quotient in q and remainder in r\n                if (rLast.isZero()) {\n                    // Oops, Euclidean algorithm already terminated?\n                    throw new ReedSolomonException(\"r_{i-1} was zero\");\n                }\n                r = rLastLast;\n                let q = field.getZero();\n                const denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n                const dltInverse = field.inverse(denominatorLeadingTerm);\n                while(r.getDegree() >= rLast.getDegree() && !r.isZero()){\n                    const degreeDiff = r.getDegree() - rLast.getDegree();\n                    const scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n                    q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));\n                    r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));\n                }\n                t = q.multiply(tLast).addOrSubtract(tLastLast);\n                if (r.getDegree() >= rLast.getDegree()) {\n                    throw new IllegalStateException(\"Division algorithm failed to reduce polynomial?\");\n                }\n            }\n            const sigmaTildeAtZero = t.getCoefficient(0);\n            if (sigmaTildeAtZero === 0) {\n                throw new ReedSolomonException(\"sigmaTilde(0) was zero\");\n            }\n            const inverse = field.inverse(sigmaTildeAtZero);\n            const sigma = t.multiplyScalar(inverse);\n            const omega = r.multiplyScalar(inverse);\n            return [\n                sigma,\n                omega\n            ];\n        }\n        findErrorLocations(errorLocator) {\n            // This is a direct application of Chien's search\n            const numErrors = errorLocator.getDegree();\n            if (numErrors === 1) {\n                return Int32Array.from([\n                    errorLocator.getCoefficient(1)\n                ]);\n            }\n            const result = new Int32Array(numErrors);\n            let e = 0;\n            const field = this.field;\n            for(let i = 1; i < field.getSize() && e < numErrors; i++){\n                if (errorLocator.evaluateAt(i) === 0) {\n                    result[e] = field.inverse(i);\n                    e++;\n                }\n            }\n            if (e !== numErrors) {\n                throw new ReedSolomonException(\"Error locator degree does not match number of roots\");\n            }\n            return result;\n        }\n        findErrorMagnitudes(errorEvaluator, errorLocations) {\n            // This is directly applying Forney's Formula\n            const s = errorLocations.length;\n            const result = new Int32Array(s);\n            const field = this.field;\n            for(let i = 0; i < s; i++){\n                const xiInverse = field.inverse(errorLocations[i]);\n                let denominator = 1;\n                for(let j = 0; j < s; j++){\n                    if (i !== j) {\n                        // denominator = field.multiply(denominator,\n                        //    GenericGF.addOrSubtract(1, field.multiply(errorLocations[j], xiInverse)))\n                        // Above should work but fails on some Apple and Linux JDKs due to a Hotspot bug.\n                        // Below is a funny-looking workaround from Steven Parkes\n                        const term = field.multiply(errorLocations[j], xiInverse);\n                        const termPlus1 = (term & 0x1) === 0 ? term | 1 : term & ~1;\n                        denominator = field.multiply(denominator, termPlus1);\n                    }\n                }\n                result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));\n                if (field.getGeneratorBase() !== 0) {\n                    result[i] = field.multiply(result[i], xiInverse);\n                }\n            }\n            return result;\n        }\n    }\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ // import java.util.Arrays;\n    var Table;\n    (function(Table) {\n        Table[Table[\"UPPER\"] = 0] = \"UPPER\";\n        Table[Table[\"LOWER\"] = 1] = \"LOWER\";\n        Table[Table[\"MIXED\"] = 2] = \"MIXED\";\n        Table[Table[\"DIGIT\"] = 3] = \"DIGIT\";\n        Table[Table[\"PUNCT\"] = 4] = \"PUNCT\";\n        Table[Table[\"BINARY\"] = 5] = \"BINARY\";\n    })(Table || (Table = {}));\n    /**\n     * <p>The main class which implements Aztec Code decoding -- as opposed to locating and extracting\n     * the Aztec Code from an image.</p>\n     *\n     * @author David Olivier\n     */ class Decoder {\n        decode(detectorResult) {\n            this.ddata = detectorResult;\n            let matrix = detectorResult.getBits();\n            let rawbits = this.extractBits(matrix);\n            let correctedBits = this.correctBits(rawbits);\n            let rawBytes = Decoder.convertBoolArrayToByteArray(correctedBits);\n            let result = Decoder.getEncodedData(correctedBits);\n            let decoderResult = new DecoderResult(rawBytes, result, null, null);\n            decoderResult.setNumBits(correctedBits.length);\n            return decoderResult;\n        }\n        // This method is used for testing the high-level encoder\n        static highLevelDecode(correctedBits) {\n            return this.getEncodedData(correctedBits);\n        }\n        /**\n         * Gets the string encoded in the aztec code bits\n         *\n         * @return the decoded string\n         */ static getEncodedData(correctedBits) {\n            let endIndex = correctedBits.length;\n            let latchTable = Table.UPPER; // table most recently latched to\n            let shiftTable = Table.UPPER; // table to use for the next read\n            let result = \"\";\n            let index = 0;\n            while(index < endIndex){\n                if (shiftTable === Table.BINARY) {\n                    if (endIndex - index < 5) {\n                        break;\n                    }\n                    let length = Decoder.readCode(correctedBits, index, 5);\n                    index += 5;\n                    if (length === 0) {\n                        if (endIndex - index < 11) {\n                            break;\n                        }\n                        length = Decoder.readCode(correctedBits, index, 11) + 31;\n                        index += 11;\n                    }\n                    for(let charCount = 0; charCount < length; charCount++){\n                        if (endIndex - index < 8) {\n                            index = endIndex; // Force outer loop to exit\n                            break;\n                        }\n                        const code = Decoder.readCode(correctedBits, index, 8);\n                        result += /*(char)*/ StringUtils.castAsNonUtf8Char(code);\n                        index += 8;\n                    }\n                    // Go back to whatever mode we had been in\n                    shiftTable = latchTable;\n                } else {\n                    let size = shiftTable === Table.DIGIT ? 4 : 5;\n                    if (endIndex - index < size) {\n                        break;\n                    }\n                    let code = Decoder.readCode(correctedBits, index, size);\n                    index += size;\n                    let str = Decoder.getCharacter(shiftTable, code);\n                    if (str.startsWith(\"CTRL_\")) {\n                        // Table changes\n                        // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n                        // That's including when that mode is a shift.\n                        // Our test case dlusbs.png for issue #642 exercises that.\n                        latchTable = shiftTable; // Latch the current mode, so as to return to Upper after U/S B/S\n                        shiftTable = Decoder.getTable(str.charAt(5));\n                        if (str.charAt(6) === \"L\") {\n                            latchTable = shiftTable;\n                        }\n                    } else {\n                        result += str;\n                        // Go back to whatever mode we had been in\n                        shiftTable = latchTable;\n                    }\n                }\n            }\n            return result;\n        }\n        /**\n         * gets the table corresponding to the char passed\n         */ static getTable(t) {\n            switch(t){\n                case \"L\":\n                    return Table.LOWER;\n                case \"P\":\n                    return Table.PUNCT;\n                case \"M\":\n                    return Table.MIXED;\n                case \"D\":\n                    return Table.DIGIT;\n                case \"B\":\n                    return Table.BINARY;\n                case \"U\":\n                default:\n                    return Table.UPPER;\n            }\n        }\n        /**\n         * Gets the character (or string) corresponding to the passed code in the given table\n         *\n         * @param table the table used\n         * @param code the code of the character\n         */ static getCharacter(table, code) {\n            switch(table){\n                case Table.UPPER:\n                    return Decoder.UPPER_TABLE[code];\n                case Table.LOWER:\n                    return Decoder.LOWER_TABLE[code];\n                case Table.MIXED:\n                    return Decoder.MIXED_TABLE[code];\n                case Table.PUNCT:\n                    return Decoder.PUNCT_TABLE[code];\n                case Table.DIGIT:\n                    return Decoder.DIGIT_TABLE[code];\n                default:\n                    // Should not reach here.\n                    throw new IllegalStateException(\"Bad table\");\n            }\n        }\n        /**\n         * <p>Performs RS error correction on an array of bits.</p>\n         *\n         * @return the corrected array\n         * @throws FormatException if the input contains too many errors\n         */ correctBits(rawbits) {\n            let gf;\n            let codewordSize;\n            if (this.ddata.getNbLayers() <= 2) {\n                codewordSize = 6;\n                gf = GenericGF.AZTEC_DATA_6;\n            } else if (this.ddata.getNbLayers() <= 8) {\n                codewordSize = 8;\n                gf = GenericGF.AZTEC_DATA_8;\n            } else if (this.ddata.getNbLayers() <= 22) {\n                codewordSize = 10;\n                gf = GenericGF.AZTEC_DATA_10;\n            } else {\n                codewordSize = 12;\n                gf = GenericGF.AZTEC_DATA_12;\n            }\n            let numDataCodewords = this.ddata.getNbDatablocks();\n            let numCodewords = rawbits.length / codewordSize;\n            if (numCodewords < numDataCodewords) {\n                throw new FormatException();\n            }\n            let offset = rawbits.length % codewordSize;\n            let dataWords = new Int32Array(numCodewords);\n            for(let i = 0; i < numCodewords; i++, offset += codewordSize){\n                dataWords[i] = Decoder.readCode(rawbits, offset, codewordSize);\n            }\n            try {\n                let rsDecoder = new ReedSolomonDecoder(gf);\n                rsDecoder.decode(dataWords, numCodewords - numDataCodewords);\n            } catch (ex) {\n                throw new FormatException(ex);\n            }\n            // Now perform the unstuffing operation.\n            // First, count how many bits are going to be thrown out as stuffing\n            let mask = (1 << codewordSize) - 1;\n            let stuffedBits = 0;\n            for(let i = 0; i < numDataCodewords; i++){\n                let dataWord = dataWords[i];\n                if (dataWord === 0 || dataWord === mask) {\n                    throw new FormatException();\n                } else if (dataWord === 1 || dataWord === mask - 1) {\n                    stuffedBits++;\n                }\n            }\n            // Now, actually unpack the bits and remove the stuffing\n            let correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);\n            let index = 0;\n            for(let i = 0; i < numDataCodewords; i++){\n                let dataWord = dataWords[i];\n                if (dataWord === 1 || dataWord === mask - 1) {\n                    // next codewordSize-1 bits are all zeros or all ones\n                    correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);\n                    // Arrays.fill(correctedBits, index, index + codewordSize - 1, dataWord > 1);\n                    index += codewordSize - 1;\n                } else {\n                    for(let bit = codewordSize - 1; bit >= 0; --bit){\n                        correctedBits[index++] = (dataWord & 1 << bit) !== 0;\n                    }\n                }\n            }\n            return correctedBits;\n        }\n        /**\n         * Gets the array of bits from an Aztec Code matrix\n         *\n         * @return the array of bits\n         */ extractBits(matrix) {\n            let compact = this.ddata.isCompact();\n            let layers = this.ddata.getNbLayers();\n            let baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n            let alignmentMap = new Int32Array(baseMatrixSize);\n            let rawbits = new Array(this.totalBitsInLayer(layers, compact));\n            if (compact) {\n                for(let i = 0; i < alignmentMap.length; i++){\n                    alignmentMap[i] = i;\n                }\n            } else {\n                let matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);\n                let origCenter = baseMatrixSize / 2;\n                let center = Integer.truncDivision(matrixSize, 2);\n                for(let i = 0; i < origCenter; i++){\n                    let newOffset = i + Integer.truncDivision(i, 15);\n                    alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n                    alignmentMap[origCenter + i] = center + newOffset + 1;\n                }\n            }\n            for(let i = 0, rowOffset = 0; i < layers; i++){\n                let rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n                // The top-left most point of this layer is <low, low> (not including alignment lines)\n                let low = i * 2;\n                // The bottom-right most point of this layer is <high, high> (not including alignment lines)\n                let high = baseMatrixSize - 1 - low;\n                // We pull bits from the two 2 x rowSize columns and two rowSize x 2 rows\n                for(let j = 0; j < rowSize; j++){\n                    let columnOffset = j * 2;\n                    for(let k = 0; k < 2; k++){\n                        // left column\n                        rawbits[rowOffset + columnOffset + k] = matrix.get(alignmentMap[low + k], alignmentMap[low + j]);\n                        // bottom row\n                        rawbits[rowOffset + 2 * rowSize + columnOffset + k] = matrix.get(alignmentMap[low + j], alignmentMap[high - k]);\n                        // right column\n                        rawbits[rowOffset + 4 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - k], alignmentMap[high - j]);\n                        // top row\n                        rawbits[rowOffset + 6 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - j], alignmentMap[low + k]);\n                    }\n                }\n                rowOffset += rowSize * 8;\n            }\n            return rawbits;\n        }\n        /**\n         * Reads a code of given length and at given index in an array of bits\n         */ static readCode(rawbits, startIndex, length) {\n            let res = 0;\n            for(let i = startIndex; i < startIndex + length; i++){\n                res <<= 1;\n                if (rawbits[i]) {\n                    res |= 0x01;\n                }\n            }\n            return res;\n        }\n        /**\n         * Reads a code of length 8 in an array of bits, padding with zeros\n         */ static readByte(rawbits, startIndex) {\n            let n = rawbits.length - startIndex;\n            if (n >= 8) {\n                return Decoder.readCode(rawbits, startIndex, 8);\n            }\n            return Decoder.readCode(rawbits, startIndex, n) << 8 - n;\n        }\n        /**\n         * Packs a bit array into bytes, most significant bit first\n         */ static convertBoolArrayToByteArray(boolArr) {\n            let byteArr = new Uint8Array((boolArr.length + 7) / 8);\n            for(let i = 0; i < byteArr.length; i++){\n                byteArr[i] = Decoder.readByte(boolArr, 8 * i);\n            }\n            return byteArr;\n        }\n        totalBitsInLayer(layers, compact) {\n            return ((compact ? 88 : 112) + 16 * layers) * layers;\n        }\n    }\n    Decoder.UPPER_TABLE = [\n        \"CTRL_PS\",\n        \" \",\n        \"A\",\n        \"B\",\n        \"C\",\n        \"D\",\n        \"E\",\n        \"F\",\n        \"G\",\n        \"H\",\n        \"I\",\n        \"J\",\n        \"K\",\n        \"L\",\n        \"M\",\n        \"N\",\n        \"O\",\n        \"P\",\n        \"Q\",\n        \"R\",\n        \"S\",\n        \"T\",\n        \"U\",\n        \"V\",\n        \"W\",\n        \"X\",\n        \"Y\",\n        \"Z\",\n        \"CTRL_LL\",\n        \"CTRL_ML\",\n        \"CTRL_DL\",\n        \"CTRL_BS\"\n    ];\n    Decoder.LOWER_TABLE = [\n        \"CTRL_PS\",\n        \" \",\n        \"a\",\n        \"b\",\n        \"c\",\n        \"d\",\n        \"e\",\n        \"f\",\n        \"g\",\n        \"h\",\n        \"i\",\n        \"j\",\n        \"k\",\n        \"l\",\n        \"m\",\n        \"n\",\n        \"o\",\n        \"p\",\n        \"q\",\n        \"r\",\n        \"s\",\n        \"t\",\n        \"u\",\n        \"v\",\n        \"w\",\n        \"x\",\n        \"y\",\n        \"z\",\n        \"CTRL_US\",\n        \"CTRL_ML\",\n        \"CTRL_DL\",\n        \"CTRL_BS\"\n    ];\n    Decoder.MIXED_TABLE = [\n        // Module parse failed: Octal literal in strict mode (50:29)\n        // so number string were scaped\n        \"CTRL_PS\",\n        \" \",\n        \"\\\\1\",\n        \"\\\\2\",\n        \"\\\\3\",\n        \"\\\\4\",\n        \"\\\\5\",\n        \"\\\\6\",\n        \"\\\\7\",\n        \"\\b\",\n        \"\t\",\n        \"\\n\",\n        \"\\\\13\",\n        \"\\f\",\n        \"\\r\",\n        \"\\\\33\",\n        \"\\\\34\",\n        \"\\\\35\",\n        \"\\\\36\",\n        \"\\\\37\",\n        \"@\",\n        \"\\\\\",\n        \"^\",\n        \"_\",\n        \"`\",\n        \"|\",\n        \"~\",\n        \"\\\\177\",\n        \"CTRL_LL\",\n        \"CTRL_UL\",\n        \"CTRL_PL\",\n        \"CTRL_BS\"\n    ];\n    Decoder.PUNCT_TABLE = [\n        \"\",\n        \"\\r\",\n        \"\\r\\n\",\n        \". \",\n        \", \",\n        \": \",\n        \"!\",\n        '\"',\n        \"#\",\n        \"$\",\n        \"%\",\n        \"&\",\n        \"'\",\n        \"(\",\n        \")\",\n        \"*\",\n        \"+\",\n        \",\",\n        \"-\",\n        \".\",\n        \"/\",\n        \":\",\n        \";\",\n        \"<\",\n        \"=\",\n        \">\",\n        \"?\",\n        \"[\",\n        \"]\",\n        \"{\",\n        \"}\",\n        \"CTRL_UL\"\n    ];\n    Decoder.DIGIT_TABLE = [\n        \"CTRL_PS\",\n        \" \",\n        \"0\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \",\",\n        \".\",\n        \"CTRL_UL\",\n        \"CTRL_US\"\n    ];\n    /*\n     * Copyright 2012 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*namespace com.google.zxing.common.detector {*/ /**\n     * General math-related and numeric utility functions.\n     */ class MathUtils {\n        constructor(){}\n        /**\n         * Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its\n         * argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut\n         * differ slightly from {@link Math#round(float)} in that half rounds down for negative\n         * values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.\n         *\n         * @param d real value to round\n         * @return nearest {@code int}\n         */ static round(d /*float*/ ) {\n            if (NaN === d) return 0;\n            if (d <= Number.MIN_SAFE_INTEGER) return Number.MIN_SAFE_INTEGER;\n            if (d >= Number.MAX_SAFE_INTEGER) return Number.MAX_SAFE_INTEGER;\n            return /*(int) */ d + (d < 0.0 ? -0.5 : 0.5) | 0;\n        }\n        // TYPESCRIPTPORT: maybe remove round method and call directly Math.round, it looks like it doesn't make sense for js\n        /**\n         * @param aX point A x coordinate\n         * @param aY point A y coordinate\n         * @param bX point B x coordinate\n         * @param bY point B y coordinate\n         * @return Euclidean distance between points A and B\n         */ static distance(aX /*float|int*/ , aY /*float|int*/ , bX /*float|int*/ , bY /*float|int*/ ) {\n            const xDiff = aX - bX;\n            const yDiff = aY - bY;\n            return /*(float) */ Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n        }\n        /**\n         * @param aX point A x coordinate\n         * @param aY point A y coordinate\n         * @param bX point B x coordinate\n         * @param bY point B y coordinate\n         * @return Euclidean distance between points A and B\n         */ // public static distance(aX: number /*int*/, aY: number /*int*/, bX: number /*int*/, bY: number /*int*/): float {\n        //   const xDiff = aX - bX\n        //   const yDiff = aY - bY\n        //   return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n        // }\n        /**\n         * @param array values to sum\n         * @return sum of values in array\n         */ static sum(array) {\n            let count = 0;\n            for(let i = 0, length = array.length; i !== length; i++){\n                const a = array[i];\n                count += a;\n            }\n            return count;\n        }\n    }\n    /**\n     * Ponyfill for Java's Float class.\n     */ class Float {\n        /**\n         * SincTS has no difference between int and float, there's all numbers,\n         * this is used only to polyfill Java code.\n         */ static floatToIntBits(f) {\n            return f;\n        }\n    }\n    /**\n     * The float max value in JS is the number max value.\n     */ Float.MAX_VALUE = Number.MAX_SAFE_INTEGER;\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this\n     * would be the location of a finder pattern or the corner of the barcode, for example.</p>\n     *\n     * @author Sean Owen\n     */ class ResultPoint {\n        constructor(x, y){\n            this.x = x;\n            this.y = y;\n        }\n        getX() {\n            return this.x;\n        }\n        getY() {\n            return this.y;\n        }\n        /*@Override*/ equals(other) {\n            if (other instanceof ResultPoint) {\n                const otherPoint = other;\n                return this.x === otherPoint.x && this.y === otherPoint.y;\n            }\n            return false;\n        }\n        /*@Override*/ hashCode() {\n            return 31 * Float.floatToIntBits(this.x) + Float.floatToIntBits(this.y);\n        }\n        /*@Override*/ toString() {\n            return \"(\" + this.x + \",\" + this.y + \")\";\n        }\n        /**\n         * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC\n         * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.\n         *\n         * @param patterns array of three {@code ResultPoint} to order\n         */ static orderBestPatterns(patterns) {\n            // Find distances between pattern centers\n            const zeroOneDistance = this.distance(patterns[0], patterns[1]);\n            const oneTwoDistance = this.distance(patterns[1], patterns[2]);\n            const zeroTwoDistance = this.distance(patterns[0], patterns[2]);\n            let pointA;\n            let pointB;\n            let pointC;\n            // Assume one closest to other two is B; A and C will just be guesses at first\n            if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\n                pointB = patterns[0];\n                pointA = patterns[1];\n                pointC = patterns[2];\n            } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\n                pointB = patterns[1];\n                pointA = patterns[0];\n                pointC = patterns[2];\n            } else {\n                pointB = patterns[2];\n                pointA = patterns[0];\n                pointC = patterns[1];\n            }\n            // Use cross product to figure out whether A and C are correct or flipped.\n            // This asks whether BC x BA has a positive z component, which is the arrangement\n            // we want for A, B, C. If it's negative, then we've got it flipped around and\n            // should swap A and C.\n            if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {\n                const temp = pointA;\n                pointA = pointC;\n                pointC = temp;\n            }\n            patterns[0] = pointA;\n            patterns[1] = pointB;\n            patterns[2] = pointC;\n        }\n        /**\n         * @param pattern1 first pattern\n         * @param pattern2 second pattern\n         * @return distance between two points\n         */ static distance(pattern1, pattern2) {\n            return MathUtils.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);\n        }\n        /**\n         * Returns the z component of the cross product between vectors BC and BA.\n         */ static crossProductZ(pointA, pointB, pointC) {\n            const bX = pointB.x;\n            const bY = pointB.y;\n            return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>Encapsulates the result of detecting a barcode in an image. This includes the raw\n     * matrix of black/white pixels corresponding to the barcode, and possibly points of interest\n     * in the image, like the location of finder patterns or corners of the barcode in the image.</p>\n     *\n     * @author Sean Owen\n     */ class DetectorResult {\n        constructor(bits, points){\n            this.bits = bits;\n            this.points = points;\n        }\n        getBits() {\n            return this.bits;\n        }\n        getPoints() {\n            return this.points;\n        }\n    }\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>Extends {@link DetectorResult} with more information specific to the Aztec format,\n     * like the number of layers and whether it's compact.</p>\n     *\n     * @author Sean Owen\n     */ class AztecDetectorResult extends DetectorResult {\n        constructor(bits, points, compact, nbDatablocks, nbLayers){\n            super(bits, points);\n            this.compact = compact;\n            this.nbDatablocks = nbDatablocks;\n            this.nbLayers = nbLayers;\n        }\n        getNbLayers() {\n            return this.nbLayers;\n        }\n        getNbDatablocks() {\n            return this.nbDatablocks;\n        }\n        isCompact() {\n            return this.compact;\n        }\n    }\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>\n     * Detects a candidate barcode-like rectangular region within an image. It\n     * starts around the center of the image, increases the size of the candidate\n     * region until it finds a white rectangular region. By keeping track of the\n     * last black points it encountered, it determines the corners of the barcode.\n     * </p>\n     *\n     * @author David Olivier\n     */ class WhiteRectangleDetector {\n        // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {\n        //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)\n        // }\n        /**\n         * @param image barcode image to find a rectangle in\n         * @param initSize initial size of search area around center\n         * @param x x position of search center\n         * @param y y position of search center\n         * @throws NotFoundException if image is too small to accommodate {@code initSize}\n         */ constructor(image, initSize /*int*/ , x /*int*/ , y /*int*/ ){\n            this.image = image;\n            this.height = image.getHeight();\n            this.width = image.getWidth();\n            if (undefined === initSize || null === initSize) {\n                initSize = WhiteRectangleDetector.INIT_SIZE;\n            }\n            if (undefined === x || null === x) {\n                x = image.getWidth() / 2 | 0;\n            }\n            if (undefined === y || null === y) {\n                y = image.getHeight() / 2 | 0;\n            }\n            const halfsize = initSize / 2 | 0;\n            this.leftInit = x - halfsize;\n            this.rightInit = x + halfsize;\n            this.upInit = y - halfsize;\n            this.downInit = y + halfsize;\n            if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {\n                throw new NotFoundException();\n            }\n        }\n        /**\n         * <p>\n         * Detects a candidate barcode-like rectangular region within an image. It\n         * starts around the center of the image, increases the size of the candidate\n         * region until it finds a white rectangular region.\n         * </p>\n         *\n         * @return {@link ResultPoint}[] describing the corners of the rectangular\n         *         region. The first and last points are opposed on the diagonal, as\n         *         are the second and third. The first point will be the topmost\n         *         point and the last, the bottommost. The second point will be\n         *         leftmost and the third, the rightmost\n         * @throws NotFoundException if no Data Matrix Code can be found\n         */ detect() {\n            let left = this.leftInit;\n            let right = this.rightInit;\n            let up = this.upInit;\n            let down = this.downInit;\n            let sizeExceeded = false;\n            let aBlackPointFoundOnBorder = true;\n            let atLeastOneBlackPointFoundOnBorder = false;\n            let atLeastOneBlackPointFoundOnRight = false;\n            let atLeastOneBlackPointFoundOnBottom = false;\n            let atLeastOneBlackPointFoundOnLeft = false;\n            let atLeastOneBlackPointFoundOnTop = false;\n            const width = this.width;\n            const height = this.height;\n            while(aBlackPointFoundOnBorder){\n                aBlackPointFoundOnBorder = false;\n                // .....\n                // .   |\n                // .....\n                let rightBorderNotWhite = true;\n                while((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width){\n                    rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);\n                    if (rightBorderNotWhite) {\n                        right++;\n                        aBlackPointFoundOnBorder = true;\n                        atLeastOneBlackPointFoundOnRight = true;\n                    } else if (!atLeastOneBlackPointFoundOnRight) {\n                        right++;\n                    }\n                }\n                if (right >= width) {\n                    sizeExceeded = true;\n                    break;\n                }\n                // .....\n                // .   .\n                // .___.\n                let bottomBorderNotWhite = true;\n                while((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height){\n                    bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);\n                    if (bottomBorderNotWhite) {\n                        down++;\n                        aBlackPointFoundOnBorder = true;\n                        atLeastOneBlackPointFoundOnBottom = true;\n                    } else if (!atLeastOneBlackPointFoundOnBottom) {\n                        down++;\n                    }\n                }\n                if (down >= height) {\n                    sizeExceeded = true;\n                    break;\n                }\n                // .....\n                // |   .\n                // .....\n                let leftBorderNotWhite = true;\n                while((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0){\n                    leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);\n                    if (leftBorderNotWhite) {\n                        left--;\n                        aBlackPointFoundOnBorder = true;\n                        atLeastOneBlackPointFoundOnLeft = true;\n                    } else if (!atLeastOneBlackPointFoundOnLeft) {\n                        left--;\n                    }\n                }\n                if (left < 0) {\n                    sizeExceeded = true;\n                    break;\n                }\n                // .___.\n                // .   .\n                // .....\n                let topBorderNotWhite = true;\n                while((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0){\n                    topBorderNotWhite = this.containsBlackPoint(left, right, up, true);\n                    if (topBorderNotWhite) {\n                        up--;\n                        aBlackPointFoundOnBorder = true;\n                        atLeastOneBlackPointFoundOnTop = true;\n                    } else if (!atLeastOneBlackPointFoundOnTop) {\n                        up--;\n                    }\n                }\n                if (up < 0) {\n                    sizeExceeded = true;\n                    break;\n                }\n                if (aBlackPointFoundOnBorder) {\n                    atLeastOneBlackPointFoundOnBorder = true;\n                }\n            }\n            if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {\n                const maxSize = right - left;\n                let z = null;\n                for(let i = 1; z === null && i < maxSize; i++){\n                    z = this.getBlackPointOnSegment(left, down - i, left + i, down);\n                }\n                if (z == null) {\n                    throw new NotFoundException();\n                }\n                let t = null;\n                // go down right\n                for(let i = 1; t === null && i < maxSize; i++){\n                    t = this.getBlackPointOnSegment(left, up + i, left + i, up);\n                }\n                if (t == null) {\n                    throw new NotFoundException();\n                }\n                let x = null;\n                // go down left\n                for(let i = 1; x === null && i < maxSize; i++){\n                    x = this.getBlackPointOnSegment(right, up + i, right - i, up);\n                }\n                if (x == null) {\n                    throw new NotFoundException();\n                }\n                let y = null;\n                // go up left\n                for(let i = 1; y === null && i < maxSize; i++){\n                    y = this.getBlackPointOnSegment(right, down - i, right - i, down);\n                }\n                if (y == null) {\n                    throw new NotFoundException();\n                }\n                return this.centerEdges(y, z, x, t);\n            } else {\n                throw new NotFoundException();\n            }\n        }\n        getBlackPointOnSegment(aX /*float*/ , aY /*float*/ , bX /*float*/ , bY /*float*/ ) {\n            const dist = MathUtils.round(MathUtils.distance(aX, aY, bX, bY));\n            const xStep = (bX - aX) / dist;\n            const yStep = (bY - aY) / dist;\n            const image = this.image;\n            for(let i = 0; i < dist; i++){\n                const x = MathUtils.round(aX + i * xStep);\n                const y = MathUtils.round(aY + i * yStep);\n                if (image.get(x, y)) {\n                    return new ResultPoint(x, y);\n                }\n            }\n            return null;\n        }\n        /**\n         * recenters the points of a constant distance towards the center\n         *\n         * @param y bottom most point\n         * @param z left most point\n         * @param x right most point\n         * @param t top most point\n         * @return {@link ResultPoint}[] describing the corners of the rectangular\n         *         region. The first and last points are opposed on the diagonal, as\n         *         are the second and third. The first point will be the topmost\n         *         point and the last, the bottommost. The second point will be\n         *         leftmost and the third, the rightmost\n         */ centerEdges(y, z, x, t) {\n            //\n            //       t            t\n            //  z                      x\n            //        x    OR    z\n            //   y                    y\n            //\n            const yi = y.getX();\n            const yj = y.getY();\n            const zi = z.getX();\n            const zj = z.getY();\n            const xi = x.getX();\n            const xj = x.getY();\n            const ti = t.getX();\n            const tj = t.getY();\n            const CORR = WhiteRectangleDetector.CORR;\n            if (yi < this.width / 2.0) {\n                return [\n                    new ResultPoint(ti - CORR, tj + CORR),\n                    new ResultPoint(zi + CORR, zj + CORR),\n                    new ResultPoint(xi - CORR, xj - CORR),\n                    new ResultPoint(yi + CORR, yj - CORR)\n                ];\n            } else {\n                return [\n                    new ResultPoint(ti + CORR, tj + CORR),\n                    new ResultPoint(zi + CORR, zj - CORR),\n                    new ResultPoint(xi - CORR, xj + CORR),\n                    new ResultPoint(yi - CORR, yj - CORR)\n                ];\n            }\n        }\n        /**\n         * Determines whether a segment contains a black point\n         *\n         * @param a          min value of the scanned coordinate\n         * @param b          max value of the scanned coordinate\n         * @param fixed      value of fixed coordinate\n         * @param horizontal set to true if scan must be horizontal, false if vertical\n         * @return true if a black point has been found, else false.\n         */ containsBlackPoint(a /*int*/ , b /*int*/ , fixed /*int*/ , horizontal) {\n            const image = this.image;\n            if (horizontal) {\n                for(let x = a; x <= b; x++){\n                    if (image.get(x, fixed)) {\n                        return true;\n                    }\n                }\n            } else {\n                for(let y = a; y <= b; y++){\n                    if (image.get(fixed, y)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n    WhiteRectangleDetector.INIT_SIZE = 10;\n    WhiteRectangleDetector.CORR = 1;\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * Implementations of this class can, given locations of finder patterns for a QR code in an\n     * image, sample the right points in the image to reconstruct the QR code, accounting for\n     * perspective distortion. It is abstracted since it is relatively expensive and should be allowed\n     * to take advantage of platform-specific optimized implementations, like Sun's Java Advanced\n     * Imaging library, but which may not be available in other environments such as J2ME, and vice\n     * versa.\n     *\n     * The implementation used can be controlled by calling {@link #setGridSampler(GridSampler)}\n     * with an instance of a class which implements this interface.\n     *\n     * @author Sean Owen\n     */ class GridSampler {\n        /**\n         * <p>Checks a set of points that have been transformed to sample points on an image against\n         * the image's dimensions to see if the point are even within the image.</p>\n         *\n         * <p>This method will actually \"nudge\" the endpoints back onto the image if they are found to be\n         * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder\n         * patterns in an image where the QR Code runs all the way to the image border.</p>\n         *\n         * <p>For efficiency, the method will check points from either end of the line until one is found\n         * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>\n         *\n         * @param image image into which the points should map\n         * @param points actual points in x1,y1,...,xn,yn form\n         * @throws NotFoundException if an endpoint is lies outside the image boundaries\n         */ static checkAndNudgePoints(image, points) {\n            const width = image.getWidth();\n            const height = image.getHeight();\n            // Check and nudge points from start until we see some that are OK:\n            let nudged = true;\n            for(let offset = 0; offset < points.length && nudged; offset += 2){\n                const x = Math.floor(points[offset]);\n                const y = Math.floor(points[offset + 1]);\n                if (x < -1 || x > width || y < -1 || y > height) {\n                    throw new NotFoundException();\n                }\n                nudged = false;\n                if (x === -1) {\n                    points[offset] = 0.0;\n                    nudged = true;\n                } else if (x === width) {\n                    points[offset] = width - 1;\n                    nudged = true;\n                }\n                if (y === -1) {\n                    points[offset + 1] = 0.0;\n                    nudged = true;\n                } else if (y === height) {\n                    points[offset + 1] = height - 1;\n                    nudged = true;\n                }\n            }\n            // Check and nudge points from end:\n            nudged = true;\n            for(let offset = points.length - 2; offset >= 0 && nudged; offset -= 2){\n                const x = Math.floor(points[offset]);\n                const y = Math.floor(points[offset + 1]);\n                if (x < -1 || x > width || y < -1 || y > height) {\n                    throw new NotFoundException();\n                }\n                nudged = false;\n                if (x === -1) {\n                    points[offset] = 0.0;\n                    nudged = true;\n                } else if (x === width) {\n                    points[offset] = width - 1;\n                    nudged = true;\n                }\n                if (y === -1) {\n                    points[offset + 1] = 0.0;\n                    nudged = true;\n                } else if (y === height) {\n                    points[offset + 1] = height - 1;\n                    nudged = true;\n                }\n            }\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*namespace com.google.zxing.common {*/ /**\n     * <p>This class implements a perspective transform in two dimensions. Given four source and four\n     * destination points, it will compute the transformation implied between them. The code is based\n     * directly upon section 3.4.2 of George Wolberg's \"Digital Image Warping\"; see pages 54-56.</p>\n     *\n     * @author Sean Owen\n     */ class PerspectiveTransform {\n        constructor(a11 /*float*/ , a21 /*float*/ , a31 /*float*/ , a12 /*float*/ , a22 /*float*/ , a32 /*float*/ , a13 /*float*/ , a23 /*float*/ , a33 /*float*/ ){\n            this.a11 = a11;\n            this.a21 = a21;\n            this.a31 = a31;\n            this.a12 = a12;\n            this.a22 = a22;\n            this.a32 = a32;\n            this.a13 = a13;\n            this.a23 = a23;\n            this.a33 = a33;\n        }\n        static quadrilateralToQuadrilateral(x0 /*float*/ , y0 /*float*/ , x1 /*float*/ , y1 /*float*/ , x2 /*float*/ , y2 /*float*/ , x3 /*float*/ , y3 /*float*/ , x0p /*float*/ , y0p /*float*/ , x1p /*float*/ , y1p /*float*/ , x2p /*float*/ , y2p /*float*/ , x3p /*float*/ , y3p /*float*/ ) {\n            const qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);\n            const sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);\n            return sToQ.times(qToS);\n        }\n        transformPoints(points) {\n            const max = points.length;\n            const a11 = this.a11;\n            const a12 = this.a12;\n            const a13 = this.a13;\n            const a21 = this.a21;\n            const a22 = this.a22;\n            const a23 = this.a23;\n            const a31 = this.a31;\n            const a32 = this.a32;\n            const a33 = this.a33;\n            for(let i = 0; i < max; i += 2){\n                const x = points[i];\n                const y = points[i + 1];\n                const denominator = a13 * x + a23 * y + a33;\n                points[i] = (a11 * x + a21 * y + a31) / denominator;\n                points[i + 1] = (a12 * x + a22 * y + a32) / denominator;\n            }\n        }\n        transformPointsWithValues(xValues, yValues) {\n            const a11 = this.a11;\n            const a12 = this.a12;\n            const a13 = this.a13;\n            const a21 = this.a21;\n            const a22 = this.a22;\n            const a23 = this.a23;\n            const a31 = this.a31;\n            const a32 = this.a32;\n            const a33 = this.a33;\n            const n = xValues.length;\n            for(let i = 0; i < n; i++){\n                const x = xValues[i];\n                const y = yValues[i];\n                const denominator = a13 * x + a23 * y + a33;\n                xValues[i] = (a11 * x + a21 * y + a31) / denominator;\n                yValues[i] = (a12 * x + a22 * y + a32) / denominator;\n            }\n        }\n        static squareToQuadrilateral(x0 /*float*/ , y0 /*float*/ , x1 /*float*/ , y1 /*float*/ , x2 /*float*/ , y2 /*float*/ , x3 /*float*/ , y3 /*float*/ ) {\n            const dx3 = x0 - x1 + x2 - x3;\n            const dy3 = y0 - y1 + y2 - y3;\n            if (dx3 === 0.0 && dy3 === 0.0) {\n                // Affine\n                return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);\n            } else {\n                const dx1 = x1 - x2;\n                const dx2 = x3 - x2;\n                const dy1 = y1 - y2;\n                const dy2 = y3 - y2;\n                const denominator = dx1 * dy2 - dx2 * dy1;\n                const a13 = (dx3 * dy2 - dx2 * dy3) / denominator;\n                const a23 = (dx1 * dy3 - dx3 * dy1) / denominator;\n                return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0);\n            }\n        }\n        static quadrilateralToSquare(x0 /*float*/ , y0 /*float*/ , x1 /*float*/ , y1 /*float*/ , x2 /*float*/ , y2 /*float*/ , x3 /*float*/ , y3 /*float*/ ) {\n            // Here, the adjoint serves as the inverse:\n            return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();\n        }\n        buildAdjoint() {\n            // Adjoint is the transpose of the cofactor matrix:\n            return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);\n        }\n        times(other) {\n            return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * @author Sean Owen\n     */ class DefaultGridSampler extends GridSampler {\n        /*@Override*/ sampleGrid(image, dimensionX /*int*/ , dimensionY /*int*/ , p1ToX /*float*/ , p1ToY /*float*/ , p2ToX /*float*/ , p2ToY /*float*/ , p3ToX /*float*/ , p3ToY /*float*/ , p4ToX /*float*/ , p4ToY /*float*/ , p1FromX /*float*/ , p1FromY /*float*/ , p2FromX /*float*/ , p2FromY /*float*/ , p3FromX /*float*/ , p3FromY /*float*/ , p4FromX /*float*/ , p4FromY /*float*/ ) {\n            const transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);\n            return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);\n        }\n        /*@Override*/ sampleGridWithTransform(image, dimensionX /*int*/ , dimensionY /*int*/ , transform) {\n            if (dimensionX <= 0 || dimensionY <= 0) {\n                throw new NotFoundException();\n            }\n            const bits = new BitMatrix(dimensionX, dimensionY);\n            const points = new Float32Array(2 * dimensionX);\n            for(let y = 0; y < dimensionY; y++){\n                const max = points.length;\n                const iValue = y + 0.5;\n                for(let x = 0; x < max; x += 2){\n                    points[x] = x / 2 + 0.5;\n                    points[x + 1] = iValue;\n                }\n                transform.transformPoints(points);\n                // Quick check to see if points transformed to something inside the image\n                // sufficient to check the endpoints\n                GridSampler.checkAndNudgePoints(image, points);\n                try {\n                    for(let x = 0; x < max; x += 2){\n                        if (image.get(Math.floor(points[x]), Math.floor(points[x + 1]))) {\n                            // Black(-ish) pixel\n                            bits.set(x / 2, y);\n                        }\n                    }\n                } catch (aioobe /*: ArrayIndexOutOfBoundsException*/ ) {\n                    // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting\n                    // transform gets \"twisted\" such that it maps a straight line of points to a set of points\n                    // whose endpoints are in bounds, but others are not. There is probably some mathematical\n                    // way to detect this about the transformation that I don't know yet.\n                    // This results in an ugly runtime exception despite our clever checks above -- can't have\n                    // that. We could check each point's coordinates but that feels duplicative. We settle for\n                    // catching and wrapping ArrayIndexOutOfBoundsException.\n                    throw new NotFoundException();\n                }\n            }\n            return bits;\n        }\n    }\n    class GridSamplerInstance {\n        /**\n         * Sets the implementation of GridSampler used by the library. One global\n         * instance is stored, which may sound problematic. But, the implementation provided\n         * ought to be appropriate for the entire platform, and all uses of this library\n         * in the whole lifetime of the JVM. For instance, an Android activity can swap in\n         * an implementation that takes advantage of native platform libraries.\n         *\n         * @param newGridSampler The platform-specific object to install.\n         */ static setGridSampler(newGridSampler) {\n            GridSamplerInstance.gridSampler = newGridSampler;\n        }\n        /**\n         * @return the current implementation of GridSampler\n         */ static getInstance() {\n            return GridSamplerInstance.gridSampler;\n        }\n    }\n    GridSamplerInstance.gridSampler = new DefaultGridSampler();\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ class Point {\n        constructor(x, y){\n            this.x = x;\n            this.y = y;\n        }\n        toResultPoint() {\n            return new ResultPoint(this.getX(), this.getY());\n        }\n        getX() {\n            return this.x;\n        }\n        getY() {\n            return this.y;\n        }\n    }\n    /**\n     * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code\n     * is rotated or skewed, or partially obscured.\n     *\n     * @author David Olivier\n     * @author Frank Yellin\n     */ class Detector {\n        constructor(image){\n            this.EXPECTED_CORNER_BITS = new Int32Array([\n                0xee0,\n                0x1dc,\n                0x83b,\n                0x707\n            ]);\n            this.image = image;\n        }\n        detect() {\n            return this.detectMirror(false);\n        }\n        /**\n         * Detects an Aztec Code in an image.\n         *\n         * @param isMirror if true, image is a mirror-image of original\n         * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code\n         * @throws NotFoundException if no Aztec Code can be found\n         */ detectMirror(isMirror) {\n            // 1. Get the center of the aztec matrix\n            let pCenter = this.getMatrixCenter();\n            // 2. Get the center points of the four diagonal points just outside the bull's eye\n            //  [topRight, bottomRight, bottomLeft, topLeft]\n            let bullsEyeCorners = this.getBullsEyeCorners(pCenter);\n            if (isMirror) {\n                let temp = bullsEyeCorners[0];\n                bullsEyeCorners[0] = bullsEyeCorners[2];\n                bullsEyeCorners[2] = temp;\n            }\n            // 3. Get the size of the matrix and other parameters from the bull's eye\n            this.extractParameters(bullsEyeCorners);\n            // 4. Sample the grid\n            let bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);\n            // 5. Get the corners of the matrix.\n            let corners = this.getMatrixCornerPoints(bullsEyeCorners);\n            return new AztecDetectorResult(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);\n        }\n        /**\n         * Extracts the number of data layers and data blocks from the layer around the bull's eye.\n         *\n         * @param bullsEyeCorners the array of bull's eye corners\n         * @throws NotFoundException in case of too many errors or invalid parameters\n         */ extractParameters(bullsEyeCorners) {\n            if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) || !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {\n                throw new NotFoundException();\n            }\n            let length = 2 * this.nbCenterLayers;\n            // Get the bits around the bull's eye\n            let sides = new Int32Array([\n                this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),\n                this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),\n                this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),\n                this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top\n            ]);\n            // bullsEyeCorners[shift] is the corner of the bulls'eye that has three\n            // orientation marks.\n            // sides[shift] is the row/column that goes from the corner with three\n            // orientation marks to the corner with two.\n            this.shift = this.getRotation(sides, length);\n            // Flatten the parameter bits into a single 28- or 40-bit long\n            let parameterData = 0;\n            for(let i = 0; i < 4; i++){\n                let side = sides[(this.shift + i) % 4];\n                if (this.compact) {\n                    // Each side of the form ..XXXXXXX. where Xs are parameter data\n                    parameterData <<= 7;\n                    parameterData += side >> 1 & 0x7F;\n                } else {\n                    // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data\n                    parameterData <<= 10;\n                    parameterData += (side >> 2 & 0x1f << 5) + (side >> 1 & 0x1F);\n                }\n            }\n            // Corrects parameter data using RS.  Returns just the data portion\n            // without the error correction.\n            let correctedData = this.getCorrectedParameterData(parameterData, this.compact);\n            if (this.compact) {\n                // 8 bits:  2 bits layers and 6 bits data blocks\n                this.nbLayers = (correctedData >> 6) + 1;\n                this.nbDataBlocks = (correctedData & 0x3F) + 1;\n            } else {\n                // 16 bits:  5 bits layers and 11 bits data blocks\n                this.nbLayers = (correctedData >> 11) + 1;\n                this.nbDataBlocks = (correctedData & 0x7FF) + 1;\n            }\n        }\n        getRotation(sides, length) {\n            // In a normal pattern, we expect to See\n            //   **    .*             D       A\n            //   *      *\n            //\n            //   .      *\n            //   ..    ..             C       B\n            //\n            // Grab the 3 bits from each of the sides the form the locator pattern and concatenate\n            // into a 12-bit integer.  Start with the bit at A\n            let cornerBits = 0;\n            sides.forEach((side, idx, arr)=>{\n                // XX......X where X's are orientation marks\n                let t = (side >> length - 2 << 1) + (side & 1);\n                cornerBits = (cornerBits << 3) + t;\n            });\n            // for (var side in sides) {\n            //     // XX......X where X's are orientation marks\n            //     var t = ((side >> (length - 2)) << 1) + (side & 1);\n            //     cornerBits = (cornerBits << 3) + t;\n            // }\n            // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are\n            // together.  cornerBits is now:\n            //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D\n            cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);\n            // The result shift indicates which element of BullsEyeCorners[] goes into the top-left\n            // corner. Since the four rotation values have a Hamming distance of 8, we\n            // can easily tolerate two errors.\n            for(let shift = 0; shift < 4; shift++){\n                if (Integer.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {\n                    return shift;\n                }\n            }\n            throw new NotFoundException();\n        }\n        /**\n         * Corrects the parameter bits using Reed-Solomon algorithm.\n         *\n         * @param parameterData parameter bits\n         * @param compact true if this is a compact Aztec code\n         * @throws NotFoundException if the array contains too many errors\n         */ getCorrectedParameterData(parameterData, compact) {\n            let numCodewords;\n            let numDataCodewords;\n            if (compact) {\n                numCodewords = 7;\n                numDataCodewords = 2;\n            } else {\n                numCodewords = 10;\n                numDataCodewords = 4;\n            }\n            let numECCodewords = numCodewords - numDataCodewords;\n            let parameterWords = new Int32Array(numCodewords);\n            for(let i = numCodewords - 1; i >= 0; --i){\n                parameterWords[i] = parameterData & 0xF;\n                parameterData >>= 4;\n            }\n            try {\n                let rsDecoder = new ReedSolomonDecoder(GenericGF.AZTEC_PARAM);\n                rsDecoder.decode(parameterWords, numECCodewords);\n            } catch (ignored) {\n                throw new NotFoundException();\n            }\n            // Toss the error correction.  Just return the data as an integer\n            let result = 0;\n            for(let i = 0; i < numDataCodewords; i++){\n                result = (result << 4) + parameterWords[i];\n            }\n            return result;\n        }\n        /**\n         * Finds the corners of a bull-eye centered on the passed point.\n         * This returns the centers of the diagonal points just outside the bull's eye\n         * Returns [topRight, bottomRight, bottomLeft, topLeft]\n         *\n         * @param pCenter Center point\n         * @return The corners of the bull-eye\n         * @throws NotFoundException If no valid bull-eye can be found\n         */ getBullsEyeCorners(pCenter) {\n            let pina = pCenter;\n            let pinb = pCenter;\n            let pinc = pCenter;\n            let pind = pCenter;\n            let color = true;\n            for(this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++){\n                let pouta = this.getFirstDifferent(pina, color, 1, -1);\n                let poutb = this.getFirstDifferent(pinb, color, 1, 1);\n                let poutc = this.getFirstDifferent(pinc, color, -1, 1);\n                let poutd = this.getFirstDifferent(pind, color, -1, -1);\n                // d      a\n                //\n                // c      b\n                if (this.nbCenterLayers > 2) {\n                    let q = this.distancePoint(poutd, pouta) * this.nbCenterLayers / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));\n                    if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {\n                        break;\n                    }\n                }\n                pina = pouta;\n                pinb = poutb;\n                pinc = poutc;\n                pind = poutd;\n                color = !color;\n            }\n            if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {\n                throw new NotFoundException();\n            }\n            this.compact = this.nbCenterLayers === 5;\n            // Expand the square by .5 pixel in each direction so that we're on the border\n            // between the white square and the black square\n            let pinax = new ResultPoint(pina.getX() + 0.5, pina.getY() - 0.5);\n            let pinbx = new ResultPoint(pinb.getX() + 0.5, pinb.getY() + 0.5);\n            let pincx = new ResultPoint(pinc.getX() - 0.5, pinc.getY() + 0.5);\n            let pindx = new ResultPoint(pind.getX() - 0.5, pind.getY() - 0.5);\n            // Expand the square so that its corners are the centers of the points\n            // just outside the bull's eye.\n            return this.expandSquare([\n                pinax,\n                pinbx,\n                pincx,\n                pindx\n            ], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);\n        }\n        /**\n         * Finds a candidate center point of an Aztec code from an image\n         *\n         * @return the center point\n         */ getMatrixCenter() {\n            let pointA;\n            let pointB;\n            let pointC;\n            let pointD;\n            // Get a white rectangle that can be the border of the matrix in center bull's eye or\n            try {\n                let cornerPoints = new WhiteRectangleDetector(this.image).detect();\n                pointA = cornerPoints[0];\n                pointB = cornerPoints[1];\n                pointC = cornerPoints[2];\n                pointD = cornerPoints[3];\n            } catch (e) {\n                // This exception can be in case the initial rectangle is white\n                // In that case, surely in the bull's eye, we try to expand the rectangle.\n                let cx = this.image.getWidth() / 2;\n                let cy = this.image.getHeight() / 2;\n                pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n                pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n                pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n                pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n            }\n            // Compute the center of the rectangle\n            let cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n            let cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n            // Redetermine the white rectangle starting from previously computed center.\n            // This will ensure that we end up with a white rectangle in center bull's eye\n            // in order to compute a more accurate center.\n            try {\n                let cornerPoints = new WhiteRectangleDetector(this.image, 15, cx, cy).detect();\n                pointA = cornerPoints[0];\n                pointB = cornerPoints[1];\n                pointC = cornerPoints[2];\n                pointD = cornerPoints[3];\n            } catch (e) {\n                // This exception can be in case the initial rectangle is white\n                // In that case we try to expand the rectangle.\n                pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n                pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n                pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n                pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n            }\n            // Recompute the center of the rectangle\n            cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n            cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n            return new Point(cx, cy);\n        }\n        /**\n         * Gets the Aztec code corners from the bull's eye corners and the parameters.\n         *\n         * @param bullsEyeCorners the array of bull's eye corners\n         * @return the array of aztec code corners\n         */ getMatrixCornerPoints(bullsEyeCorners) {\n            return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());\n        }\n        /**\n         * Creates a BitMatrix by sampling the provided image.\n         * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the\n         * diagonal just outside the bull's eye.\n         */ sampleGrid(image, topLeft, topRight, bottomRight, bottomLeft) {\n            let sampler = GridSamplerInstance.getInstance();\n            let dimension = this.getDimension();\n            let low = dimension / 2 - this.nbCenterLayers;\n            let high = dimension / 2 + this.nbCenterLayers;\n            return sampler.sampleGrid(image, dimension, dimension, low, low, high, low, high, high, low, high, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n        }\n        /**\n         * Samples a line.\n         *\n         * @param p1   start point (inclusive)\n         * @param p2   end point (exclusive)\n         * @param size number of bits\n         * @return the array of bits as an int (first bit is high-order bit of result)\n         */ sampleLine(p1, p2, size) {\n            let result = 0;\n            let d = this.distanceResultPoint(p1, p2);\n            let moduleSize = d / size;\n            let px = p1.getX();\n            let py = p1.getY();\n            let dx = moduleSize * (p2.getX() - p1.getX()) / d;\n            let dy = moduleSize * (p2.getY() - p1.getY()) / d;\n            for(let i = 0; i < size; i++){\n                if (this.image.get(MathUtils.round(px + i * dx), MathUtils.round(py + i * dy))) {\n                    result |= 1 << size - i - 1;\n                }\n            }\n            return result;\n        }\n        /**\n         * @return true if the border of the rectangle passed in parameter is compound of white points only\n         *         or black points only\n         */ isWhiteOrBlackRectangle(p1, p2, p3, p4) {\n            let corr = 3;\n            p1 = new Point(p1.getX() - corr, p1.getY() + corr);\n            p2 = new Point(p2.getX() - corr, p2.getY() - corr);\n            p3 = new Point(p3.getX() + corr, p3.getY() - corr);\n            p4 = new Point(p4.getX() + corr, p4.getY() + corr);\n            let cInit = this.getColor(p4, p1);\n            if (cInit === 0) {\n                return false;\n            }\n            let c = this.getColor(p1, p2);\n            if (c !== cInit) {\n                return false;\n            }\n            c = this.getColor(p2, p3);\n            if (c !== cInit) {\n                return false;\n            }\n            c = this.getColor(p3, p4);\n            return c === cInit;\n        }\n        /**\n         * Gets the color of a segment\n         *\n         * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else\n         */ getColor(p1, p2) {\n            let d = this.distancePoint(p1, p2);\n            let dx = (p2.getX() - p1.getX()) / d;\n            let dy = (p2.getY() - p1.getY()) / d;\n            let error = 0;\n            let px = p1.getX();\n            let py = p1.getY();\n            let colorModel = this.image.get(p1.getX(), p1.getY());\n            let iMax = Math.ceil(d);\n            for(let i = 0; i < iMax; i++){\n                px += dx;\n                py += dy;\n                if (this.image.get(MathUtils.round(px), MathUtils.round(py)) !== colorModel) {\n                    error++;\n                }\n            }\n            let errRatio = error / d;\n            if (errRatio > 0.1 && errRatio < 0.9) {\n                return 0;\n            }\n            return errRatio <= 0.1 === colorModel ? 1 : -1;\n        }\n        /**\n         * Gets the coordinate of the first point with a different color in the given direction\n         */ getFirstDifferent(init, color, dx, dy) {\n            let x = init.getX() + dx;\n            let y = init.getY() + dy;\n            while(this.isValid(x, y) && this.image.get(x, y) === color){\n                x += dx;\n                y += dy;\n            }\n            x -= dx;\n            y -= dy;\n            while(this.isValid(x, y) && this.image.get(x, y) === color){\n                x += dx;\n            }\n            x -= dx;\n            while(this.isValid(x, y) && this.image.get(x, y) === color){\n                y += dy;\n            }\n            y -= dy;\n            return new Point(x, y);\n        }\n        /**\n         * Expand the square represented by the corner points by pushing out equally in all directions\n         *\n         * @param cornerPoints the corners of the square, which has the bull's eye at its center\n         * @param oldSide the original length of the side of the square in the target bit matrix\n         * @param newSide the new length of the size of the square in the target bit matrix\n         * @return the corners of the expanded square\n         */ expandSquare(cornerPoints, oldSide, newSide) {\n            let ratio = newSide / (2.0 * oldSide);\n            let dx = cornerPoints[0].getX() - cornerPoints[2].getX();\n            let dy = cornerPoints[0].getY() - cornerPoints[2].getY();\n            let centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;\n            let centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;\n            let result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);\n            let result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);\n            dx = cornerPoints[1].getX() - cornerPoints[3].getX();\n            dy = cornerPoints[1].getY() - cornerPoints[3].getY();\n            centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;\n            centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;\n            let result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);\n            let result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);\n            let results = [\n                result0,\n                result1,\n                result2,\n                result3\n            ];\n            return results;\n        }\n        isValid(x, y) {\n            return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();\n        }\n        isValidPoint(point) {\n            let x = MathUtils.round(point.getX());\n            let y = MathUtils.round(point.getY());\n            return this.isValid(x, y);\n        }\n        distancePoint(a, b) {\n            return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());\n        }\n        distanceResultPoint(a, b) {\n            return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());\n        }\n        getDimension() {\n            if (this.compact) {\n                return 4 * this.nbLayers + 11;\n            }\n            if (this.nbLayers <= 4) {\n                return 4 * this.nbLayers + 15;\n            }\n            return 4 * this.nbLayers + 2 * (Integer.truncDivision(this.nbLayers - 4, 8) + 1) + 15;\n        }\n    }\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ // import java.util.List;\n    // import java.util.Map;\n    /**\n     * This implementation can detect and decode Aztec codes in an image.\n     *\n     * @author David Olivier\n     */ class AztecReader {\n        /**\n         * Locates and decodes a Data Matrix code in an image.\n         *\n         * @return a String representing the content encoded by the Data Matrix code\n         * @throws NotFoundException if a Data Matrix code cannot be found\n         * @throws FormatException if a Data Matrix code cannot be decoded\n         */ decode(image, hints = null) {\n            let exception = null;\n            let detector = new Detector(image.getBlackMatrix());\n            let points = null;\n            let decoderResult = null;\n            try {\n                let detectorResult = detector.detectMirror(false);\n                points = detectorResult.getPoints();\n                this.reportFoundResultPoints(hints, points);\n                decoderResult = new Decoder().decode(detectorResult);\n            } catch (e) {\n                exception = e;\n            }\n            if (decoderResult == null) {\n                try {\n                    let detectorResult = detector.detectMirror(true);\n                    points = detectorResult.getPoints();\n                    this.reportFoundResultPoints(hints, points);\n                    decoderResult = new Decoder().decode(detectorResult);\n                } catch (e) {\n                    if (exception != null) {\n                        throw exception;\n                    }\n                    throw e;\n                }\n            }\n            let result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat$1.AZTEC, System.currentTimeMillis());\n            let byteSegments = decoderResult.getByteSegments();\n            if (byteSegments != null) {\n                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);\n            }\n            let ecLevel = decoderResult.getECLevel();\n            if (ecLevel != null) {\n                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);\n            }\n            return result;\n        }\n        reportFoundResultPoints(hints, points) {\n            if (hints != null) {\n                let rpcb = hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n                if (rpcb != null) {\n                    points.forEach((point, idx, arr)=>{\n                        rpcb.foundPossibleResultPoint(point);\n                    });\n                }\n            }\n        }\n        // @Override\n        reset() {\n        // do nothing\n        }\n    }\n    /**\n     * Aztec Code reader to use from browser.\n     *\n     * @class BrowserAztecCodeReader\n     * @extends {BrowserCodeReader}\n     */ class BrowserAztecCodeReader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserAztecCodeReader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         *\n         * @memberOf BrowserAztecCodeReader\n         */ constructor(timeBetweenScansMillis = 500){\n            super(new AztecReader(), timeBetweenScansMillis);\n        }\n    }\n    /**\n     * Encapsulates functionality and implementation that is common to all families\n     * of one-dimensional barcodes.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     */ class OneDReader {\n        /*\n        @Override\n        public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {\n          return decode(image, null);\n        }\n        */ // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n        // @Override\n        decode(image, hints) {\n            try {\n                return this.doDecode(image, hints);\n            } catch (nfe) {\n                const tryHarder = hints && hints.get(DecodeHintType$1.TRY_HARDER) === true;\n                if (tryHarder && image.isRotateSupported()) {\n                    const rotatedImage = image.rotateCounterClockwise();\n                    const result = this.doDecode(rotatedImage, hints);\n                    // Record that we found it rotated 90 degrees CCW / 270 degrees CW\n                    const metadata = result.getResultMetadata();\n                    let orientation = 270;\n                    if (metadata !== null && metadata.get(ResultMetadataType$1.ORIENTATION) === true) {\n                        // But if we found it reversed in doDecode(), add in that result here:\n                        orientation = orientation + metadata.get(ResultMetadataType$1.ORIENTATION) % 360;\n                    }\n                    result.putMetadata(ResultMetadataType$1.ORIENTATION, orientation);\n                    // Update result points\n                    const points = result.getResultPoints();\n                    if (points !== null) {\n                        const height = rotatedImage.getHeight();\n                        for(let i = 0; i < points.length; i++){\n                            points[i] = new ResultPoint(height - points[i].getY() - 1, points[i].getX());\n                        }\n                    }\n                    return result;\n                } else {\n                    throw new NotFoundException();\n                }\n            }\n        }\n        // @Override\n        reset() {\n        // do nothing\n        }\n        /**\n         * We're going to examine rows from the middle outward, searching alternately above and below the\n         * middle, and farther out each time. rowStep is the number of rows between each successive\n         * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then\n         * middle + rowStep, then middle - (2 * rowStep), etc.\n         * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily\n         * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the\n         * image if \"trying harder\".\n         *\n         * @param image The image to decode\n         * @param hints Any hints that were requested\n         * @return The contents of the decoded barcode\n         * @throws NotFoundException Any spontaneous errors which occur\n         */ doDecode(image, hints) {\n            const width = image.getWidth();\n            const height = image.getHeight();\n            let row = new BitArray(width);\n            const tryHarder = hints && hints.get(DecodeHintType$1.TRY_HARDER) === true;\n            const rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));\n            let maxLines;\n            if (tryHarder) {\n                maxLines = height; // Look at the whole image, not just the center\n            } else {\n                maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image\n            }\n            const middle = Math.trunc(height / 2);\n            for(let x = 0; x < maxLines; x++){\n                // Scanning from the middle out. Determine which row we're looking at next:\n                const rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);\n                const isAbove = (x & 0x01) === 0; // i.e. is x even?\n                const rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);\n                if (rowNumber < 0 || rowNumber >= height) {\n                    break;\n                }\n                // Estimate black point for this row and load it:\n                try {\n                    row = image.getBlackRow(rowNumber, row);\n                } catch (ignored) {\n                    continue;\n                }\n                // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to\n                // handle decoding upside down barcodes.\n                for(let attempt = 0; attempt < 2; attempt++){\n                    if (attempt === 1) {\n                        row.reverse(); // reverse the row and continue\n                        // This means we will only ever draw result points *once* in the life of this method\n                        // since we want to avoid drawing the wrong points after flipping the row, and,\n                        // don't want to clutter with noise from every single row scan -- just the scans\n                        // that start on the center line.\n                        if (hints && hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK) === true) {\n                            const newHints = new Map();\n                            hints.forEach((hint, key)=>newHints.set(key, hint));\n                            newHints.delete(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n                            hints = newHints;\n                        }\n                    }\n                    try {\n                        // Look for a barcode\n                        const result = this.decodeRow(rowNumber, row, hints);\n                        // We found our barcode\n                        if (attempt === 1) {\n                            // But it was upside down, so note that\n                            result.putMetadata(ResultMetadataType$1.ORIENTATION, 180);\n                            // And remember to flip the result points horizontally.\n                            const points = result.getResultPoints();\n                            if (points !== null) {\n                                points[0] = new ResultPoint(width - points[0].getX() - 1, points[0].getY());\n                                points[1] = new ResultPoint(width - points[1].getX() - 1, points[1].getY());\n                            }\n                        }\n                        return result;\n                    } catch (re) {\n                    // continue -- just couldn't decode this row\n                    }\n                }\n            }\n            throw new NotFoundException();\n        }\n        /**\n         * Records the size of successive runs of white and black pixels in a row, starting at a given point.\n         * The values are recorded in the given array, and the number of runs recorded is equal to the size\n         * of the array. If the row starts on a white pixel at the given start point, then the first count\n         * recorded is the run of white pixels starting from that point; likewise it is the count of a run\n         * of black pixels if the row begin on a black pixels at that point.\n         *\n         * @param row row to count from\n         * @param start offset into row to start at\n         * @param counters array into which to record counts\n         * @throws NotFoundException if counters cannot be filled entirely from row before running out\n         *  of pixels\n         */ static recordPattern(row, start, counters) {\n            const numCounters = counters.length;\n            for(let index = 0; index < numCounters; index++)counters[index] = 0;\n            const end = row.getSize();\n            if (start >= end) {\n                throw new NotFoundException();\n            }\n            let isWhite = !row.get(start);\n            let counterPosition = 0;\n            let i = start;\n            while(i < end){\n                if (row.get(i) !== isWhite) {\n                    counters[counterPosition]++;\n                } else {\n                    if (++counterPosition === numCounters) {\n                        break;\n                    } else {\n                        counters[counterPosition] = 1;\n                        isWhite = !isWhite;\n                    }\n                }\n                i++;\n            }\n            // If we read fully the last section of pixels and filled up our counters -- or filled\n            // the last counter but ran off the side of the image, OK. Otherwise, a problem.\n            if (!(counterPosition === numCounters || counterPosition === numCounters - 1 && i === end)) {\n                throw new NotFoundException();\n            }\n        }\n        static recordPatternInReverse(row, start, counters) {\n            // This could be more efficient I guess\n            let numTransitionsLeft = counters.length;\n            let last = row.get(start);\n            while(start > 0 && numTransitionsLeft >= 0){\n                if (row.get(--start) !== last) {\n                    numTransitionsLeft--;\n                    last = !last;\n                }\n            }\n            if (numTransitionsLeft >= 0) {\n                throw new NotFoundException();\n            }\n            OneDReader.recordPattern(row, start + 1, counters);\n        }\n        /**\n         * Determines how closely a set of observed counts of runs of black/white values matches a given\n         * target pattern. This is reported as the ratio of the total variance from the expected pattern\n         * proportions across all pattern elements, to the length of the pattern.\n         *\n         * @param counters observed counters\n         * @param pattern expected pattern\n         * @param maxIndividualVariance The most any counter can differ before we give up\n         * @return ratio of total variance between counters and pattern compared to total pattern size\n         */ static patternMatchVariance(counters, pattern, maxIndividualVariance) {\n            const numCounters = counters.length;\n            let total = 0;\n            let patternLength = 0;\n            for(let i = 0; i < numCounters; i++){\n                total += counters[i];\n                patternLength += pattern[i];\n            }\n            if (total < patternLength) {\n                // If we don't even have one pixel per unit of bar width, assume this is too small\n                // to reliably match, so fail:\n                return Number.POSITIVE_INFINITY;\n            }\n            const unitBarWidth = total / patternLength;\n            maxIndividualVariance *= unitBarWidth;\n            let totalVariance = 0.0;\n            for(let x = 0; x < numCounters; x++){\n                const counter = counters[x];\n                const scaledPattern = pattern[x] * unitBarWidth;\n                const variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n                if (variance > maxIndividualVariance) {\n                    return Number.POSITIVE_INFINITY;\n                }\n                totalVariance += variance;\n            }\n            return totalVariance / total;\n        }\n    }\n    /**\n     * <p>Decodes Code 128 barcodes.</p>\n     *\n     * @author Sean Owen\n     */ class Code128Reader extends OneDReader {\n        static findStartPattern(row) {\n            const width = row.getSize();\n            const rowOffset = row.getNextSet(0);\n            let counterPosition = 0;\n            let counters = Int32Array.from([\n                0,\n                0,\n                0,\n                0,\n                0,\n                0\n            ]);\n            let patternStart = rowOffset;\n            let isWhite = false;\n            const patternLength = 6;\n            for(let i = rowOffset; i < width; i++){\n                if (row.get(i) !== isWhite) {\n                    counters[counterPosition]++;\n                } else {\n                    if (counterPosition === patternLength - 1) {\n                        let bestVariance = Code128Reader.MAX_AVG_VARIANCE;\n                        let bestMatch = -1;\n                        for(let startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++){\n                            const variance = OneDReader.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);\n                            if (variance < bestVariance) {\n                                bestVariance = variance;\n                                bestMatch = startCode;\n                            }\n                        }\n                        // Look for whitespace before start pattern, >= 50% of width of start pattern\n                        if (bestMatch >= 0 && row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {\n                            return Int32Array.from([\n                                patternStart,\n                                i,\n                                bestMatch\n                            ]);\n                        }\n                        patternStart += counters[0] + counters[1];\n                        counters = counters.slice(2, counters.length - 1);\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    } else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        static decodeCode(row, counters, rowOffset) {\n            OneDReader.recordPattern(row, rowOffset, counters);\n            let bestVariance = Code128Reader.MAX_AVG_VARIANCE; // worst variance we'll accept\n            let bestMatch = -1;\n            for(let d = 0; d < Code128Reader.CODE_PATTERNS.length; d++){\n                const pattern = Code128Reader.CODE_PATTERNS[d];\n                const variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);\n                if (variance < bestVariance) {\n                    bestVariance = variance;\n                    bestMatch = d;\n                }\n            }\n            // TODO We're overlooking the fact that the STOP pattern has 7 values, not 6.\n            if (bestMatch >= 0) {\n                return bestMatch;\n            } else {\n                throw new NotFoundException();\n            }\n        }\n        decodeRow(rowNumber, row, hints) {\n            const convertFNC1 = hints && hints.get(DecodeHintType$1.ASSUME_GS1) === true;\n            const startPatternInfo = Code128Reader.findStartPattern(row);\n            const startCode = startPatternInfo[2];\n            let currentRawCodesIndex = 0;\n            const rawCodes = new Uint8Array(20);\n            rawCodes[currentRawCodesIndex++] = startCode;\n            let codeSet;\n            switch(startCode){\n                case Code128Reader.CODE_START_A:\n                    codeSet = Code128Reader.CODE_CODE_A;\n                    break;\n                case Code128Reader.CODE_START_B:\n                    codeSet = Code128Reader.CODE_CODE_B;\n                    break;\n                case Code128Reader.CODE_START_C:\n                    codeSet = Code128Reader.CODE_CODE_C;\n                    break;\n                default:\n                    throw new FormatException();\n            }\n            let done = false;\n            let isNextShifted = false;\n            let result = \"\";\n            let lastStart = startPatternInfo[0];\n            let nextStart = startPatternInfo[1];\n            const counters = Int32Array.from([\n                0,\n                0,\n                0,\n                0,\n                0,\n                0\n            ]);\n            let lastCode = 0;\n            let code = 0;\n            let checksumTotal = startCode;\n            let multiplier = 0;\n            let lastCharacterWasPrintable = true;\n            let upperMode = false;\n            let shiftUpperMode = false;\n            while(!done){\n                const unshift = isNextShifted;\n                isNextShifted = false;\n                // Save off last code\n                lastCode = code;\n                // Decode another code from image\n                code = Code128Reader.decodeCode(row, counters, nextStart);\n                rawCodes[currentRawCodesIndex++] = code;\n                // Remember whether the last code was printable or not (excluding CODE_STOP)\n                if (code !== Code128Reader.CODE_STOP) {\n                    lastCharacterWasPrintable = true;\n                }\n                // Add to checksum computation (if not CODE_STOP of course)\n                if (code !== Code128Reader.CODE_STOP) {\n                    multiplier++;\n                    checksumTotal += multiplier * code;\n                }\n                // Advance to where the next code will to start\n                lastStart = nextStart;\n                nextStart += counters.reduce((previous, current)=>previous + current, 0);\n                // Take care of illegal start codes\n                switch(code){\n                    case Code128Reader.CODE_START_A:\n                    case Code128Reader.CODE_START_B:\n                    case Code128Reader.CODE_START_C:\n                        throw new FormatException();\n                }\n                switch(codeSet){\n                    case Code128Reader.CODE_CODE_A:\n                        if (code < 64) {\n                            if (shiftUpperMode === upperMode) {\n                                result += String.fromCharCode(\" \".charCodeAt(0) + code);\n                            } else {\n                                result += String.fromCharCode(\" \".charCodeAt(0) + code + 128);\n                            }\n                            shiftUpperMode = false;\n                        } else if (code < 96) {\n                            if (shiftUpperMode === upperMode) {\n                                result += String.fromCharCode(code - 64);\n                            } else {\n                                result += String.fromCharCode(code + 64);\n                            }\n                            shiftUpperMode = false;\n                        } else {\n                            // Don't let CODE_STOP, which always appears, affect whether whether we think the last\n                            // code was printable or not.\n                            if (code !== Code128Reader.CODE_STOP) {\n                                lastCharacterWasPrintable = false;\n                            }\n                            switch(code){\n                                case Code128Reader.CODE_FNC_1:\n                                    if (convertFNC1) {\n                                        if (result.length === 0) {\n                                            // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                            // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                            result += \"]C1\";\n                                        } else {\n                                            // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                            result += String.fromCharCode(29);\n                                        }\n                                    }\n                                    break;\n                                case Code128Reader.CODE_FNC_2:\n                                case Code128Reader.CODE_FNC_3:\n                                    break;\n                                case Code128Reader.CODE_FNC_4_A:\n                                    if (!upperMode && shiftUpperMode) {\n                                        upperMode = true;\n                                        shiftUpperMode = false;\n                                    } else if (upperMode && shiftUpperMode) {\n                                        upperMode = false;\n                                        shiftUpperMode = false;\n                                    } else {\n                                        shiftUpperMode = true;\n                                    }\n                                    break;\n                                case Code128Reader.CODE_SHIFT:\n                                    isNextShifted = true;\n                                    codeSet = Code128Reader.CODE_CODE_B;\n                                    break;\n                                case Code128Reader.CODE_CODE_B:\n                                    codeSet = Code128Reader.CODE_CODE_B;\n                                    break;\n                                case Code128Reader.CODE_CODE_C:\n                                    codeSet = Code128Reader.CODE_CODE_C;\n                                    break;\n                                case Code128Reader.CODE_STOP:\n                                    done = true;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Code128Reader.CODE_CODE_B:\n                        if (code < 96) {\n                            if (shiftUpperMode === upperMode) {\n                                result += String.fromCharCode(\" \".charCodeAt(0) + code);\n                            } else {\n                                result += String.fromCharCode(\" \".charCodeAt(0) + code + 128);\n                            }\n                            shiftUpperMode = false;\n                        } else {\n                            if (code !== Code128Reader.CODE_STOP) {\n                                lastCharacterWasPrintable = false;\n                            }\n                            switch(code){\n                                case Code128Reader.CODE_FNC_1:\n                                    if (convertFNC1) {\n                                        if (result.length === 0) {\n                                            // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                            // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                            result += \"]C1\";\n                                        } else {\n                                            // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                            result += String.fromCharCode(29);\n                                        }\n                                    }\n                                    break;\n                                case Code128Reader.CODE_FNC_2:\n                                case Code128Reader.CODE_FNC_3:\n                                    break;\n                                case Code128Reader.CODE_FNC_4_B:\n                                    if (!upperMode && shiftUpperMode) {\n                                        upperMode = true;\n                                        shiftUpperMode = false;\n                                    } else if (upperMode && shiftUpperMode) {\n                                        upperMode = false;\n                                        shiftUpperMode = false;\n                                    } else {\n                                        shiftUpperMode = true;\n                                    }\n                                    break;\n                                case Code128Reader.CODE_SHIFT:\n                                    isNextShifted = true;\n                                    codeSet = Code128Reader.CODE_CODE_A;\n                                    break;\n                                case Code128Reader.CODE_CODE_A:\n                                    codeSet = Code128Reader.CODE_CODE_A;\n                                    break;\n                                case Code128Reader.CODE_CODE_C:\n                                    codeSet = Code128Reader.CODE_CODE_C;\n                                    break;\n                                case Code128Reader.CODE_STOP:\n                                    done = true;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Code128Reader.CODE_CODE_C:\n                        if (code < 100) {\n                            if (code < 10) {\n                                result += \"0\";\n                            }\n                            result += code;\n                        } else {\n                            if (code !== Code128Reader.CODE_STOP) {\n                                lastCharacterWasPrintable = false;\n                            }\n                            switch(code){\n                                case Code128Reader.CODE_FNC_1:\n                                    if (convertFNC1) {\n                                        if (result.length === 0) {\n                                            // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                            // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                            result += \"]C1\";\n                                        } else {\n                                            // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                            result += String.fromCharCode(29);\n                                        }\n                                    }\n                                    break;\n                                case Code128Reader.CODE_CODE_A:\n                                    codeSet = Code128Reader.CODE_CODE_A;\n                                    break;\n                                case Code128Reader.CODE_CODE_B:\n                                    codeSet = Code128Reader.CODE_CODE_B;\n                                    break;\n                                case Code128Reader.CODE_STOP:\n                                    done = true;\n                                    break;\n                            }\n                        }\n                        break;\n                }\n                // Unshift back to another code set if we were shifted\n                if (unshift) {\n                    codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;\n                }\n            }\n            const lastPatternSize = nextStart - lastStart;\n            // Check for ample whitespace following pattern, but, to do this we first need to remember that\n            // we fudged decoding CODE_STOP since it actually has 7 bars, not 6. There is a black bar left\n            // to read off. Would be slightly better to properly read. Here we just skip it:\n            nextStart = row.getNextUnset(nextStart);\n            if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {\n                throw new NotFoundException();\n            }\n            // Pull out from sum the value of the penultimate check code\n            checksumTotal -= multiplier * lastCode;\n            // lastCode is the checksum then:\n            if (checksumTotal % 103 !== lastCode) {\n                throw new ChecksumException();\n            }\n            // Need to pull out the check digits from string\n            const resultLength = result.length;\n            if (resultLength === 0) {\n                // false positive\n                throw new NotFoundException();\n            }\n            // Only bother if the result had at least one character, and if the checksum digit happened to\n            // be a printable character. If it was just interpreted as a control code, nothing to remove.\n            if (resultLength > 0 && lastCharacterWasPrintable) {\n                if (codeSet === Code128Reader.CODE_CODE_C) {\n                    result = result.substring(0, resultLength - 2);\n                } else {\n                    result = result.substring(0, resultLength - 1);\n                }\n            }\n            const left = (startPatternInfo[1] + startPatternInfo[0]) / 2.0;\n            const right = lastStart + lastPatternSize / 2.0;\n            const rawCodesSize = rawCodes.length;\n            const rawBytes = new Uint8Array(rawCodesSize);\n            for(let i = 0; i < rawCodesSize; i++){\n                rawBytes[i] = rawCodes[i];\n            }\n            const points = [\n                new ResultPoint(left, rowNumber),\n                new ResultPoint(right, rowNumber)\n            ];\n            return new Result(result, rawBytes, 0, points, BarcodeFormat$1.CODE_128, new Date().getTime());\n        }\n    }\n    Code128Reader.CODE_PATTERNS = [\n        Int32Array.from([\n            2,\n            1,\n            2,\n            2,\n            2,\n            2\n        ]),\n        Int32Array.from([\n            2,\n            2,\n            2,\n            1,\n            2,\n            2\n        ]),\n        Int32Array.from([\n            2,\n            2,\n            2,\n            2,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            1,\n            2,\n            2,\n            3\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            1,\n            3,\n            2,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            1,\n            2,\n            2,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            2,\n            2,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            2,\n            3,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            2,\n            2,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            2,\n            2,\n            1,\n            2,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            2,\n            2,\n            1,\n            3,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            2,\n            3,\n            1,\n            2,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            2,\n            2,\n            3,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            2,\n            1,\n            3,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            2,\n            2,\n            3,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            3,\n            2,\n            2,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            3,\n            1,\n            2,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            3,\n            2,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            2,\n            3,\n            2,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            2,\n            1,\n            1,\n            3,\n            2\n        ]),\n        Int32Array.from([\n            2,\n            2,\n            1,\n            2,\n            3,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            3,\n            2,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            2,\n            2,\n            3,\n            1,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            2,\n            1,\n            3,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            1,\n            2,\n            2,\n            2\n        ]),\n        Int32Array.from([\n            3,\n            2,\n            1,\n            1,\n            2,\n            2\n        ]),\n        Int32Array.from([\n            3,\n            2,\n            1,\n            2,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            2,\n            2,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            3,\n            2,\n            2,\n            1,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            3,\n            2,\n            2,\n            2,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            2,\n            1,\n            2,\n            3\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            2,\n            3,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            3,\n            2,\n            1,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            1,\n            3,\n            2,\n            3\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            1,\n            1,\n            2,\n            3\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            1,\n            3,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            2,\n            3,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            2,\n            1,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            2,\n            3,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            1,\n            3,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            2,\n            3,\n            1,\n            1,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            2,\n            3,\n            1,\n            3,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            2,\n            1,\n            3,\n            3\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            2,\n            3,\n            3,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            2,\n            1,\n            3,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            3,\n            1,\n            2,\n            3\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            3,\n            3,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            3,\n            1,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            3,\n            1,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            1,\n            3,\n            3,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            3,\n            1,\n            1,\n            3,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            3,\n            1,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            3,\n            3,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            3,\n            1,\n            3,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            1,\n            1,\n            2,\n            3\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            1,\n            3,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            3,\n            1,\n            1,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            2,\n            1,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            2,\n            3,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            3,\n            2,\n            1,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            4,\n            1,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            2,\n            1,\n            4,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            4,\n            3,\n            1,\n            1,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            1,\n            2,\n            2,\n            4\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            1,\n            4,\n            2,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            1,\n            1,\n            2,\n            4\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            1,\n            4,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            4,\n            1,\n            1,\n            2,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            4,\n            1,\n            2,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            2,\n            2,\n            1,\n            4\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            2,\n            4,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            2,\n            1,\n            1,\n            4\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            2,\n            4,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            4,\n            2,\n            1,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            4,\n            2,\n            2,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            4,\n            1,\n            2,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            2,\n            1,\n            1,\n            1,\n            4\n        ]),\n        Int32Array.from([\n            4,\n            1,\n            3,\n            1,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            4,\n            1,\n            1,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            4,\n            1,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            1,\n            2,\n            4,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            1,\n            1,\n            4,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            1,\n            2,\n            4,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            4,\n            2,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            4,\n            1,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            4,\n            2,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            4,\n            1,\n            1,\n            2,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            4,\n            2,\n            1,\n            1,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            4,\n            2,\n            1,\n            2,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            2,\n            1,\n            4,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            4,\n            1,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            4,\n            1,\n            2,\n            1,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            1,\n            1,\n            4,\n            3\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            1,\n            3,\n            4,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            1,\n            1,\n            4,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            4,\n            1,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            4,\n            3,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            4,\n            1,\n            1,\n            1,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            4,\n            1,\n            1,\n            3,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            3,\n            1,\n            4,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            4,\n            1,\n            3,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            1,\n            1,\n            4,\n            1\n        ]),\n        Int32Array.from([\n            4,\n            1,\n            1,\n            1,\n            3,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            1,\n            4,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            1,\n            2,\n            1,\n            4\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            1,\n            2,\n            3,\n            2\n        ]),\n        Int32Array.from([\n            2,\n            3,\n            3,\n            1,\n            1,\n            1,\n            2\n        ])\n    ];\n    Code128Reader.MAX_AVG_VARIANCE = 0.25;\n    Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n    Code128Reader.CODE_SHIFT = 98;\n    Code128Reader.CODE_CODE_C = 99;\n    Code128Reader.CODE_CODE_B = 100;\n    Code128Reader.CODE_CODE_A = 101;\n    Code128Reader.CODE_FNC_1 = 102;\n    Code128Reader.CODE_FNC_2 = 97;\n    Code128Reader.CODE_FNC_3 = 96;\n    Code128Reader.CODE_FNC_4_A = 101;\n    Code128Reader.CODE_FNC_4_B = 100;\n    Code128Reader.CODE_START_A = 103;\n    Code128Reader.CODE_START_B = 104;\n    Code128Reader.CODE_START_C = 105;\n    Code128Reader.CODE_STOP = 106;\n    /**\n     * <p>Decodes Code 39 barcodes. Supports \"Full ASCII Code 39\" if USE_CODE_39_EXTENDED_MODE is set.</p>\n     *\n     * @author Sean Owen\n     * @see Code93Reader\n     */ class Code39Reader extends OneDReader {\n        /**\n         * Creates a reader that assumes all encoded data is data, and does not treat the final\n         * character as a check digit. It will not decoded \"extended Code 39\" sequences.\n         */ // public Code39Reader() {\n        //   this(false);\n        // }\n        /**\n         * Creates a reader that can be configured to check the last character as a check digit.\n         * It will not decoded \"extended Code 39\" sequences.\n         *\n         * @param usingCheckDigit if true, treat the last data character as a check digit, not\n         * data, and verify that the checksum passes.\n         */ // public Code39Reader(boolean usingCheckDigit) {\n        //   this(usingCheckDigit, false);\n        // }\n        /**\n         * Creates a reader that can be configured to check the last character as a check digit,\n         * or optionally attempt to decode \"extended Code 39\" sequences that are used to encode\n         * the full ASCII character set.\n         *\n         * @param usingCheckDigit if true, treat the last data character as a check digit, not\n         * data, and verify that the checksum passes.\n         * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the\n         * text.\n         */ constructor(usingCheckDigit = false, extendedMode = false){\n            super();\n            this.usingCheckDigit = usingCheckDigit;\n            this.extendedMode = extendedMode;\n            this.decodeRowResult = \"\";\n            this.counters = new Int32Array(9);\n        }\n        decodeRow(rowNumber, row, hints) {\n            let theCounters = this.counters;\n            theCounters.fill(0);\n            this.decodeRowResult = \"\";\n            let start = Code39Reader.findAsteriskPattern(row, theCounters);\n            // Read off white space\n            let nextStart = row.getNextSet(start[1]);\n            let end = row.getSize();\n            let decodedChar;\n            let lastStart;\n            do {\n                Code39Reader.recordPattern(row, nextStart, theCounters);\n                let pattern = Code39Reader.toNarrowWidePattern(theCounters);\n                if (pattern < 0) {\n                    throw new NotFoundException();\n                }\n                decodedChar = Code39Reader.patternToChar(pattern);\n                this.decodeRowResult += decodedChar;\n                lastStart = nextStart;\n                for (let counter of theCounters){\n                    nextStart += counter;\n                }\n                // Read off white space\n                nextStart = row.getNextSet(nextStart);\n            }while (decodedChar !== \"*\");\n            this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1); // remove asterisk\n            // Look for whitespace after pattern:\n            let lastPatternSize = 0;\n            for (let counter of theCounters){\n                lastPatternSize += counter;\n            }\n            let whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;\n            // If 50% of last pattern size, following last pattern, is not whitespace, fail\n            // (but if it's whitespace to the very end of the image, that's OK)\n            if (nextStart !== end && whiteSpaceAfterEnd * 2 < lastPatternSize) {\n                throw new NotFoundException();\n            }\n            if (this.usingCheckDigit) {\n                let max = this.decodeRowResult.length - 1;\n                let total = 0;\n                for(let i = 0; i < max; i++){\n                    total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));\n                }\n                if (this.decodeRowResult.charAt(max) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {\n                    throw new ChecksumException();\n                }\n                this.decodeRowResult = this.decodeRowResult.substring(0, max);\n            }\n            if (this.decodeRowResult.length === 0) {\n                // false positive\n                throw new NotFoundException();\n            }\n            let resultString;\n            if (this.extendedMode) {\n                resultString = Code39Reader.decodeExtended(this.decodeRowResult);\n            } else {\n                resultString = this.decodeRowResult;\n            }\n            let left = (start[1] + start[0]) / 2.0;\n            let right = lastStart + lastPatternSize / 2.0;\n            return new Result(resultString, null, 0, [\n                new ResultPoint(left, rowNumber),\n                new ResultPoint(right, rowNumber)\n            ], BarcodeFormat$1.CODE_39, new Date().getTime());\n        }\n        static findAsteriskPattern(row, counters) {\n            let width = row.getSize();\n            let rowOffset = row.getNextSet(0);\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            let isWhite = false;\n            let patternLength = counters.length;\n            for(let i = rowOffset; i < width; i++){\n                if (row.get(i) !== isWhite) {\n                    counters[counterPosition]++;\n                } else {\n                    if (counterPosition === patternLength - 1) {\n                        // Look for whitespace before start pattern, >= 50% of width of start pattern\n                        if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING && row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {\n                            return [\n                                patternStart,\n                                i\n                            ];\n                        }\n                        patternStart += counters[0] + counters[1];\n                        counters.copyWithin(0, 2, 2 + counterPosition - 1);\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    } else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        // For efficiency, returns -1 on failure. Not throwing here saved as many as 700 exceptions\n        // per image when using some of our blackbox images.\n        static toNarrowWidePattern(counters) {\n            let numCounters = counters.length;\n            let maxNarrowCounter = 0;\n            let wideCounters;\n            do {\n                let minCounter = 0x7fffffff;\n                for (let counter of counters){\n                    if (counter < minCounter && counter > maxNarrowCounter) {\n                        minCounter = counter;\n                    }\n                }\n                maxNarrowCounter = minCounter;\n                wideCounters = 0;\n                let totalWideCountersWidth = 0;\n                let pattern = 0;\n                for(let i = 0; i < numCounters; i++){\n                    let counter = counters[i];\n                    if (counter > maxNarrowCounter) {\n                        pattern |= 1 << numCounters - 1 - i;\n                        wideCounters++;\n                        totalWideCountersWidth += counter;\n                    }\n                }\n                if (wideCounters === 3) {\n                    // Found 3 wide counters, but are they close enough in width?\n                    // We can perform a cheap, conservative check to see if any individual\n                    // counter is more than 1.5 times the average:\n                    for(let i = 0; i < numCounters && wideCounters > 0; i++){\n                        let counter = counters[i];\n                        if (counter > maxNarrowCounter) {\n                            wideCounters--;\n                            // totalWideCountersWidth = 3 * average, so this checks if counter >= 3/2 * average\n                            if (counter * 2 >= totalWideCountersWidth) {\n                                return -1;\n                            }\n                        }\n                    }\n                    return pattern;\n                }\n            }while (wideCounters > 3);\n            return -1;\n        }\n        static patternToChar(pattern) {\n            for(let i = 0; i < Code39Reader.CHARACTER_ENCODINGS.length; i++){\n                if (Code39Reader.CHARACTER_ENCODINGS[i] === pattern) {\n                    return Code39Reader.ALPHABET_STRING.charAt(i);\n                }\n            }\n            if (pattern === Code39Reader.ASTERISK_ENCODING) {\n                return \"*\";\n            }\n            throw new NotFoundException();\n        }\n        static decodeExtended(encoded) {\n            let length = encoded.length;\n            let decoded = \"\";\n            for(let i = 0; i < length; i++){\n                let c = encoded.charAt(i);\n                if (c === \"+\" || c === \"$\" || c === \"%\" || c === \"/\") {\n                    let next = encoded.charAt(i + 1);\n                    let decodedChar = \"\\x00\";\n                    switch(c){\n                        case \"+\":\n                            // +A to +Z map to a to z\n                            if (next >= \"A\" && next <= \"Z\") {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);\n                            } else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case \"$\":\n                            // $A to $Z map to control codes SH to SB\n                            if (next >= \"A\" && next <= \"Z\") {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);\n                            } else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case \"%\":\n                            // %A to %E map to control codes ESC to US\n                            if (next >= \"A\" && next <= \"E\") {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);\n                            } else if (next >= \"F\" && next <= \"J\") {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);\n                            } else if (next >= \"K\" && next <= \"O\") {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);\n                            } else if (next >= \"P\" && next <= \"T\") {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);\n                            } else if (next === \"U\") {\n                                decodedChar = \"\\x00\";\n                            } else if (next === \"V\") {\n                                decodedChar = \"@\";\n                            } else if (next === \"W\") {\n                                decodedChar = \"`\";\n                            } else if (next === \"X\" || next === \"Y\" || next === \"Z\") {\n                                decodedChar = \"\\x7f\";\n                            } else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case \"/\":\n                            // /A to /O map to ! to , and /Z maps to :\n                            if (next >= \"A\" && next <= \"O\") {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);\n                            } else if (next === \"Z\") {\n                                decodedChar = \":\";\n                            } else {\n                                throw new FormatException();\n                            }\n                            break;\n                    }\n                    decoded += decodedChar;\n                    // bump up i again since we read two characters\n                    i++;\n                } else {\n                    decoded += c;\n                }\n            }\n            return decoded;\n        }\n    }\n    Code39Reader.ALPHABET_STRING = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%\";\n    /**\n     * These represent the encodings of characters, as patterns of wide and narrow bars.\n     * The 9 least-significant bits of each int correspond to the pattern of wide and narrow,\n     * with 1s representing \"wide\" and 0s representing narrow.\n     */ Code39Reader.CHARACTER_ENCODINGS = [\n        0x034,\n        0x121,\n        0x061,\n        0x160,\n        0x031,\n        0x130,\n        0x070,\n        0x025,\n        0x124,\n        0x064,\n        0x109,\n        0x049,\n        0x148,\n        0x019,\n        0x118,\n        0x058,\n        0x00D,\n        0x10C,\n        0x04C,\n        0x01C,\n        0x103,\n        0x043,\n        0x142,\n        0x013,\n        0x112,\n        0x052,\n        0x007,\n        0x106,\n        0x046,\n        0x016,\n        0x181,\n        0x0C1,\n        0x1C0,\n        0x091,\n        0x190,\n        0x0D0,\n        0x085,\n        0x184,\n        0x0C4,\n        0x0A8,\n        0x0A2,\n        0x08A,\n        0x02A // /-%\n    ];\n    Code39Reader.ASTERISK_ENCODING = 0x094;\n    /**\n     * <p>Decodes ITF barcodes.</p>\n     *\n     * @author Tjieco\n     */ class ITFReader extends OneDReader {\n        constructor(){\n            // private static W = 3; // Pixel width of a 3x wide line\n            // private static w = 2; // Pixel width of a 2x wide line\n            // private static N = 1; // Pixed width of a narrow line\n            super(...arguments);\n            // Stores the actual narrow line width of the image being decoded.\n            this.narrowLineWidth = -1;\n        }\n        // See ITFWriter.PATTERNS\n        /*\n      \n        /!**\n         * Patterns of Wide / Narrow lines to indicate each digit\n         *!/\n        */ decodeRow(rowNumber, row, hints) {\n            // Find out where the Middle section (payload) starts & ends\n            let startRange = this.decodeStart(row);\n            let endRange = this.decodeEnd(row);\n            let result = new StringBuilder();\n            ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);\n            let resultString = result.toString();\n            let allowedLengths = null;\n            if (hints != null) {\n                allowedLengths = hints.get(DecodeHintType$1.ALLOWED_LENGTHS);\n            }\n            if (allowedLengths == null) {\n                allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;\n            }\n            // To avoid false positives with 2D barcodes (and other patterns), make\n            // an assumption that the decoded string must be a 'standard' length if it's short\n            let length = resultString.length;\n            let lengthOK = false;\n            let maxAllowedLength = 0;\n            for (let value of allowedLengths){\n                if (length === value) {\n                    lengthOK = true;\n                    break;\n                }\n                if (value > maxAllowedLength) {\n                    maxAllowedLength = value;\n                }\n            }\n            if (!lengthOK && length > maxAllowedLength) {\n                lengthOK = true;\n            }\n            if (!lengthOK) {\n                throw new FormatException();\n            }\n            const points = [\n                new ResultPoint(startRange[1], rowNumber),\n                new ResultPoint(endRange[0], rowNumber)\n            ];\n            let resultReturn = new Result(resultString, null, 0, points, BarcodeFormat$1.ITF, new Date().getTime());\n            return resultReturn;\n        }\n        /*\n        /!**\n         * @param row          row of black/white values to search\n         * @param payloadStart offset of start pattern\n         * @param resultString {@link StringBuilder} to append decoded chars to\n         * @throws NotFoundException if decoding could not complete successfully\n         *!/*/ static decodeMiddle(row, payloadStart, payloadEnd, resultString) {\n            // Digits are interleaved in pairs - 5 black lines for one digit, and the\n            // 5\n            // interleaved white lines for the second digit.\n            // Therefore, need to scan 10 lines and then\n            // split these into two arrays\n            let counterDigitPair = new Int32Array(10); // 10\n            let counterBlack = new Int32Array(5); // 5\n            let counterWhite = new Int32Array(5); // 5\n            counterDigitPair.fill(0);\n            counterBlack.fill(0);\n            counterWhite.fill(0);\n            while(payloadStart < payloadEnd){\n                // Get 10 runs of black/white.\n                OneDReader.recordPattern(row, payloadStart, counterDigitPair);\n                // Split them into each array\n                for(let k = 0; k < 5; k++){\n                    let twoK = 2 * k;\n                    counterBlack[k] = counterDigitPair[twoK];\n                    counterWhite[k] = counterDigitPair[twoK + 1];\n                }\n                let bestMatch = ITFReader.decodeDigit(counterBlack);\n                resultString.append(bestMatch.toString());\n                bestMatch = this.decodeDigit(counterWhite);\n                resultString.append(bestMatch.toString());\n                counterDigitPair.forEach(function(counterDigit) {\n                    payloadStart += counterDigit;\n                });\n            }\n        }\n        /*/!**\n         * Identify where the start of the middle / payload section starts.\n         *\n         * @param row row of black/white values to search\n         * @return Array, containing index of start of 'start block' and end of\n         *         'start block'\n         *!/*/ decodeStart(row) {\n            let endStart = ITFReader.skipWhiteSpace(row);\n            let startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);\n            // Determine the width of a narrow line in pixels. We can do this by\n            // getting the width of the start pattern and dividing by 4 because its\n            // made up of 4 narrow lines.\n            this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;\n            this.validateQuietZone(row, startPattern[0]);\n            return startPattern;\n        }\n        /*/!**\n         * The start & end patterns must be pre/post fixed by a quiet zone. This\n         * zone must be at least 10 times the width of a narrow line.  Scan back until\n         * we either get to the start of the barcode or match the necessary number of\n         * quiet zone pixels.\n         *\n         * Note: Its assumed the row is reversed when using this method to find\n         * quiet zone after the end pattern.\n         *\n         * ref: http://www.barcode-1.net/i25code.html\n         *\n         * @param row bit array representing the scanned barcode.\n         * @param startPattern index into row of the start or end pattern.\n         * @throws NotFoundException if the quiet zone cannot be found\n         *!/*/ validateQuietZone(row, startPattern) {\n            let quietCount = this.narrowLineWidth * 10; // expect to find this many pixels of quiet zone\n            // if there are not so many pixel at all let's try as many as possible\n            quietCount = quietCount < startPattern ? quietCount : startPattern;\n            for(let i = startPattern - 1; quietCount > 0 && i >= 0; i--){\n                if (row.get(i)) {\n                    break;\n                }\n                quietCount--;\n            }\n            if (quietCount !== 0) {\n                // Unable to find the necessary number of quiet zone pixels.\n                throw new NotFoundException();\n            }\n        }\n        /*\n        /!**\n         * Skip all whitespace until we get to the first black line.\n         *\n         * @param row row of black/white values to search\n         * @return index of the first black line.\n         * @throws NotFoundException Throws exception if no black lines are found in the row\n         *!/*/ static skipWhiteSpace(row) {\n            const width = row.getSize();\n            const endStart = row.getNextSet(0);\n            if (endStart === width) {\n                throw new NotFoundException();\n            }\n            return endStart;\n        }\n        /*/!**\n         * Identify where the end of the middle / payload section ends.\n         *\n         * @param row row of black/white values to search\n         * @return Array, containing index of start of 'end block' and end of 'end\n         *         block'\n         *!/*/ decodeEnd(row) {\n            // For convenience, reverse the row and then\n            // search from 'the start' for the end block\n            row.reverse();\n            try {\n                let endStart = ITFReader.skipWhiteSpace(row);\n                let endPattern;\n                try {\n                    endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);\n                } catch (error) {\n                    if (error instanceof NotFoundException) {\n                        endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);\n                    }\n                }\n                // The start & end patterns must be pre/post fixed by a quiet zone. This\n                // zone must be at least 10 times the width of a narrow line.\n                // ref: http://www.barcode-1.net/i25code.html\n                this.validateQuietZone(row, endPattern[0]);\n                // Now recalculate the indices of where the 'endblock' starts & stops to\n                // accommodate\n                // the reversed nature of the search\n                let temp = endPattern[0];\n                endPattern[0] = row.getSize() - endPattern[1];\n                endPattern[1] = row.getSize() - temp;\n                return endPattern;\n            } finally{\n                // Put the row back the right way.\n                row.reverse();\n            }\n        }\n        /*\n        /!**\n         * @param row       row of black/white values to search\n         * @param rowOffset position to start search\n         * @param pattern   pattern of counts of number of black and white pixels that are\n         *                  being searched for as a pattern\n         * @return start/end horizontal offset of guard pattern, as an array of two\n         *         ints\n         * @throws NotFoundException if pattern is not found\n         *!/*/ static findGuardPattern(row, rowOffset, pattern) {\n            let patternLength = pattern.length;\n            let counters = new Int32Array(patternLength);\n            let width = row.getSize();\n            let isWhite = false;\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            counters.fill(0);\n            for(let x = rowOffset; x < width; x++){\n                if (row.get(x) !== isWhite) {\n                    counters[counterPosition]++;\n                } else {\n                    if (counterPosition === patternLength - 1) {\n                        if (OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {\n                            return [\n                                patternStart,\n                                x\n                            ];\n                        }\n                        patternStart += counters[0] + counters[1];\n                        System.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    } else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        /*/!**\n         * Attempts to decode a sequence of ITF black/white lines into single\n         * digit.\n         *\n         * @param counters the counts of runs of observed black/white/black/... values\n         * @return The decoded digit\n         * @throws NotFoundException if digit cannot be decoded\n         *!/*/ static decodeDigit(counters) {\n            let bestVariance = ITFReader.MAX_AVG_VARIANCE; // worst variance we'll accept\n            let bestMatch = -1;\n            let max = ITFReader.PATTERNS.length;\n            for(let i = 0; i < max; i++){\n                let pattern = ITFReader.PATTERNS[i];\n                let variance = OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);\n                if (variance < bestVariance) {\n                    bestVariance = variance;\n                    bestMatch = i;\n                } else if (variance === bestVariance) {\n                    // if we find a second 'best match' with the same variance, we can not reliably report to have a suitable match\n                    bestMatch = -1;\n                }\n            }\n            if (bestMatch >= 0) {\n                return bestMatch % 10;\n            } else {\n                throw new NotFoundException();\n            }\n        }\n    }\n    ITFReader.PATTERNS = [\n        Int32Array.from([\n            1,\n            1,\n            2,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            1,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            1,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            2,\n            2,\n            1,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            2,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            2,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            2,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            1,\n            2,\n            2\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            1,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            1,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            3,\n            3,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            1,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            1,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            3,\n            3,\n            1,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            3,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            3,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            3,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            1,\n            3,\n            3\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            1,\n            3,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            1,\n            3,\n            1\n        ]) // 9\n    ];\n    ITFReader.MAX_AVG_VARIANCE = 0.38;\n    ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;\n    /* /!** Valid ITF lengths. Anything longer than the largest value is also allowed. *!/*/ ITFReader.DEFAULT_ALLOWED_LENGTHS = [\n        6,\n        8,\n        10,\n        12,\n        14\n    ];\n    /*/!**\n     * Start/end guard pattern.\n     *\n     * Note: The end pattern is reversed because the row is reversed before\n     * searching for the END_PATTERN\n     *!/*/ ITFReader.START_PATTERN = Int32Array.from([\n        1,\n        1,\n        1,\n        1\n    ]);\n    ITFReader.END_PATTERN_REVERSED = [\n        Int32Array.from([\n            1,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            3\n        ]) // 3x\n    ];\n    /**\n     * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n     * of one-dimensional barcodes.</p>\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     * @author alasdair@google.com (Alasdair Mackintosh)\n     */ class AbstractUPCEANReader extends OneDReader {\n        constructor(){\n            super(...arguments);\n            this.decodeRowStringBuffer = \"\";\n        }\n        static findStartGuardPattern(row) {\n            let foundStart = false;\n            let startRange;\n            let nextStart = 0;\n            let counters = Int32Array.from([\n                0,\n                0,\n                0\n            ]);\n            while(!foundStart){\n                counters = Int32Array.from([\n                    0,\n                    0,\n                    0\n                ]);\n                startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);\n                let start = startRange[0];\n                nextStart = startRange[1];\n                let quietStart = start - (nextStart - start);\n                if (quietStart >= 0) {\n                    foundStart = row.isRange(quietStart, start, false);\n                }\n            }\n            return startRange;\n        }\n        static checkChecksum(s) {\n            return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);\n        }\n        static checkStandardUPCEANChecksum(s) {\n            let length = s.length;\n            if (length === 0) return false;\n            let check = parseInt(s.charAt(length - 1), 10);\n            return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n        }\n        static getStandardUPCEANChecksum(s) {\n            let length = s.length;\n            let sum = 0;\n            for(let i = length - 1; i >= 0; i -= 2){\n                let digit = s.charAt(i).charCodeAt(0) - \"0\".charCodeAt(0);\n                if (digit < 0 || digit > 9) {\n                    throw new FormatException();\n                }\n                sum += digit;\n            }\n            sum *= 3;\n            for(let i = length - 2; i >= 0; i -= 2){\n                let digit = s.charAt(i).charCodeAt(0) - \"0\".charCodeAt(0);\n                if (digit < 0 || digit > 9) {\n                    throw new FormatException();\n                }\n                sum += digit;\n            }\n            return (1000 - sum) % 10;\n        }\n        static decodeEnd(row, endStart) {\n            return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));\n        }\n        /**\n         * @throws NotFoundException\n         */ static findGuardPatternWithoutCounters(row, rowOffset, whiteFirst, pattern) {\n            return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));\n        }\n        /**\n         * @param row row of black/white values to search\n         * @param rowOffset position to start search\n         * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...\n         * pixel counts, otherwise, it is interpreted as black/white/black/...\n         * @param pattern pattern of counts of number of black and white pixels that are being\n         * searched for as a pattern\n         * @param counters array of counters, as long as pattern, to re-use\n         * @return start/end horizontal offset of guard pattern, as an array of two ints\n         * @throws NotFoundException if pattern is not found\n         */ static findGuardPattern(row, rowOffset, whiteFirst, pattern, counters) {\n            let width = row.getSize();\n            rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            let patternLength = pattern.length;\n            let isWhite = whiteFirst;\n            for(let x = rowOffset; x < width; x++){\n                if (row.get(x) !== isWhite) {\n                    counters[counterPosition]++;\n                } else {\n                    if (counterPosition === patternLength - 1) {\n                        if (OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {\n                            return Int32Array.from([\n                                patternStart,\n                                x\n                            ]);\n                        }\n                        patternStart += counters[0] + counters[1];\n                        let slice = counters.slice(2, counters.length - 1);\n                        for(let i = 0; i < counterPosition - 1; i++){\n                            counters[i] = slice[i];\n                        }\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    } else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        static decodeDigit(row, counters, rowOffset, patterns) {\n            this.recordPattern(row, rowOffset, counters);\n            let bestVariance = this.MAX_AVG_VARIANCE;\n            let bestMatch = -1;\n            let max = patterns.length;\n            for(let i = 0; i < max; i++){\n                let pattern = patterns[i];\n                let variance = OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);\n                if (variance < bestVariance) {\n                    bestVariance = variance;\n                    bestMatch = i;\n                }\n            }\n            if (bestMatch >= 0) {\n                return bestMatch;\n            } else {\n                throw new NotFoundException();\n            }\n        }\n    }\n    // These two values are critical for determining how permissive the decoding will be.\n    // We've arrived at these values through a lot of trial and error. Setting them any higher\n    // lets false positives creep in quickly.\n    AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;\n    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n    /**\n     * Start/end guard pattern.\n     */ AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([\n        1,\n        1,\n        1\n    ]);\n    /**\n     * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.\n     */ AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([\n        1,\n        1,\n        1,\n        1,\n        1\n    ]);\n    /**\n     * end guard pattern.\n     */ AbstractUPCEANReader.END_PATTERN = Int32Array.from([\n        1,\n        1,\n        1,\n        1,\n        1,\n        1\n    ]);\n    /**\n     * \"Odd\", or \"L\" patterns used to encode UPC/EAN digits.\n     */ AbstractUPCEANReader.L_PATTERNS = [\n        Int32Array.from([\n            3,\n            2,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            2,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            1,\n            2,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            4,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            3,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            3,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            1,\n            4\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            1,\n            2\n        ]),\n        Int32Array.from([\n            1,\n            2,\n            1,\n            3\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            1,\n            2\n        ])\n    ];\n    /**\n     * @see UPCEANExtension2Support\n     */ class UPCEANExtension5Support {\n        constructor(){\n            this.CHECK_DIGIT_ENCODINGS = [\n                0x18,\n                0x14,\n                0x12,\n                0x11,\n                0x0C,\n                0x06,\n                0x03,\n                0x0A,\n                0x09,\n                0x05\n            ];\n            this.decodeMiddleCounters = Int32Array.from([\n                0,\n                0,\n                0,\n                0\n            ]);\n            this.decodeRowStringBuffer = \"\";\n        }\n        decodeRow(rowNumber, row, extensionStartRange) {\n            let result = this.decodeRowStringBuffer;\n            let end = this.decodeMiddle(row, extensionStartRange, result);\n            let resultString = result.toString();\n            let extensionData = UPCEANExtension5Support.parseExtensionString(resultString);\n            let resultPoints = [\n                new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),\n                new ResultPoint(end, rowNumber)\n            ];\n            let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, new Date().getTime());\n            if (extensionData != null) {\n                extensionResult.putAllMetadata(extensionData);\n            }\n            return extensionResult;\n        }\n        decodeMiddle(row, startRange, resultString) {\n            let counters = this.decodeMiddleCounters;\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let end = row.getSize();\n            let rowOffset = startRange[1];\n            let lgPatternFound = 0;\n            for(let x = 0; x < 5 && rowOffset < end; x++){\n                let bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);\n                resultString += String.fromCharCode(\"0\".charCodeAt(0) + bestMatch % 10);\n                for (let counter of counters){\n                    rowOffset += counter;\n                }\n                if (bestMatch >= 10) {\n                    lgPatternFound |= 1 << 4 - x;\n                }\n                if (x !== 4) {\n                    // Read off separator if not last\n                    rowOffset = row.getNextSet(rowOffset);\n                    rowOffset = row.getNextUnset(rowOffset);\n                }\n            }\n            if (resultString.length !== 5) {\n                throw new NotFoundException();\n            }\n            let checkDigit = this.determineCheckDigit(lgPatternFound);\n            if (UPCEANExtension5Support.extensionChecksum(resultString.toString()) !== checkDigit) {\n                throw new NotFoundException();\n            }\n            return rowOffset;\n        }\n        static extensionChecksum(s) {\n            let length = s.length;\n            let sum = 0;\n            for(let i = length - 2; i >= 0; i -= 2){\n                sum += s.charAt(i).charCodeAt(0) - \"0\".charCodeAt(0);\n            }\n            sum *= 3;\n            for(let i = length - 1; i >= 0; i -= 2){\n                sum += s.charAt(i).charCodeAt(0) - \"0\".charCodeAt(0);\n            }\n            sum *= 3;\n            return sum % 10;\n        }\n        determineCheckDigit(lgPatternFound) {\n            for(let d = 0; d < 10; d++){\n                if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d]) {\n                    return d;\n                }\n            }\n            throw new NotFoundException();\n        }\n        static parseExtensionString(raw) {\n            if (raw.length !== 5) {\n                return null;\n            }\n            let value = UPCEANExtension5Support.parseExtension5String(raw);\n            if (value == null) {\n                return null;\n            }\n            return new Map([\n                [\n                    ResultMetadataType$1.SUGGESTED_PRICE,\n                    value\n                ]\n            ]);\n        }\n        static parseExtension5String(raw) {\n            let currency;\n            switch(raw.charAt(0)){\n                case \"0\":\n                    currency = \"\\xa3\";\n                    break;\n                case \"5\":\n                    currency = \"$\";\n                    break;\n                case \"9\":\n                    // Reference: http://www.jollytech.com\n                    switch(raw){\n                        case \"90000\":\n                            // No suggested retail price\n                            return null;\n                        case \"99991\":\n                            // Complementary\n                            return \"0.00\";\n                        case \"99990\":\n                            return \"Used\";\n                    }\n                    // Otherwise... unknown currency?\n                    currency = \"\";\n                    break;\n                default:\n                    currency = \"\";\n                    break;\n            }\n            let rawAmount = parseInt(raw.substring(1));\n            let unitsString = (rawAmount / 100).toString();\n            let hundredths = rawAmount % 100;\n            let hundredthsString = hundredths < 10 ? \"0\" + hundredths : hundredths.toString(); // fixme\n            return currency + unitsString + \".\" + hundredthsString;\n        }\n    }\n    /**\n     * @see UPCEANExtension5Support\n     */ class UPCEANExtension2Support {\n        constructor(){\n            this.decodeMiddleCounters = Int32Array.from([\n                0,\n                0,\n                0,\n                0\n            ]);\n            this.decodeRowStringBuffer = \"\";\n        }\n        decodeRow(rowNumber, row, extensionStartRange) {\n            let result = this.decodeRowStringBuffer;\n            let end = this.decodeMiddle(row, extensionStartRange, result);\n            let resultString = result.toString();\n            let extensionData = UPCEANExtension2Support.parseExtensionString(resultString);\n            let resultPoints = [\n                new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),\n                new ResultPoint(end, rowNumber)\n            ];\n            let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, new Date().getTime());\n            if (extensionData != null) {\n                extensionResult.putAllMetadata(extensionData);\n            }\n            return extensionResult;\n        }\n        decodeMiddle(row, startRange, resultString) {\n            let counters = this.decodeMiddleCounters;\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let end = row.getSize();\n            let rowOffset = startRange[1];\n            let checkParity = 0;\n            for(let x = 0; x < 2 && rowOffset < end; x++){\n                let bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);\n                resultString += String.fromCharCode(\"0\".charCodeAt(0) + bestMatch % 10);\n                for (let counter of counters){\n                    rowOffset += counter;\n                }\n                if (bestMatch >= 10) {\n                    checkParity |= 1 << 1 - x;\n                }\n                if (x !== 1) {\n                    // Read off separator if not last\n                    rowOffset = row.getNextSet(rowOffset);\n                    rowOffset = row.getNextUnset(rowOffset);\n                }\n            }\n            if (resultString.length !== 2) {\n                throw new NotFoundException();\n            }\n            if (parseInt(resultString.toString()) % 4 !== checkParity) {\n                throw new NotFoundException();\n            }\n            return rowOffset;\n        }\n        static parseExtensionString(raw) {\n            if (raw.length !== 2) {\n                return null;\n            }\n            return new Map([\n                [\n                    ResultMetadataType$1.ISSUE_NUMBER,\n                    parseInt(raw)\n                ]\n            ]);\n        }\n    }\n    class UPCEANExtensionSupport {\n        static decodeRow(rowNumber, row, rowOffset) {\n            let extensionStartRange = AbstractUPCEANReader.findGuardPattern(row, rowOffset, false, this.EXTENSION_START_PATTERN, new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0));\n            try {\n                // return null;\n                let fiveSupport = new UPCEANExtension5Support();\n                return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);\n            } catch (err) {\n                // return null;\n                let twoSupport = new UPCEANExtension2Support();\n                return twoSupport.decodeRow(rowNumber, row, extensionStartRange);\n            }\n        }\n    }\n    UPCEANExtensionSupport.EXTENSION_START_PATTERN = Int32Array.from([\n        1,\n        1,\n        2\n    ]);\n    /**\n     * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n     * of one-dimensional barcodes.</p>\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     * @author alasdair@google.com (Alasdair Mackintosh)\n     */ class UPCEANReader extends AbstractUPCEANReader {\n        constructor(){\n            super();\n            this.decodeRowStringBuffer = \"\";\n            UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map((arr)=>Int32Array.from(arr));\n            for(let i = 10; i < 20; i++){\n                let widths = UPCEANReader.L_PATTERNS[i - 10];\n                let reversedWidths = new Int32Array(widths.length);\n                for(let j = 0; j < widths.length; j++){\n                    reversedWidths[j] = widths[widths.length - j - 1];\n                }\n                UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;\n            }\n        }\n        decodeRow(rowNumber, row, hints) {\n            let startGuardRange = UPCEANReader.findStartGuardPattern(row);\n            let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n            if (resultPointCallback != null) {\n                const resultPoint = new ResultPoint((startGuardRange[0] + startGuardRange[1]) / 2.0, rowNumber);\n                resultPointCallback.foundPossibleResultPoint(resultPoint);\n            }\n            let budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);\n            let endStart = budello.rowOffset;\n            let result = budello.resultString;\n            if (resultPointCallback != null) {\n                const resultPoint = new ResultPoint(endStart, rowNumber);\n                resultPointCallback.foundPossibleResultPoint(resultPoint);\n            }\n            let endRange = this.decodeEnd(row, endStart);\n            if (resultPointCallback != null) {\n                const resultPoint = new ResultPoint((endRange[0] + endRange[1]) / 2.0, rowNumber);\n                resultPointCallback.foundPossibleResultPoint(resultPoint);\n            }\n            // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The\n            // spec might want more whitespace, but in practice this is the maximum we can count on.\n            let end = endRange[1];\n            let quietEnd = end + (end - endRange[0]);\n            if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {\n                throw new NotFoundException();\n            }\n            let resultString = result.toString();\n            // UPC/EAN should never be less than 8 chars anyway\n            if (resultString.length < 8) {\n                throw new FormatException();\n            }\n            if (!UPCEANReader.checkChecksum(resultString)) {\n                throw new ChecksumException();\n            }\n            let left = (startGuardRange[1] + startGuardRange[0]) / 2.0;\n            let right = (endRange[1] + endRange[0]) / 2.0;\n            let format = this.getBarcodeFormat();\n            let resultPoint = [\n                new ResultPoint(left, rowNumber),\n                new ResultPoint(right, rowNumber)\n            ];\n            let decodeResult = new Result(resultString, null, 0, resultPoint, format, new Date().getTime());\n            let extensionLength = 0;\n            try {\n                let extensionResult = UPCEANExtensionSupport.decodeRow(rowNumber, row, endRange[1]);\n                decodeResult.putMetadata(ResultMetadataType$1.UPC_EAN_EXTENSION, extensionResult.getText());\n                decodeResult.putAllMetadata(extensionResult.getResultMetadata());\n                decodeResult.addResultPoints(extensionResult.getResultPoints());\n                extensionLength = extensionResult.getText().length;\n            } catch (ignoreError) {}\n            let allowedExtensions = hints == null ? null : hints.get(DecodeHintType$1.ALLOWED_EAN_EXTENSIONS);\n            if (allowedExtensions != null) {\n                let valid = false;\n                for(let length in allowedExtensions){\n                    if (extensionLength.toString() === length) {\n                        valid = true;\n                        break;\n                    }\n                }\n                if (!valid) {\n                    throw new NotFoundException();\n                }\n            }\n            return decodeResult;\n        }\n        decodeEnd(row, endStart) {\n            return UPCEANReader.findGuardPattern(row, endStart, false, UPCEANReader.START_END_PATTERN, new Int32Array(UPCEANReader.START_END_PATTERN.length).fill(0));\n        }\n        static checkChecksum(s) {\n            return UPCEANReader.checkStandardUPCEANChecksum(s);\n        }\n        static checkStandardUPCEANChecksum(s) {\n            let length = s.length;\n            if (length === 0) return false;\n            let check = parseInt(s.charAt(length - 1), 10);\n            return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n        }\n        static getStandardUPCEANChecksum(s) {\n            let length = s.length;\n            let sum = 0;\n            for(let i = length - 1; i >= 0; i -= 2){\n                let digit = s.charAt(i).charCodeAt(0) - \"0\".charCodeAt(0);\n                if (digit < 0 || digit > 9) {\n                    throw new FormatException();\n                }\n                sum += digit;\n            }\n            sum *= 3;\n            for(let i = length - 2; i >= 0; i -= 2){\n                let digit = s.charAt(i).charCodeAt(0) - \"0\".charCodeAt(0);\n                if (digit < 0 || digit > 9) {\n                    throw new FormatException();\n                }\n                sum += digit;\n            }\n            return (1000 - sum) % 10;\n        }\n    }\n    /**\n     * <p>Implements decoding of the EAN-13 format.</p>\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     * @author alasdair@google.com (Alasdair Mackintosh)\n     */ class EAN13Reader extends UPCEANReader {\n        constructor(){\n            super();\n            this.decodeMiddleCounters = Int32Array.from([\n                0,\n                0,\n                0,\n                0\n            ]);\n        }\n        decodeMiddle(row, startRange, resultString) {\n            let counters = this.decodeMiddleCounters;\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let end = row.getSize();\n            let rowOffset = startRange[1];\n            let lgPatternFound = 0;\n            for(let x = 0; x < 6 && rowOffset < end; x++){\n                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_AND_G_PATTERNS);\n                resultString += String.fromCharCode(\"0\".charCodeAt(0) + bestMatch % 10);\n                for (let counter of counters){\n                    rowOffset += counter;\n                }\n                if (bestMatch >= 10) {\n                    lgPatternFound |= 1 << 5 - x;\n                }\n            }\n            resultString = EAN13Reader.determineFirstDigit(resultString, lgPatternFound);\n            let middleRange = UPCEANReader.findGuardPattern(row, rowOffset, true, UPCEANReader.MIDDLE_PATTERN, new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));\n            rowOffset = middleRange[1];\n            for(let x = 0; x < 6 && rowOffset < end; x++){\n                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);\n                resultString += String.fromCharCode(\"0\".charCodeAt(0) + bestMatch);\n                for (let counter of counters){\n                    rowOffset += counter;\n                }\n            }\n            return {\n                rowOffset,\n                resultString\n            };\n        }\n        getBarcodeFormat() {\n            return BarcodeFormat$1.EAN_13;\n        }\n        static determineFirstDigit(resultString, lgPatternFound) {\n            for(let d = 0; d < 10; d++){\n                if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d]) {\n                    resultString = String.fromCharCode(\"0\".charCodeAt(0) + d) + resultString;\n                    return resultString;\n                }\n            }\n            throw new NotFoundException();\n        }\n    }\n    EAN13Reader.FIRST_DIGIT_ENCODINGS = [\n        0x00,\n        0x0B,\n        0x0D,\n        0xE,\n        0x13,\n        0x19,\n        0x1C,\n        0x15,\n        0x16,\n        0x1A\n    ];\n    /**\n     * <p>Implements decoding of the EAN-8 format.</p>\n     *\n     * @author Sean Owen\n     */ class EAN8Reader extends UPCEANReader {\n        constructor(){\n            super();\n            this.decodeMiddleCounters = Int32Array.from([\n                0,\n                0,\n                0,\n                0\n            ]);\n        }\n        decodeMiddle(row, startRange, resultString) {\n            const counters = this.decodeMiddleCounters;\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let end = row.getSize();\n            let rowOffset = startRange[1];\n            for(let x = 0; x < 4 && rowOffset < end; x++){\n                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);\n                resultString += String.fromCharCode(\"0\".charCodeAt(0) + bestMatch);\n                for (let counter of counters){\n                    rowOffset += counter;\n                }\n            }\n            let middleRange = UPCEANReader.findGuardPattern(row, rowOffset, true, UPCEANReader.MIDDLE_PATTERN, new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));\n            rowOffset = middleRange[1];\n            for(let x = 0; x < 4 && rowOffset < end; x++){\n                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);\n                resultString += String.fromCharCode(\"0\".charCodeAt(0) + bestMatch);\n                for (let counter of counters){\n                    rowOffset += counter;\n                }\n            }\n            return {\n                rowOffset,\n                resultString\n            };\n        }\n        getBarcodeFormat() {\n            return BarcodeFormat$1.EAN_8;\n        }\n    }\n    /**\n     * Encapsulates functionality and implementation that is common to all families\n     * of one-dimensional barcodes.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     * @author sam2332 (Sam Rudloff)\n     *\n     * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCAReader.java\n     *\n     * @experimental\n     */ class UPCAReader extends UPCEANReader {\n        constructor(){\n            super(...arguments);\n            this.ean13Reader = new EAN13Reader();\n        }\n        // @Override\n        getBarcodeFormat() {\n            return BarcodeFormat$1.UPC_A;\n        }\n        // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n        // @Override\n        decode(image, hints) {\n            return this.maybeReturnResult(this.ean13Reader.decode(image));\n        }\n        // @Override\n        decodeRow(rowNumber, row, hints) {\n            return this.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber, row, hints));\n        }\n        // @Override\n        decodeMiddle(row, startRange, resultString) {\n            return this.ean13Reader.decodeMiddle(row, startRange, resultString);\n        }\n        maybeReturnResult(result) {\n            let text = result.getText();\n            if (text.charAt(0) === \"0\") {\n                let upcaResult = new Result(text.substring(1), null, null, result.getResultPoints(), BarcodeFormat$1.UPC_A);\n                if (result.getResultMetadata() != null) {\n                    upcaResult.putAllMetadata(result.getResultMetadata());\n                }\n                return upcaResult;\n            } else {\n                throw new NotFoundException();\n            }\n        }\n        reset() {\n            this.ean13Reader.reset();\n        }\n    }\n    /**\n     * <p>Implements decoding of the UPC-E format.</p>\n     * <p><a href=\"http://www.barcodeisland.com/upce.phtml\">This</a> is a great reference for\n     * UPC-E information.</p>\n     *\n     * @author Sean Owen\n     *\n     * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCEReader.java\n     *\n     * @experimental\n     */ /* final */ class UPCEReader extends UPCEANReader {\n        constructor(){\n            super();\n            this.decodeMiddleCounters = new Int32Array(4);\n        }\n        /**\n         * @throws NotFoundException\n         */ // @Override\n        decodeMiddle(row, startRange, result) {\n            const counters = this.decodeMiddleCounters.map((x)=>x);\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            const end = row.getSize();\n            let rowOffset = startRange[1];\n            let lgPatternFound = 0;\n            for(let x = 0; x < 6 && rowOffset < end; x++){\n                const bestMatch = UPCEReader.decodeDigit(row, counters, rowOffset, UPCEReader.L_AND_G_PATTERNS);\n                result += String.fromCharCode(\"0\".charCodeAt(0) + bestMatch % 10);\n                for (let counter of counters){\n                    rowOffset += counter;\n                }\n                if (bestMatch >= 10) {\n                    lgPatternFound |= 1 << 5 - x;\n                }\n            }\n            let resultString = UPCEReader.determineNumSysAndCheckDigit(result, lgPatternFound);\n            return {\n                rowOffset,\n                resultString\n            };\n        }\n        /**\n         * @throws NotFoundException\n         */ // @Override\n        decodeEnd(row, endStart) {\n            return UPCEReader.findGuardPatternWithoutCounters(row, endStart, true, UPCEReader.MIDDLE_END_PATTERN);\n        }\n        /**\n         * @throws FormatException\n         */ // @Override\n        checkChecksum(s) {\n            return UPCEANReader.checkChecksum(UPCEReader.convertUPCEtoUPCA(s));\n        }\n        /**\n         * @throws NotFoundException\n         */ static determineNumSysAndCheckDigit(resultString, lgPatternFound) {\n            for(let numSys = 0; numSys <= 1; numSys++){\n                for(let d = 0; d < 10; d++){\n                    if (lgPatternFound === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d]) {\n                        let prefix = String.fromCharCode(\"0\".charCodeAt(0) + numSys);\n                        let suffix = String.fromCharCode(\"0\".charCodeAt(0) + d);\n                        return prefix + resultString + suffix;\n                    }\n                }\n            }\n            throw NotFoundException.getNotFoundInstance();\n        }\n        // @Override\n        getBarcodeFormat() {\n            return BarcodeFormat$1.UPC_E;\n        }\n        /**\n         * Expands a UPC-E value back into its full, equivalent UPC-A code value.\n         *\n         * @param upce UPC-E code as string of digits\n         * @return equivalent UPC-A code as string of digits\n         */ static convertUPCEtoUPCA(upce) {\n            // the following line is equivalent to upce.getChars(1, 7, upceChars, 0);\n            const upceChars = upce.slice(1, 7).split(\"\").map((x)=>x.charCodeAt(0));\n            const result = new StringBuilder();\n            result.append(upce.charAt(0));\n            let lastChar = upceChars[5];\n            switch(lastChar){\n                case 0:\n                case 1:\n                case 2:\n                    result.appendChars(upceChars, 0, 2);\n                    result.append(lastChar);\n                    result.append(\"0000\");\n                    result.appendChars(upceChars, 2, 3);\n                    break;\n                case 3:\n                    result.appendChars(upceChars, 0, 3);\n                    result.append(\"00000\");\n                    result.appendChars(upceChars, 3, 2);\n                    break;\n                case 4:\n                    result.appendChars(upceChars, 0, 4);\n                    result.append(\"00000\");\n                    result.append(upceChars[4]);\n                    break;\n                default:\n                    result.appendChars(upceChars, 0, 5);\n                    result.append(\"0000\");\n                    result.append(lastChar);\n                    break;\n            }\n            // Only append check digit in conversion if supplied\n            if (upce.length >= 8) {\n                result.append(upce.charAt(7));\n            }\n            return result.toString();\n        }\n    }\n    /**\n     * The pattern that marks the middle, and end, of a UPC-E pattern.\n     * There is no \"second half\" to a UPC-E barcode.\n     */ UPCEReader.MIDDLE_END_PATTERN = Int32Array.from([\n        1,\n        1,\n        1,\n        1,\n        1,\n        1\n    ]);\n    // For an UPC-E barcode, the final digit is represented by the parities used\n    // to encode the middle six digits, according to the table below.\n    //\n    //                Parity of next 6 digits\n    //    Digit   0     1     2     3     4     5\n    //       0    Even   Even  Even Odd  Odd   Odd\n    //       1    Even   Even  Odd  Even Odd   Odd\n    //       2    Even   Even  Odd  Odd  Even  Odd\n    //       3    Even   Even  Odd  Odd  Odd   Even\n    //       4    Even   Odd   Even Even Odd   Odd\n    //       5    Even   Odd   Odd  Even Even  Odd\n    //       6    Even   Odd   Odd  Odd  Even  Even\n    //       7    Even   Odd   Even Odd  Even  Odd\n    //       8    Even   Odd   Even Odd  Odd   Even\n    //       9    Even   Odd   Odd  Even Odd   Even\n    //\n    // The encoding is represented by the following array, which is a bit pattern\n    // using Odd = 0 and Even = 1. For example, 5 is represented by:\n    //\n    //              Odd Even Even Odd Odd Even\n    // in binary:\n    //                0    1    1   0   0    1   == 0x19\n    //\n    /**\n     * See {@link #L_AND_G_PATTERNS}; these values similarly represent patterns of\n     * even-odd parity encodings of digits that imply both the number system (0 or 1)\n     * used, and the check digit.\n     */ UPCEReader.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [\n        Int32Array.from([\n            0x38,\n            0x34,\n            0x32,\n            0x31,\n            0x2C,\n            0x26,\n            0x23,\n            0x2A,\n            0x29,\n            0x25\n        ]),\n        Int32Array.from([\n            0x07,\n            0x0B,\n            0x0D,\n            0x0E,\n            0x13,\n            0x19,\n            0x1C,\n            0x15,\n            0x16,\n            0x1A\n        ])\n    ];\n    /**\n     * <p>A reader that can read all available UPC/EAN formats. If a caller wants to try to\n     * read all such formats, it is most efficient to use this implementation rather than invoke\n     * individual readers.</p>\n     *\n     * @author Sean Owen\n     */ class MultiFormatUPCEANReader extends OneDReader {\n        constructor(hints){\n            super();\n            let possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);\n            let readers = [];\n            if (!isNullOrUndefined(possibleFormats)) {\n                if (possibleFormats.indexOf(BarcodeFormat$1.EAN_13) > -1) {\n                    readers.push(new EAN13Reader());\n                }\n                if (possibleFormats.indexOf(BarcodeFormat$1.UPC_A) > -1) {\n                    readers.push(new UPCAReader());\n                }\n                if (possibleFormats.indexOf(BarcodeFormat$1.EAN_8) > -1) {\n                    readers.push(new EAN8Reader());\n                }\n                if (possibleFormats.indexOf(BarcodeFormat$1.UPC_E) > -1) {\n                    readers.push(new UPCEReader());\n                }\n            } else {\n                // No hints provided.\n                readers.push(new EAN13Reader());\n                readers.push(new UPCAReader());\n                readers.push(new EAN8Reader());\n                readers.push(new UPCEReader());\n            }\n            this.readers = readers;\n        }\n        decodeRow(rowNumber, row, hints) {\n            for (let reader of this.readers){\n                try {\n                    // const result: Result = reader.decodeRow(rowNumber, row, startGuardPattern, hints);\n                    const result = reader.decodeRow(rowNumber, row, hints);\n                    // Special case: a 12-digit code encoded in UPC-A is identical to a \"0\"\n                    // followed by those 12 digits encoded as EAN-13. Each will recognize such a code,\n                    // UPC-A as a 12-digit string and EAN-13 as a 13-digit string starting with \"0\".\n                    // Individually these are correct and their readers will both read such a code\n                    // and correctly call it EAN-13, or UPC-A, respectively.\n                    //\n                    // In this case, if we've been looking for both types, we'd like to call it\n                    // a UPC-A code. But for efficiency we only run the EAN-13 decoder to also read\n                    // UPC-A. So we special case it here, and convert an EAN-13 result to a UPC-A\n                    // result if appropriate.\n                    //\n                    // But, don't return UPC-A if UPC-A was not a requested format!\n                    const ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat$1.EAN_13 && result.getText().charAt(0) === \"0\";\n                    // @SuppressWarnings(\"unchecked\")\n                    const possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);\n                    const canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat$1.UPC_A);\n                    if (ean13MayBeUPCA && canReturnUPCA) {\n                        const rawBytes = result.getRawBytes();\n                        // Transfer the metadata across\n                        const resultUPCA = new Result(result.getText().substring(1), rawBytes, rawBytes ? rawBytes.length : null, result.getResultPoints(), BarcodeFormat$1.UPC_A);\n                        resultUPCA.putAllMetadata(result.getResultMetadata());\n                        return resultUPCA;\n                    }\n                    return result;\n                } catch (err) {\n                // continue;\n                }\n            }\n            throw new NotFoundException();\n        }\n        reset() {\n            for (let reader of this.readers){\n                reader.reset();\n            }\n        }\n    }\n    // import Integer from '../../util/Integer';\n    // import Float from '../../util/Float';\n    class AbstractRSSReader extends OneDReader {\n        constructor(){\n            super();\n            this.decodeFinderCounters = new Int32Array(4);\n            this.dataCharacterCounters = new Int32Array(8);\n            this.oddRoundingErrors = new Array(4);\n            this.evenRoundingErrors = new Array(4);\n            this.oddCounts = new Array(this.dataCharacterCounters.length / 2);\n            this.evenCounts = new Array(this.dataCharacterCounters.length / 2);\n        }\n        getDecodeFinderCounters() {\n            return this.decodeFinderCounters;\n        }\n        getDataCharacterCounters() {\n            return this.dataCharacterCounters;\n        }\n        getOddRoundingErrors() {\n            return this.oddRoundingErrors;\n        }\n        getEvenRoundingErrors() {\n            return this.evenRoundingErrors;\n        }\n        getOddCounts() {\n            return this.oddCounts;\n        }\n        getEvenCounts() {\n            return this.evenCounts;\n        }\n        parseFinderValue(counters, finderPatterns) {\n            for(let value = 0; value < finderPatterns.length; value++){\n                if (OneDReader.patternMatchVariance(counters, finderPatterns[value], AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader.MAX_AVG_VARIANCE) {\n                    return value;\n                }\n            }\n            throw new NotFoundException();\n        }\n        /**\n         * @param array values to sum\n         * @return sum of values\n         * @deprecated call {@link MathUtils#sum(int[])}\n         */ static count(array) {\n            return MathUtils.sum(new Int32Array(array));\n        }\n        static increment(array, errors) {\n            let index = 0;\n            let biggestError = errors[0];\n            for(let i = 1; i < array.length; i++){\n                if (errors[i] > biggestError) {\n                    biggestError = errors[i];\n                    index = i;\n                }\n            }\n            array[index]++;\n        }\n        static decrement(array, errors) {\n            let index = 0;\n            let biggestError = errors[0];\n            for(let i = 1; i < array.length; i++){\n                if (errors[i] < biggestError) {\n                    biggestError = errors[i];\n                    index = i;\n                }\n            }\n            array[index]--;\n        }\n        static isFinderPattern(counters) {\n            let firstTwoSum = counters[0] + counters[1];\n            let sum = firstTwoSum + counters[2] + counters[3];\n            let ratio = firstTwoSum / sum;\n            if (ratio >= AbstractRSSReader.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader.MAX_FINDER_PATTERN_RATIO) {\n                // passes ratio test in spec, but see if the counts are unreasonable\n                let minCounter = Number.MAX_SAFE_INTEGER;\n                let maxCounter = Number.MIN_SAFE_INTEGER;\n                for (let counter of counters){\n                    if (counter > maxCounter) {\n                        maxCounter = counter;\n                    }\n                    if (counter < minCounter) {\n                        minCounter = counter;\n                    }\n                }\n                return maxCounter < 10 * minCounter;\n            }\n            return false;\n        }\n    }\n    AbstractRSSReader.MAX_AVG_VARIANCE = 0.2;\n    AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE = 0.45;\n    AbstractRSSReader.MIN_FINDER_PATTERN_RATIO = 9.5 / 12.0;\n    AbstractRSSReader.MAX_FINDER_PATTERN_RATIO = 12.5 / 14.0;\n    class DataCharacter {\n        constructor(value, checksumPortion){\n            this.value = value;\n            this.checksumPortion = checksumPortion;\n        }\n        getValue() {\n            return this.value;\n        }\n        getChecksumPortion() {\n            return this.checksumPortion;\n        }\n        toString() {\n            return this.value + \"(\" + this.checksumPortion + \")\";\n        }\n        equals(o) {\n            if (!(o instanceof DataCharacter)) {\n                return false;\n            }\n            const that = o;\n            return this.value === that.value && this.checksumPortion === that.checksumPortion;\n        }\n        hashCode() {\n            return this.value ^ this.checksumPortion;\n        }\n    }\n    class FinderPattern {\n        constructor(value, startEnd, start, end, rowNumber){\n            this.value = value;\n            this.startEnd = startEnd;\n            this.value = value;\n            this.startEnd = startEnd;\n            this.resultPoints = new Array();\n            this.resultPoints.push(new ResultPoint(start, rowNumber));\n            this.resultPoints.push(new ResultPoint(end, rowNumber));\n        }\n        getValue() {\n            return this.value;\n        }\n        getStartEnd() {\n            return this.startEnd;\n        }\n        getResultPoints() {\n            return this.resultPoints;\n        }\n        equals(o) {\n            if (!(o instanceof FinderPattern)) {\n                return false;\n            }\n            const that = o;\n            return this.value === that.value;\n        }\n        hashCode() {\n            return this.value;\n        }\n    }\n    /**\n     * RSS util functions.\n     */ class RSSUtils {\n        constructor(){}\n        static getRSSvalue(widths, maxWidth, noNarrow) {\n            let n = 0;\n            for (let width of widths){\n                n += width;\n            }\n            let val = 0;\n            let narrowMask = 0;\n            let elements = widths.length;\n            for(let bar = 0; bar < elements - 1; bar++){\n                let elmWidth;\n                for(elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)){\n                    let subVal = RSSUtils.combins(n - elmWidth - 1, elements - bar - 2);\n                    if (noNarrow && narrowMask === 0 && n - elmWidth - (elements - bar - 1) >= elements - bar - 1) {\n                        subVal -= RSSUtils.combins(n - elmWidth - (elements - bar), elements - bar - 2);\n                    }\n                    if (elements - bar - 1 > 1) {\n                        let lessVal = 0;\n                        for(let mxwElement = n - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--){\n                            lessVal += RSSUtils.combins(n - elmWidth - mxwElement - 1, elements - bar - 3);\n                        }\n                        subVal -= lessVal * (elements - 1 - bar);\n                    } else if (n - elmWidth > maxWidth) {\n                        subVal--;\n                    }\n                    val += subVal;\n                }\n                n -= elmWidth;\n            }\n            return val;\n        }\n        static combins(n, r) {\n            let maxDenom;\n            let minDenom;\n            if (n - r > r) {\n                minDenom = r;\n                maxDenom = n - r;\n            } else {\n                minDenom = n - r;\n                maxDenom = r;\n            }\n            let val = 1;\n            let j = 1;\n            for(let i = n; i > maxDenom; i--){\n                val *= i;\n                if (j <= minDenom) {\n                    val /= j;\n                    j++;\n                }\n            }\n            while(j <= minDenom){\n                val /= j;\n                j++;\n            }\n            return val;\n        }\n    }\n    class BitArrayBuilder {\n        static buildBitArray(pairs) {\n            let charNumber = pairs.length * 2 - 1;\n            if (pairs[pairs.length - 1].getRightChar() == null) {\n                charNumber -= 1;\n            }\n            let size = 12 * charNumber;\n            let binary = new BitArray(size);\n            let accPos = 0;\n            let firstPair = pairs[0];\n            let firstValue = firstPair.getRightChar().getValue();\n            for(let i = 11; i >= 0; --i){\n                if ((firstValue & 1 << i) != 0) {\n                    binary.set(accPos);\n                }\n                accPos++;\n            }\n            for(let i = 1; i < pairs.length; ++i){\n                let currentPair = pairs[i];\n                let leftValue = currentPair.getLeftChar().getValue();\n                for(let j = 11; j >= 0; --j){\n                    if ((leftValue & 1 << j) != 0) {\n                        binary.set(accPos);\n                    }\n                    accPos++;\n                }\n                if (currentPair.getRightChar() != null) {\n                    let rightValue = currentPair.getRightChar().getValue();\n                    for(let j = 11; j >= 0; --j){\n                        if ((rightValue & 1 << j) != 0) {\n                            binary.set(accPos);\n                        }\n                        accPos++;\n                    }\n                }\n            }\n            return binary;\n        }\n    }\n    class BlockParsedResult {\n        constructor(finished, decodedInformation){\n            if (decodedInformation) {\n                this.decodedInformation = null;\n            } else {\n                this.finished = finished;\n                this.decodedInformation = decodedInformation;\n            }\n        }\n        getDecodedInformation() {\n            return this.decodedInformation;\n        }\n        isFinished() {\n            return this.finished;\n        }\n    }\n    class DecodedObject {\n        constructor(newPosition){\n            this.newPosition = newPosition;\n        }\n        getNewPosition() {\n            return this.newPosition;\n        }\n    }\n    class DecodedChar extends DecodedObject {\n        constructor(newPosition, value){\n            super(newPosition);\n            this.value = value;\n        }\n        getValue() {\n            return this.value;\n        }\n        isFNC1() {\n            return this.value === DecodedChar.FNC1;\n        }\n    }\n    DecodedChar.FNC1 = \"$\";\n    class DecodedInformation extends DecodedObject {\n        constructor(newPosition, newString, remainingValue){\n            super(newPosition);\n            if (remainingValue) {\n                this.remaining = true;\n                this.remainingValue = this.remainingValue;\n            } else {\n                this.remaining = false;\n                this.remainingValue = 0;\n            }\n            this.newString = newString;\n        }\n        getNewString() {\n            return this.newString;\n        }\n        isRemaining() {\n            return this.remaining;\n        }\n        getRemainingValue() {\n            return this.remainingValue;\n        }\n    }\n    class DecodedNumeric extends DecodedObject {\n        constructor(newPosition, firstDigit, secondDigit){\n            super(newPosition);\n            if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {\n                throw new FormatException();\n            }\n            this.firstDigit = firstDigit;\n            this.secondDigit = secondDigit;\n        }\n        getFirstDigit() {\n            return this.firstDigit;\n        }\n        getSecondDigit() {\n            return this.secondDigit;\n        }\n        getValue() {\n            return this.firstDigit * 10 + this.secondDigit;\n        }\n        isFirstDigitFNC1() {\n            return this.firstDigit === DecodedNumeric.FNC1;\n        }\n        isSecondDigitFNC1() {\n            return this.secondDigit === DecodedNumeric.FNC1;\n        }\n        isAnyFNC1() {\n            return this.firstDigit === DecodedNumeric.FNC1 || this.secondDigit === DecodedNumeric.FNC1;\n        }\n    }\n    DecodedNumeric.FNC1 = 10;\n    class FieldParser {\n        constructor(){}\n        static parseFieldsInGeneralPurpose(rawInformation) {\n            if (!rawInformation) {\n                return null;\n            }\n            // Processing 2-digit AIs\n            if (rawInformation.length < 2) {\n                throw new NotFoundException();\n            }\n            let firstTwoDigits = rawInformation.substring(0, 2);\n            for (let dataLength of FieldParser.TWO_DIGIT_DATA_LENGTH){\n                if (dataLength[0] === firstTwoDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(2, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(2, dataLength[1], rawInformation);\n                }\n            }\n            if (rawInformation.length < 3) {\n                throw new NotFoundException();\n            }\n            let firstThreeDigits = rawInformation.substring(0, 3);\n            for (let dataLength of FieldParser.THREE_DIGIT_DATA_LENGTH){\n                if (dataLength[0] === firstThreeDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(3, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(3, dataLength[1], rawInformation);\n                }\n            }\n            for (let dataLength of FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH){\n                if (dataLength[0] === firstThreeDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);\n                }\n            }\n            if (rawInformation.length < 4) {\n                throw new NotFoundException();\n            }\n            let firstFourDigits = rawInformation.substring(0, 4);\n            for (let dataLength of FieldParser.FOUR_DIGIT_DATA_LENGTH){\n                if (dataLength[0] === firstFourDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);\n                }\n            }\n            throw new NotFoundException();\n        }\n        static processFixedAI(aiSize, fieldSize, rawInformation) {\n            if (rawInformation.length < aiSize) {\n                throw new NotFoundException();\n            }\n            let ai = rawInformation.substring(0, aiSize);\n            if (rawInformation.length < aiSize + fieldSize) {\n                throw new NotFoundException();\n            }\n            let field = rawInformation.substring(aiSize, aiSize + fieldSize);\n            let remaining = rawInformation.substring(aiSize + fieldSize);\n            let result = \"(\" + ai + \")\" + field;\n            let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);\n            return parsedAI == null ? result : result + parsedAI;\n        }\n        static processVariableAI(aiSize, variableFieldSize, rawInformation) {\n            let ai = rawInformation.substring(0, aiSize);\n            let maxSize;\n            if (rawInformation.length < aiSize + variableFieldSize) {\n                maxSize = rawInformation.length;\n            } else {\n                maxSize = aiSize + variableFieldSize;\n            }\n            let field = rawInformation.substring(aiSize, maxSize);\n            let remaining = rawInformation.substring(maxSize);\n            let result = \"(\" + ai + \")\" + field;\n            let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);\n            return parsedAI == null ? result : result + parsedAI;\n        }\n    }\n    FieldParser.VARIABLE_LENGTH = [];\n    FieldParser.TWO_DIGIT_DATA_LENGTH = [\n        [\n            \"00\",\n            18\n        ],\n        [\n            \"01\",\n            14\n        ],\n        [\n            \"02\",\n            14\n        ],\n        [\n            \"10\",\n            FieldParser.VARIABLE_LENGTH,\n            20\n        ],\n        [\n            \"11\",\n            6\n        ],\n        [\n            \"12\",\n            6\n        ],\n        [\n            \"13\",\n            6\n        ],\n        [\n            \"15\",\n            6\n        ],\n        [\n            \"17\",\n            6\n        ],\n        [\n            \"20\",\n            2\n        ],\n        [\n            \"21\",\n            FieldParser.VARIABLE_LENGTH,\n            20\n        ],\n        [\n            \"22\",\n            FieldParser.VARIABLE_LENGTH,\n            29\n        ],\n        [\n            \"30\",\n            FieldParser.VARIABLE_LENGTH,\n            8\n        ],\n        [\n            \"37\",\n            FieldParser.VARIABLE_LENGTH,\n            8\n        ],\n        // internal company codes\n        [\n            \"90\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"91\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"92\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"93\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"94\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"95\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"96\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"97\",\n            FieldParser.VARIABLE_LENGTH,\n            3\n        ],\n        [\n            \"98\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"99\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ]\n    ];\n    FieldParser.THREE_DIGIT_DATA_LENGTH = [\n        // Same format as above\n        [\n            \"240\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"241\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"242\",\n            FieldParser.VARIABLE_LENGTH,\n            6\n        ],\n        [\n            \"250\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"251\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"253\",\n            FieldParser.VARIABLE_LENGTH,\n            17\n        ],\n        [\n            \"254\",\n            FieldParser.VARIABLE_LENGTH,\n            20\n        ],\n        [\n            \"400\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"401\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"402\",\n            17\n        ],\n        [\n            \"403\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"410\",\n            13\n        ],\n        [\n            \"411\",\n            13\n        ],\n        [\n            \"412\",\n            13\n        ],\n        [\n            \"413\",\n            13\n        ],\n        [\n            \"414\",\n            13\n        ],\n        [\n            \"420\",\n            FieldParser.VARIABLE_LENGTH,\n            20\n        ],\n        [\n            \"421\",\n            FieldParser.VARIABLE_LENGTH,\n            15\n        ],\n        [\n            \"422\",\n            3\n        ],\n        [\n            \"423\",\n            FieldParser.VARIABLE_LENGTH,\n            15\n        ],\n        [\n            \"424\",\n            3\n        ],\n        [\n            \"425\",\n            3\n        ],\n        [\n            \"426\",\n            3\n        ]\n    ];\n    FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [\n        // Same format as above\n        [\n            \"310\",\n            6\n        ],\n        [\n            \"311\",\n            6\n        ],\n        [\n            \"312\",\n            6\n        ],\n        [\n            \"313\",\n            6\n        ],\n        [\n            \"314\",\n            6\n        ],\n        [\n            \"315\",\n            6\n        ],\n        [\n            \"316\",\n            6\n        ],\n        [\n            \"320\",\n            6\n        ],\n        [\n            \"321\",\n            6\n        ],\n        [\n            \"322\",\n            6\n        ],\n        [\n            \"323\",\n            6\n        ],\n        [\n            \"324\",\n            6\n        ],\n        [\n            \"325\",\n            6\n        ],\n        [\n            \"326\",\n            6\n        ],\n        [\n            \"327\",\n            6\n        ],\n        [\n            \"328\",\n            6\n        ],\n        [\n            \"329\",\n            6\n        ],\n        [\n            \"330\",\n            6\n        ],\n        [\n            \"331\",\n            6\n        ],\n        [\n            \"332\",\n            6\n        ],\n        [\n            \"333\",\n            6\n        ],\n        [\n            \"334\",\n            6\n        ],\n        [\n            \"335\",\n            6\n        ],\n        [\n            \"336\",\n            6\n        ],\n        [\n            \"340\",\n            6\n        ],\n        [\n            \"341\",\n            6\n        ],\n        [\n            \"342\",\n            6\n        ],\n        [\n            \"343\",\n            6\n        ],\n        [\n            \"344\",\n            6\n        ],\n        [\n            \"345\",\n            6\n        ],\n        [\n            \"346\",\n            6\n        ],\n        [\n            \"347\",\n            6\n        ],\n        [\n            \"348\",\n            6\n        ],\n        [\n            \"349\",\n            6\n        ],\n        [\n            \"350\",\n            6\n        ],\n        [\n            \"351\",\n            6\n        ],\n        [\n            \"352\",\n            6\n        ],\n        [\n            \"353\",\n            6\n        ],\n        [\n            \"354\",\n            6\n        ],\n        [\n            \"355\",\n            6\n        ],\n        [\n            \"356\",\n            6\n        ],\n        [\n            \"357\",\n            6\n        ],\n        [\n            \"360\",\n            6\n        ],\n        [\n            \"361\",\n            6\n        ],\n        [\n            \"362\",\n            6\n        ],\n        [\n            \"363\",\n            6\n        ],\n        [\n            \"364\",\n            6\n        ],\n        [\n            \"365\",\n            6\n        ],\n        [\n            \"366\",\n            6\n        ],\n        [\n            \"367\",\n            6\n        ],\n        [\n            \"368\",\n            6\n        ],\n        [\n            \"369\",\n            6\n        ],\n        [\n            \"390\",\n            FieldParser.VARIABLE_LENGTH,\n            15\n        ],\n        [\n            \"391\",\n            FieldParser.VARIABLE_LENGTH,\n            18\n        ],\n        [\n            \"392\",\n            FieldParser.VARIABLE_LENGTH,\n            15\n        ],\n        [\n            \"393\",\n            FieldParser.VARIABLE_LENGTH,\n            18\n        ],\n        [\n            \"703\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ]\n    ];\n    FieldParser.FOUR_DIGIT_DATA_LENGTH = [\n        // Same format as above\n        [\n            \"7001\",\n            13\n        ],\n        [\n            \"7002\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"7003\",\n            10\n        ],\n        [\n            \"8001\",\n            14\n        ],\n        [\n            \"8002\",\n            FieldParser.VARIABLE_LENGTH,\n            20\n        ],\n        [\n            \"8003\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"8004\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"8005\",\n            6\n        ],\n        [\n            \"8006\",\n            18\n        ],\n        [\n            \"8007\",\n            FieldParser.VARIABLE_LENGTH,\n            30\n        ],\n        [\n            \"8008\",\n            FieldParser.VARIABLE_LENGTH,\n            12\n        ],\n        [\n            \"8018\",\n            18\n        ],\n        [\n            \"8020\",\n            FieldParser.VARIABLE_LENGTH,\n            25\n        ],\n        [\n            \"8100\",\n            6\n        ],\n        [\n            \"8101\",\n            10\n        ],\n        [\n            \"8102\",\n            2\n        ],\n        [\n            \"8110\",\n            FieldParser.VARIABLE_LENGTH,\n            70\n        ],\n        [\n            \"8200\",\n            FieldParser.VARIABLE_LENGTH,\n            70\n        ]\n    ];\n    class GeneralAppIdDecoder {\n        constructor(information){\n            this.buffer = new StringBuilder();\n            this.information = information;\n        }\n        decodeAllCodes(buff, initialPosition) {\n            let currentPosition = initialPosition;\n            let remaining = null;\n            do {\n                let info = this.decodeGeneralPurposeField(currentPosition, remaining);\n                let parsedFields = FieldParser.parseFieldsInGeneralPurpose(info.getNewString());\n                if (parsedFields != null) {\n                    buff.append(parsedFields);\n                }\n                if (info.isRemaining()) {\n                    remaining = \"\" + info.getRemainingValue();\n                } else {\n                    remaining = null;\n                }\n                if (currentPosition === info.getNewPosition()) {\n                    break;\n                }\n                currentPosition = info.getNewPosition();\n            }while (true);\n            return buff.toString();\n        }\n        isStillNumeric(pos) {\n            // It's numeric if it still has 7 positions\n            // and one of the first 4 bits is \"1\".\n            if (pos + 7 > this.information.getSize()) {\n                return pos + 4 <= this.information.getSize();\n            }\n            for(let i = pos; i < pos + 3; ++i){\n                if (this.information.get(i)) {\n                    return true;\n                }\n            }\n            return this.information.get(pos + 3);\n        }\n        decodeNumeric(pos) {\n            if (pos + 7 > this.information.getSize()) {\n                let numeric = this.extractNumericValueFromBitArray(pos, 4);\n                if (numeric === 0) {\n                    return new DecodedNumeric(this.information.getSize(), DecodedNumeric.FNC1, DecodedNumeric.FNC1);\n                }\n                return new DecodedNumeric(this.information.getSize(), numeric - 1, DecodedNumeric.FNC1);\n            }\n            let numeric = this.extractNumericValueFromBitArray(pos, 7);\n            let digit1 = (numeric - 8) / 11;\n            let digit2 = (numeric - 8) % 11;\n            return new DecodedNumeric(pos + 7, digit1, digit2);\n        }\n        extractNumericValueFromBitArray(pos, bits) {\n            return GeneralAppIdDecoder.extractNumericValueFromBitArray(this.information, pos, bits);\n        }\n        static extractNumericValueFromBitArray(information, pos, bits) {\n            let value = 0;\n            for(let i = 0; i < bits; ++i){\n                if (information.get(pos + i)) {\n                    value |= 1 << bits - i - 1;\n                }\n            }\n            return value;\n        }\n        decodeGeneralPurposeField(pos, remaining) {\n            // this.buffer.setLength(0);\n            this.buffer.setLengthToZero();\n            if (remaining != null) {\n                this.buffer.append(remaining);\n            }\n            this.current.setPosition(pos);\n            let lastDecoded = this.parseBlocks();\n            if (lastDecoded != null && lastDecoded.isRemaining()) {\n                return new DecodedInformation(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());\n            }\n            return new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n        }\n        parseBlocks() {\n            let isFinished;\n            let result;\n            do {\n                let initialPosition = this.current.getPosition();\n                if (this.current.isAlpha()) {\n                    result = this.parseAlphaBlock();\n                    isFinished = result.isFinished();\n                } else if (this.current.isIsoIec646()) {\n                    result = this.parseIsoIec646Block();\n                    isFinished = result.isFinished();\n                } else {\n                    result = this.parseNumericBlock();\n                    isFinished = result.isFinished();\n                }\n                let positionChanged = initialPosition !== this.current.getPosition();\n                if (!positionChanged && !isFinished) {\n                    break;\n                }\n            }while (!isFinished);\n            return result.getDecodedInformation();\n        }\n        parseNumericBlock() {\n            while(this.isStillNumeric(this.current.getPosition())){\n                let numeric = this.decodeNumeric(this.current.getPosition());\n                this.current.setPosition(numeric.getNewPosition());\n                if (numeric.isFirstDigitFNC1()) {\n                    let information;\n                    if (numeric.isSecondDigitFNC1()) {\n                        information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n                    } else {\n                        information = new DecodedInformation(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());\n                    }\n                    return new BlockParsedResult(true, information);\n                }\n                this.buffer.append(numeric.getFirstDigit());\n                if (numeric.isSecondDigitFNC1()) {\n                    let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n                    return new BlockParsedResult(true, information);\n                }\n                this.buffer.append(numeric.getSecondDigit());\n            }\n            if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {\n                this.current.setAlpha();\n                this.current.incrementPosition(4);\n            }\n            return new BlockParsedResult(false);\n        }\n        parseIsoIec646Block() {\n            while(this.isStillIsoIec646(this.current.getPosition())){\n                let iso = this.decodeIsoIec646(this.current.getPosition());\n                this.current.setPosition(iso.getNewPosition());\n                if (iso.isFNC1()) {\n                    let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n                    return new BlockParsedResult(true, information);\n                }\n                this.buffer.append(iso.getValue());\n            }\n            if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {\n                this.current.incrementPosition(3);\n                this.current.setNumeric();\n            } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {\n                if (this.current.getPosition() + 5 < this.information.getSize()) {\n                    this.current.incrementPosition(5);\n                } else {\n                    this.current.setPosition(this.information.getSize());\n                }\n                this.current.setAlpha();\n            }\n            return new BlockParsedResult(false);\n        }\n        parseAlphaBlock() {\n            while(this.isStillAlpha(this.current.getPosition())){\n                let alpha = this.decodeAlphanumeric(this.current.getPosition());\n                this.current.setPosition(alpha.getNewPosition());\n                if (alpha.isFNC1()) {\n                    let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n                    return new BlockParsedResult(true, information); // end of the char block\n                }\n                this.buffer.append(alpha.getValue());\n            }\n            if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {\n                this.current.incrementPosition(3);\n                this.current.setNumeric();\n            } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {\n                if (this.current.getPosition() + 5 < this.information.getSize()) {\n                    this.current.incrementPosition(5);\n                } else {\n                    this.current.setPosition(this.information.getSize());\n                }\n                this.current.setIsoIec646();\n            }\n            return new BlockParsedResult(false);\n        }\n        isStillIsoIec646(pos) {\n            if (pos + 5 > this.information.getSize()) {\n                return false;\n            }\n            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n            if (fiveBitValue >= 5 && fiveBitValue < 16) {\n                return true;\n            }\n            if (pos + 7 > this.information.getSize()) {\n                return false;\n            }\n            let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);\n            if (sevenBitValue >= 64 && sevenBitValue < 116) {\n                return true;\n            }\n            if (pos + 8 > this.information.getSize()) {\n                return false;\n            }\n            let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);\n            return eightBitValue >= 232 && eightBitValue < 253;\n        }\n        decodeIsoIec646(pos) {\n            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n            if (fiveBitValue === 15) {\n                return new DecodedChar(pos + 5, DecodedChar.FNC1);\n            }\n            if (fiveBitValue >= 5 && fiveBitValue < 15) {\n                return new DecodedChar(pos + 5, \"0\" + (fiveBitValue - 5));\n            }\n            let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);\n            if (sevenBitValue >= 64 && sevenBitValue < 90) {\n                return new DecodedChar(pos + 7, \"\" + (sevenBitValue + 1));\n            }\n            if (sevenBitValue >= 90 && sevenBitValue < 116) {\n                return new DecodedChar(pos + 7, \"\" + (sevenBitValue + 7));\n            }\n            let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);\n            let c;\n            switch(eightBitValue){\n                case 232:\n                    c = \"!\";\n                    break;\n                case 233:\n                    c = '\"';\n                    break;\n                case 234:\n                    c = \"%\";\n                    break;\n                case 235:\n                    c = \"&\";\n                    break;\n                case 236:\n                    c = \"'\";\n                    break;\n                case 237:\n                    c = \"(\";\n                    break;\n                case 238:\n                    c = \")\";\n                    break;\n                case 239:\n                    c = \"*\";\n                    break;\n                case 240:\n                    c = \"+\";\n                    break;\n                case 241:\n                    c = \",\";\n                    break;\n                case 242:\n                    c = \"-\";\n                    break;\n                case 243:\n                    c = \".\";\n                    break;\n                case 244:\n                    c = \"/\";\n                    break;\n                case 245:\n                    c = \":\";\n                    break;\n                case 246:\n                    c = \";\";\n                    break;\n                case 247:\n                    c = \"<\";\n                    break;\n                case 248:\n                    c = \"=\";\n                    break;\n                case 249:\n                    c = \">\";\n                    break;\n                case 250:\n                    c = \"?\";\n                    break;\n                case 251:\n                    c = \"_\";\n                    break;\n                case 252:\n                    c = \" \";\n                    break;\n                default:\n                    throw new FormatException();\n            }\n            return new DecodedChar(pos + 8, c);\n        }\n        isStillAlpha(pos) {\n            if (pos + 5 > this.information.getSize()) {\n                return false;\n            }\n            // We now check if it's a valid 5-bit value (0..9 and FNC1)\n            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n            if (fiveBitValue >= 5 && fiveBitValue < 16) {\n                return true;\n            }\n            if (pos + 6 > this.information.getSize()) {\n                return false;\n            }\n            let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);\n            return sixBitValue >= 16 && sixBitValue < 63; // 63 not included\n        }\n        decodeAlphanumeric(pos) {\n            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n            if (fiveBitValue === 15) {\n                return new DecodedChar(pos + 5, DecodedChar.FNC1);\n            }\n            if (fiveBitValue >= 5 && fiveBitValue < 15) {\n                return new DecodedChar(pos + 5, \"0\" + (fiveBitValue - 5));\n            }\n            let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);\n            if (sixBitValue >= 32 && sixBitValue < 58) {\n                return new DecodedChar(pos + 6, \"\" + (sixBitValue + 33));\n            }\n            let c;\n            switch(sixBitValue){\n                case 58:\n                    c = \"*\";\n                    break;\n                case 59:\n                    c = \",\";\n                    break;\n                case 60:\n                    c = \"-\";\n                    break;\n                case 61:\n                    c = \".\";\n                    break;\n                case 62:\n                    c = \"/\";\n                    break;\n                default:\n                    throw new IllegalStateException(\"Decoding invalid alphanumeric value: \" + sixBitValue);\n            }\n            return new DecodedChar(pos + 6, c);\n        }\n        isAlphaTo646ToAlphaLatch(pos) {\n            if (pos + 1 > this.information.getSize()) {\n                return false;\n            }\n            for(let i = 0; i < 5 && i + pos < this.information.getSize(); ++i){\n                if (i === 2) {\n                    if (!this.information.get(pos + 2)) {\n                        return false;\n                    }\n                } else if (this.information.get(pos + i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        isAlphaOr646ToNumericLatch(pos) {\n            // Next is alphanumeric if there are 3 positions and they are all zeros\n            if (pos + 3 > this.information.getSize()) {\n                return false;\n            }\n            for(let i = pos; i < pos + 3; ++i){\n                if (this.information.get(i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        isNumericToAlphaNumericLatch(pos) {\n            // Next is alphanumeric if there are 4 positions and they are all zeros, or\n            // if there is a subset of this just before the end of the symbol\n            if (pos + 1 > this.information.getSize()) {\n                return false;\n            }\n            for(let i = 0; i < 4 && i + pos < this.information.getSize(); ++i){\n                if (this.information.get(pos + i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    class AbstractExpandedDecoder {\n        constructor(information){\n            this.information = information;\n            this.generalDecoder = new GeneralAppIdDecoder(information);\n        }\n        getInformation() {\n            return this.information;\n        }\n        getGeneralDecoder() {\n            return this.generalDecoder;\n        }\n    }\n    class AI01decoder extends AbstractExpandedDecoder {\n        constructor(information){\n            super(information);\n        }\n        encodeCompressedGtin(buf, currentPos) {\n            buf.append(\"(01)\");\n            let initialPosition = buf.length();\n            buf.append(\"9\");\n            this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);\n        }\n        encodeCompressedGtinWithoutAI(buf, currentPos, initialBufferPosition) {\n            for(let i = 0; i < 4; ++i){\n                let currentBlock = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i, 10);\n                if (currentBlock / 100 === 0) {\n                    buf.append(\"0\");\n                }\n                if (currentBlock / 10 === 0) {\n                    buf.append(\"0\");\n                }\n                buf.append(currentBlock);\n            }\n            AI01decoder.appendCheckDigit(buf, initialBufferPosition);\n        }\n        static appendCheckDigit(buf, currentPos) {\n            let checkDigit = 0;\n            for(let i = 0; i < 13; i++){\n                // let digit = buf.charAt(i + currentPos) - '0';\n                // To be checked\n                let digit = buf.charAt(i + currentPos).charCodeAt(0) - \"0\".charCodeAt(0);\n                checkDigit += (i & 0x01) === 0 ? 3 * digit : digit;\n            }\n            checkDigit = 10 - checkDigit % 10;\n            if (checkDigit === 10) {\n                checkDigit = 0;\n            }\n            buf.append(checkDigit);\n        }\n    }\n    AI01decoder.GTIN_SIZE = 40;\n    class AI01AndOtherAIs extends AI01decoder {\n        // the second one is the encodation method, and the other two are for the variable length\n        constructor(information){\n            super(information);\n        }\n        parseInformation() {\n            let buff = new StringBuilder();\n            buff.append(\"(01)\");\n            let initialGtinPosition = buff.length();\n            let firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs.HEADER_SIZE, 4);\n            buff.append(firstGtinDigit);\n            this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs.HEADER_SIZE + 4, initialGtinPosition);\n            return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs.HEADER_SIZE + 44);\n        }\n    }\n    AI01AndOtherAIs.HEADER_SIZE = 1 + 1 + 2; // first bit encodes the linkage flag,\n    class AnyAIDecoder extends AbstractExpandedDecoder {\n        constructor(information){\n            super(information);\n        }\n        parseInformation() {\n            let buf = new StringBuilder();\n            return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder.HEADER_SIZE);\n        }\n    }\n    AnyAIDecoder.HEADER_SIZE = 2 + 1 + 2;\n    class AI01weightDecoder extends AI01decoder {\n        constructor(information){\n            super(information);\n        }\n        encodeCompressedWeight(buf, currentPos, weightSize) {\n            let originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);\n            this.addWeightCode(buf, originalWeightNumeric);\n            let weightNumeric = this.checkWeight(originalWeightNumeric);\n            let currentDivisor = 100000;\n            for(let i = 0; i < 5; ++i){\n                if (weightNumeric / currentDivisor === 0) {\n                    buf.append(\"0\");\n                }\n                currentDivisor /= 10;\n            }\n            buf.append(weightNumeric);\n        }\n    }\n    class AI013x0xDecoder extends AI01weightDecoder {\n        constructor(information){\n            super(information);\n        }\n        parseInformation() {\n            if (this.getInformation().getSize() != AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE + AI013x0xDecoder.WEIGHT_SIZE) {\n                throw new NotFoundException();\n            }\n            let buf = new StringBuilder();\n            this.encodeCompressedGtin(buf, AI013x0xDecoder.HEADER_SIZE);\n            this.encodeCompressedWeight(buf, AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE, AI013x0xDecoder.WEIGHT_SIZE);\n            return buf.toString();\n        }\n    }\n    AI013x0xDecoder.HEADER_SIZE = 4 + 1;\n    AI013x0xDecoder.WEIGHT_SIZE = 15;\n    class AI013103decoder extends AI013x0xDecoder {\n        constructor(information){\n            super(information);\n        }\n        addWeightCode(buf, weight) {\n            buf.append(\"(3103)\");\n        }\n        checkWeight(weight) {\n            return weight;\n        }\n    }\n    class AI01320xDecoder extends AI013x0xDecoder {\n        constructor(information){\n            super(information);\n        }\n        addWeightCode(buf, weight) {\n            if (weight < 10000) {\n                buf.append(\"(3202)\");\n            } else {\n                buf.append(\"(3203)\");\n            }\n        }\n        checkWeight(weight) {\n            if (weight < 10000) {\n                return weight;\n            }\n            return weight - 10000;\n        }\n    }\n    class AI01392xDecoder extends AI01decoder {\n        constructor(information){\n            super(information);\n        }\n        parseInformation() {\n            if (this.getInformation().getSize() < AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {\n                throw new NotFoundException();\n            }\n            let buf = new StringBuilder();\n            this.encodeCompressedGtin(buf, AI01392xDecoder.HEADER_SIZE);\n            let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01392xDecoder.LAST_DIGIT_SIZE);\n            buf.append(\"(392\");\n            buf.append(lastAIdigit);\n            buf.append(\")\");\n            let decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01392xDecoder.LAST_DIGIT_SIZE, null);\n            buf.append(decodedInformation.getNewString());\n            return buf.toString();\n        }\n    }\n    AI01392xDecoder.HEADER_SIZE = 5 + 1 + 2;\n    AI01392xDecoder.LAST_DIGIT_SIZE = 2;\n    class AI01393xDecoder extends AI01decoder {\n        constructor(information){\n            super(information);\n        }\n        parseInformation() {\n            if (this.getInformation().getSize() < AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {\n                throw new NotFoundException();\n            }\n            let buf = new StringBuilder();\n            this.encodeCompressedGtin(buf, AI01393xDecoder.HEADER_SIZE);\n            let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01393xDecoder.LAST_DIGIT_SIZE);\n            buf.append(\"(393\");\n            buf.append(lastAIdigit);\n            buf.append(\")\");\n            let firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE, AI01393xDecoder.FIRST_THREE_DIGITS_SIZE);\n            if (firstThreeDigits / 100 == 0) {\n                buf.append(\"0\");\n            }\n            if (firstThreeDigits / 10 == 0) {\n                buf.append(\"0\");\n            }\n            buf.append(firstThreeDigits);\n            let generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE + AI01393xDecoder.FIRST_THREE_DIGITS_SIZE, null);\n            buf.append(generalInformation.getNewString());\n            return buf.toString();\n        }\n    }\n    AI01393xDecoder.HEADER_SIZE = 5 + 1 + 2;\n    AI01393xDecoder.LAST_DIGIT_SIZE = 2;\n    AI01393xDecoder.FIRST_THREE_DIGITS_SIZE = 10;\n    class AI013x0x1xDecoder extends AI01weightDecoder {\n        constructor(information, firstAIdigits, dateCode){\n            super(information);\n            this.dateCode = dateCode;\n            this.firstAIdigits = firstAIdigits;\n        }\n        parseInformation() {\n            if (this.getInformation().getSize() != AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE + AI013x0x1xDecoder.DATE_SIZE) {\n                throw new NotFoundException();\n            }\n            let buf = new StringBuilder();\n            this.encodeCompressedGtin(buf, AI013x0x1xDecoder.HEADER_SIZE);\n            this.encodeCompressedWeight(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE, AI013x0x1xDecoder.WEIGHT_SIZE);\n            this.encodeCompressedDate(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE);\n            return buf.toString();\n        }\n        encodeCompressedDate(buf, currentPos) {\n            let numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder.DATE_SIZE);\n            if (numericDate == 38400) {\n                return;\n            }\n            buf.append(\"(\");\n            buf.append(this.dateCode);\n            buf.append(\")\");\n            let day = numericDate % 32;\n            numericDate /= 32;\n            let month = numericDate % 12 + 1;\n            numericDate /= 12;\n            let year = numericDate;\n            if (year / 10 == 0) {\n                buf.append(\"0\");\n            }\n            buf.append(year);\n            if (month / 10 == 0) {\n                buf.append(\"0\");\n            }\n            buf.append(month);\n            if (day / 10 == 0) {\n                buf.append(\"0\");\n            }\n            buf.append(day);\n        }\n        addWeightCode(buf, weight) {\n            buf.append(\"(\");\n            buf.append(this.firstAIdigits);\n            buf.append(weight / 100000);\n            buf.append(\")\");\n        }\n        checkWeight(weight) {\n            return weight % 100000;\n        }\n    }\n    AI013x0x1xDecoder.HEADER_SIZE = 7 + 1;\n    AI013x0x1xDecoder.WEIGHT_SIZE = 20;\n    AI013x0x1xDecoder.DATE_SIZE = 16;\n    function createDecoder(information) {\n        try {\n            if (information.get(1)) {\n                return new AI01AndOtherAIs(information);\n            }\n            if (!information.get(2)) {\n                return new AnyAIDecoder(information);\n            }\n            let fourBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 4);\n            switch(fourBitEncodationMethod){\n                case 4:\n                    return new AI013103decoder(information);\n                case 5:\n                    return new AI01320xDecoder(information);\n            }\n            let fiveBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 5);\n            switch(fiveBitEncodationMethod){\n                case 12:\n                    return new AI01392xDecoder(information);\n                case 13:\n                    return new AI01393xDecoder(information);\n            }\n            let sevenBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 7);\n            switch(sevenBitEncodationMethod){\n                case 56:\n                    return new AI013x0x1xDecoder(information, \"310\", \"11\");\n                case 57:\n                    return new AI013x0x1xDecoder(information, \"320\", \"11\");\n                case 58:\n                    return new AI013x0x1xDecoder(information, \"310\", \"13\");\n                case 59:\n                    return new AI013x0x1xDecoder(information, \"320\", \"13\");\n                case 60:\n                    return new AI013x0x1xDecoder(information, \"310\", \"15\");\n                case 61:\n                    return new AI013x0x1xDecoder(information, \"320\", \"15\");\n                case 62:\n                    return new AI013x0x1xDecoder(information, \"310\", \"17\");\n                case 63:\n                    return new AI013x0x1xDecoder(information, \"320\", \"17\");\n            }\n        } catch (e) {\n            console.log(e);\n            throw new IllegalStateException(\"unknown decoder: \" + information);\n        }\n    }\n    class ExpandedPair {\n        constructor(leftChar, rightChar, finderPatter, mayBeLast){\n            this.leftchar = leftChar;\n            this.rightchar = rightChar;\n            this.finderpattern = finderPatter;\n            this.maybeLast = mayBeLast;\n        }\n        mayBeLast() {\n            return this.maybeLast;\n        }\n        getLeftChar() {\n            return this.leftchar;\n        }\n        getRightChar() {\n            return this.rightchar;\n        }\n        getFinderPattern() {\n            return this.finderpattern;\n        }\n        mustBeLast() {\n            return this.rightchar == null;\n        }\n        toString() {\n            return \"[ \" + this.leftchar + \", \" + this.rightchar + \" : \" + (this.finderpattern == null ? \"null\" : this.finderpattern.getValue()) + \" ]\";\n        }\n        static equals(o1, o2) {\n            if (!(o1 instanceof ExpandedPair)) {\n                return false;\n            }\n            return ExpandedPair.equalsOrNull(o1.leftchar, o2.leftchar) && ExpandedPair.equalsOrNull(o1.rightchar, o2.rightchar) && ExpandedPair.equalsOrNull(o1.finderpattern, o2.finderpattern);\n        }\n        static equalsOrNull(o1, o2) {\n            return o1 === null ? o2 === null : ExpandedPair.equals(o1, o2);\n        }\n        hashCode() {\n            // return ExpandedPair.hashNotNull(leftChar) ^ hashNotNull(rightChar) ^ hashNotNull(finderPattern);\n            let value = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();\n            return value;\n        }\n    }\n    class ExpandedRow {\n        constructor(pairs, rowNumber, wasReversed){\n            this.pairs = pairs;\n            this.rowNumber = rowNumber;\n            this.wasReversed = wasReversed;\n        }\n        getPairs() {\n            return this.pairs;\n        }\n        getRowNumber() {\n            return this.rowNumber;\n        }\n        isReversed() {\n            return this.wasReversed;\n        }\n        // check implementation\n        isEquivalent(otherPairs) {\n            return this.checkEqualitity(this, otherPairs);\n        }\n        // @Override\n        toString() {\n            return \"{ \" + this.pairs + \" }\";\n        }\n        /**\n         * Two rows are equal if they contain the same pairs in the same order.\n         */ // @Override\n        // check implementation\n        equals(o1, o2) {\n            if (!(o1 instanceof ExpandedRow)) {\n                return false;\n            }\n            return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;\n        }\n        checkEqualitity(pair1, pair2) {\n            if (!pair1 || !pair2) return;\n            let result;\n            pair1.forEach((e1, i)=>{\n                pair2.forEach((e2)=>{\n                    if (e1.getLeftChar().getValue() === e2.getLeftChar().getValue() && e1.getRightChar().getValue() === e2.getRightChar().getValue() && e1.getFinderPatter().getValue() === e2.getFinderPatter().getValue()) {\n                        result = true;\n                    }\n                });\n            });\n            return result;\n        }\n    }\n    // import java.util.ArrayList;\n    // import java.util.Iterator;\n    // import java.util.List;\n    // import java.util.Map;\n    // import java.util.Collections;\n    class RSSExpandedReader extends AbstractRSSReader {\n        constructor(verbose){\n            super(...arguments);\n            this.pairs = new Array(RSSExpandedReader.MAX_PAIRS);\n            this.rows = new Array();\n            this.startEnd = [\n                2\n            ];\n            this.verbose = verbose === true;\n        }\n        decodeRow(rowNumber, row, hints) {\n            // Rows can start with even pattern in case in prev rows there where odd number of patters.\n            // So lets try twice\n            // this.pairs.clear();\n            this.pairs.length = 0;\n            this.startFromEven = false;\n            try {\n                return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));\n            } catch (e) {\n                // OK\n                if (this.verbose) {\n                    console.log(e);\n                }\n            }\n            this.pairs.length = 0;\n            this.startFromEven = true;\n            return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));\n        }\n        reset() {\n            this.pairs.length = 0;\n            this.rows.length = 0;\n        }\n        // Not private for testing\n        decodeRow2pairs(rowNumber, row) {\n            let done = false;\n            while(!done){\n                try {\n                    this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));\n                } catch (error) {\n                    if (error instanceof NotFoundException) {\n                        if (!this.pairs.length) {\n                            throw new NotFoundException();\n                        }\n                        // exit this loop when retrieveNextPair() fails and throws\n                        done = true;\n                    }\n                }\n            }\n            // TODO: verify sequence of finder patterns as in checkPairSequence()\n            if (this.checkChecksum()) {\n                return this.pairs;\n            }\n            let tryStackedDecode;\n            if (this.rows.length) {\n                tryStackedDecode = true;\n            } else {\n                tryStackedDecode = false;\n            }\n            // let tryStackedDecode = !this.rows.isEmpty();\n            this.storeRow(rowNumber, false); // TODO: deal with reversed rows\n            if (tryStackedDecode) {\n                // When the image is 180-rotated, then rows are sorted in wrong direction.\n                // Try twice with both the directions.\n                let ps = this.checkRowsBoolean(false);\n                if (ps != null) {\n                    return ps;\n                }\n                ps = this.checkRowsBoolean(true);\n                if (ps != null) {\n                    return ps;\n                }\n            }\n            throw new NotFoundException();\n        }\n        // Need to Verify\n        checkRowsBoolean(reverse) {\n            // Limit number of rows we are checking\n            // We use recursive algorithm with pure complexity and don't want it to take forever\n            // Stacked barcode can have up to 11 rows, so 25 seems reasonable enough\n            if (this.rows.length > 25) {\n                this.rows.length = 0; // We will never have a chance to get result, so clear it\n                return null;\n            }\n            this.pairs.length = 0;\n            if (reverse) {\n                this.rows = this.rows.reverse();\n            // Collections.reverse(this.rows);\n            }\n            let ps = null;\n            try {\n                ps = this.checkRows(new Array(), 0);\n            } catch (e) {\n                // OK\n                if (this.verbose) {\n                    console.log(e);\n                }\n            }\n            if (reverse) {\n                this.rows = this.rows.reverse();\n            // Collections.reverse(this.rows);\n            }\n            return ps;\n        }\n        // Try to construct a valid rows sequence\n        // Recursion is used to implement backtracking\n        checkRows(collectedRows, currentRow) {\n            for(let i = currentRow; i < this.rows.length; i++){\n                let row = this.rows[i];\n                this.pairs.length = 0;\n                for (let collectedRow of collectedRows){\n                    this.pairs.push(collectedRow.getPairs());\n                }\n                this.pairs.push(row.getPairs());\n                if (!RSSExpandedReader.isValidSequence(this.pairs)) {\n                    continue;\n                }\n                if (this.checkChecksum()) {\n                    return this.pairs;\n                }\n                let rs = new Array(collectedRows);\n                rs.push(row);\n                try {\n                    // Recursion: try to add more rows\n                    return this.checkRows(rs, i + 1);\n                } catch (e) {\n                    // We failed, try the next candidate\n                    if (this.verbose) {\n                        console.log(e);\n                    }\n                }\n            }\n            throw new NotFoundException();\n        }\n        // Whether the pairs form a valid find pattern sequence,\n        // either complete or a prefix\n        static isValidSequence(pairs) {\n            for (let sequence of RSSExpandedReader.FINDER_PATTERN_SEQUENCES){\n                if (pairs.length > sequence.length) {\n                    continue;\n                }\n                let stop = true;\n                for(let j = 0; j < pairs.length; j++){\n                    if (pairs[j].getFinderPattern().getValue() != sequence[j]) {\n                        stop = false;\n                        break;\n                    }\n                }\n                if (stop) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        storeRow(rowNumber, wasReversed) {\n            // Discard if duplicate above or below; otherwise insert in order by row number.\n            let insertPos = 0;\n            let prevIsSame = false;\n            let nextIsSame = false;\n            while(insertPos < this.rows.length){\n                let erow = this.rows[insertPos];\n                if (erow.getRowNumber() > rowNumber) {\n                    nextIsSame = erow.isEquivalent(this.pairs);\n                    break;\n                }\n                prevIsSame = erow.isEquivalent(this.pairs);\n                insertPos++;\n            }\n            if (nextIsSame || prevIsSame) {\n                return;\n            }\n            // When the row was partially decoded (e.g. 2 pairs found instead of 3),\n            // it will prevent us from detecting the barcode.\n            // Try to merge partial rows\n            // Check whether the row is part of an allready detected row\n            if (RSSExpandedReader.isPartialRow(this.pairs, this.rows)) {\n                return;\n            }\n            this.rows.push(insertPos, new ExpandedRow(this.pairs, rowNumber, wasReversed));\n            this.removePartialRows(this.pairs, this.rows);\n        }\n        // Remove all the rows that contains only specified pairs\n        removePartialRows(pairs, rows) {\n            // for (Iterator<ExpandedRow> iterator = rows.iterator(); iterator.hasNext();) {\n            //   ExpandedRow r = iterator.next();\n            //   if (r.getPairs().size() == pairs.size()) {\n            //     continue;\n            //   }\n            //   boolean allFound = true;\n            //   for (ExpandedPair p : r.getPairs()) {\n            //     boolean found = false;\n            //     for (ExpandedPair pp : pairs) {\n            //       if (p.equals(pp)) {\n            //         found = true;\n            //         break;\n            //       }\n            //     }\n            //     if (!found) {\n            //       allFound = false;\n            //       break;\n            //     }\n            //   }\n            //   if (allFound) {\n            //     // 'pairs' contains all the pairs from the row 'r'\n            //     iterator.remove();\n            //   }\n            // }\n            for (let row of rows){\n                if (row.getPairs().length === pairs.length) {\n                    continue;\n                }\n                for (let p of row.getPairs()){\n                    for (let pp of pairs){\n                        if (ExpandedPair.equals(p, pp)) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        // Returns true when one of the rows already contains all the pairs\n        static isPartialRow(pairs, rows) {\n            for (let r of rows){\n                let allFound = true;\n                for (let p of pairs){\n                    let found = false;\n                    for (let pp of r.getPairs()){\n                        if (p.equals(pp)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        allFound = false;\n                        break;\n                    }\n                }\n                if (allFound) {\n                    // the row 'r' contain all the pairs from 'pairs'\n                    return true;\n                }\n            }\n            return false;\n        }\n        // Only used for unit testing\n        getRows() {\n            return this.rows;\n        }\n        // Not private for unit testing\n        static constructResult(pairs) {\n            let binary = BitArrayBuilder.buildBitArray(pairs);\n            let decoder = createDecoder(binary);\n            let resultingString = decoder.parseInformation();\n            let firstPoints = pairs[0].getFinderPattern().getResultPoints();\n            let lastPoints = pairs[pairs.length - 1].getFinderPattern().getResultPoints();\n            let points = [\n                firstPoints[0],\n                firstPoints[1],\n                lastPoints[0],\n                lastPoints[1]\n            ];\n            return new Result(resultingString, null, null, points, BarcodeFormat$1.RSS_EXPANDED, null);\n        }\n        checkChecksum() {\n            let firstPair = this.pairs.get(0);\n            let checkCharacter = firstPair.getLeftChar();\n            let firstCharacter = firstPair.getRightChar();\n            if (firstCharacter == null) {\n                return false;\n            }\n            let checksum = firstCharacter.getChecksumPortion();\n            let s = 2;\n            for(let i = 1; i < this.pairs.size(); ++i){\n                let currentPair = this.pairs.get(i);\n                checksum += currentPair.getLeftChar().getChecksumPortion();\n                s++;\n                let currentRightChar = currentPair.getRightChar();\n                if (currentRightChar != null) {\n                    checksum += currentRightChar.getChecksumPortion();\n                    s++;\n                }\n            }\n            checksum %= 211;\n            let checkCharacterValue = 211 * (s - 4) + checksum;\n            return checkCharacterValue == checkCharacter.getValue();\n        }\n        static getNextSecondBar(row, initialPos) {\n            let currentPos;\n            if (row.get(initialPos)) {\n                currentPos = row.getNextUnset(initialPos);\n                currentPos = row.getNextSet(currentPos);\n            } else {\n                currentPos = row.getNextSet(initialPos);\n                currentPos = row.getNextUnset(currentPos);\n            }\n            return currentPos;\n        }\n        // not private for testing\n        retrieveNextPair(row, previousPairs, rowNumber) {\n            let isOddPattern = previousPairs.length % 2 == 0;\n            if (this.startFromEven) {\n                isOddPattern = !isOddPattern;\n            }\n            let pattern;\n            let keepFinding = true;\n            let forcedOffset = -1;\n            do {\n                this.findNextPair(row, previousPairs, forcedOffset);\n                pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);\n                if (pattern == null) {\n                    forcedOffset = RSSExpandedReader.getNextSecondBar(row, this.startEnd[0]);\n                } else {\n                    keepFinding = false;\n                }\n            }while (keepFinding);\n            // When stacked symbol is split over multiple rows, there's no way to guess if this pair can be last or not.\n            // boolean mayBeLast = checkPairSequence(previousPairs, pattern);\n            let leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);\n            if (!this.isEmptyPair(previousPairs) && previousPairs[previousPairs.length - 1].mustBeLast()) {\n                throw new NotFoundException();\n            }\n            let rightChar;\n            try {\n                rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);\n            } catch (e) {\n                rightChar = null;\n                if (this.verbose) {\n                    console.log(e);\n                }\n            }\n            return new ExpandedPair(leftChar, rightChar, pattern, true);\n        }\n        isEmptyPair(pairs) {\n            if (pairs.length === 0) {\n                return true;\n            }\n            return false;\n        }\n        findNextPair(row, previousPairs, forcedOffset) {\n            let counters = this.getDecodeFinderCounters();\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let width = row.getSize();\n            let rowOffset;\n            if (forcedOffset >= 0) {\n                rowOffset = forcedOffset;\n            } else if (this.isEmptyPair(previousPairs)) {\n                rowOffset = 0;\n            } else {\n                let lastPair = previousPairs[previousPairs.length - 1];\n                rowOffset = lastPair.getFinderPattern().getStartEnd()[1];\n            }\n            let searchingEvenPair = previousPairs.length % 2 != 0;\n            if (this.startFromEven) {\n                searchingEvenPair = !searchingEvenPair;\n            }\n            let isWhite = false;\n            while(rowOffset < width){\n                isWhite = !row.get(rowOffset);\n                if (!isWhite) {\n                    break;\n                }\n                rowOffset++;\n            }\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            for(let x = rowOffset; x < width; x++){\n                if (row.get(x) != isWhite) {\n                    counters[counterPosition]++;\n                } else {\n                    if (counterPosition == 3) {\n                        if (searchingEvenPair) {\n                            RSSExpandedReader.reverseCounters(counters);\n                        }\n                        if (RSSExpandedReader.isFinderPattern(counters)) {\n                            this.startEnd[0] = patternStart;\n                            this.startEnd[1] = x;\n                            return;\n                        }\n                        if (searchingEvenPair) {\n                            RSSExpandedReader.reverseCounters(counters);\n                        }\n                        patternStart += counters[0] + counters[1];\n                        counters[0] = counters[2];\n                        counters[1] = counters[3];\n                        counters[2] = 0;\n                        counters[3] = 0;\n                        counterPosition--;\n                    } else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        static reverseCounters(counters) {\n            let length = counters.length;\n            for(let i = 0; i < length / 2; ++i){\n                let tmp = counters[i];\n                counters[i] = counters[length - i - 1];\n                counters[length - i - 1] = tmp;\n            }\n        }\n        parseFoundFinderPattern(row, rowNumber, oddPattern) {\n            // Actually we found elements 2-5.\n            let firstCounter;\n            let start;\n            let end;\n            if (oddPattern) {\n                // If pattern number is odd, we need to locate element 1 *before* the current block.\n                let firstElementStart = this.startEnd[0] - 1;\n                // Locate element 1\n                while(firstElementStart >= 0 && !row.get(firstElementStart)){\n                    firstElementStart--;\n                }\n                firstElementStart++;\n                firstCounter = this.startEnd[0] - firstElementStart;\n                start = firstElementStart;\n                end = this.startEnd[1];\n            } else {\n                // If pattern number is even, the pattern is reversed, so we need to locate element 1 *after* the current block.\n                start = this.startEnd[0];\n                end = row.getNextUnset(this.startEnd[1] + 1);\n                firstCounter = end - this.startEnd[1];\n            }\n            // Make 'counters' hold 1-4\n            let counters = this.getDecodeFinderCounters();\n            System.arraycopy(counters, 0, counters, 1, counters.length - 1);\n            counters[0] = firstCounter;\n            let value;\n            try {\n                value = this.parseFinderValue(counters, RSSExpandedReader.FINDER_PATTERNS);\n            } catch (e) {\n                return null;\n            }\n            // return new FinderPattern(value, new int[] { start, end }, start, end, rowNumber});\n            return new FinderPattern(value, [\n                start,\n                end\n            ], start, end, rowNumber);\n        }\n        decodeDataCharacter(row, pattern, isOddPattern, leftChar) {\n            let counters = this.getDataCharacterCounters();\n            for(let x = 0; x < counters.length; x++){\n                counters[x] = 0;\n            }\n            if (leftChar) {\n                RSSExpandedReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);\n            } else {\n                RSSExpandedReader.recordPattern(row, pattern.getStartEnd()[1], counters);\n                // reverse it\n                for(let i = 0, j = counters.length - 1; i < j; i++, j--){\n                    let temp = counters[i];\n                    counters[i] = counters[j];\n                    counters[j] = temp;\n                }\n            } // counters[] has the pixels of the module\n            let numModules = 17; // left and right data characters have all the same length\n            let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;\n            // Sanity check: element width for pattern and the character should match\n            let expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15.0;\n            if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth > 0.3) {\n                throw new NotFoundException();\n            }\n            let oddCounts = this.getOddCounts();\n            let evenCounts = this.getEvenCounts();\n            let oddRoundingErrors = this.getOddRoundingErrors();\n            let evenRoundingErrors = this.getEvenRoundingErrors();\n            for(let i = 0; i < counters.length; i++){\n                let value = 1.0 * counters[i] / elementWidth;\n                let count = value + 0.5; // Round\n                if (count < 1) {\n                    if (value < 0.3) {\n                        throw new NotFoundException();\n                    }\n                    count = 1;\n                } else if (count > 8) {\n                    if (value > 8.7) {\n                        throw new NotFoundException();\n                    }\n                    count = 8;\n                }\n                let offset = i / 2;\n                if ((i & 0x01) == 0) {\n                    oddCounts[offset] = count;\n                    oddRoundingErrors[offset] = value - count;\n                } else {\n                    evenCounts[offset] = count;\n                    evenRoundingErrors[offset] = value - count;\n                }\n            }\n            this.adjustOddEvenCounts(numModules);\n            let weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;\n            let oddSum = 0;\n            let oddChecksumPortion = 0;\n            for(let i = oddCounts.length - 1; i >= 0; i--){\n                if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {\n                    let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i];\n                    oddChecksumPortion += oddCounts[i] * weight;\n                }\n                oddSum += oddCounts[i];\n            }\n            let evenChecksumPortion = 0;\n            // int evenSum = 0;\n            for(let i = evenCounts.length - 1; i >= 0; i--){\n                if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {\n                    let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i + 1];\n                    evenChecksumPortion += evenCounts[i] * weight;\n                }\n            // evenSum += evenCounts[i];\n            }\n            let checksumPortion = oddChecksumPortion + evenChecksumPortion;\n            if ((oddSum & 0x01) != 0 || oddSum > 13 || oddSum < 4) {\n                throw new NotFoundException();\n            }\n            let group = (13 - oddSum) / 2;\n            let oddWidest = RSSExpandedReader.SYMBOL_WIDEST[group];\n            let evenWidest = 9 - oddWidest;\n            let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);\n            let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);\n            let tEven = RSSExpandedReader.EVEN_TOTAL_SUBSET[group];\n            let gSum = RSSExpandedReader.GSUM[group];\n            let value = vOdd * tEven + vEven + gSum;\n            return new DataCharacter(value, checksumPortion);\n        }\n        static isNotA1left(pattern, isOddPattern, leftChar) {\n            // A1: pattern.getValue is 0 (A), and it's an oddPattern, and it is a left char\n            return !(pattern.getValue() == 0 && isOddPattern && leftChar);\n        }\n        adjustOddEvenCounts(numModules) {\n            let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));\n            let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));\n            let incrementOdd = false;\n            let decrementOdd = false;\n            if (oddSum > 13) {\n                decrementOdd = true;\n            } else if (oddSum < 4) {\n                incrementOdd = true;\n            }\n            let incrementEven = false;\n            let decrementEven = false;\n            if (evenSum > 13) {\n                decrementEven = true;\n            } else if (evenSum < 4) {\n                incrementEven = true;\n            }\n            let mismatch = oddSum + evenSum - numModules;\n            let oddParityBad = (oddSum & 0x01) == 1;\n            let evenParityBad = (evenSum & 0x01) == 0;\n            if (mismatch == 1) {\n                if (oddParityBad) {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    decrementOdd = true;\n                } else {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    decrementEven = true;\n                }\n            } else if (mismatch == -1) {\n                if (oddParityBad) {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    incrementOdd = true;\n                } else {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    incrementEven = true;\n                }\n            } else if (mismatch == 0) {\n                if (oddParityBad) {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    // Both bad\n                    if (oddSum < evenSum) {\n                        incrementOdd = true;\n                        decrementEven = true;\n                    } else {\n                        decrementOdd = true;\n                        incrementEven = true;\n                    }\n                } else {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                // Nothing to do!\n                }\n            } else {\n                throw new NotFoundException();\n            }\n            if (incrementOdd) {\n                if (decrementOdd) {\n                    throw new NotFoundException();\n                }\n                RSSExpandedReader.increment(this.getOddCounts(), this.getOddRoundingErrors());\n            }\n            if (decrementOdd) {\n                RSSExpandedReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());\n            }\n            if (incrementEven) {\n                if (decrementEven) {\n                    throw new NotFoundException();\n                }\n                RSSExpandedReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());\n            }\n            if (decrementEven) {\n                RSSExpandedReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());\n            }\n        }\n    }\n    RSSExpandedReader.SYMBOL_WIDEST = [\n        7,\n        5,\n        4,\n        3,\n        1\n    ];\n    RSSExpandedReader.EVEN_TOTAL_SUBSET = [\n        4,\n        20,\n        52,\n        104,\n        204\n    ];\n    RSSExpandedReader.GSUM = [\n        0,\n        348,\n        1388,\n        2948,\n        3988\n    ];\n    RSSExpandedReader.FINDER_PATTERNS = [\n        Int32Array.from([\n            1,\n            8,\n            4,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            6,\n            4,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            4,\n            6,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            2,\n            8,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            6,\n            5,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            2,\n            9,\n            1\n        ]) // F\n    ];\n    RSSExpandedReader.WEIGHTS = [\n        [\n            1,\n            3,\n            9,\n            27,\n            81,\n            32,\n            96,\n            77\n        ],\n        [\n            20,\n            60,\n            180,\n            118,\n            143,\n            7,\n            21,\n            63\n        ],\n        [\n            189,\n            145,\n            13,\n            39,\n            117,\n            140,\n            209,\n            205\n        ],\n        [\n            193,\n            157,\n            49,\n            147,\n            19,\n            57,\n            171,\n            91\n        ],\n        [\n            62,\n            186,\n            136,\n            197,\n            169,\n            85,\n            44,\n            132\n        ],\n        [\n            185,\n            133,\n            188,\n            142,\n            4,\n            12,\n            36,\n            108\n        ],\n        [\n            113,\n            128,\n            173,\n            97,\n            80,\n            29,\n            87,\n            50\n        ],\n        [\n            150,\n            28,\n            84,\n            41,\n            123,\n            158,\n            52,\n            156\n        ],\n        [\n            46,\n            138,\n            203,\n            187,\n            139,\n            206,\n            196,\n            166\n        ],\n        [\n            76,\n            17,\n            51,\n            153,\n            37,\n            111,\n            122,\n            155\n        ],\n        [\n            43,\n            129,\n            176,\n            106,\n            107,\n            110,\n            119,\n            146\n        ],\n        [\n            16,\n            48,\n            144,\n            10,\n            30,\n            90,\n            59,\n            177\n        ],\n        [\n            109,\n            116,\n            137,\n            200,\n            178,\n            112,\n            125,\n            164\n        ],\n        [\n            70,\n            210,\n            208,\n            202,\n            184,\n            130,\n            179,\n            115\n        ],\n        [\n            134,\n            191,\n            151,\n            31,\n            93,\n            68,\n            204,\n            190\n        ],\n        [\n            148,\n            22,\n            66,\n            198,\n            172,\n            94,\n            71,\n            2\n        ],\n        [\n            6,\n            18,\n            54,\n            162,\n            64,\n            192,\n            154,\n            40\n        ],\n        [\n            120,\n            149,\n            25,\n            75,\n            14,\n            42,\n            126,\n            167\n        ],\n        [\n            79,\n            26,\n            78,\n            23,\n            69,\n            207,\n            199,\n            175\n        ],\n        [\n            103,\n            98,\n            83,\n            38,\n            114,\n            131,\n            182,\n            124\n        ],\n        [\n            161,\n            61,\n            183,\n            127,\n            170,\n            88,\n            53,\n            159\n        ],\n        [\n            55,\n            165,\n            73,\n            8,\n            24,\n            72,\n            5,\n            15\n        ],\n        [\n            45,\n            135,\n            194,\n            160,\n            58,\n            174,\n            100,\n            89\n        ]\n    ];\n    RSSExpandedReader.FINDER_PAT_A = 0;\n    RSSExpandedReader.FINDER_PAT_B = 1;\n    RSSExpandedReader.FINDER_PAT_C = 2;\n    RSSExpandedReader.FINDER_PAT_D = 3;\n    RSSExpandedReader.FINDER_PAT_E = 4;\n    RSSExpandedReader.FINDER_PAT_F = 5;\n    RSSExpandedReader.FINDER_PATTERN_SEQUENCES = [\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_A\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_B\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_D\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_C\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_F\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_F,\n            RSSExpandedReader.FINDER_PAT_F\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_D\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_E\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_F,\n            RSSExpandedReader.FINDER_PAT_F\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_F,\n            RSSExpandedReader.FINDER_PAT_F\n        ]\n    ];\n    RSSExpandedReader.MAX_PAIRS = 11;\n    class Pair extends DataCharacter {\n        constructor(value, checksumPortion, finderPattern){\n            super(value, checksumPortion);\n            this.count = 0;\n            this.finderPattern = finderPattern;\n        }\n        getFinderPattern() {\n            return this.finderPattern;\n        }\n        getCount() {\n            return this.count;\n        }\n        incrementCount() {\n            this.count++;\n        }\n    }\n    class RSS14Reader extends AbstractRSSReader {\n        constructor(){\n            super(...arguments);\n            this.possibleLeftPairs = [];\n            this.possibleRightPairs = [];\n        }\n        decodeRow(rowNumber, row, hints) {\n            const leftPair = this.decodePair(row, false, rowNumber, hints);\n            RSS14Reader.addOrTally(this.possibleLeftPairs, leftPair);\n            row.reverse();\n            let rightPair = this.decodePair(row, true, rowNumber, hints);\n            RSS14Reader.addOrTally(this.possibleRightPairs, rightPair);\n            row.reverse();\n            for (let left of this.possibleLeftPairs){\n                if (left.getCount() > 1) {\n                    for (let right of this.possibleRightPairs){\n                        if (right.getCount() > 1 && RSS14Reader.checkChecksum(left, right)) {\n                            return RSS14Reader.constructResult(left, right);\n                        }\n                    }\n                }\n            }\n            throw new NotFoundException();\n        }\n        static addOrTally(possiblePairs, pair) {\n            if (pair == null) {\n                return;\n            }\n            let found = false;\n            for (let other of possiblePairs){\n                if (other.getValue() === pair.getValue()) {\n                    other.incrementCount();\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                possiblePairs.push(pair);\n            }\n        }\n        reset() {\n            this.possibleLeftPairs.length = 0;\n            this.possibleRightPairs.length = 0;\n        }\n        static constructResult(leftPair, rightPair) {\n            let symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();\n            let text = new String(symbolValue).toString();\n            let buffer = new StringBuilder();\n            for(let i = 13 - text.length; i > 0; i--){\n                buffer.append(\"0\");\n            }\n            buffer.append(text);\n            let checkDigit = 0;\n            for(let i = 0; i < 13; i++){\n                let digit = buffer.charAt(i).charCodeAt(0) - \"0\".charCodeAt(0);\n                checkDigit += (i & 0x01) === 0 ? 3 * digit : digit;\n            }\n            checkDigit = 10 - checkDigit % 10;\n            if (checkDigit === 10) {\n                checkDigit = 0;\n            }\n            buffer.append(checkDigit.toString());\n            let leftPoints = leftPair.getFinderPattern().getResultPoints();\n            let rightPoints = rightPair.getFinderPattern().getResultPoints();\n            return new Result(buffer.toString(), null, 0, [\n                leftPoints[0],\n                leftPoints[1],\n                rightPoints[0],\n                rightPoints[1]\n            ], BarcodeFormat$1.RSS_14, new Date().getTime());\n        }\n        static checkChecksum(leftPair, rightPair) {\n            let checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;\n            let targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();\n            if (targetCheckValue > 72) {\n                targetCheckValue--;\n            }\n            if (targetCheckValue > 8) {\n                targetCheckValue--;\n            }\n            return checkValue === targetCheckValue;\n        }\n        decodePair(row, right, rowNumber, hints) {\n            try {\n                let startEnd = this.findFinderPattern(row, right);\n                let pattern = this.parseFoundFinderPattern(row, rowNumber, right, startEnd);\n                let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n                if (resultPointCallback != null) {\n                    let center = (startEnd[0] + startEnd[1]) / 2.0;\n                    if (right) {\n                        // row is actually reversed\n                        center = row.getSize() - 1 - center;\n                    }\n                    resultPointCallback.foundPossibleResultPoint(new ResultPoint(center, rowNumber));\n                }\n                let outside = this.decodeDataCharacter(row, pattern, true);\n                let inside = this.decodeDataCharacter(row, pattern, false);\n                return new Pair(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);\n            } catch (err) {\n                return null;\n            }\n        }\n        decodeDataCharacter(row, pattern, outsideChar) {\n            let counters = this.getDataCharacterCounters();\n            for(let x = 0; x < counters.length; x++){\n                counters[x] = 0;\n            }\n            if (outsideChar) {\n                OneDReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);\n            } else {\n                OneDReader.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);\n                // reverse it\n                for(let i = 0, j = counters.length - 1; i < j; i++, j--){\n                    let temp = counters[i];\n                    counters[i] = counters[j];\n                    counters[j] = temp;\n                }\n            }\n            let numModules = outsideChar ? 16 : 15;\n            let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;\n            let oddCounts = this.getOddCounts();\n            let evenCounts = this.getEvenCounts();\n            let oddRoundingErrors = this.getOddRoundingErrors();\n            let evenRoundingErrors = this.getEvenRoundingErrors();\n            for(let i = 0; i < counters.length; i++){\n                let value = counters[i] / elementWidth;\n                let count = Math.floor(value + 0.5);\n                if (count < 1) {\n                    count = 1;\n                } else if (count > 8) {\n                    count = 8;\n                }\n                let offset = Math.floor(i / 2);\n                if ((i & 0x01) === 0) {\n                    oddCounts[offset] = count;\n                    oddRoundingErrors[offset] = value - count;\n                } else {\n                    evenCounts[offset] = count;\n                    evenRoundingErrors[offset] = value - count;\n                }\n            }\n            this.adjustOddEvenCounts(outsideChar, numModules);\n            let oddSum = 0;\n            let oddChecksumPortion = 0;\n            for(let i = oddCounts.length - 1; i >= 0; i--){\n                oddChecksumPortion *= 9;\n                oddChecksumPortion += oddCounts[i];\n                oddSum += oddCounts[i];\n            }\n            let evenChecksumPortion = 0;\n            let evenSum = 0;\n            for(let i = evenCounts.length - 1; i >= 0; i--){\n                evenChecksumPortion *= 9;\n                evenChecksumPortion += evenCounts[i];\n                evenSum += evenCounts[i];\n            }\n            let checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;\n            if (outsideChar) {\n                if ((oddSum & 0x01) !== 0 || oddSum > 12 || oddSum < 4) {\n                    throw new NotFoundException();\n                }\n                let group = (12 - oddSum) / 2;\n                let oddWidest = RSS14Reader.OUTSIDE_ODD_WIDEST[group];\n                let evenWidest = 9 - oddWidest;\n                let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, false);\n                let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, true);\n                let tEven = RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET[group];\n                let gSum = RSS14Reader.OUTSIDE_GSUM[group];\n                return new DataCharacter(vOdd * tEven + vEven + gSum, checksumPortion);\n            } else {\n                if ((evenSum & 0x01) !== 0 || evenSum > 10 || evenSum < 4) {\n                    throw new NotFoundException();\n                }\n                let group = (10 - evenSum) / 2;\n                let oddWidest = RSS14Reader.INSIDE_ODD_WIDEST[group];\n                let evenWidest = 9 - oddWidest;\n                let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);\n                let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);\n                let tOdd = RSS14Reader.INSIDE_ODD_TOTAL_SUBSET[group];\n                let gSum = RSS14Reader.INSIDE_GSUM[group];\n                return new DataCharacter(vEven * tOdd + vOdd + gSum, checksumPortion);\n            }\n        }\n        findFinderPattern(row, rightFinderPattern) {\n            let counters = this.getDecodeFinderCounters();\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let width = row.getSize();\n            let isWhite = false;\n            let rowOffset = 0;\n            while(rowOffset < width){\n                isWhite = !row.get(rowOffset);\n                if (rightFinderPattern === isWhite) {\n                    break;\n                }\n                rowOffset++;\n            }\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            for(let x = rowOffset; x < width; x++){\n                if (row.get(x) !== isWhite) {\n                    counters[counterPosition]++;\n                } else {\n                    if (counterPosition === 3) {\n                        if (AbstractRSSReader.isFinderPattern(counters)) {\n                            return [\n                                patternStart,\n                                x\n                            ];\n                        }\n                        patternStart += counters[0] + counters[1];\n                        counters[0] = counters[2];\n                        counters[1] = counters[3];\n                        counters[2] = 0;\n                        counters[3] = 0;\n                        counterPosition--;\n                    } else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        parseFoundFinderPattern(row, rowNumber, right, startEnd) {\n            // Actually we found elements 2-5\n            let firstIsBlack = row.get(startEnd[0]);\n            let firstElementStart = startEnd[0] - 1;\n            // Locate element 1\n            while(firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)){\n                firstElementStart--;\n            }\n            firstElementStart++;\n            const firstCounter = startEnd[0] - firstElementStart;\n            // Make 'counters' hold 1-4\n            const counters = this.getDecodeFinderCounters();\n            const copy = new Int32Array(counters.length);\n            System.arraycopy(counters, 0, copy, 1, counters.length - 1);\n            copy[0] = firstCounter;\n            const value = this.parseFinderValue(copy, RSS14Reader.FINDER_PATTERNS);\n            let start = firstElementStart;\n            let end = startEnd[1];\n            if (right) {\n                // row is actually reversed\n                start = row.getSize() - 1 - start;\n                end = row.getSize() - 1 - end;\n            }\n            return new FinderPattern(value, [\n                firstElementStart,\n                startEnd[1]\n            ], start, end, rowNumber);\n        }\n        adjustOddEvenCounts(outsideChar, numModules) {\n            let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));\n            let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));\n            let incrementOdd = false;\n            let decrementOdd = false;\n            let incrementEven = false;\n            let decrementEven = false;\n            if (outsideChar) {\n                if (oddSum > 12) {\n                    decrementOdd = true;\n                } else if (oddSum < 4) {\n                    incrementOdd = true;\n                }\n                if (evenSum > 12) {\n                    decrementEven = true;\n                } else if (evenSum < 4) {\n                    incrementEven = true;\n                }\n            } else {\n                if (oddSum > 11) {\n                    decrementOdd = true;\n                } else if (oddSum < 5) {\n                    incrementOdd = true;\n                }\n                if (evenSum > 10) {\n                    decrementEven = true;\n                } else if (evenSum < 4) {\n                    incrementEven = true;\n                }\n            }\n            let mismatch = oddSum + evenSum - numModules;\n            let oddParityBad = (oddSum & 0x01) === (outsideChar ? 1 : 0);\n            let evenParityBad = (evenSum & 0x01) === 1;\n            if (mismatch === 1) {\n                if (oddParityBad) {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    decrementOdd = true;\n                } else {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    decrementEven = true;\n                }\n            } else if (mismatch === -1) {\n                if (oddParityBad) {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    incrementOdd = true;\n                } else {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    incrementEven = true;\n                }\n            } else if (mismatch === 0) {\n                if (oddParityBad) {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    // Both bad\n                    if (oddSum < evenSum) {\n                        incrementOdd = true;\n                        decrementEven = true;\n                    } else {\n                        decrementOdd = true;\n                        incrementEven = true;\n                    }\n                } else {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                // Nothing to do!\n                }\n            } else {\n                throw new NotFoundException();\n            }\n            if (incrementOdd) {\n                if (decrementOdd) {\n                    throw new NotFoundException();\n                }\n                AbstractRSSReader.increment(this.getOddCounts(), this.getOddRoundingErrors());\n            }\n            if (decrementOdd) {\n                AbstractRSSReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());\n            }\n            if (incrementEven) {\n                if (decrementEven) {\n                    throw new NotFoundException();\n                }\n                AbstractRSSReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());\n            }\n            if (decrementEven) {\n                AbstractRSSReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());\n            }\n        }\n    }\n    RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET = [\n        1,\n        10,\n        34,\n        70,\n        126\n    ];\n    RSS14Reader.INSIDE_ODD_TOTAL_SUBSET = [\n        4,\n        20,\n        48,\n        81\n    ];\n    RSS14Reader.OUTSIDE_GSUM = [\n        0,\n        161,\n        961,\n        2015,\n        2715\n    ];\n    RSS14Reader.INSIDE_GSUM = [\n        0,\n        336,\n        1036,\n        1516\n    ];\n    RSS14Reader.OUTSIDE_ODD_WIDEST = [\n        8,\n        6,\n        4,\n        3,\n        1\n    ];\n    RSS14Reader.INSIDE_ODD_WIDEST = [\n        2,\n        4,\n        6,\n        8\n    ];\n    RSS14Reader.FINDER_PATTERNS = [\n        Int32Array.from([\n            3,\n            8,\n            2,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            5,\n            5,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            3,\n            7,\n            1\n        ]),\n        Int32Array.from([\n            3,\n            1,\n            9,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            7,\n            4,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            5,\n            6,\n            1\n        ]),\n        Int32Array.from([\n            2,\n            3,\n            8,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            5,\n            7,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            3,\n            9,\n            1\n        ])\n    ];\n    /**\n     * @author Daniel Switkin <dswitkin@google.com>\n     * @author Sean Owen\n     */ class MultiFormatOneDReader extends OneDReader {\n        constructor(hints, verbose){\n            super();\n            this.readers = [];\n            this.verbose = verbose === true;\n            const possibleFormats = !hints ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);\n            const useCode39CheckDigit = hints && hints.get(DecodeHintType$1.ASSUME_CODE_39_CHECK_DIGIT) !== undefined;\n            if (possibleFormats) {\n                if (possibleFormats.includes(BarcodeFormat$1.EAN_13) || possibleFormats.includes(BarcodeFormat$1.UPC_A) || possibleFormats.includes(BarcodeFormat$1.EAN_8) || possibleFormats.includes(BarcodeFormat$1.UPC_E)) {\n                    this.readers.push(new MultiFormatUPCEANReader(hints));\n                }\n                if (possibleFormats.includes(BarcodeFormat$1.CODE_39)) {\n                    this.readers.push(new Code39Reader(useCode39CheckDigit));\n                }\n                // if (possibleFormats.includes(BarcodeFormat.CODE_93)) {\n                //    this.readers.push(new Code93Reader());\n                // }\n                if (possibleFormats.includes(BarcodeFormat$1.CODE_128)) {\n                    this.readers.push(new Code128Reader());\n                }\n                if (possibleFormats.includes(BarcodeFormat$1.ITF)) {\n                    this.readers.push(new ITFReader());\n                }\n                // if (possibleFormats.includes(BarcodeFormat.CODABAR)) {\n                //    this.readers.push(new CodaBarReader());\n                // }\n                if (possibleFormats.includes(BarcodeFormat$1.RSS_14)) {\n                    this.readers.push(new RSS14Reader());\n                }\n                if (possibleFormats.includes(BarcodeFormat$1.RSS_EXPANDED)) {\n                    this.readers.push(new RSSExpandedReader(this.verbose));\n                }\n            } else {\n                // Case when no hints were provided -> add all.\n                this.readers.push(new MultiFormatUPCEANReader(hints));\n                this.readers.push(new Code39Reader());\n                // this.readers.push(new CodaBarReader());\n                // this.readers.push(new Code93Reader());\n                this.readers.push(new MultiFormatUPCEANReader(hints));\n                this.readers.push(new Code128Reader());\n                this.readers.push(new ITFReader());\n                this.readers.push(new RSS14Reader());\n                this.readers.push(new RSSExpandedReader(this.verbose));\n            }\n        }\n        // @Override\n        decodeRow(rowNumber, row, hints) {\n            for(let i = 0; i < this.readers.length; i++){\n                try {\n                    return this.readers[i].decodeRow(rowNumber, row, hints);\n                } catch (re) {\n                // continue\n                }\n            }\n            throw new NotFoundException();\n        }\n        // @Override\n        reset() {\n            this.readers.forEach((reader)=>reader.reset());\n        }\n    }\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * Barcode reader reader to use from browser.\n     */ class BrowserBarcodeReader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserBarcodeReader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         * @param {Map<DecodeHintType, any>} hints\n         */ constructor(timeBetweenScansMillis = 500, hints){\n            super(new MultiFormatOneDReader(hints), timeBetweenScansMillis, hints);\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will\n     * use blocks of differing sizes within one version, so, this encapsulates the parameters for\n     * each set of blocks. It also holds the number of error-correction codewords per block since it\n     * will be the same across all blocks within one version.</p>\n     */ class ECBlocks {\n        constructor(ecCodewords, ecBlocks1, ecBlocks2){\n            this.ecCodewords = ecCodewords;\n            this.ecBlocks = [\n                ecBlocks1\n            ];\n            ecBlocks2 && this.ecBlocks.push(ecBlocks2);\n        }\n        getECCodewords() {\n            return this.ecCodewords;\n        }\n        getECBlocks() {\n            return this.ecBlocks;\n        }\n    }\n    /**\n     * <p>Encapsulates the parameters for one error-correction block in one symbol version.\n     * This includes the number of data codewords, and the number of times a block with these\n     * parameters is used consecutively in the Data Matrix code version's format.</p>\n     */ class ECB {\n        constructor(count, dataCodewords){\n            this.count = count;\n            this.dataCodewords = dataCodewords;\n        }\n        getCount() {\n            return this.count;\n        }\n        getDataCodewords() {\n            return this.dataCodewords;\n        }\n    }\n    /**\n     * The Version object encapsulates attributes about a particular\n     * size Data Matrix Code.\n     *\n     * @author bbrown@google.com (Brian Brown)\n     */ class Version {\n        constructor(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks){\n            this.versionNumber = versionNumber;\n            this.symbolSizeRows = symbolSizeRows;\n            this.symbolSizeColumns = symbolSizeColumns;\n            this.dataRegionSizeRows = dataRegionSizeRows;\n            this.dataRegionSizeColumns = dataRegionSizeColumns;\n            this.ecBlocks = ecBlocks;\n            // Calculate the total number of codewords\n            let total = 0;\n            const ecCodewords = ecBlocks.getECCodewords();\n            const ecbArray = ecBlocks.getECBlocks();\n            for (let ecBlock of ecbArray){\n                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);\n            }\n            this.totalCodewords = total;\n        }\n        getVersionNumber() {\n            return this.versionNumber;\n        }\n        getSymbolSizeRows() {\n            return this.symbolSizeRows;\n        }\n        getSymbolSizeColumns() {\n            return this.symbolSizeColumns;\n        }\n        getDataRegionSizeRows() {\n            return this.dataRegionSizeRows;\n        }\n        getDataRegionSizeColumns() {\n            return this.dataRegionSizeColumns;\n        }\n        getTotalCodewords() {\n            return this.totalCodewords;\n        }\n        getECBlocks() {\n            return this.ecBlocks;\n        }\n        /**\n         * <p>Deduces version information from Data Matrix dimensions.</p>\n         *\n         * @param numRows Number of rows in modules\n         * @param numColumns Number of columns in modules\n         * @return Version for a Data Matrix Code of those dimensions\n         * @throws FormatException if dimensions do correspond to a valid Data Matrix size\n         */ static getVersionForDimensions(numRows, numColumns) {\n            if ((numRows & 0x01) !== 0 || (numColumns & 0x01) !== 0) {\n                throw new FormatException();\n            }\n            for (let version of Version.VERSIONS){\n                if (version.symbolSizeRows === numRows && version.symbolSizeColumns === numColumns) {\n                    return version;\n                }\n            }\n            throw new FormatException();\n        }\n        //  @Override\n        toString() {\n            return \"\" + this.versionNumber;\n        }\n        /**\n         * See ISO 16022:2006 5.5.1 Table 7\n         */ static buildVersions() {\n            return [\n                new Version(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),\n                new Version(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),\n                new Version(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),\n                new Version(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),\n                new Version(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),\n                new Version(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),\n                new Version(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),\n                new Version(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),\n                new Version(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),\n                new Version(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),\n                new Version(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),\n                new Version(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),\n                new Version(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),\n                new Version(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),\n                new Version(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),\n                new Version(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),\n                new Version(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),\n                new Version(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),\n                new Version(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),\n                new Version(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),\n                new Version(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),\n                new Version(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),\n                new Version(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),\n                new Version(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),\n                new Version(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),\n                new Version(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),\n                new Version(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),\n                new Version(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),\n                new Version(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),\n                new Version(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))\n            ];\n        }\n    }\n    Version.VERSIONS = Version.buildVersions();\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * @author bbrown@google.com (Brian Brown)\n     */ class BitMatrixParser {\n        /**\n         * @param bitMatrix {@link BitMatrix} to parse\n         * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2\n         */ constructor(bitMatrix){\n            const dimension = bitMatrix.getHeight();\n            if (dimension < 8 || dimension > 144 || (dimension & 0x01) !== 0) {\n                throw new FormatException();\n            }\n            this.version = BitMatrixParser.readVersion(bitMatrix);\n            this.mappingBitMatrix = this.extractDataRegion(bitMatrix);\n            this.readMappingMatrix = new BitMatrix(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());\n        }\n        getVersion() {\n            return this.version;\n        }\n        /**\n         * <p>Creates the version object based on the dimension of the original bit matrix from\n         * the datamatrix code.</p>\n         *\n         * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>\n         *\n         * @param bitMatrix Original {@link BitMatrix} including alignment patterns\n         * @return {@link Version} encapsulating the Data Matrix Code's \"version\"\n         * @throws FormatException if the dimensions of the mapping matrix are not valid\n         * Data Matrix dimensions.\n         */ static readVersion(bitMatrix) {\n            const numRows = bitMatrix.getHeight();\n            const numColumns = bitMatrix.getWidth();\n            return Version.getVersionForDimensions(numRows, numColumns);\n        }\n        /**\n         * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)\n         * in the correct order in order to reconstitute the codewords bytes contained within the\n         * Data Matrix Code.</p>\n         *\n         * @return bytes encoded within the Data Matrix Code\n         * @throws FormatException if the exact number of bytes expected is not read\n         */ readCodewords() {\n            const result = new Int8Array(this.version.getTotalCodewords());\n            let resultOffset = 0;\n            let row = 4;\n            let column = 0;\n            const numRows = this.mappingBitMatrix.getHeight();\n            const numColumns = this.mappingBitMatrix.getWidth();\n            let corner1Read = false;\n            let corner2Read = false;\n            let corner3Read = false;\n            let corner4Read = false;\n            // Read all of the codewords\n            do {\n                // Check the four corner cases\n                if (row === numRows && column === 0 && !corner1Read) {\n                    result[resultOffset++] = this.readCorner1(numRows, numColumns) & 0xff;\n                    row -= 2;\n                    column += 2;\n                    corner1Read = true;\n                } else if (row === numRows - 2 && column === 0 && (numColumns & 0x03) !== 0 && !corner2Read) {\n                    result[resultOffset++] = this.readCorner2(numRows, numColumns) & 0xff;\n                    row -= 2;\n                    column += 2;\n                    corner2Read = true;\n                } else if (row === numRows + 4 && column === 2 && (numColumns & 0x07) === 0 && !corner3Read) {\n                    result[resultOffset++] = this.readCorner3(numRows, numColumns) & 0xff;\n                    row -= 2;\n                    column += 2;\n                    corner3Read = true;\n                } else if (row === numRows - 2 && column === 0 && (numColumns & 0x07) === 4 && !corner4Read) {\n                    result[resultOffset++] = this.readCorner4(numRows, numColumns) & 0xff;\n                    row -= 2;\n                    column += 2;\n                    corner4Read = true;\n                } else {\n                    // Sweep upward diagonally to the right\n                    do {\n                        if (row < numRows && column >= 0 && !this.readMappingMatrix.get(column, row)) {\n                            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n                        }\n                        row -= 2;\n                        column += 2;\n                    }while (row >= 0 && column < numColumns);\n                    row += 1;\n                    column += 3;\n                    // Sweep downward diagonally to the left\n                    do {\n                        if (row >= 0 && column < numColumns && !this.readMappingMatrix.get(column, row)) {\n                            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n                        }\n                        row += 2;\n                        column -= 2;\n                    }while (row < numRows && column >= 0);\n                    row += 3;\n                    column += 1;\n                }\n            }while (row < numRows || column < numColumns);\n            if (resultOffset !== this.version.getTotalCodewords()) {\n                throw new FormatException();\n            }\n            return result;\n        }\n        /**\n         * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>\n         *\n         * @param row Row to read in the mapping matrix\n         * @param column Column to read in the mapping matrix\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return value of the given bit in the mapping matrix\n         */ readModule(row, column, numRows, numColumns) {\n            // Adjust the row and column indices based on boundary wrapping\n            if (row < 0) {\n                row += numRows;\n                column += 4 - (numRows + 4 & 0x07);\n            }\n            if (column < 0) {\n                column += numColumns;\n                row += 4 - (numColumns + 4 & 0x07);\n            }\n            this.readMappingMatrix.set(column, row);\n            return this.mappingBitMatrix.get(column, row);\n        }\n        /**\n         * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>\n         *\n         * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>\n         *\n         * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n         * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the utah shape\n         */ readUtah(row, column, numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(row - 2, column - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row - 2, column - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row - 1, column - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row - 1, column - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row - 1, column, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row, column - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row, column - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row, column, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Reads the 8 bits of the special corner condition 1.</p>\n         *\n         * <p>See ISO 16022:2006, Figure F.3</p>\n         *\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the Corner condition 1\n         */ readCorner1(numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Reads the 8 bits of the special corner condition 2.</p>\n         *\n         * <p>See ISO 16022:2006, Figure F.4</p>\n         *\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the Corner condition 2\n         */ readCorner2(numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 4, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Reads the 8 bits of the special corner condition 3.</p>\n         *\n         * <p>See ISO 16022:2006, Figure F.5</p>\n         *\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the Corner condition 3\n         */ readCorner3(numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 3, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Reads the 8 bits of the special corner condition 4.</p>\n         *\n         * <p>See ISO 16022:2006, Figure F.6</p>\n         *\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the Corner condition 4\n         */ readCorner4(numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Extracts the data region from a {@link BitMatrix} that contains\n         * alignment patterns.</p>\n         *\n         * @param bitMatrix Original {@link BitMatrix} with alignment patterns\n         * @return BitMatrix that has the alignment patterns removed\n         */ extractDataRegion(bitMatrix) {\n            const symbolSizeRows = this.version.getSymbolSizeRows();\n            const symbolSizeColumns = this.version.getSymbolSizeColumns();\n            if (bitMatrix.getHeight() !== symbolSizeRows) {\n                throw new IllegalArgumentException(\"Dimension of bitMatrix must match the version size\");\n            }\n            const dataRegionSizeRows = this.version.getDataRegionSizeRows();\n            const dataRegionSizeColumns = this.version.getDataRegionSizeColumns();\n            const numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;\n            const numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;\n            const sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;\n            const sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;\n            const bitMatrixWithoutAlignment = new BitMatrix(sizeDataRegionColumn, sizeDataRegionRow);\n            for(let dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow){\n                const dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;\n                for(let dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn){\n                    const dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;\n                    for(let i = 0; i < dataRegionSizeRows; ++i){\n                        const readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;\n                        const writeRowOffset = dataRegionRowOffset + i;\n                        for(let j = 0; j < dataRegionSizeColumns; ++j){\n                            const readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;\n                            if (bitMatrix.get(readColumnOffset, readRowOffset)) {\n                                const writeColumnOffset = dataRegionColumnOffset + j;\n                                bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);\n                            }\n                        }\n                    }\n                }\n            }\n            return bitMatrixWithoutAlignment;\n        }\n    }\n    /**\n     * <p>Encapsulates a block of data within a Data Matrix Code. Data Matrix Codes may split their data into\n     * multiple blocks, each of which is a unit of data and error-correction codewords. Each\n     * is represented by an instance of this class.</p>\n     *\n     * @author bbrown@google.com (Brian Brown)\n     */ class DataBlock {\n        constructor(numDataCodewords, codewords){\n            this.numDataCodewords = numDataCodewords;\n            this.codewords = codewords;\n        }\n        /**\n         * <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.\n         * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This\n         * method will separate the data into original blocks.</p>\n         *\n         * @param rawCodewords bytes as read directly from the Data Matrix Code\n         * @param version version of the Data Matrix Code\n         * @return DataBlocks containing original bytes, \"de-interleaved\" from representation in the\n         *         Data Matrix Code\n         */ static getDataBlocks(rawCodewords, version) {\n            // Figure out the number and size of data blocks used by this version\n            const ecBlocks = version.getECBlocks();\n            // First count the total number of data blocks\n            let totalBlocks = 0;\n            const ecBlockArray = ecBlocks.getECBlocks();\n            for (let ecBlock of ecBlockArray){\n                totalBlocks += ecBlock.getCount();\n            }\n            // Now establish DataBlocks of the appropriate size and number of data codewords\n            const result = new Array(totalBlocks);\n            let numResultBlocks = 0;\n            for (let ecBlock of ecBlockArray){\n                for(let i = 0; i < ecBlock.getCount(); i++){\n                    const numDataCodewords = ecBlock.getDataCodewords();\n                    const numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;\n                    result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));\n                }\n            }\n            // All blocks have the same amount of data, except that the last n\n            // (where n may be 0) have 1 less byte. Figure out where these start.\n            // TODO(bbrown): There is only one case where there is a difference for Data Matrix for size 144\n            const longerBlocksTotalCodewords = result[0].codewords.length;\n            // int shorterBlocksTotalCodewords = longerBlocksTotalCodewords - 1;\n            const longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();\n            const shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;\n            // The last elements of result may be 1 element shorter for 144 matrix\n            // first fill out as many elements as all of them have minus 1\n            let rawCodewordsOffset = 0;\n            for(let i = 0; i < shorterBlocksNumDataCodewords; i++){\n                for(let j = 0; j < numResultBlocks; j++){\n                    result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\n                }\n            }\n            // Fill out the last data block in the longer ones\n            const specialVersion = version.getVersionNumber() === 24;\n            const numLongerBlocks = specialVersion ? 8 : numResultBlocks;\n            for(let j = 0; j < numLongerBlocks; j++){\n                result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];\n            }\n            // Now add in error correction blocks\n            const max = result[0].codewords.length;\n            for(let i = longerBlocksNumDataCodewords; i < max; i++){\n                for(let j = 0; j < numResultBlocks; j++){\n                    const jOffset = specialVersion ? (j + 8) % numResultBlocks : j;\n                    const iOffset = specialVersion && jOffset > 7 ? i - 1 : i;\n                    result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\n                }\n            }\n            if (rawCodewordsOffset !== rawCodewords.length) {\n                throw new IllegalArgumentException();\n            }\n            return result;\n        }\n        getNumDataCodewords() {\n            return this.numDataCodewords;\n        }\n        getCodewords() {\n            return this.codewords;\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the\n     * number of bits read is not often a multiple of 8.</p>\n     *\n     * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array\n     * it passed in, in which case all bets are off.</p>\n     *\n     * @author Sean Owen\n     */ class BitSource {\n        /**\n         * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.\n         * Bits are read within a byte from most-significant to least-significant bit.\n         */ constructor(bytes){\n            this.bytes = bytes;\n            this.byteOffset = 0;\n            this.bitOffset = 0;\n        }\n        /**\n         * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.\n         */ getBitOffset() {\n            return this.bitOffset;\n        }\n        /**\n         * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.\n         */ getByteOffset() {\n            return this.byteOffset;\n        }\n        /**\n         * @param numBits number of bits to read\n         * @return int representing the bits read. The bits will appear as the least-significant\n         *         bits of the int\n         * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available\n         */ readBits(numBits /*int*/ ) {\n            if (numBits < 1 || numBits > 32 || numBits > this.available()) {\n                throw new IllegalArgumentException(\"\" + numBits);\n            }\n            let result = 0;\n            let bitOffset = this.bitOffset;\n            let byteOffset = this.byteOffset;\n            const bytes = this.bytes;\n            // First, read remainder from current byte\n            if (bitOffset > 0) {\n                const bitsLeft = 8 - bitOffset;\n                const toRead = numBits < bitsLeft ? numBits : bitsLeft;\n                const bitsToNotRead = bitsLeft - toRead;\n                const mask = 0xFF >> 8 - toRead << bitsToNotRead;\n                result = (bytes[byteOffset] & mask) >> bitsToNotRead;\n                numBits -= toRead;\n                bitOffset += toRead;\n                if (bitOffset === 8) {\n                    bitOffset = 0;\n                    byteOffset++;\n                }\n            }\n            // Next read whole bytes\n            if (numBits > 0) {\n                while(numBits >= 8){\n                    result = result << 8 | bytes[byteOffset] & 0xFF;\n                    byteOffset++;\n                    numBits -= 8;\n                }\n                // Finally read a partial byte\n                if (numBits > 0) {\n                    const bitsToNotRead = 8 - numBits;\n                    const mask = 0xFF >> bitsToNotRead << bitsToNotRead;\n                    result = result << numBits | (bytes[byteOffset] & mask) >> bitsToNotRead;\n                    bitOffset += numBits;\n                }\n            }\n            this.bitOffset = bitOffset;\n            this.byteOffset = byteOffset;\n            return result;\n        }\n        /**\n         * @return number of bits that can be read successfully\n         */ available() {\n            return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;\n        }\n    }\n    var Mode;\n    (function(Mode) {\n        Mode[Mode[\"PAD_ENCODE\"] = 0] = \"PAD_ENCODE\";\n        Mode[Mode[\"ASCII_ENCODE\"] = 1] = \"ASCII_ENCODE\";\n        Mode[Mode[\"C40_ENCODE\"] = 2] = \"C40_ENCODE\";\n        Mode[Mode[\"TEXT_ENCODE\"] = 3] = \"TEXT_ENCODE\";\n        Mode[Mode[\"ANSIX12_ENCODE\"] = 4] = \"ANSIX12_ENCODE\";\n        Mode[Mode[\"EDIFACT_ENCODE\"] = 5] = \"EDIFACT_ENCODE\";\n        Mode[Mode[\"BASE256_ENCODE\"] = 6] = \"BASE256_ENCODE\";\n    })(Mode || (Mode = {}));\n    /**\n     * <p>Data Matrix Codes can encode text as bits in one of several modes, and can use multiple modes\n     * in one Data Matrix Code. This class decodes the bits back into text.</p>\n     *\n     * <p>See ISO 16022:2006, 5.2.1 - 5.2.9.2</p>\n     *\n     * @author bbrown@google.com (Brian Brown)\n     * @author Sean Owen\n     */ class DecodedBitStreamParser {\n        static decode(bytes) {\n            const bits = new BitSource(bytes);\n            const result = new StringBuilder();\n            const resultTrailer = new StringBuilder();\n            const byteSegments = new Array();\n            let mode = Mode.ASCII_ENCODE;\n            do {\n                if (mode === Mode.ASCII_ENCODE) {\n                    mode = this.decodeAsciiSegment(bits, result, resultTrailer);\n                } else {\n                    switch(mode){\n                        case Mode.C40_ENCODE:\n                            this.decodeC40Segment(bits, result);\n                            break;\n                        case Mode.TEXT_ENCODE:\n                            this.decodeTextSegment(bits, result);\n                            break;\n                        case Mode.ANSIX12_ENCODE:\n                            this.decodeAnsiX12Segment(bits, result);\n                            break;\n                        case Mode.EDIFACT_ENCODE:\n                            this.decodeEdifactSegment(bits, result);\n                            break;\n                        case Mode.BASE256_ENCODE:\n                            this.decodeBase256Segment(bits, result, byteSegments);\n                            break;\n                        default:\n                            throw new FormatException();\n                    }\n                    mode = Mode.ASCII_ENCODE;\n                }\n            }while (mode !== Mode.PAD_ENCODE && bits.available() > 0);\n            if (resultTrailer.length() > 0) {\n                result.append(resultTrailer.toString());\n            }\n            return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);\n        }\n        /**\n         * See ISO 16022:2006, 5.2.3 and Annex C, Table C.2\n         */ static decodeAsciiSegment(bits, result, resultTrailer) {\n            let upperShift = false;\n            do {\n                let oneByte = bits.readBits(8);\n                if (oneByte === 0) {\n                    throw new FormatException();\n                } else if (oneByte <= 128) {\n                    if (upperShift) {\n                        oneByte += 128;\n                    // upperShift = false;\n                    }\n                    result.append(String.fromCharCode(oneByte - 1));\n                    return Mode.ASCII_ENCODE;\n                } else if (oneByte === 129) {\n                    return Mode.PAD_ENCODE;\n                } else if (oneByte <= 229) {\n                    const value = oneByte - 130;\n                    if (value < 10) {\n                        result.append(\"0\");\n                    }\n                    result.append(\"\" + value);\n                } else {\n                    switch(oneByte){\n                        case 230:\n                            return Mode.C40_ENCODE;\n                        case 231:\n                            return Mode.BASE256_ENCODE;\n                        case 232:\n                            result.append(String.fromCharCode(29)); // translate as ASCII 29\n                            break;\n                        case 233:\n                        case 234:\n                            break;\n                        case 235:\n                            upperShift = true;\n                            break;\n                        case 236:\n                            result.append(\"[)>\\x1e05\\x1d\");\n                            resultTrailer.insert(0, \"\\x1e\\x04\");\n                            break;\n                        case 237:\n                            result.append(\"[)>\\x1e06\\x1d\");\n                            resultTrailer.insert(0, \"\\x1e\\x04\");\n                            break;\n                        case 238:\n                            return Mode.ANSIX12_ENCODE;\n                        case 239:\n                            return Mode.TEXT_ENCODE;\n                        case 240:\n                            return Mode.EDIFACT_ENCODE;\n                        case 241:\n                            break;\n                        default:\n                            // Not to be used in ASCII encodation\n                            // but work around encoders that end with 254, latch back to ASCII\n                            if (oneByte !== 254 || bits.available() !== 0) {\n                                throw new FormatException();\n                            }\n                            break;\n                    }\n                }\n            }while (bits.available() > 0);\n            return Mode.ASCII_ENCODE;\n        }\n        /**\n         * See ISO 16022:2006, 5.2.5 and Annex C, Table C.1\n         */ static decodeC40Segment(bits, result) {\n            // Three C40 values are encoded in a 16-bit value as\n            // (1600 * C1) + (40 * C2) + C3 + 1\n            // TODO(bbrown): The Upper Shift with C40 doesn't work in the 4 value scenario all the time\n            let upperShift = false;\n            const cValues = [];\n            let shift = 0;\n            do {\n                // If there is only one byte left then it will be encoded as ASCII\n                if (bits.available() === 8) {\n                    return;\n                }\n                const firstByte = bits.readBits(8);\n                if (firstByte === 254) {\n                    return;\n                }\n                this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n                for(let i = 0; i < 3; i++){\n                    const cValue = cValues[i];\n                    switch(shift){\n                        case 0:\n                            if (cValue < 3) {\n                                shift = cValue + 1;\n                            } else if (cValue < this.C40_BASIC_SET_CHARS.length) {\n                                const c40char = this.C40_BASIC_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                } else {\n                                    result.append(c40char);\n                                }\n                            } else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case 1:\n                            if (upperShift) {\n                                result.append(String.fromCharCode(cValue + 128));\n                                upperShift = false;\n                            } else {\n                                result.append(String.fromCharCode(cValue));\n                            }\n                            shift = 0;\n                            break;\n                        case 2:\n                            if (cValue < this.C40_SHIFT2_SET_CHARS.length) {\n                                const c40char = this.C40_SHIFT2_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                } else {\n                                    result.append(c40char);\n                                }\n                            } else {\n                                switch(cValue){\n                                    case 27:\n                                        result.append(String.fromCharCode(29)); // translate as ASCII 29\n                                        break;\n                                    case 30:\n                                        upperShift = true;\n                                        break;\n                                    default:\n                                        throw new FormatException();\n                                }\n                            }\n                            shift = 0;\n                            break;\n                        case 3:\n                            if (upperShift) {\n                                result.append(String.fromCharCode(cValue + 224));\n                                upperShift = false;\n                            } else {\n                                result.append(String.fromCharCode(cValue + 96));\n                            }\n                            shift = 0;\n                            break;\n                        default:\n                            throw new FormatException();\n                    }\n                }\n            }while (bits.available() > 0);\n        }\n        /**\n         * See ISO 16022:2006, 5.2.6 and Annex C, Table C.2\n         */ static decodeTextSegment(bits, result) {\n            // Three Text values are encoded in a 16-bit value as\n            // (1600 * C1) + (40 * C2) + C3 + 1\n            // TODO(bbrown): The Upper Shift with Text doesn't work in the 4 value scenario all the time\n            let upperShift = false;\n            let cValues = [];\n            let shift = 0;\n            do {\n                // If there is only one byte left then it will be encoded as ASCII\n                if (bits.available() === 8) {\n                    return;\n                }\n                const firstByte = bits.readBits(8);\n                if (firstByte === 254) {\n                    return;\n                }\n                this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n                for(let i = 0; i < 3; i++){\n                    const cValue = cValues[i];\n                    switch(shift){\n                        case 0:\n                            if (cValue < 3) {\n                                shift = cValue + 1;\n                            } else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {\n                                const textChar = this.TEXT_BASIC_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                } else {\n                                    result.append(textChar);\n                                }\n                            } else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case 1:\n                            if (upperShift) {\n                                result.append(String.fromCharCode(cValue + 128));\n                                upperShift = false;\n                            } else {\n                                result.append(String.fromCharCode(cValue));\n                            }\n                            shift = 0;\n                            break;\n                        case 2:\n                            // Shift 2 for Text is the same encoding as C40\n                            if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {\n                                const textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                } else {\n                                    result.append(textChar);\n                                }\n                            } else {\n                                switch(cValue){\n                                    case 27:\n                                        result.append(String.fromCharCode(29)); // translate as ASCII 29\n                                        break;\n                                    case 30:\n                                        upperShift = true;\n                                        break;\n                                    default:\n                                        throw new FormatException();\n                                }\n                            }\n                            shift = 0;\n                            break;\n                        case 3:\n                            if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {\n                                const textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                } else {\n                                    result.append(textChar);\n                                }\n                                shift = 0;\n                            } else {\n                                throw new FormatException();\n                            }\n                            break;\n                        default:\n                            throw new FormatException();\n                    }\n                }\n            }while (bits.available() > 0);\n        }\n        /**\n         * See ISO 16022:2006, 5.2.7\n         */ static decodeAnsiX12Segment(bits, result) {\n            // Three ANSI X12 values are encoded in a 16-bit value as\n            // (1600 * C1) + (40 * C2) + C3 + 1\n            const cValues = [];\n            do {\n                // If there is only one byte left then it will be encoded as ASCII\n                if (bits.available() === 8) {\n                    return;\n                }\n                const firstByte = bits.readBits(8);\n                if (firstByte === 254) {\n                    return;\n                }\n                this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n                for(let i = 0; i < 3; i++){\n                    const cValue = cValues[i];\n                    switch(cValue){\n                        case 0:\n                            result.append(\"\\r\");\n                            break;\n                        case 1:\n                            result.append(\"*\");\n                            break;\n                        case 2:\n                            result.append(\">\");\n                            break;\n                        case 3:\n                            result.append(\" \");\n                            break;\n                        default:\n                            if (cValue < 14) {\n                                result.append(String.fromCharCode(cValue + 44));\n                            } else if (cValue < 40) {\n                                result.append(String.fromCharCode(cValue + 51));\n                            } else {\n                                throw new FormatException();\n                            }\n                            break;\n                    }\n                }\n            }while (bits.available() > 0);\n        }\n        static parseTwoBytes(firstByte, secondByte, result) {\n            let fullBitValue = (firstByte << 8) + secondByte - 1;\n            let temp = Math.floor(fullBitValue / 1600);\n            result[0] = temp;\n            fullBitValue -= temp * 1600;\n            temp = Math.floor(fullBitValue / 40);\n            result[1] = temp;\n            result[2] = fullBitValue - temp * 40;\n        }\n        /**\n         * See ISO 16022:2006, 5.2.8 and Annex C Table C.3\n         */ static decodeEdifactSegment(bits, result) {\n            do {\n                // If there is only two or less bytes left then it will be encoded as ASCII\n                if (bits.available() <= 16) {\n                    return;\n                }\n                for(let i = 0; i < 4; i++){\n                    let edifactValue = bits.readBits(6);\n                    // Check for the unlatch character\n                    if (edifactValue === 0x1F) {\n                        // Read rest of byte, which should be 0, and stop\n                        const bitsLeft = 8 - bits.getBitOffset();\n                        if (bitsLeft !== 8) {\n                            bits.readBits(bitsLeft);\n                        }\n                        return;\n                    }\n                    if ((edifactValue & 0x20) === 0) {\n                        edifactValue |= 0x40; // Add a leading 01 to the 6 bit binary value\n                    }\n                    result.append(String.fromCharCode(edifactValue));\n                }\n            }while (bits.available() > 0);\n        }\n        /**\n         * See ISO 16022:2006, 5.2.9 and Annex B, B.2\n         */ static decodeBase256Segment(bits, result, byteSegments) {\n            // Figure out how long the Base 256 Segment is.\n            let codewordPosition = 1 + bits.getByteOffset(); // position is 1-indexed\n            const d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);\n            let count;\n            if (d1 === 0) {\n                count = bits.available() / 8 | 0;\n            } else if (d1 < 250) {\n                count = d1;\n            } else {\n                count = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);\n            }\n            // We're seeing NegativeArraySizeException errors from users.\n            if (count < 0) {\n                throw new FormatException();\n            }\n            const bytes = new Uint8Array(count);\n            for(let i = 0; i < count; i++){\n                // Have seen this particular error in the wild, such as at\n                // http://www.bcgen.com/demo/IDAutomationStreamingDataMatrix.aspx?MODE=3&D=Fred&PFMT=3&PT=F&X=0.3&O=0&LM=0.2\n                if (bits.available() < 8) {\n                    throw new FormatException();\n                }\n                bytes[i] = this.unrandomize255State(bits.readBits(8), codewordPosition++);\n            }\n            byteSegments.push(bytes);\n            try {\n                result.append(StringEncoding.decode(bytes, StringUtils.ISO88591));\n            } catch (uee) {\n                throw new IllegalStateException(\"Platform does not support required encoding: \" + uee.message);\n            }\n        }\n        /**\n         * See ISO 16022:2006, Annex B, B.2\n         */ static unrandomize255State(randomizedBase256Codeword, base256CodewordPosition) {\n            const pseudoRandomNumber = 149 * base256CodewordPosition % 255 + 1;\n            const tempVariable = randomizedBase256Codeword - pseudoRandomNumber;\n            return tempVariable >= 0 ? tempVariable : tempVariable + 256;\n        }\n    }\n    /**\n     * See ISO 16022:2006, Annex C Table C.1\n     * The C40 Basic Character Set (*'s used for placeholders for the shift values)\n     */ DecodedBitStreamParser.C40_BASIC_SET_CHARS = [\n        \"*\",\n        \"*\",\n        \"*\",\n        \" \",\n        \"0\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"A\",\n        \"B\",\n        \"C\",\n        \"D\",\n        \"E\",\n        \"F\",\n        \"G\",\n        \"H\",\n        \"I\",\n        \"J\",\n        \"K\",\n        \"L\",\n        \"M\",\n        \"N\",\n        \"O\",\n        \"P\",\n        \"Q\",\n        \"R\",\n        \"S\",\n        \"T\",\n        \"U\",\n        \"V\",\n        \"W\",\n        \"X\",\n        \"Y\",\n        \"Z\"\n    ];\n    DecodedBitStreamParser.C40_SHIFT2_SET_CHARS = [\n        \"!\",\n        '\"',\n        \"#\",\n        \"$\",\n        \"%\",\n        \"&\",\n        \"'\",\n        \"(\",\n        \")\",\n        \"*\",\n        \"+\",\n        \",\",\n        \"-\",\n        \".\",\n        \"/\",\n        \":\",\n        \";\",\n        \"<\",\n        \"=\",\n        \">\",\n        \"?\",\n        \"@\",\n        \"[\",\n        \"\\\\\",\n        \"]\",\n        \"^\",\n        \"_\"\n    ];\n    /**\n     * See ISO 16022:2006, Annex C Table C.2\n     * The Text Basic Character Set (*'s used for placeholders for the shift values)\n     */ DecodedBitStreamParser.TEXT_BASIC_SET_CHARS = [\n        \"*\",\n        \"*\",\n        \"*\",\n        \" \",\n        \"0\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"a\",\n        \"b\",\n        \"c\",\n        \"d\",\n        \"e\",\n        \"f\",\n        \"g\",\n        \"h\",\n        \"i\",\n        \"j\",\n        \"k\",\n        \"l\",\n        \"m\",\n        \"n\",\n        \"o\",\n        \"p\",\n        \"q\",\n        \"r\",\n        \"s\",\n        \"t\",\n        \"u\",\n        \"v\",\n        \"w\",\n        \"x\",\n        \"y\",\n        \"z\"\n    ];\n    // Shift 2 for Text is the same encoding as C40\n    DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;\n    DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS = [\n        \"`\",\n        \"A\",\n        \"B\",\n        \"C\",\n        \"D\",\n        \"E\",\n        \"F\",\n        \"G\",\n        \"H\",\n        \"I\",\n        \"J\",\n        \"K\",\n        \"L\",\n        \"M\",\n        \"N\",\n        \"O\",\n        \"P\",\n        \"Q\",\n        \"R\",\n        \"S\",\n        \"T\",\n        \"U\",\n        \"V\",\n        \"W\",\n        \"X\",\n        \"Y\",\n        \"Z\",\n        \"{\",\n        \"|\",\n        \"}\",\n        \"~\",\n        String.fromCharCode(127)\n    ];\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>The main class which implements Data Matrix Code decoding -- as opposed to locating and extracting\n     * the Data Matrix Code from an image.</p>\n     *\n     * @author bbrown@google.com (Brian Brown)\n     */ class Decoder$1 {\n        constructor(){\n            this.rsDecoder = new ReedSolomonDecoder(GenericGF.DATA_MATRIX_FIELD_256);\n        }\n        /**\n         * <p>Decodes a Data Matrix Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken\n         * to mean a black module.</p>\n         *\n         * @param bits booleans representing white/black Data Matrix Code modules\n         * @return text and bytes encoded within the Data Matrix Code\n         * @throws FormatException if the Data Matrix Code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */ decode(bits) {\n            // Construct a parser and read version, error-correction level\n            const parser = new BitMatrixParser(bits);\n            const version = parser.getVersion();\n            // Read codewords\n            const codewords = parser.readCodewords();\n            // Separate into data blocks\n            const dataBlocks = DataBlock.getDataBlocks(codewords, version);\n            // Count total number of data bytes\n            let totalBytes = 0;\n            for (let db of dataBlocks){\n                totalBytes += db.getNumDataCodewords();\n            }\n            const resultBytes = new Uint8Array(totalBytes);\n            const dataBlocksCount = dataBlocks.length;\n            // Error-correct and copy data blocks together into a stream of bytes\n            for(let j = 0; j < dataBlocksCount; j++){\n                const dataBlock = dataBlocks[j];\n                const codewordBytes = dataBlock.getCodewords();\n                const numDataCodewords = dataBlock.getNumDataCodewords();\n                this.correctErrors(codewordBytes, numDataCodewords);\n                for(let i = 0; i < numDataCodewords; i++){\n                    // De-interlace data blocks.\n                    resultBytes[i * dataBlocksCount + j] = codewordBytes[i];\n                }\n            }\n            // Decode the contents of that stream of bytes\n            return DecodedBitStreamParser.decode(resultBytes);\n        }\n        /**\n         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n         * correct the errors in-place using Reed-Solomon error correction.</p>\n         *\n         * @param codewordBytes data and error correction codewords\n         * @param numDataCodewords number of codewords that are data bytes\n         * @throws ChecksumException if error correction fails\n         */ correctErrors(codewordBytes, numDataCodewords) {\n            // const numCodewords = codewordBytes.length;\n            // First read into an array of ints\n            const codewordsInts = new Int32Array(codewordBytes);\n            // for (let i = 0; i < numCodewords; i++) {\n            //   codewordsInts[i] = codewordBytes[i] & 0xFF;\n            // }\n            try {\n                this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n            } catch (ignored /* ReedSolomonException */ ) {\n                throw new ChecksumException();\n            }\n            // Copy back into array of bytes -- only need to worry about the bytes that were data\n            // We don't care about errors in the error-correction codewords\n            for(let i = 0; i < numDataCodewords; i++){\n                codewordBytes[i] = codewordsInts[i];\n            }\n        }\n    }\n    /**\n     * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code\n     * is rotated or skewed, or partially obscured.</p>\n     *\n     * @author Sean Owen\n     */ class Detector$1 {\n        constructor(image){\n            this.image = image;\n            this.rectangleDetector = new WhiteRectangleDetector(this.image);\n        }\n        /**\n         * <p>Detects a Data Matrix Code in an image.</p>\n         *\n         * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code\n         * @throws NotFoundException if no Data Matrix Code can be found\n         */ detect() {\n            const cornerPoints = this.rectangleDetector.detect();\n            let points = this.detectSolid1(cornerPoints);\n            points = this.detectSolid2(points);\n            points[3] = this.correctTopRight(points);\n            if (!points[3]) {\n                throw new NotFoundException();\n            }\n            points = this.shiftToModuleCenter(points);\n            const topLeft = points[0];\n            const bottomLeft = points[1];\n            const bottomRight = points[2];\n            const topRight = points[3];\n            let dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;\n            let dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;\n            if ((dimensionTop & 0x01) === 1) {\n                dimensionTop += 1;\n            }\n            if ((dimensionRight & 0x01) === 1) {\n                dimensionRight += 1;\n            }\n            if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {\n                // The matrix is square\n                dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);\n            }\n            let bits = Detector$1.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);\n            return new DetectorResult(bits, [\n                topLeft,\n                bottomLeft,\n                bottomRight,\n                topRight\n            ]);\n        }\n        static shiftPoint(point, to, div) {\n            let x = (to.getX() - point.getX()) / (div + 1);\n            let y = (to.getY() - point.getY()) / (div + 1);\n            return new ResultPoint(point.getX() + x, point.getY() + y);\n        }\n        static moveAway(point, fromX, fromY) {\n            let x = point.getX();\n            let y = point.getY();\n            if (x < fromX) {\n                x -= 1;\n            } else {\n                x += 1;\n            }\n            if (y < fromY) {\n                y -= 1;\n            } else {\n                y += 1;\n            }\n            return new ResultPoint(x, y);\n        }\n        /**\n         * Detect a solid side which has minimum transition.\n         */ detectSolid1(cornerPoints) {\n            // 0  2\n            // 1  3\n            let pointA = cornerPoints[0];\n            let pointB = cornerPoints[1];\n            let pointC = cornerPoints[3];\n            let pointD = cornerPoints[2];\n            let trAB = this.transitionsBetween(pointA, pointB);\n            let trBC = this.transitionsBetween(pointB, pointC);\n            let trCD = this.transitionsBetween(pointC, pointD);\n            let trDA = this.transitionsBetween(pointD, pointA);\n            // 0..3\n            // :  :\n            // 1--2\n            let min = trAB;\n            let points = [\n                pointD,\n                pointA,\n                pointB,\n                pointC\n            ];\n            if (min > trBC) {\n                min = trBC;\n                points[0] = pointA;\n                points[1] = pointB;\n                points[2] = pointC;\n                points[3] = pointD;\n            }\n            if (min > trCD) {\n                min = trCD;\n                points[0] = pointB;\n                points[1] = pointC;\n                points[2] = pointD;\n                points[3] = pointA;\n            }\n            if (min > trDA) {\n                points[0] = pointC;\n                points[1] = pointD;\n                points[2] = pointA;\n                points[3] = pointB;\n            }\n            return points;\n        }\n        /**\n         * Detect a second solid side next to first solid side.\n         */ detectSolid2(points) {\n            // A..D\n            // :  :\n            // B--C\n            let pointA = points[0];\n            let pointB = points[1];\n            let pointC = points[2];\n            let pointD = points[3];\n            // Transition detection on the edge is not stable.\n            // To safely detect, shift the points to the module center.\n            let tr = this.transitionsBetween(pointA, pointD);\n            let pointBs = Detector$1.shiftPoint(pointB, pointC, (tr + 1) * 4);\n            let pointCs = Detector$1.shiftPoint(pointC, pointB, (tr + 1) * 4);\n            let trBA = this.transitionsBetween(pointBs, pointA);\n            let trCD = this.transitionsBetween(pointCs, pointD);\n            // 0..3\n            // |  :\n            // 1--2\n            if (trBA < trCD) {\n                // solid sides: A-B-C\n                points[0] = pointA;\n                points[1] = pointB;\n                points[2] = pointC;\n                points[3] = pointD;\n            } else {\n                // solid sides: B-C-D\n                points[0] = pointB;\n                points[1] = pointC;\n                points[2] = pointD;\n                points[3] = pointA;\n            }\n            return points;\n        }\n        /**\n         * Calculates the corner position of the white top right module.\n         */ correctTopRight(points) {\n            // A..D\n            // |  :\n            // B--C\n            let pointA = points[0];\n            let pointB = points[1];\n            let pointC = points[2];\n            let pointD = points[3];\n            // shift points for safe transition detection.\n            let trTop = this.transitionsBetween(pointA, pointD);\n            let trRight = this.transitionsBetween(pointB, pointD);\n            let pointAs = Detector$1.shiftPoint(pointA, pointB, (trRight + 1) * 4);\n            let pointCs = Detector$1.shiftPoint(pointC, pointB, (trTop + 1) * 4);\n            trTop = this.transitionsBetween(pointAs, pointD);\n            trRight = this.transitionsBetween(pointCs, pointD);\n            let candidate1 = new ResultPoint(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));\n            let candidate2 = new ResultPoint(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));\n            if (!this.isValid(candidate1)) {\n                if (this.isValid(candidate2)) {\n                    return candidate2;\n                }\n                return null;\n            }\n            if (!this.isValid(candidate2)) {\n                return candidate1;\n            }\n            let sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);\n            let sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);\n            if (sumc1 > sumc2) {\n                return candidate1;\n            } else {\n                return candidate2;\n            }\n        }\n        /**\n         * Shift the edge points to the module center.\n         */ shiftToModuleCenter(points) {\n            // A..D\n            // |  :\n            // B--C\n            let pointA = points[0];\n            let pointB = points[1];\n            let pointC = points[2];\n            let pointD = points[3];\n            // calculate pseudo dimensions\n            let dimH = this.transitionsBetween(pointA, pointD) + 1;\n            let dimV = this.transitionsBetween(pointC, pointD) + 1;\n            // shift points for safe dimension detection\n            let pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);\n            let pointCs = Detector$1.shiftPoint(pointC, pointB, dimH * 4);\n            //  calculate more precise dimensions\n            dimH = this.transitionsBetween(pointAs, pointD) + 1;\n            dimV = this.transitionsBetween(pointCs, pointD) + 1;\n            if ((dimH & 0x01) === 1) {\n                dimH += 1;\n            }\n            if ((dimV & 0x01) === 1) {\n                dimV += 1;\n            }\n            // WhiteRectangleDetector returns points inside of the rectangle.\n            // I want points on the edges.\n            let centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;\n            let centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;\n            pointA = Detector$1.moveAway(pointA, centerX, centerY);\n            pointB = Detector$1.moveAway(pointB, centerX, centerY);\n            pointC = Detector$1.moveAway(pointC, centerX, centerY);\n            pointD = Detector$1.moveAway(pointD, centerX, centerY);\n            let pointBs;\n            let pointDs;\n            // shift points to the center of each modules\n            pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);\n            pointAs = Detector$1.shiftPoint(pointAs, pointD, dimH * 4);\n            pointBs = Detector$1.shiftPoint(pointB, pointA, dimV * 4);\n            pointBs = Detector$1.shiftPoint(pointBs, pointC, dimH * 4);\n            pointCs = Detector$1.shiftPoint(pointC, pointD, dimV * 4);\n            pointCs = Detector$1.shiftPoint(pointCs, pointB, dimH * 4);\n            pointDs = Detector$1.shiftPoint(pointD, pointC, dimV * 4);\n            pointDs = Detector$1.shiftPoint(pointDs, pointA, dimH * 4);\n            return [\n                pointAs,\n                pointBs,\n                pointCs,\n                pointDs\n            ];\n        }\n        isValid(p) {\n            return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();\n        }\n        static sampleGrid(image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {\n            const sampler = GridSamplerInstance.getInstance();\n            return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n        }\n        /**\n         * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.\n         */ transitionsBetween(from, to) {\n            // See QR Code Detector, sizeOfBlackWhiteBlackRun()\n            let fromX = Math.trunc(from.getX());\n            let fromY = Math.trunc(from.getY());\n            let toX = Math.trunc(to.getX());\n            let toY = Math.trunc(to.getY());\n            let steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n            if (steep) {\n                let temp = fromX;\n                fromX = fromY;\n                fromY = temp;\n                temp = toX;\n                toX = toY;\n                toY = temp;\n            }\n            let dx = Math.abs(toX - fromX);\n            let dy = Math.abs(toY - fromY);\n            let error = -dx / 2;\n            let ystep = fromY < toY ? 1 : -1;\n            let xstep = fromX < toX ? 1 : -1;\n            let transitions = 0;\n            let inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);\n            for(let x = fromX, y = fromY; x !== toX; x += xstep){\n                let isBlack = this.image.get(steep ? y : x, steep ? x : y);\n                if (isBlack !== inBlack) {\n                    transitions++;\n                    inBlack = isBlack;\n                }\n                error += dy;\n                if (error > 0) {\n                    if (y === toY) {\n                        break;\n                    }\n                    y += ystep;\n                    error -= dx;\n                }\n            }\n            return transitions;\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * This implementation can detect and decode Data Matrix codes in an image.\n     *\n     * @author bbrown@google.com (Brian Brown)\n     */ class DataMatrixReader {\n        constructor(){\n            this.decoder = new Decoder$1();\n        }\n        /**\n         * Locates and decodes a Data Matrix code in an image.\n         *\n         * @return a String representing the content encoded by the Data Matrix code\n         * @throws NotFoundException if a Data Matrix code cannot be found\n         * @throws FormatException if a Data Matrix code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */ // @Override\n        // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n        //   return decode(image, null);\n        // }\n        // @Override\n        decode(image, hints = null) {\n            let decoderResult;\n            let points;\n            if (hints != null && hints.has(DecodeHintType$1.PURE_BARCODE)) {\n                const bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\n                decoderResult = this.decoder.decode(bits);\n                points = DataMatrixReader.NO_POINTS;\n            } else {\n                const detectorResult = new Detector$1(image.getBlackMatrix()).detect();\n                decoderResult = this.decoder.decode(detectorResult.getBits());\n                points = detectorResult.getPoints();\n            }\n            const rawBytes = decoderResult.getRawBytes();\n            const result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat$1.DATA_MATRIX, System.currentTimeMillis());\n            const byteSegments = decoderResult.getByteSegments();\n            if (byteSegments != null) {\n                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);\n            }\n            const ecLevel = decoderResult.getECLevel();\n            if (ecLevel != null) {\n                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);\n            }\n            return result;\n        }\n        // @Override\n        reset() {\n        // do nothing\n        }\n        /**\n         * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n         * which contains only an unrotated, unskewed, image of a code, with some white border\n         * around it. This is a specialized method that works exceptionally fast in this special\n         * case.\n         *\n         * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\n         */ static extractPureBits(image) {\n            const leftTopBlack = image.getTopLeftOnBit();\n            const rightBottomBlack = image.getBottomRightOnBit();\n            if (leftTopBlack == null || rightBottomBlack == null) {\n                throw new NotFoundException();\n            }\n            const moduleSize = this.moduleSize(leftTopBlack, image);\n            let top = leftTopBlack[1];\n            const bottom = rightBottomBlack[1];\n            let left = leftTopBlack[0];\n            const right = rightBottomBlack[0];\n            const matrixWidth = (right - left + 1) / moduleSize;\n            const matrixHeight = (bottom - top + 1) / moduleSize;\n            if (matrixWidth <= 0 || matrixHeight <= 0) {\n                throw new NotFoundException();\n            }\n            // Push in the \"border\" by half the module width so that we start\n            // sampling in the middle of the module. Just in case the image is a\n            // little off, this will help recover.\n            const nudge = moduleSize / 2;\n            top += nudge;\n            left += nudge;\n            // Now just read off the bits\n            const bits = new BitMatrix(matrixWidth, matrixHeight);\n            for(let y = 0; y < matrixHeight; y++){\n                const iOffset = top + y * moduleSize;\n                for(let x = 0; x < matrixWidth; x++){\n                    if (image.get(left + x * moduleSize, iOffset)) {\n                        bits.set(x, y);\n                    }\n                }\n            }\n            return bits;\n        }\n        static moduleSize(leftTopBlack, image) {\n            const width = image.getWidth();\n            let x = leftTopBlack[0];\n            const y = leftTopBlack[1];\n            while(x < width && image.get(x, y)){\n                x++;\n            }\n            if (x === width) {\n                throw new NotFoundException();\n            }\n            const moduleSize = x - leftTopBlack[0];\n            if (moduleSize === 0) {\n                throw new NotFoundException();\n            }\n            return moduleSize;\n        }\n    }\n    DataMatrixReader.NO_POINTS = [];\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * QR Code reader to use from browser.\n     */ class BrowserDatamatrixCodeReader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserQRCodeReader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         */ constructor(timeBetweenScansMillis = 500){\n            super(new DataMatrixReader(), timeBetweenScansMillis);\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ var ErrorCorrectionLevelValues;\n    (function(ErrorCorrectionLevelValues) {\n        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"L\"] = 0] = \"L\";\n        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"M\"] = 1] = \"M\";\n        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"Q\"] = 2] = \"Q\";\n        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"H\"] = 3] = \"H\";\n    })(ErrorCorrectionLevelValues || (ErrorCorrectionLevelValues = {}));\n    /**\n     * <p>See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels\n     * defined by the QR code standard.</p>\n     *\n     * @author Sean Owen\n     */ class ErrorCorrectionLevel {\n        constructor(value, stringValue, bits /*int*/ ){\n            this.value = value;\n            this.stringValue = stringValue;\n            this.bits = bits;\n            ErrorCorrectionLevel.FOR_BITS.set(bits, this);\n            ErrorCorrectionLevel.FOR_VALUE.set(value, this);\n        }\n        getValue() {\n            return this.value;\n        }\n        getBits() {\n            return this.bits;\n        }\n        static fromString(s) {\n            switch(s){\n                case \"L\":\n                    return ErrorCorrectionLevel.L;\n                case \"M\":\n                    return ErrorCorrectionLevel.M;\n                case \"Q\":\n                    return ErrorCorrectionLevel.Q;\n                case \"H\":\n                    return ErrorCorrectionLevel.H;\n                default:\n                    throw new ArgumentException(s + \"not available\");\n            }\n        }\n        toString() {\n            return this.stringValue;\n        }\n        equals(o) {\n            if (!(o instanceof ErrorCorrectionLevel)) {\n                return false;\n            }\n            const other = o;\n            return this.value === other.value;\n        }\n        /**\n         * @param bits int containing the two bits encoding a QR Code's error correction level\n         * @return ErrorCorrectionLevel representing the encoded error correction level\n         */ static forBits(bits /*int*/ ) {\n            if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.size) {\n                throw new IllegalArgumentException();\n            }\n            return ErrorCorrectionLevel.FOR_BITS.get(bits);\n        }\n    }\n    ErrorCorrectionLevel.FOR_BITS = new Map();\n    ErrorCorrectionLevel.FOR_VALUE = new Map();\n    /** L = ~7% correction */ ErrorCorrectionLevel.L = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.L, \"L\", 0x01);\n    /** M = ~15% correction */ ErrorCorrectionLevel.M = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.M, \"M\", 0x00);\n    /** Q = ~25% correction */ ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.Q, \"Q\", 0x03);\n    /** H = ~30% correction */ ErrorCorrectionLevel.H = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.H, \"H\", 0x02);\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>Encapsulates a QR Code's format information, including the data mask used and\n     * error correction level.</p>\n     *\n     * @author Sean Owen\n     * @see DataMask\n     * @see ErrorCorrectionLevel\n     */ class FormatInformation {\n        constructor(formatInfo /*int*/ ){\n            // Bits 3,4\n            this.errorCorrectionLevel = ErrorCorrectionLevel.forBits(formatInfo >> 3 & 0x03);\n            // Bottom 3 bits\n            this.dataMask = /*(byte) */ formatInfo & 0x07;\n        }\n        static numBitsDiffering(a /*int*/ , b /*int*/ ) {\n            return Integer.bitCount(a ^ b);\n        }\n        /**\n         * @param maskedFormatInfo1 format info indicator, with mask still applied\n         * @param maskedFormatInfo2 second copy of same info; both are checked at the same time\n         *  to establish best match\n         * @return information about the format it specifies, or {@code null}\n         *  if doesn't seem to match any known pattern\n         */ static decodeFormatInformation(maskedFormatInfo1 /*int*/ , maskedFormatInfo2 /*int*/ ) {\n            const formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);\n            if (formatInfo !== null) {\n                return formatInfo;\n            }\n            // Should return null, but, some QR codes apparently\n            // do not mask this info. Try again by actually masking the pattern\n            // first\n            return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);\n        }\n        static doDecodeFormatInformation(maskedFormatInfo1 /*int*/ , maskedFormatInfo2 /*int*/ ) {\n            // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing\n            let bestDifference = Number.MAX_SAFE_INTEGER;\n            let bestFormatInfo = 0;\n            for (const decodeInfo of FormatInformation.FORMAT_INFO_DECODE_LOOKUP){\n                const targetInfo = decodeInfo[0];\n                if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {\n                    // Found an exact match\n                    return new FormatInformation(decodeInfo[1]);\n                }\n                let bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);\n                if (bitsDifference < bestDifference) {\n                    bestFormatInfo = decodeInfo[1];\n                    bestDifference = bitsDifference;\n                }\n                if (maskedFormatInfo1 !== maskedFormatInfo2) {\n                    // also try the other option\n                    bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);\n                    if (bitsDifference < bestDifference) {\n                        bestFormatInfo = decodeInfo[1];\n                        bestDifference = bitsDifference;\n                    }\n                }\n            }\n            // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits\n            // differing means we found a match\n            if (bestDifference <= 3) {\n                return new FormatInformation(bestFormatInfo);\n            }\n            return null;\n        }\n        getErrorCorrectionLevel() {\n            return this.errorCorrectionLevel;\n        }\n        getDataMask() {\n            return this.dataMask;\n        }\n        /*@Override*/ hashCode() {\n            return this.errorCorrectionLevel.getBits() << 3 | this.dataMask;\n        }\n        /*@Override*/ equals(o) {\n            if (!(o instanceof FormatInformation)) {\n                return false;\n            }\n            const other = o;\n            return this.errorCorrectionLevel === other.errorCorrectionLevel && this.dataMask === other.dataMask;\n        }\n    }\n    FormatInformation.FORMAT_INFO_MASK_QR = 0x5412;\n    /**\n     * See ISO 18004:2006, Annex C, Table C.1\n     */ FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [\n        Int32Array.from([\n            0x5412,\n            0x00\n        ]),\n        Int32Array.from([\n            0x5125,\n            0x01\n        ]),\n        Int32Array.from([\n            0x5E7C,\n            0x02\n        ]),\n        Int32Array.from([\n            0x5B4B,\n            0x03\n        ]),\n        Int32Array.from([\n            0x45F9,\n            0x04\n        ]),\n        Int32Array.from([\n            0x40CE,\n            0x05\n        ]),\n        Int32Array.from([\n            0x4F97,\n            0x06\n        ]),\n        Int32Array.from([\n            0x4AA0,\n            0x07\n        ]),\n        Int32Array.from([\n            0x77C4,\n            0x08\n        ]),\n        Int32Array.from([\n            0x72F3,\n            0x09\n        ]),\n        Int32Array.from([\n            0x7DAA,\n            0x0A\n        ]),\n        Int32Array.from([\n            0x789D,\n            0x0B\n        ]),\n        Int32Array.from([\n            0x662F,\n            0x0C\n        ]),\n        Int32Array.from([\n            0x6318,\n            0x0D\n        ]),\n        Int32Array.from([\n            0x6C41,\n            0x0E\n        ]),\n        Int32Array.from([\n            0x6976,\n            0x0F\n        ]),\n        Int32Array.from([\n            0x1689,\n            0x10\n        ]),\n        Int32Array.from([\n            0x13BE,\n            0x11\n        ]),\n        Int32Array.from([\n            0x1CE7,\n            0x12\n        ]),\n        Int32Array.from([\n            0x19D0,\n            0x13\n        ]),\n        Int32Array.from([\n            0x0762,\n            0x14\n        ]),\n        Int32Array.from([\n            0x0255,\n            0x15\n        ]),\n        Int32Array.from([\n            0x0D0C,\n            0x16\n        ]),\n        Int32Array.from([\n            0x083B,\n            0x17\n        ]),\n        Int32Array.from([\n            0x355F,\n            0x18\n        ]),\n        Int32Array.from([\n            0x3068,\n            0x19\n        ]),\n        Int32Array.from([\n            0x3F31,\n            0x1A\n        ]),\n        Int32Array.from([\n            0x3A06,\n            0x1B\n        ]),\n        Int32Array.from([\n            0x24B4,\n            0x1C\n        ]),\n        Int32Array.from([\n            0x2183,\n            0x1D\n        ]),\n        Int32Array.from([\n            0x2EDA,\n            0x1E\n        ]),\n        Int32Array.from([\n            0x2BED,\n            0x1F\n        ])\n    ];\n    /**\n     * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will\n     * use blocks of differing sizes within one version, so, this encapsulates the parameters for\n     * each set of blocks. It also holds the number of error-correction codewords per block since it\n     * will be the same across all blocks within one version.</p>\n     */ class ECBlocks$1 {\n        constructor(ecCodewordsPerBlock /*int*/ , ...ecBlocks){\n            this.ecCodewordsPerBlock = ecCodewordsPerBlock;\n            this.ecBlocks = ecBlocks;\n        }\n        getECCodewordsPerBlock() {\n            return this.ecCodewordsPerBlock;\n        }\n        getNumBlocks() {\n            let total = 0;\n            const ecBlocks = this.ecBlocks;\n            for (const ecBlock of ecBlocks){\n                total += ecBlock.getCount();\n            }\n            return total;\n        }\n        getTotalECCodewords() {\n            return this.ecCodewordsPerBlock * this.getNumBlocks();\n        }\n        getECBlocks() {\n            return this.ecBlocks;\n        }\n    }\n    /**\n     * <p>Encapsulates the parameters for one error-correction block in one symbol version.\n     * This includes the number of data codewords, and the number of times a block with these\n     * parameters is used consecutively in the QR code version's format.</p>\n     */ class ECB$1 {\n        constructor(count /*int*/ , dataCodewords /*int*/ ){\n            this.count = count;\n            this.dataCodewords = dataCodewords;\n        }\n        getCount() {\n            return this.count;\n        }\n        getDataCodewords() {\n            return this.dataCodewords;\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * See ISO 18004:2006 Annex D\n     *\n     * @author Sean Owen\n     */ class Version$1 {\n        constructor(versionNumber /*int*/ , alignmentPatternCenters, ...ecBlocks){\n            this.versionNumber = versionNumber;\n            this.alignmentPatternCenters = alignmentPatternCenters;\n            this.ecBlocks = ecBlocks;\n            let total = 0;\n            const ecCodewords = ecBlocks[0].getECCodewordsPerBlock();\n            const ecbArray = ecBlocks[0].getECBlocks();\n            for (const ecBlock of ecbArray){\n                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);\n            }\n            this.totalCodewords = total;\n        }\n        getVersionNumber() {\n            return this.versionNumber;\n        }\n        getAlignmentPatternCenters() {\n            return this.alignmentPatternCenters;\n        }\n        getTotalCodewords() {\n            return this.totalCodewords;\n        }\n        getDimensionForVersion() {\n            return 17 + 4 * this.versionNumber;\n        }\n        getECBlocksForLevel(ecLevel) {\n            return this.ecBlocks[ecLevel.getValue()];\n        // TYPESCRIPTPORT: original was using ordinal, and using the order of levels as defined in ErrorCorrectionLevel enum (LMQH)\n        // I will use the direct value from ErrorCorrectionLevelValues enum which in typescript goes to a number\n        }\n        /**\n         * <p>Deduces version information purely from QR Code dimensions.</p>\n         *\n         * @param dimension dimension in modules\n         * @return Version for a QR Code of that dimension\n         * @throws FormatException if dimension is not 1 mod 4\n         */ static getProvisionalVersionForDimension(dimension /*int*/ ) {\n            if (dimension % 4 !== 1) {\n                throw new FormatException();\n            }\n            try {\n                return this.getVersionForNumber((dimension - 17) / 4);\n            } catch (ignored /*: IllegalArgumentException*/ ) {\n                throw new FormatException();\n            }\n        }\n        static getVersionForNumber(versionNumber /*int*/ ) {\n            if (versionNumber < 1 || versionNumber > 40) {\n                throw new IllegalArgumentException();\n            }\n            return Version$1.VERSIONS[versionNumber - 1];\n        }\n        static decodeVersionInformation(versionBits /*int*/ ) {\n            let bestDifference = Number.MAX_SAFE_INTEGER;\n            let bestVersion = 0;\n            for(let i = 0; i < Version$1.VERSION_DECODE_INFO.length; i++){\n                const targetVersion = Version$1.VERSION_DECODE_INFO[i];\n                // Do the version info bits match exactly? done.\n                if (targetVersion === versionBits) {\n                    return Version$1.getVersionForNumber(i + 7);\n                }\n                // Otherwise see if this is the closest to a real version info bit string\n                // we have seen so far\n                const bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);\n                if (bitsDifference < bestDifference) {\n                    bestVersion = i + 7;\n                    bestDifference = bitsDifference;\n                }\n            }\n            // We can tolerate up to 3 bits of error since no two version info codewords will\n            // differ in less than 8 bits.\n            if (bestDifference <= 3) {\n                return Version$1.getVersionForNumber(bestVersion);\n            }\n            // If we didn't find a close enough match, fail\n            return null;\n        }\n        /**\n         * See ISO 18004:2006 Annex E\n         */ buildFunctionPattern() {\n            const dimension = this.getDimensionForVersion();\n            const bitMatrix = new BitMatrix(dimension);\n            // Top left finder pattern + separator + format\n            bitMatrix.setRegion(0, 0, 9, 9);\n            // Top right finder pattern + separator + format\n            bitMatrix.setRegion(dimension - 8, 0, 8, 9);\n            // Bottom left finder pattern + separator + format\n            bitMatrix.setRegion(0, dimension - 8, 9, 8);\n            // Alignment patterns\n            const max = this.alignmentPatternCenters.length;\n            for(let x = 0; x < max; x++){\n                const i = this.alignmentPatternCenters[x] - 2;\n                for(let y = 0; y < max; y++){\n                    if (x === 0 && (y === 0 || y === max - 1) || x === max - 1 && y === 0) {\n                        continue;\n                    }\n                    bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);\n                }\n            }\n            // Vertical timing pattern\n            bitMatrix.setRegion(6, 9, 1, dimension - 17);\n            // Horizontal timing pattern\n            bitMatrix.setRegion(9, 6, dimension - 17, 1);\n            if (this.versionNumber > 6) {\n                // Version info, top right\n                bitMatrix.setRegion(dimension - 11, 0, 3, 6);\n                // Version info, bottom left\n                bitMatrix.setRegion(0, dimension - 11, 6, 3);\n            }\n            return bitMatrix;\n        }\n        /*@Override*/ toString() {\n            return \"\" + this.versionNumber;\n        }\n    }\n    /**\n       * See ISO 18004:2006 Annex D.\n       * Element i represents the raw version bits that specify version i + 7\n       */ Version$1.VERSION_DECODE_INFO = Int32Array.from([\n        0x07C94,\n        0x085BC,\n        0x09A99,\n        0x0A4D3,\n        0x0BBF6,\n        0x0C762,\n        0x0D847,\n        0x0E60D,\n        0x0F928,\n        0x10B78,\n        0x1145D,\n        0x12A17,\n        0x13532,\n        0x149A6,\n        0x15683,\n        0x168C9,\n        0x177EC,\n        0x18EC4,\n        0x191E1,\n        0x1AFAB,\n        0x1B08E,\n        0x1CC1A,\n        0x1D33F,\n        0x1ED75,\n        0x1F250,\n        0x209D5,\n        0x216F0,\n        0x228BA,\n        0x2379F,\n        0x24B0B,\n        0x2542E,\n        0x26A64,\n        0x27541,\n        0x28C69\n    ]);\n    /**\n       * See ISO 18004:2006 6.5.1 Table 9\n       */ Version$1.VERSIONS = [\n        new Version$1(1, new Int32Array(0), new ECBlocks$1(7, new ECB$1(1, 19)), new ECBlocks$1(10, new ECB$1(1, 16)), new ECBlocks$1(13, new ECB$1(1, 13)), new ECBlocks$1(17, new ECB$1(1, 9))),\n        new Version$1(2, Int32Array.from([\n            6,\n            18\n        ]), new ECBlocks$1(10, new ECB$1(1, 34)), new ECBlocks$1(16, new ECB$1(1, 28)), new ECBlocks$1(22, new ECB$1(1, 22)), new ECBlocks$1(28, new ECB$1(1, 16))),\n        new Version$1(3, Int32Array.from([\n            6,\n            22\n        ]), new ECBlocks$1(15, new ECB$1(1, 55)), new ECBlocks$1(26, new ECB$1(1, 44)), new ECBlocks$1(18, new ECB$1(2, 17)), new ECBlocks$1(22, new ECB$1(2, 13))),\n        new Version$1(4, Int32Array.from([\n            6,\n            26\n        ]), new ECBlocks$1(20, new ECB$1(1, 80)), new ECBlocks$1(18, new ECB$1(2, 32)), new ECBlocks$1(26, new ECB$1(2, 24)), new ECBlocks$1(16, new ECB$1(4, 9))),\n        new Version$1(5, Int32Array.from([\n            6,\n            30\n        ]), new ECBlocks$1(26, new ECB$1(1, 108)), new ECBlocks$1(24, new ECB$1(2, 43)), new ECBlocks$1(18, new ECB$1(2, 15), new ECB$1(2, 16)), new ECBlocks$1(22, new ECB$1(2, 11), new ECB$1(2, 12))),\n        new Version$1(6, Int32Array.from([\n            6,\n            34\n        ]), new ECBlocks$1(18, new ECB$1(2, 68)), new ECBlocks$1(16, new ECB$1(4, 27)), new ECBlocks$1(24, new ECB$1(4, 19)), new ECBlocks$1(28, new ECB$1(4, 15))),\n        new Version$1(7, Int32Array.from([\n            6,\n            22,\n            38\n        ]), new ECBlocks$1(20, new ECB$1(2, 78)), new ECBlocks$1(18, new ECB$1(4, 31)), new ECBlocks$1(18, new ECB$1(2, 14), new ECB$1(4, 15)), new ECBlocks$1(26, new ECB$1(4, 13), new ECB$1(1, 14))),\n        new Version$1(8, Int32Array.from([\n            6,\n            24,\n            42\n        ]), new ECBlocks$1(24, new ECB$1(2, 97)), new ECBlocks$1(22, new ECB$1(2, 38), new ECB$1(2, 39)), new ECBlocks$1(22, new ECB$1(4, 18), new ECB$1(2, 19)), new ECBlocks$1(26, new ECB$1(4, 14), new ECB$1(2, 15))),\n        new Version$1(9, Int32Array.from([\n            6,\n            26,\n            46\n        ]), new ECBlocks$1(30, new ECB$1(2, 116)), new ECBlocks$1(22, new ECB$1(3, 36), new ECB$1(2, 37)), new ECBlocks$1(20, new ECB$1(4, 16), new ECB$1(4, 17)), new ECBlocks$1(24, new ECB$1(4, 12), new ECB$1(4, 13))),\n        new Version$1(10, Int32Array.from([\n            6,\n            28,\n            50\n        ]), new ECBlocks$1(18, new ECB$1(2, 68), new ECB$1(2, 69)), new ECBlocks$1(26, new ECB$1(4, 43), new ECB$1(1, 44)), new ECBlocks$1(24, new ECB$1(6, 19), new ECB$1(2, 20)), new ECBlocks$1(28, new ECB$1(6, 15), new ECB$1(2, 16))),\n        new Version$1(11, Int32Array.from([\n            6,\n            30,\n            54\n        ]), new ECBlocks$1(20, new ECB$1(4, 81)), new ECBlocks$1(30, new ECB$1(1, 50), new ECB$1(4, 51)), new ECBlocks$1(28, new ECB$1(4, 22), new ECB$1(4, 23)), new ECBlocks$1(24, new ECB$1(3, 12), new ECB$1(8, 13))),\n        new Version$1(12, Int32Array.from([\n            6,\n            32,\n            58\n        ]), new ECBlocks$1(24, new ECB$1(2, 92), new ECB$1(2, 93)), new ECBlocks$1(22, new ECB$1(6, 36), new ECB$1(2, 37)), new ECBlocks$1(26, new ECB$1(4, 20), new ECB$1(6, 21)), new ECBlocks$1(28, new ECB$1(7, 14), new ECB$1(4, 15))),\n        new Version$1(13, Int32Array.from([\n            6,\n            34,\n            62\n        ]), new ECBlocks$1(26, new ECB$1(4, 107)), new ECBlocks$1(22, new ECB$1(8, 37), new ECB$1(1, 38)), new ECBlocks$1(24, new ECB$1(8, 20), new ECB$1(4, 21)), new ECBlocks$1(22, new ECB$1(12, 11), new ECB$1(4, 12))),\n        new Version$1(14, Int32Array.from([\n            6,\n            26,\n            46,\n            66\n        ]), new ECBlocks$1(30, new ECB$1(3, 115), new ECB$1(1, 116)), new ECBlocks$1(24, new ECB$1(4, 40), new ECB$1(5, 41)), new ECBlocks$1(20, new ECB$1(11, 16), new ECB$1(5, 17)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(5, 13))),\n        new Version$1(15, Int32Array.from([\n            6,\n            26,\n            48,\n            70\n        ]), new ECBlocks$1(22, new ECB$1(5, 87), new ECB$1(1, 88)), new ECBlocks$1(24, new ECB$1(5, 41), new ECB$1(5, 42)), new ECBlocks$1(30, new ECB$1(5, 24), new ECB$1(7, 25)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(7, 13))),\n        new Version$1(16, Int32Array.from([\n            6,\n            26,\n            50,\n            74\n        ]), new ECBlocks$1(24, new ECB$1(5, 98), new ECB$1(1, 99)), new ECBlocks$1(28, new ECB$1(7, 45), new ECB$1(3, 46)), new ECBlocks$1(24, new ECB$1(15, 19), new ECB$1(2, 20)), new ECBlocks$1(30, new ECB$1(3, 15), new ECB$1(13, 16))),\n        new Version$1(17, Int32Array.from([\n            6,\n            30,\n            54,\n            78\n        ]), new ECBlocks$1(28, new ECB$1(1, 107), new ECB$1(5, 108)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(1, 47)), new ECBlocks$1(28, new ECB$1(1, 22), new ECB$1(15, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(17, 15))),\n        new Version$1(18, Int32Array.from([\n            6,\n            30,\n            56,\n            82\n        ]), new ECBlocks$1(30, new ECB$1(5, 120), new ECB$1(1, 121)), new ECBlocks$1(26, new ECB$1(9, 43), new ECB$1(4, 44)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(1, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(19, 15))),\n        new Version$1(19, Int32Array.from([\n            6,\n            30,\n            58,\n            86\n        ]), new ECBlocks$1(28, new ECB$1(3, 113), new ECB$1(4, 114)), new ECBlocks$1(26, new ECB$1(3, 44), new ECB$1(11, 45)), new ECBlocks$1(26, new ECB$1(17, 21), new ECB$1(4, 22)), new ECBlocks$1(26, new ECB$1(9, 13), new ECB$1(16, 14))),\n        new Version$1(20, Int32Array.from([\n            6,\n            34,\n            62,\n            90\n        ]), new ECBlocks$1(28, new ECB$1(3, 107), new ECB$1(5, 108)), new ECBlocks$1(26, new ECB$1(3, 41), new ECB$1(13, 42)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(5, 25)), new ECBlocks$1(28, new ECB$1(15, 15), new ECB$1(10, 16))),\n        new Version$1(21, Int32Array.from([\n            6,\n            28,\n            50,\n            72,\n            94\n        ]), new ECBlocks$1(28, new ECB$1(4, 116), new ECB$1(4, 117)), new ECBlocks$1(26, new ECB$1(17, 42)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(19, 16), new ECB$1(6, 17))),\n        new Version$1(22, Int32Array.from([\n            6,\n            26,\n            50,\n            74,\n            98\n        ]), new ECBlocks$1(28, new ECB$1(2, 111), new ECB$1(7, 112)), new ECBlocks$1(28, new ECB$1(17, 46)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(16, 25)), new ECBlocks$1(24, new ECB$1(34, 13))),\n        new Version$1(23, Int32Array.from([\n            6,\n            30,\n            54,\n            78,\n            102\n        ]), new ECBlocks$1(30, new ECB$1(4, 121), new ECB$1(5, 122)), new ECBlocks$1(28, new ECB$1(4, 47), new ECB$1(14, 48)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(16, 15), new ECB$1(14, 16))),\n        new Version$1(24, Int32Array.from([\n            6,\n            28,\n            54,\n            80,\n            106\n        ]), new ECBlocks$1(30, new ECB$1(6, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(6, 45), new ECB$1(14, 46)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(16, 25)), new ECBlocks$1(30, new ECB$1(30, 16), new ECB$1(2, 17))),\n        new Version$1(25, Int32Array.from([\n            6,\n            32,\n            58,\n            84,\n            110\n        ]), new ECBlocks$1(26, new ECB$1(8, 106), new ECB$1(4, 107)), new ECBlocks$1(28, new ECB$1(8, 47), new ECB$1(13, 48)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(13, 16))),\n        new Version$1(26, Int32Array.from([\n            6,\n            30,\n            58,\n            86,\n            114\n        ]), new ECBlocks$1(28, new ECB$1(10, 114), new ECB$1(2, 115)), new ECBlocks$1(28, new ECB$1(19, 46), new ECB$1(4, 47)), new ECBlocks$1(28, new ECB$1(28, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(33, 16), new ECB$1(4, 17))),\n        new Version$1(27, Int32Array.from([\n            6,\n            34,\n            62,\n            90,\n            118\n        ]), new ECBlocks$1(30, new ECB$1(8, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(22, 45), new ECB$1(3, 46)), new ECBlocks$1(30, new ECB$1(8, 23), new ECB$1(26, 24)), new ECBlocks$1(30, new ECB$1(12, 15), new ECB$1(28, 16))),\n        new Version$1(28, Int32Array.from([\n            6,\n            26,\n            50,\n            74,\n            98,\n            122\n        ]), new ECBlocks$1(30, new ECB$1(3, 117), new ECB$1(10, 118)), new ECBlocks$1(28, new ECB$1(3, 45), new ECB$1(23, 46)), new ECBlocks$1(30, new ECB$1(4, 24), new ECB$1(31, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(31, 16))),\n        new Version$1(29, Int32Array.from([\n            6,\n            30,\n            54,\n            78,\n            102,\n            126\n        ]), new ECBlocks$1(30, new ECB$1(7, 116), new ECB$1(7, 117)), new ECBlocks$1(28, new ECB$1(21, 45), new ECB$1(7, 46)), new ECBlocks$1(30, new ECB$1(1, 23), new ECB$1(37, 24)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(26, 16))),\n        new Version$1(30, Int32Array.from([\n            6,\n            26,\n            52,\n            78,\n            104,\n            130\n        ]), new ECBlocks$1(30, new ECB$1(5, 115), new ECB$1(10, 116)), new ECBlocks$1(28, new ECB$1(19, 47), new ECB$1(10, 48)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(25, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(25, 16))),\n        new Version$1(31, Int32Array.from([\n            6,\n            30,\n            56,\n            82,\n            108,\n            134\n        ]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(3, 116)), new ECBlocks$1(28, new ECB$1(2, 46), new ECB$1(29, 47)), new ECBlocks$1(30, new ECB$1(42, 24), new ECB$1(1, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(28, 16))),\n        new Version$1(32, Int32Array.from([\n            6,\n            34,\n            60,\n            86,\n            112,\n            138\n        ]), new ECBlocks$1(30, new ECB$1(17, 115)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(10, 24), new ECB$1(35, 25)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(35, 16))),\n        new Version$1(33, Int32Array.from([\n            6,\n            30,\n            58,\n            86,\n            114,\n            142\n        ]), new ECBlocks$1(30, new ECB$1(17, 115), new ECB$1(1, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(21, 47)), new ECBlocks$1(30, new ECB$1(29, 24), new ECB$1(19, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(46, 16))),\n        new Version$1(34, Int32Array.from([\n            6,\n            34,\n            62,\n            90,\n            118,\n            146\n        ]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(6, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(44, 24), new ECB$1(7, 25)), new ECBlocks$1(30, new ECB$1(59, 16), new ECB$1(1, 17))),\n        new Version$1(35, Int32Array.from([\n            6,\n            30,\n            54,\n            78,\n            102,\n            126,\n            150\n        ]), new ECBlocks$1(30, new ECB$1(12, 121), new ECB$1(7, 122)), new ECBlocks$1(28, new ECB$1(12, 47), new ECB$1(26, 48)), new ECBlocks$1(30, new ECB$1(39, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(41, 16))),\n        new Version$1(36, Int32Array.from([\n            6,\n            24,\n            50,\n            76,\n            102,\n            128,\n            154\n        ]), new ECBlocks$1(30, new ECB$1(6, 121), new ECB$1(14, 122)), new ECBlocks$1(28, new ECB$1(6, 47), new ECB$1(34, 48)), new ECBlocks$1(30, new ECB$1(46, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(2, 15), new ECB$1(64, 16))),\n        new Version$1(37, Int32Array.from([\n            6,\n            28,\n            54,\n            80,\n            106,\n            132,\n            158\n        ]), new ECBlocks$1(30, new ECB$1(17, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(29, 46), new ECB$1(14, 47)), new ECBlocks$1(30, new ECB$1(49, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(24, 15), new ECB$1(46, 16))),\n        new Version$1(38, Int32Array.from([\n            6,\n            32,\n            58,\n            84,\n            110,\n            136,\n            162\n        ]), new ECBlocks$1(30, new ECB$1(4, 122), new ECB$1(18, 123)), new ECBlocks$1(28, new ECB$1(13, 46), new ECB$1(32, 47)), new ECBlocks$1(30, new ECB$1(48, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(42, 15), new ECB$1(32, 16))),\n        new Version$1(39, Int32Array.from([\n            6,\n            26,\n            54,\n            82,\n            110,\n            138,\n            166\n        ]), new ECBlocks$1(30, new ECB$1(20, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(40, 47), new ECB$1(7, 48)), new ECBlocks$1(30, new ECB$1(43, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(10, 15), new ECB$1(67, 16))),\n        new Version$1(40, Int32Array.from([\n            6,\n            30,\n            58,\n            86,\n            114,\n            142,\n            170\n        ]), new ECBlocks$1(30, new ECB$1(19, 118), new ECB$1(6, 119)), new ECBlocks$1(28, new ECB$1(18, 47), new ECB$1(31, 48)), new ECBlocks$1(30, new ECB$1(34, 24), new ECB$1(34, 25)), new ECBlocks$1(30, new ECB$1(20, 15), new ECB$1(61, 16)))\n    ];\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ var DataMaskValues;\n    (function(DataMaskValues) {\n        DataMaskValues[DataMaskValues[\"DATA_MASK_000\"] = 0] = \"DATA_MASK_000\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_001\"] = 1] = \"DATA_MASK_001\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_010\"] = 2] = \"DATA_MASK_010\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_011\"] = 3] = \"DATA_MASK_011\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_100\"] = 4] = \"DATA_MASK_100\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_101\"] = 5] = \"DATA_MASK_101\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_110\"] = 6] = \"DATA_MASK_110\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_111\"] = 7] = \"DATA_MASK_111\";\n    })(DataMaskValues || (DataMaskValues = {}));\n    /**\n     * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations\n     * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,\n     * including areas used for finder patterns, timing patterns, etc. These areas should be unused\n     * after the point they are unmasked anyway.</p>\n     *\n     * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position\n     * and j is row position. In fact, as the text says, i is row position and j is column position.</p>\n     *\n     * @author Sean Owen\n     */ class DataMask {\n        // See ISO 18004:2006 6.8.1\n        constructor(value, isMasked){\n            this.value = value;\n            this.isMasked = isMasked;\n        }\n        // End of enum constants.\n        /**\n         * <p>Implementations of this method reverse the data masking process applied to a QR Code and\n         * make its bits ready to read.</p>\n         *\n         * @param bits representation of QR Code bits\n         * @param dimension dimension of QR Code, represented by bits, being unmasked\n         */ unmaskBitMatrix(bits, dimension /*int*/ ) {\n            for(let i = 0; i < dimension; i++){\n                for(let j = 0; j < dimension; j++){\n                    if (this.isMasked(i, j)) {\n                        bits.flip(j, i);\n                    }\n                }\n            }\n        }\n    }\n    DataMask.values = new Map([\n        /**\n         * 000: mask bits for which (x + y) mod 2 == 0\n         */ [\n            DataMaskValues.DATA_MASK_000,\n            new DataMask(DataMaskValues.DATA_MASK_000, (i /*int*/ , j /*int*/ )=>{\n                return (i + j & 0x01) === 0;\n            })\n        ],\n        /**\n         * 001: mask bits for which x mod 2 == 0\n         */ [\n            DataMaskValues.DATA_MASK_001,\n            new DataMask(DataMaskValues.DATA_MASK_001, (i /*int*/ , j /*int*/ )=>{\n                return (i & 0x01) === 0;\n            })\n        ],\n        /**\n         * 010: mask bits for which y mod 3 == 0\n         */ [\n            DataMaskValues.DATA_MASK_010,\n            new DataMask(DataMaskValues.DATA_MASK_010, (i /*int*/ , j /*int*/ )=>{\n                return j % 3 === 0;\n            })\n        ],\n        /**\n         * 011: mask bits for which (x + y) mod 3 == 0\n         */ [\n            DataMaskValues.DATA_MASK_011,\n            new DataMask(DataMaskValues.DATA_MASK_011, (i /*int*/ , j /*int*/ )=>{\n                return (i + j) % 3 === 0;\n            })\n        ],\n        /**\n         * 100: mask bits for which (x/2 + y/3) mod 2 == 0\n         */ [\n            DataMaskValues.DATA_MASK_100,\n            new DataMask(DataMaskValues.DATA_MASK_100, (i /*int*/ , j /*int*/ )=>{\n                return (Math.floor(i / 2) + Math.floor(j / 3) & 0x01) === 0;\n            })\n        ],\n        /**\n         * 101: mask bits for which xy mod 2 + xy mod 3 == 0\n         * equivalently, such that xy mod 6 == 0\n         */ [\n            DataMaskValues.DATA_MASK_101,\n            new DataMask(DataMaskValues.DATA_MASK_101, (i /*int*/ , j /*int*/ )=>{\n                return i * j % 6 === 0;\n            })\n        ],\n        /**\n         * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0\n         * equivalently, such that xy mod 6 < 3\n         */ [\n            DataMaskValues.DATA_MASK_110,\n            new DataMask(DataMaskValues.DATA_MASK_110, (i /*int*/ , j /*int*/ )=>{\n                return i * j % 6 < 3;\n            })\n        ],\n        /**\n         * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0\n         * equivalently, such that (x + y + xy mod 3) mod 2 == 0\n         */ [\n            DataMaskValues.DATA_MASK_111,\n            new DataMask(DataMaskValues.DATA_MASK_111, (i /*int*/ , j /*int*/ )=>{\n                return (i + j + i * j % 3 & 0x01) === 0;\n            })\n        ]\n    ]);\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * @author Sean Owen\n     */ class BitMatrixParser$1 {\n        /**\n         * @param bitMatrix {@link BitMatrix} to parse\n         * @throws FormatException if dimension is not >= 21 and 1 mod 4\n         */ constructor(bitMatrix){\n            const dimension = bitMatrix.getHeight();\n            if (dimension < 21 || (dimension & 0x03) !== 1) {\n                throw new FormatException();\n            }\n            this.bitMatrix = bitMatrix;\n        }\n        /**\n         * <p>Reads format information from one of its two locations within the QR Code.</p>\n         *\n         * @return {@link FormatInformation} encapsulating the QR Code's format info\n         * @throws FormatException if both format information locations cannot be parsed as\n         * the valid encoding of format information\n         */ readFormatInformation() {\n            if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {\n                return this.parsedFormatInfo;\n            }\n            // Read top-left format info bits\n            let formatInfoBits1 = 0;\n            for(let i = 0; i < 6; i++){\n                formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);\n            }\n            // .. and skip a bit in the timing pattern ...\n            formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);\n            formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);\n            formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);\n            // .. and skip a bit in the timing pattern ...\n            for(let j = 5; j >= 0; j--){\n                formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);\n            }\n            // Read the top-right/bottom-left pattern too\n            const dimension = this.bitMatrix.getHeight();\n            let formatInfoBits2 = 0;\n            const jMin = dimension - 7;\n            for(let j = dimension - 1; j >= jMin; j--){\n                formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);\n            }\n            for(let i = dimension - 8; i < dimension; i++){\n                formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);\n            }\n            this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);\n            if (this.parsedFormatInfo !== null) {\n                return this.parsedFormatInfo;\n            }\n            throw new FormatException();\n        }\n        /**\n         * <p>Reads version information from one of its two locations within the QR Code.</p>\n         *\n         * @return {@link Version} encapsulating the QR Code's version\n         * @throws FormatException if both version information locations cannot be parsed as\n         * the valid encoding of version information\n         */ readVersion() {\n            if (this.parsedVersion !== null && this.parsedVersion !== undefined) {\n                return this.parsedVersion;\n            }\n            const dimension = this.bitMatrix.getHeight();\n            const provisionalVersion = Math.floor((dimension - 17) / 4);\n            if (provisionalVersion <= 6) {\n                return Version$1.getVersionForNumber(provisionalVersion);\n            }\n            // Read top-right version info: 3 wide by 6 tall\n            let versionBits = 0;\n            const ijMin = dimension - 11;\n            for(let j = 5; j >= 0; j--){\n                for(let i = dimension - 9; i >= ijMin; i--){\n                    versionBits = this.copyBit(i, j, versionBits);\n                }\n            }\n            let theParsedVersion = Version$1.decodeVersionInformation(versionBits);\n            if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n                this.parsedVersion = theParsedVersion;\n                return theParsedVersion;\n            }\n            // Hmm, failed. Try bottom left: 6 wide by 3 tall\n            versionBits = 0;\n            for(let i = 5; i >= 0; i--){\n                for(let j = dimension - 9; j >= ijMin; j--){\n                    versionBits = this.copyBit(i, j, versionBits);\n                }\n            }\n            theParsedVersion = Version$1.decodeVersionInformation(versionBits);\n            if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n                this.parsedVersion = theParsedVersion;\n                return theParsedVersion;\n            }\n            throw new FormatException();\n        }\n        copyBit(i /*int*/ , j /*int*/ , versionBits /*int*/ ) {\n            const bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);\n            return bit ? versionBits << 1 | 0x1 : versionBits << 1;\n        }\n        /**\n         * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the\n         * correct order in order to reconstruct the codewords bytes contained within the\n         * QR Code.</p>\n         *\n         * @return bytes encoded within the QR Code\n         * @throws FormatException if the exact number of bytes expected is not read\n         */ readCodewords() {\n            const formatInfo = this.readFormatInformation();\n            const version = this.readVersion();\n            // Get the data mask for the format used in this QR Code. This will exclude\n            // some bits from reading as we wind through the bit matrix.\n            const dataMask = DataMask.values.get(formatInfo.getDataMask());\n            const dimension = this.bitMatrix.getHeight();\n            dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n            const functionPattern = version.buildFunctionPattern();\n            let readingUp = true;\n            const result = new Uint8Array(version.getTotalCodewords());\n            let resultOffset = 0;\n            let currentByte = 0;\n            let bitsRead = 0;\n            // Read columns in pairs, from right to left\n            for(let j = dimension - 1; j > 0; j -= 2){\n                if (j === 6) {\n                    // Skip whole column with vertical alignment pattern\n                    // saves time and makes the other code proceed more cleanly\n                    j--;\n                }\n                // Read alternatingly from bottom to top then top to bottom\n                for(let count = 0; count < dimension; count++){\n                    const i = readingUp ? dimension - 1 - count : count;\n                    for(let col = 0; col < 2; col++){\n                        // Ignore bits covered by the function pattern\n                        if (!functionPattern.get(j - col, i)) {\n                            // Read a bit\n                            bitsRead++;\n                            currentByte <<= 1;\n                            if (this.bitMatrix.get(j - col, i)) {\n                                currentByte |= 1;\n                            }\n                            // If we've made a whole byte, save it off\n                            if (bitsRead === 8) {\n                                result[resultOffset++] = /*(byte) */ currentByte;\n                                bitsRead = 0;\n                                currentByte = 0;\n                            }\n                        }\n                    }\n                }\n                readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions\n            }\n            if (resultOffset !== version.getTotalCodewords()) {\n                throw new FormatException();\n            }\n            return result;\n        }\n        /**\n         * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.\n         */ remask() {\n            if (this.parsedFormatInfo === null) {\n                return; // We have no format information, and have no data mask\n            }\n            const dataMask = DataMask.values[this.parsedFormatInfo.getDataMask()];\n            const dimension = this.bitMatrix.getHeight();\n            dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n        }\n        /**\n         * Prepare the parser for a mirrored operation.\n         * This flag has effect only on the {@link #readFormatInformation()} and the\n         * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the\n         * {@link #mirror()} method should be called.\n         *\n         * @param mirror Whether to read version and format information mirrored.\n         */ setMirror(isMirror) {\n            this.parsedVersion = null;\n            this.parsedFormatInfo = null;\n            this.isMirror = isMirror;\n        }\n        /** Mirror the bit matrix in order to attempt a second reading. */ mirror() {\n            const bitMatrix = this.bitMatrix;\n            for(let x = 0, width = bitMatrix.getWidth(); x < width; x++){\n                for(let y = x + 1, height = bitMatrix.getHeight(); y < height; y++){\n                    if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {\n                        bitMatrix.flip(y, x);\n                        bitMatrix.flip(x, y);\n                    }\n                }\n            }\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into\n     * multiple blocks, each of which is a unit of data and error-correction codewords. Each\n     * is represented by an instance of this class.</p>\n     *\n     * @author Sean Owen\n     */ class DataBlock$1 {\n        constructor(numDataCodewords /*int*/ , codewords){\n            this.numDataCodewords = numDataCodewords;\n            this.codewords = codewords;\n        }\n        /**\n         * <p>When QR Codes use multiple data blocks, they are actually interleaved.\n         * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This\n         * method will separate the data into original blocks.</p>\n         *\n         * @param rawCodewords bytes as read directly from the QR Code\n         * @param version version of the QR Code\n         * @param ecLevel error-correction level of the QR Code\n         * @return DataBlocks containing original bytes, \"de-interleaved\" from representation in the\n         *         QR Code\n         */ static getDataBlocks(rawCodewords, version, ecLevel) {\n            if (rawCodewords.length !== version.getTotalCodewords()) {\n                throw new IllegalArgumentException();\n            }\n            // Figure out the number and size of data blocks used by this version and\n            // error correction level\n            const ecBlocks = version.getECBlocksForLevel(ecLevel);\n            // First count the total number of data blocks\n            let totalBlocks = 0;\n            const ecBlockArray = ecBlocks.getECBlocks();\n            for (const ecBlock of ecBlockArray){\n                totalBlocks += ecBlock.getCount();\n            }\n            // Now establish DataBlocks of the appropriate size and number of data codewords\n            const result = new Array(totalBlocks);\n            let numResultBlocks = 0;\n            for (const ecBlock of ecBlockArray){\n                for(let i = 0; i < ecBlock.getCount(); i++){\n                    const numDataCodewords = ecBlock.getDataCodewords();\n                    const numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;\n                    result[numResultBlocks++] = new DataBlock$1(numDataCodewords, new Uint8Array(numBlockCodewords));\n                }\n            }\n            // All blocks have the same amount of data, except that the last n\n            // (where n may be 0) have 1 more byte. Figure out where these start.\n            const shorterBlocksTotalCodewords = result[0].codewords.length;\n            let longerBlocksStartAt = result.length - 1;\n            // TYPESCRIPTPORT: check length is correct here\n            while(longerBlocksStartAt >= 0){\n                const numCodewords = result[longerBlocksStartAt].codewords.length;\n                if (numCodewords === shorterBlocksTotalCodewords) {\n                    break;\n                }\n                longerBlocksStartAt--;\n            }\n            longerBlocksStartAt++;\n            const shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();\n            // The last elements of result may be 1 element longer\n            // first fill out as many elements as all of them have\n            let rawCodewordsOffset = 0;\n            for(let i = 0; i < shorterBlocksNumDataCodewords; i++){\n                for(let j = 0; j < numResultBlocks; j++){\n                    result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\n                }\n            }\n            // Fill out the last data block in the longer ones\n            for(let j = longerBlocksStartAt; j < numResultBlocks; j++){\n                result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];\n            }\n            // Now add in error correction blocks\n            const max = result[0].codewords.length;\n            for(let i = shorterBlocksNumDataCodewords; i < max; i++){\n                for(let j = 0; j < numResultBlocks; j++){\n                    const iOffset = j < longerBlocksStartAt ? i : i + 1;\n                    result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\n                }\n            }\n            return result;\n        }\n        getNumDataCodewords() {\n            return this.numDataCodewords;\n        }\n        getCodewords() {\n            return this.codewords;\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ var ModeValues;\n    (function(ModeValues) {\n        ModeValues[ModeValues[\"TERMINATOR\"] = 0] = \"TERMINATOR\";\n        ModeValues[ModeValues[\"NUMERIC\"] = 1] = \"NUMERIC\";\n        ModeValues[ModeValues[\"ALPHANUMERIC\"] = 2] = \"ALPHANUMERIC\";\n        ModeValues[ModeValues[\"STRUCTURED_APPEND\"] = 3] = \"STRUCTURED_APPEND\";\n        ModeValues[ModeValues[\"BYTE\"] = 4] = \"BYTE\";\n        ModeValues[ModeValues[\"ECI\"] = 5] = \"ECI\";\n        ModeValues[ModeValues[\"KANJI\"] = 6] = \"KANJI\";\n        ModeValues[ModeValues[\"FNC1_FIRST_POSITION\"] = 7] = \"FNC1_FIRST_POSITION\";\n        ModeValues[ModeValues[\"FNC1_SECOND_POSITION\"] = 8] = \"FNC1_SECOND_POSITION\";\n        /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */ ModeValues[ModeValues[\"HANZI\"] = 9] = \"HANZI\";\n    })(ModeValues || (ModeValues = {}));\n    /**\n     * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which\n     * data can be encoded to bits in the QR code standard.</p>\n     *\n     * @author Sean Owen\n     */ class Mode$1 {\n        constructor(value, stringValue, characterCountBitsForVersions, bits /*int*/ ){\n            this.value = value;\n            this.stringValue = stringValue;\n            this.characterCountBitsForVersions = characterCountBitsForVersions;\n            this.bits = bits;\n            Mode$1.FOR_BITS.set(bits, this);\n            Mode$1.FOR_VALUE.set(value, this);\n        }\n        /**\n         * @param bits four bits encoding a QR Code data mode\n         * @return Mode encoded by these bits\n         * @throws IllegalArgumentException if bits do not correspond to a known mode\n         */ static forBits(bits /*int*/ ) {\n            const mode = Mode$1.FOR_BITS.get(bits);\n            if (undefined === mode) {\n                throw new IllegalArgumentException();\n            }\n            return mode;\n        }\n        /**\n         * @param version version in question\n         * @return number of bits used, in this QR Code symbol {@link Version}, to encode the\n         *         count of characters that will follow encoded in this Mode\n         */ getCharacterCountBits(version) {\n            const versionNumber = version.getVersionNumber();\n            let offset;\n            if (versionNumber <= 9) {\n                offset = 0;\n            } else if (versionNumber <= 26) {\n                offset = 1;\n            } else {\n                offset = 2;\n            }\n            return this.characterCountBitsForVersions[offset];\n        }\n        getValue() {\n            return this.value;\n        }\n        getBits() {\n            return this.bits;\n        }\n        equals(o) {\n            if (!(o instanceof Mode$1)) {\n                return false;\n            }\n            const other = o;\n            return this.value === other.value;\n        }\n        toString() {\n            return this.stringValue;\n        }\n    }\n    Mode$1.FOR_BITS = new Map();\n    Mode$1.FOR_VALUE = new Map();\n    Mode$1.TERMINATOR = new Mode$1(ModeValues.TERMINATOR, \"TERMINATOR\", Int32Array.from([\n        0,\n        0,\n        0\n    ]), 0x00); // Not really a mode...\n    Mode$1.NUMERIC = new Mode$1(ModeValues.NUMERIC, \"NUMERIC\", Int32Array.from([\n        10,\n        12,\n        14\n    ]), 0x01);\n    Mode$1.ALPHANUMERIC = new Mode$1(ModeValues.ALPHANUMERIC, \"ALPHANUMERIC\", Int32Array.from([\n        9,\n        11,\n        13\n    ]), 0x02);\n    Mode$1.STRUCTURED_APPEND = new Mode$1(ModeValues.STRUCTURED_APPEND, \"STRUCTURED_APPEND\", Int32Array.from([\n        0,\n        0,\n        0\n    ]), 0x03); // Not supported\n    Mode$1.BYTE = new Mode$1(ModeValues.BYTE, \"BYTE\", Int32Array.from([\n        8,\n        16,\n        16\n    ]), 0x04);\n    Mode$1.ECI = new Mode$1(ModeValues.ECI, \"ECI\", Int32Array.from([\n        0,\n        0,\n        0\n    ]), 0x07); // character counts don't apply\n    Mode$1.KANJI = new Mode$1(ModeValues.KANJI, \"KANJI\", Int32Array.from([\n        8,\n        10,\n        12\n    ]), 0x08);\n    Mode$1.FNC1_FIRST_POSITION = new Mode$1(ModeValues.FNC1_FIRST_POSITION, \"FNC1_FIRST_POSITION\", Int32Array.from([\n        0,\n        0,\n        0\n    ]), 0x05);\n    Mode$1.FNC1_SECOND_POSITION = new Mode$1(ModeValues.FNC1_SECOND_POSITION, \"FNC1_SECOND_POSITION\", Int32Array.from([\n        0,\n        0,\n        0\n    ]), 0x09);\n    /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */ Mode$1.HANZI = new Mode$1(ModeValues.HANZI, \"HANZI\", Int32Array.from([\n        8,\n        10,\n        12\n    ]), 0x0D);\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*import java.io.UnsupportedEncodingException;*/ /*import java.util.ArrayList;*/ /*import java.util.Collection;*/ /*import java.util.List;*/ /*import java.util.Map;*/ /**\n     * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\n     * in one QR Code. This class decodes the bits back into text.</p>\n     *\n     * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\n     *\n     * @author Sean Owen\n     */ class DecodedBitStreamParser$1 {\n        static decode(bytes, version, ecLevel, hints) {\n            const bits = new BitSource(bytes);\n            let result = new StringBuilder();\n            const byteSegments = new Array(); // 1\n            // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\n            let symbolSequence = -1;\n            let parityData = -1;\n            try {\n                let currentCharacterSetECI = null;\n                let fc1InEffect = false;\n                let mode;\n                do {\n                    // While still another segment to read...\n                    if (bits.available() < 4) {\n                        // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\n                        mode = Mode$1.TERMINATOR;\n                    } else {\n                        const modeBits = bits.readBits(4);\n                        mode = Mode$1.forBits(modeBits); // mode is encoded by 4 bits\n                    }\n                    switch(mode){\n                        case Mode$1.TERMINATOR:\n                            break;\n                        case Mode$1.FNC1_FIRST_POSITION:\n                        case Mode$1.FNC1_SECOND_POSITION:\n                            // We do little with FNC1 except alter the parsed result a bit according to the spec\n                            fc1InEffect = true;\n                            break;\n                        case Mode$1.STRUCTURED_APPEND:\n                            if (bits.available() < 16) {\n                                throw new FormatException();\n                            }\n                            // sequence number and parity is added later to the result metadata\n                            // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\n                            symbolSequence = bits.readBits(8);\n                            parityData = bits.readBits(8);\n                            break;\n                        case Mode$1.ECI:\n                            // Count doesn't apply to ECI\n                            const value = DecodedBitStreamParser$1.parseECIValue(bits);\n                            currentCharacterSetECI = CharacterSetECI.getCharacterSetECIByValue(value);\n                            if (currentCharacterSetECI === null) {\n                                throw new FormatException();\n                            }\n                            break;\n                        case Mode$1.HANZI:\n                            // First handle Hanzi mode which does not start with character count\n                            // Chinese mode contains a sub set indicator right after mode indicator\n                            const subset = bits.readBits(4);\n                            const countHanzi = bits.readBits(mode.getCharacterCountBits(version));\n                            if (subset === DecodedBitStreamParser$1.GB2312_SUBSET) {\n                                DecodedBitStreamParser$1.decodeHanziSegment(bits, result, countHanzi);\n                            }\n                            break;\n                        default:\n                            // \"Normal\" QR code modes:\n                            // How many characters will follow, encoded in this mode?\n                            const count = bits.readBits(mode.getCharacterCountBits(version));\n                            switch(mode){\n                                case Mode$1.NUMERIC:\n                                    DecodedBitStreamParser$1.decodeNumericSegment(bits, result, count);\n                                    break;\n                                case Mode$1.ALPHANUMERIC:\n                                    DecodedBitStreamParser$1.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\n                                    break;\n                                case Mode$1.BYTE:\n                                    DecodedBitStreamParser$1.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\n                                    break;\n                                case Mode$1.KANJI:\n                                    DecodedBitStreamParser$1.decodeKanjiSegment(bits, result, count);\n                                    break;\n                                default:\n                                    throw new FormatException();\n                            }\n                            break;\n                    }\n                }while (mode !== Mode$1.TERMINATOR);\n            } catch (iae /*: IllegalArgumentException*/ ) {\n                // from readBits() calls\n                throw new FormatException();\n            }\n            return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\n        }\n        /**\n         * See specification GBT 18284-2000\n         */ static decodeHanziSegment(bits, result, count /*int*/ ) {\n            // Don't crash trying to read more bits than we have available.\n            if (count * 13 > bits.available()) {\n                throw new FormatException();\n            }\n            // Each character will require 2 bytes. Read the characters as 2-byte pairs\n            // and decode as GB2312 afterwards\n            const buffer = new Uint8Array(2 * count);\n            let offset = 0;\n            while(count > 0){\n                // Each 13 bits encodes a 2-byte character\n                const twoBytes = bits.readBits(13);\n                let assembledTwoBytes = twoBytes / 0x060 << 8 & 0xFFFFFFFF | twoBytes % 0x060;\n                if (assembledTwoBytes < 0x003BF) {\n                    // In the 0xA1A1 to 0xAAFE range\n                    assembledTwoBytes += 0x0A1A1;\n                } else {\n                    // In the 0xB0A1 to 0xFAFE range\n                    assembledTwoBytes += 0x0A6A1;\n                }\n                buffer[offset] = /*(byte) */ assembledTwoBytes >> 8 & 0xFF;\n                buffer[offset + 1] = /*(byte) */ assembledTwoBytes & 0xFF;\n                offset += 2;\n                count--;\n            }\n            try {\n                result.append(StringEncoding.decode(buffer, StringUtils.GB2312));\n            // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\n            } catch (ignored /*: UnsupportedEncodingException*/ ) {\n                throw new FormatException(ignored);\n            }\n        }\n        static decodeKanjiSegment(bits, result, count /*int*/ ) {\n            // Don't crash trying to read more bits than we have available.\n            if (count * 13 > bits.available()) {\n                throw new FormatException();\n            }\n            // Each character will require 2 bytes. Read the characters as 2-byte pairs\n            // and decode as Shift_JIS afterwards\n            const buffer = new Uint8Array(2 * count);\n            let offset = 0;\n            while(count > 0){\n                // Each 13 bits encodes a 2-byte character\n                const twoBytes = bits.readBits(13);\n                let assembledTwoBytes = twoBytes / 0x0C0 << 8 & 0xFFFFFFFF | twoBytes % 0x0C0;\n                if (assembledTwoBytes < 0x01F00) {\n                    // In the 0x8140 to 0x9FFC range\n                    assembledTwoBytes += 0x08140;\n                } else {\n                    // In the 0xE040 to 0xEBBF range\n                    assembledTwoBytes += 0x0C140;\n                }\n                buffer[offset] = /*(byte) */ assembledTwoBytes >> 8;\n                buffer[offset + 1] = /*(byte) */ assembledTwoBytes;\n                offset += 2;\n                count--;\n            }\n            // Shift_JIS may not be supported in some environments:\n            try {\n                result.append(StringEncoding.decode(buffer, StringUtils.SHIFT_JIS));\n            // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\n            } catch (ignored /*: UnsupportedEncodingException*/ ) {\n                throw new FormatException(ignored);\n            }\n        }\n        static decodeByteSegment(bits, result, count /*int*/ , currentCharacterSetECI, byteSegments, hints) {\n            // Don't crash trying to read more bits than we have available.\n            if (8 * count > bits.available()) {\n                throw new FormatException();\n            }\n            const readBytes = new Uint8Array(count);\n            for(let i = 0; i < count; i++){\n                readBytes[i] = /*(byte) */ bits.readBits(8);\n            }\n            let encoding;\n            if (currentCharacterSetECI === null) {\n                // The spec isn't clear on this mode; see\n                // section 6.4.5: t does not say which encoding to assuming\n                // upon decoding. I have seen ISO-8859-1 used as well as\n                // Shift_JIS -- without anything like an ECI designator to\n                // give a hint.\n                encoding = StringUtils.guessEncoding(readBytes, hints);\n            } else {\n                encoding = currentCharacterSetECI.getName();\n            }\n            try {\n                result.append(StringEncoding.decode(readBytes, encoding));\n            } catch (ignored /*: UnsupportedEncodingException*/ ) {\n                throw new FormatException(ignored);\n            }\n            byteSegments.push(readBytes);\n        }\n        static toAlphaNumericChar(value /*int*/ ) {\n            if (value >= DecodedBitStreamParser$1.ALPHANUMERIC_CHARS.length) {\n                throw new FormatException();\n            }\n            return DecodedBitStreamParser$1.ALPHANUMERIC_CHARS[value];\n        }\n        static decodeAlphanumericSegment(bits, result, count /*int*/ , fc1InEffect) {\n            // Read two characters at a time\n            const start = result.length();\n            while(count > 1){\n                if (bits.available() < 11) {\n                    throw new FormatException();\n                }\n                const nextTwoCharsBits = bits.readBits(11);\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(nextTwoCharsBits % 45));\n                count -= 2;\n            }\n            if (count === 1) {\n                // special case: one character left\n                if (bits.available() < 6) {\n                    throw new FormatException();\n                }\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(bits.readBits(6)));\n            }\n            // See section 6.4.8.1, 6.4.8.2\n            if (fc1InEffect) {\n                // We need to massage the result a bit if in an FNC1 mode:\n                for(let i = start; i < result.length(); i++){\n                    if (result.charAt(i) === \"%\") {\n                        if (i < result.length() - 1 && result.charAt(i + 1) === \"%\") {\n                            // %% is rendered as %\n                            result.deleteCharAt(i + 1);\n                        } else {\n                            // In alpha mode, % should be converted to FNC1 separator 0x1D\n                            result.setCharAt(i, String.fromCharCode(0x1D));\n                        }\n                    }\n                }\n            }\n        }\n        static decodeNumericSegment(bits, result, count /*int*/ ) {\n            // Read three digits at a time\n            while(count >= 3){\n                // Each 10 bits encodes three digits\n                if (bits.available() < 10) {\n                    throw new FormatException();\n                }\n                const threeDigitsBits = bits.readBits(10);\n                if (threeDigitsBits >= 1000) {\n                    throw new FormatException();\n                }\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(threeDigitsBits % 10));\n                count -= 3;\n            }\n            if (count === 2) {\n                // Two digits left over to read, encoded in 7 bits\n                if (bits.available() < 7) {\n                    throw new FormatException();\n                }\n                const twoDigitsBits = bits.readBits(7);\n                if (twoDigitsBits >= 100) {\n                    throw new FormatException();\n                }\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(twoDigitsBits % 10));\n            } else if (count === 1) {\n                // One digit left over to read\n                if (bits.available() < 4) {\n                    throw new FormatException();\n                }\n                const digitBits = bits.readBits(4);\n                if (digitBits >= 10) {\n                    throw new FormatException();\n                }\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(digitBits));\n            }\n        }\n        static parseECIValue(bits) {\n            const firstByte = bits.readBits(8);\n            if ((firstByte & 0x80) === 0) {\n                // just one byte\n                return firstByte & 0x7F;\n            }\n            if ((firstByte & 0xC0) === 0x80) {\n                // two bytes\n                const secondByte = bits.readBits(8);\n                return (firstByte & 0x3F) << 8 & 0xFFFFFFFF | secondByte;\n            }\n            if ((firstByte & 0xE0) === 0xC0) {\n                // three bytes\n                const secondThirdBytes = bits.readBits(16);\n                return (firstByte & 0x1F) << 16 & 0xFFFFFFFF | secondThirdBytes;\n            }\n            throw new FormatException();\n        }\n    }\n    /**\n     * See ISO 18004:2006, 6.4.4 Table 5\n     */ DecodedBitStreamParser$1.ALPHANUMERIC_CHARS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n    DecodedBitStreamParser$1.GB2312_SUBSET = 1;\n    // function Uint8ArrayToString(a: Uint8Array): string {\n    //     const CHUNK_SZ = 0x8000;\n    //     const c = new StringBuilder();\n    //     for (let i = 0, length = a.length; i < length; i += CHUNK_SZ) {\n    //         c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\n    //     }\n    //     return c.toString();\n    // }\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * Meta-data container for QR Code decoding. Instances of this class may be used to convey information back to the\n     * decoding caller. Callers are expected to process this.\n     *\n     * @see com.google.zxing.common.DecoderResult#getOther()\n     */ class QRCodeDecoderMetaData {\n        constructor(mirrored){\n            this.mirrored = mirrored;\n        }\n        /**\n         * @return true if the QR Code was mirrored.\n         */ isMirrored() {\n            return this.mirrored;\n        }\n        /**\n         * Apply the result points' order correction due to mirroring.\n         *\n         * @param points Array of points to apply mirror correction to.\n         */ applyMirroredCorrection(points) {\n            if (!this.mirrored || points === null || points.length < 3) {\n                return;\n            }\n            const bottomLeft = points[0];\n            points[0] = points[2];\n            points[2] = bottomLeft;\n        // No need to 'fix' top-left and alignment pattern.\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*import java.util.Map;*/ /**\n     * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting\n     * the QR Code from an image.</p>\n     *\n     * @author Sean Owen\n     */ class Decoder$2 {\n        constructor(){\n            this.rsDecoder = new ReedSolomonDecoder(GenericGF.QR_CODE_FIELD_256);\n        }\n        // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {\n        //   return decode(image, null)\n        // }\n        /**\n         * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.\n         * \"true\" is taken to mean a black module.</p>\n         *\n         * @param image booleans representing white/black QR Code modules\n         * @param hints decoding hints that should be used to influence decoding\n         * @return text and bytes encoded within the QR Code\n         * @throws FormatException if the QR Code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */ decodeBooleanArray(image, hints) {\n            return this.decodeBitMatrix(BitMatrix.parseFromBooleanArray(image), hints);\n        }\n        // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {\n        //   return decode(bits, null)\n        // }\n        /**\n         * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken to mean a black module.</p>\n         *\n         * @param bits booleans representing white/black QR Code modules\n         * @param hints decoding hints that should be used to influence decoding\n         * @return text and bytes encoded within the QR Code\n         * @throws FormatException if the QR Code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */ decodeBitMatrix(bits, hints) {\n            // Construct a parser and read version, error-correction level\n            const parser = new BitMatrixParser$1(bits);\n            let ex = null;\n            try {\n                return this.decodeBitMatrixParser(parser, hints);\n            } catch (e /*: FormatException, ChecksumException*/ ) {\n                ex = e;\n            }\n            try {\n                // Revert the bit matrix\n                parser.remask();\n                // Will be attempting a mirrored reading of the version and format info.\n                parser.setMirror(true);\n                // Preemptively read the version.\n                parser.readVersion();\n                // Preemptively read the format information.\n                parser.readFormatInformation();\n                /*\n                 * Since we're here, this means we have successfully detected some kind\n                 * of version and format information when mirrored. This is a good sign,\n                 * that the QR code may be mirrored, and we should try once more with a\n                 * mirrored content.\n                 */ // Prepare for a mirrored reading.\n                parser.mirror();\n                const result = this.decodeBitMatrixParser(parser, hints);\n                // Success! Notify the caller that the code was mirrored.\n                result.setOther(new QRCodeDecoderMetaData(true));\n                return result;\n            } catch (e /*FormatException | ChecksumException*/ ) {\n                // Throw the exception from the original reading\n                if (ex !== null) {\n                    throw ex;\n                }\n                throw e;\n            }\n        }\n        decodeBitMatrixParser(parser, hints) {\n            const version = parser.readVersion();\n            const ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\n            // Read codewords\n            const codewords = parser.readCodewords();\n            // Separate into data blocks\n            const dataBlocks = DataBlock$1.getDataBlocks(codewords, version, ecLevel);\n            // Count total number of data bytes\n            let totalBytes = 0;\n            for (const dataBlock of dataBlocks){\n                totalBytes += dataBlock.getNumDataCodewords();\n            }\n            const resultBytes = new Uint8Array(totalBytes);\n            let resultOffset = 0;\n            // Error-correct and copy data blocks together into a stream of bytes\n            for (const dataBlock of dataBlocks){\n                const codewordBytes = dataBlock.getCodewords();\n                const numDataCodewords = dataBlock.getNumDataCodewords();\n                this.correctErrors(codewordBytes, numDataCodewords);\n                for(let i = 0; i < numDataCodewords; i++){\n                    resultBytes[resultOffset++] = codewordBytes[i];\n                }\n            }\n            // Decode the contents of that stream of bytes\n            return DecodedBitStreamParser$1.decode(resultBytes, version, ecLevel, hints);\n        }\n        /**\n         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n         * correct the errors in-place using Reed-Solomon error correction.</p>\n         *\n         * @param codewordBytes data and error correction codewords\n         * @param numDataCodewords number of codewords that are data bytes\n         * @throws ChecksumException if error correction fails\n         */ correctErrors(codewordBytes, numDataCodewords /*int*/ ) {\n            // const numCodewords = codewordBytes.length;\n            // First read into an array of ints\n            const codewordsInts = new Int32Array(codewordBytes);\n            // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?\n            // const codewordsInts = new Int32Array(numCodewords)\n            // for (let i = 0; i < numCodewords; i++) {\n            //   codewordsInts[i] = codewordBytes[i] & 0xFF\n            // }\n            try {\n                this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n            } catch (ignored /*: ReedSolomonException*/ ) {\n                throw new ChecksumException();\n            }\n            // Copy back into array of bytes -- only need to worry about the bytes that were data\n            // We don't care about errors in the error-correction codewords\n            for(let i = 0; i < numDataCodewords; i++){\n                codewordBytes[i] = /*(byte) */ codewordsInts[i];\n            }\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>Encapsulates an alignment pattern, which are the smaller square patterns found in\n     * all but the simplest QR Codes.</p>\n     *\n     * @author Sean Owen\n     */ class AlignmentPattern extends ResultPoint {\n        constructor(posX /*float*/ , posY /*float*/ , estimatedModuleSize /*float*/ ){\n            super(posX, posY);\n            this.estimatedModuleSize = estimatedModuleSize;\n        }\n        /**\n         * <p>Determines if this alignment pattern \"about equals\" an alignment pattern at the stated\n         * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>\n         */ aboutEquals(moduleSize /*float*/ , i /*float*/ , j /*float*/ ) {\n            if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {\n                const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n                return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;\n            }\n            return false;\n        }\n        /**\n         * Combines this object's current estimate of a finder pattern position and module size\n         * with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.\n         */ combineEstimate(i /*float*/ , j /*float*/ , newModuleSize /*float*/ ) {\n            const combinedX = (this.getX() + j) / 2.0;\n            const combinedY = (this.getY() + i) / 2.0;\n            const combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2.0;\n            return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*import java.util.ArrayList;*/ /*import java.util.List;*/ /**\n     * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder\n     * patterns but are smaller and appear at regular intervals throughout the image.</p>\n     *\n     * <p>At the moment this only looks for the bottom-right alignment pattern.</p>\n     *\n     * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,\n     * pasted and stripped down here for maximum performance but does unfortunately duplicate\n     * some code.</p>\n     *\n     * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>\n     *\n     * @author Sean Owen\n     */ class AlignmentPatternFinder {\n        /**\n         * <p>Creates a finder that will look in a portion of the whole image.</p>\n         *\n         * @param image image to search\n         * @param startX left column from which to start searching\n         * @param startY top row from which to start searching\n         * @param width width of region to search\n         * @param height height of region to search\n         * @param moduleSize estimated module size so far\n         */ constructor(image, startX /*int*/ , startY /*int*/ , width /*int*/ , height /*int*/ , moduleSize /*float*/ , resultPointCallback){\n            this.image = image;\n            this.startX = startX;\n            this.startY = startY;\n            this.width = width;\n            this.height = height;\n            this.moduleSize = moduleSize;\n            this.resultPointCallback = resultPointCallback;\n            this.possibleCenters = []; // new Array<any>(5))\n            // TYPESCRIPTPORT: array initialization without size as the length is checked below\n            this.crossCheckStateCount = new Int32Array(3);\n        }\n        /**\n         * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since\n         * it's pretty performance-critical and so is written to be fast foremost.</p>\n         *\n         * @return {@link AlignmentPattern} if found\n         * @throws NotFoundException if not found\n         */ find() {\n            const startX = this.startX;\n            const height = this.height;\n            const width = this.width;\n            const maxJ = startX + width;\n            const middleI = this.startY + height / 2;\n            // We are looking for black/white/black modules in 1:1:1 ratio\n            // this tracks the number of black/white/black modules seen so far\n            const stateCount = new Int32Array(3);\n            const image = this.image;\n            for(let iGen = 0; iGen < height; iGen++){\n                // Search from middle outwards\n                const i = middleI + ((iGen & 0x01) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));\n                stateCount[0] = 0;\n                stateCount[1] = 0;\n                stateCount[2] = 0;\n                let j = startX;\n                // Burn off leading white pixels before anything else; if we start in the middle of\n                // a white run, it doesn't make sense to count its length, since we don't know if the\n                // white run continued to the left of the start point\n                while(j < maxJ && !image.get(j, i)){\n                    j++;\n                }\n                let currentState = 0;\n                while(j < maxJ){\n                    if (image.get(j, i)) {\n                        // Black pixel\n                        if (currentState === 1) {\n                            stateCount[1]++;\n                        } else {\n                            if (currentState === 2) {\n                                if (this.foundPatternCross(stateCount)) {\n                                    const confirmed = this.handlePossibleCenter(stateCount, i, j);\n                                    if (confirmed !== null) {\n                                        return confirmed;\n                                    }\n                                }\n                                stateCount[0] = stateCount[2];\n                                stateCount[1] = 1;\n                                stateCount[2] = 0;\n                                currentState = 1;\n                            } else {\n                                stateCount[++currentState]++;\n                            }\n                        }\n                    } else {\n                        if (currentState === 1) {\n                            currentState++;\n                        }\n                        stateCount[currentState]++;\n                    }\n                    j++;\n                }\n                if (this.foundPatternCross(stateCount)) {\n                    const confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\n                    if (confirmed !== null) {\n                        return confirmed;\n                    }\n                }\n            }\n            // Hmm, nothing we saw was observed and confirmed twice. If we had\n            // any guess at all, return it.\n            if (this.possibleCenters.length !== 0) {\n                return this.possibleCenters[0];\n            }\n            throw new NotFoundException();\n        }\n        /**\n         * Given a count of black/white/black pixels just seen and an end position,\n         * figures the location of the center of this black/white/black run.\n         */ static centerFromEnd(stateCount, end /*int*/ ) {\n            return end - stateCount[2] - stateCount[1] / 2.0;\n        }\n        /**\n         * @param stateCount count of black/white/black pixels just read\n         * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios\n         *         used by alignment patterns to be considered a match\n         */ foundPatternCross(stateCount) {\n            const moduleSize = this.moduleSize;\n            const maxVariance = moduleSize / 2.0;\n            for(let i = 0; i < 3; i++){\n                if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * <p>After a horizontal scan finds a potential alignment pattern, this method\n         * \"cross-checks\" by scanning down vertically through the center of the possible\n         * alignment pattern to see if the same proportion is detected.</p>\n         *\n         * @param startI row where an alignment pattern was detected\n         * @param centerJ center of the section that appears to cross an alignment pattern\n         * @param maxCount maximum reasonable number of modules that should be\n         * observed in any reading state, based on the results of the horizontal scan\n         * @return vertical center of alignment pattern, or {@link Float#NaN} if not found\n         */ crossCheckVertical(startI /*int*/ , centerJ /*int*/ , maxCount /*int*/ , originalStateCountTotal /*int*/ ) {\n            const image = this.image;\n            const maxI = image.getHeight();\n            const stateCount = this.crossCheckStateCount;\n            stateCount[0] = 0;\n            stateCount[1] = 0;\n            stateCount[2] = 0;\n            // Start counting up from center\n            let i = startI;\n            while(i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount){\n                stateCount[1]++;\n                i--;\n            }\n            // If already too many modules in this state or ran off the edge:\n            if (i < 0 || stateCount[1] > maxCount) {\n                return NaN;\n            }\n            while(i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount){\n                stateCount[0]++;\n                i--;\n            }\n            if (stateCount[0] > maxCount) {\n                return NaN;\n            }\n            // Now also count down from center\n            i = startI + 1;\n            while(i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount){\n                stateCount[1]++;\n                i++;\n            }\n            if (i === maxI || stateCount[1] > maxCount) {\n                return NaN;\n            }\n            while(i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount){\n                stateCount[2]++;\n                i++;\n            }\n            if (stateCount[2] > maxCount) {\n                return NaN;\n            }\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n                return NaN;\n            }\n            return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;\n        }\n        /**\n         * <p>This is called when a horizontal scan finds a possible alignment pattern. It will\n         * cross check with a vertical scan, and if successful, will see if this pattern had been\n         * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have\n         * found the alignment pattern.</p>\n         *\n         * @param stateCount reading state module counts from horizontal scan\n         * @param i row where alignment pattern may be found\n         * @param j end of possible alignment pattern in row\n         * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not\n         */ handlePossibleCenter(stateCount, i /*int*/ , j /*int*/ ) {\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n            const centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);\n            const centerI = this.crossCheckVertical(i, /*(int) */ centerJ, 2 * stateCount[1], stateCountTotal);\n            if (!isNaN(centerI)) {\n                const estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;\n                for (const center of this.possibleCenters){\n                    // Look for about the same center and module size:\n                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n                        return center.combineEstimate(centerI, centerJ, estimatedModuleSize);\n                    }\n                }\n                // Hadn't found this before; save it\n                const point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);\n                this.possibleCenters.push(point);\n                if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {\n                    this.resultPointCallback.foundPossibleResultPoint(point);\n                }\n            }\n            return null;\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>Encapsulates a finder pattern, which are the three square patterns found in\n     * the corners of QR Codes. It also encapsulates a count of similar finder patterns,\n     * as a convenience to the finder's bookkeeping.</p>\n     *\n     * @author Sean Owen\n     */ class FinderPattern$1 extends ResultPoint {\n        // FinderPattern(posX: number/*float*/, posY: number/*float*/, estimatedModuleSize: number/*float*/) {\n        //   this(posX, posY, estimatedModuleSize, 1)\n        // }\n        constructor(posX /*float*/ , posY /*float*/ , estimatedModuleSize /*float*/ , count /*int*/ ){\n            super(posX, posY);\n            this.estimatedModuleSize = estimatedModuleSize;\n            this.count = count;\n            if (undefined === count) {\n                this.count = 1;\n            }\n        }\n        getEstimatedModuleSize() {\n            return this.estimatedModuleSize;\n        }\n        getCount() {\n            return this.count;\n        }\n        /*\n        void incrementCount() {\n          this.count++\n        }\n         */ /**\n         * <p>Determines if this finder pattern \"about equals\" a finder pattern at the stated\n         * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>\n         */ aboutEquals(moduleSize /*float*/ , i /*float*/ , j /*float*/ ) {\n            if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {\n                const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n                return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;\n            }\n            return false;\n        }\n        /**\n         * Combines this object's current estimate of a finder pattern position and module size\n         * with a new estimate. It returns a new {@code FinderPattern} containing a weighted average\n         * based on count.\n         */ combineEstimate(i /*float*/ , j /*float*/ , newModuleSize /*float*/ ) {\n            const combinedCount = this.count + 1;\n            const combinedX = (this.count * this.getX() + j) / combinedCount;\n            const combinedY = (this.count * this.getY() + i) / combinedCount;\n            const combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;\n            return new FinderPattern$1(combinedX, combinedY, combinedModuleSize, combinedCount);\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>Encapsulates information about finder patterns in an image, including the location of\n     * the three finder patterns, and their estimated module size.</p>\n     *\n     * @author Sean Owen\n     */ class FinderPatternInfo {\n        constructor(patternCenters){\n            this.bottomLeft = patternCenters[0];\n            this.topLeft = patternCenters[1];\n            this.topRight = patternCenters[2];\n        }\n        getBottomLeft() {\n            return this.bottomLeft;\n        }\n        getTopLeft() {\n            return this.topLeft;\n        }\n        getTopRight() {\n            return this.topRight;\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*import java.io.Serializable;*/ /*import java.util.ArrayList;*/ /*import java.util.Collections;*/ /*import java.util.Comparator;*/ /*import java.util.List;*/ /*import java.util.Map;*/ /**\n     * <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square\n     * markers at three corners of a QR Code.</p>\n     *\n     * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.\n     *\n     * @author Sean Owen\n     */ class FinderPatternFinder {\n        /**\n         * <p>Creates a finder that will search the image for three finder patterns.</p>\n         *\n         * @param image image to search\n         */ // public constructor(image: BitMatrix) {\n        //   this(image, null)\n        // }\n        constructor(image, resultPointCallback){\n            this.image = image;\n            this.resultPointCallback = resultPointCallback;\n            this.possibleCenters = [];\n            this.crossCheckStateCount = new Int32Array(5);\n            this.resultPointCallback = resultPointCallback;\n        }\n        getImage() {\n            return this.image;\n        }\n        getPossibleCenters() {\n            return this.possibleCenters;\n        }\n        find(hints) {\n            const tryHarder = hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType$1.TRY_HARDER);\n            const pureBarcode = hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType$1.PURE_BARCODE);\n            const image = this.image;\n            const maxI = image.getHeight();\n            const maxJ = image.getWidth();\n            // We are looking for black/white/black/white/black modules in\n            // 1:1:3:1:1 ratio; this tracks the number of such modules seen so far\n            // Let's assume that the maximum version QR Code we support takes up 1/4 the height of the\n            // image, and then account for the center being 3 modules in size. This gives the smallest\n            // number of pixels the center could be, so skip this often. When trying harder, look for all\n            // QR versions regardless of how dense they are.\n            let iSkip = Math.floor(3 * maxI / (4 * FinderPatternFinder.MAX_MODULES));\n            if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {\n                iSkip = FinderPatternFinder.MIN_SKIP;\n            }\n            let done = false;\n            const stateCount = new Int32Array(5);\n            for(let i = iSkip - 1; i < maxI && !done; i += iSkip){\n                // Get a row of black/white values\n                stateCount[0] = 0;\n                stateCount[1] = 0;\n                stateCount[2] = 0;\n                stateCount[3] = 0;\n                stateCount[4] = 0;\n                let currentState = 0;\n                for(let j = 0; j < maxJ; j++){\n                    if (image.get(j, i)) {\n                        // Black pixel\n                        if ((currentState & 1) === 1) {\n                            currentState++;\n                        }\n                        stateCount[currentState]++;\n                    } else {\n                        if ((currentState & 1) === 0) {\n                            if (currentState === 4) {\n                                if (FinderPatternFinder.foundPatternCross(stateCount)) {\n                                    const confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);\n                                    if (confirmed === true) {\n                                        // Start examining every other line. Checking each line turned out to be too\n                                        // expensive and didn't improve performance.\n                                        iSkip = 2;\n                                        if (this.hasSkipped === true) {\n                                            done = this.haveMultiplyConfirmedCenters();\n                                        } else {\n                                            const rowSkip = this.findRowSkip();\n                                            if (rowSkip > stateCount[2]) {\n                                                // Skip rows between row of lower confirmed center\n                                                // and top of presumed third confirmed center\n                                                // but back up a bit to get a full chance of detecting\n                                                // it, entire width of center of finder pattern\n                                                // Skip by rowSkip, but back off by stateCount[2] (size of last center\n                                                // of pattern we saw) to be conservative, and also back off by iSkip which\n                                                // is about to be re-added\n                                                i += rowSkip - stateCount[2] - iSkip;\n                                                j = maxJ - 1;\n                                            }\n                                        }\n                                    } else {\n                                        stateCount[0] = stateCount[2];\n                                        stateCount[1] = stateCount[3];\n                                        stateCount[2] = stateCount[4];\n                                        stateCount[3] = 1;\n                                        stateCount[4] = 0;\n                                        currentState = 3;\n                                        continue;\n                                    }\n                                    // Clear state to start looking again\n                                    currentState = 0;\n                                    stateCount[0] = 0;\n                                    stateCount[1] = 0;\n                                    stateCount[2] = 0;\n                                    stateCount[3] = 0;\n                                    stateCount[4] = 0;\n                                } else {\n                                    stateCount[0] = stateCount[2];\n                                    stateCount[1] = stateCount[3];\n                                    stateCount[2] = stateCount[4];\n                                    stateCount[3] = 1;\n                                    stateCount[4] = 0;\n                                    currentState = 3;\n                                }\n                            } else {\n                                stateCount[++currentState]++;\n                            }\n                        } else {\n                            stateCount[currentState]++;\n                        }\n                    }\n                }\n                if (FinderPatternFinder.foundPatternCross(stateCount)) {\n                    const confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);\n                    if (confirmed === true) {\n                        iSkip = stateCount[0];\n                        if (this.hasSkipped) {\n                            // Found a third one\n                            done = this.haveMultiplyConfirmedCenters();\n                        }\n                    }\n                }\n            }\n            const patternInfo = this.selectBestPatterns();\n            ResultPoint.orderBestPatterns(patternInfo);\n            return new FinderPatternInfo(patternInfo);\n        }\n        /**\n         * Given a count of black/white/black/white/black pixels just seen and an end position,\n         * figures the location of the center of this run.\n         */ static centerFromEnd(stateCount, end /*int*/ ) {\n            return end - stateCount[4] - stateCount[3] - stateCount[2] / 2.0;\n        }\n        /**\n         * @param stateCount count of black/white/black/white/black pixels just read\n         * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios\n         *         used by finder patterns to be considered a match\n         */ static foundPatternCross(stateCount) {\n            let totalModuleSize = 0;\n            for(let i = 0; i < 5; i++){\n                const count = stateCount[i];\n                if (count === 0) {\n                    return false;\n                }\n                totalModuleSize += count;\n            }\n            if (totalModuleSize < 7) {\n                return false;\n            }\n            const moduleSize = totalModuleSize / 7.0;\n            const maxVariance = moduleSize / 2.0;\n            // Allow less than 50% variance from 1-1-3-1-1 proportions\n            return Math.abs(moduleSize - stateCount[0]) < maxVariance && Math.abs(moduleSize - stateCount[1]) < maxVariance && Math.abs(3.0 * moduleSize - stateCount[2]) < 3 * maxVariance && Math.abs(moduleSize - stateCount[3]) < maxVariance && Math.abs(moduleSize - stateCount[4]) < maxVariance;\n        }\n        getCrossCheckStateCount() {\n            const crossCheckStateCount = this.crossCheckStateCount;\n            crossCheckStateCount[0] = 0;\n            crossCheckStateCount[1] = 0;\n            crossCheckStateCount[2] = 0;\n            crossCheckStateCount[3] = 0;\n            crossCheckStateCount[4] = 0;\n            return crossCheckStateCount;\n        }\n        /**\n         * After a vertical and horizontal scan finds a potential finder pattern, this method\n         * \"cross-cross-cross-checks\" by scanning down diagonally through the center of the possible\n         * finder pattern to see if the same proportion is detected.\n         *\n         * @param startI row where a finder pattern was detected\n         * @param centerJ center of the section that appears to cross a finder pattern\n         * @param maxCount maximum reasonable number of modules that should be\n         *  observed in any reading state, based on the results of the horizontal scan\n         * @param originalStateCountTotal The original state count total.\n         * @return true if proportions are withing expected limits\n         */ crossCheckDiagonal(startI /*int*/ , centerJ /*int*/ , maxCount /*int*/ , originalStateCountTotal /*int*/ ) {\n            const stateCount = this.getCrossCheckStateCount();\n            // Start counting up, left from center finding black center mass\n            let i = 0;\n            const image = this.image;\n            while(startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)){\n                stateCount[2]++;\n                i++;\n            }\n            if (startI < i || centerJ < i) {\n                return false;\n            }\n            // Continue up, left finding white space\n            while(startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) && stateCount[1] <= maxCount){\n                stateCount[1]++;\n                i++;\n            }\n            // If already too many modules in this state or ran off the edge:\n            if (startI < i || centerJ < i || stateCount[1] > maxCount) {\n                return false;\n            }\n            // Continue up, left finding black border\n            while(startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) && stateCount[0] <= maxCount){\n                stateCount[0]++;\n                i++;\n            }\n            if (stateCount[0] > maxCount) {\n                return false;\n            }\n            const maxI = image.getHeight();\n            const maxJ = image.getWidth();\n            // Now also count down, right from center\n            i = 1;\n            while(startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)){\n                stateCount[2]++;\n                i++;\n            }\n            // Ran off the edge?\n            if (startI + i >= maxI || centerJ + i >= maxJ) {\n                return false;\n            }\n            while(startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) && stateCount[3] < maxCount){\n                stateCount[3]++;\n                i++;\n            }\n            if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {\n                return false;\n            }\n            while(startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) && stateCount[4] < maxCount){\n                stateCount[4]++;\n                i++;\n            }\n            if (stateCount[4] >= maxCount) {\n                return false;\n            }\n            // If we found a finder-pattern-like section, but its size is more than 100% different than\n            // the original, assume it's a false positive\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n            return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal && FinderPatternFinder.foundPatternCross(stateCount);\n        }\n        /**\n         * <p>After a horizontal scan finds a potential finder pattern, this method\n         * \"cross-checks\" by scanning down vertically through the center of the possible\n         * finder pattern to see if the same proportion is detected.</p>\n         *\n         * @param startI row where a finder pattern was detected\n         * @param centerJ center of the section that appears to cross a finder pattern\n         * @param maxCount maximum reasonable number of modules that should be\n         * observed in any reading state, based on the results of the horizontal scan\n         * @return vertical center of finder pattern, or {@link Float#NaN} if not found\n         */ crossCheckVertical(startI /*int*/ , centerJ /*int*/ , maxCount /*int*/ , originalStateCountTotal /*int*/ ) {\n            const image = this.image;\n            const maxI = image.getHeight();\n            const stateCount = this.getCrossCheckStateCount();\n            // Start counting up from center\n            let i = startI;\n            while(i >= 0 && image.get(centerJ, i)){\n                stateCount[2]++;\n                i--;\n            }\n            if (i < 0) {\n                return NaN;\n            }\n            while(i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount){\n                stateCount[1]++;\n                i--;\n            }\n            // If already too many modules in this state or ran off the edge:\n            if (i < 0 || stateCount[1] > maxCount) {\n                return NaN;\n            }\n            while(i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount){\n                stateCount[0]++;\n                i--;\n            }\n            if (stateCount[0] > maxCount) {\n                return NaN;\n            }\n            // Now also count down from center\n            i = startI + 1;\n            while(i < maxI && image.get(centerJ, i)){\n                stateCount[2]++;\n                i++;\n            }\n            if (i === maxI) {\n                return NaN;\n            }\n            while(i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount){\n                stateCount[3]++;\n                i++;\n            }\n            if (i === maxI || stateCount[3] >= maxCount) {\n                return NaN;\n            }\n            while(i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount){\n                stateCount[4]++;\n                i++;\n            }\n            if (stateCount[4] >= maxCount) {\n                return NaN;\n            }\n            // If we found a finder-pattern-like section, but its size is more than 40% different than\n            // the original, assume it's a false positive\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n                return NaN;\n            }\n            return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i) : NaN;\n        }\n        /**\n         * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,\n         * except it reads horizontally instead of vertically. This is used to cross-cross\n         * check a vertical cross check and locate the real center of the alignment pattern.</p>\n         */ crossCheckHorizontal(startJ /*int*/ , centerI /*int*/ , maxCount /*int*/ , originalStateCountTotal /*int*/ ) {\n            const image = this.image;\n            const maxJ = image.getWidth();\n            const stateCount = this.getCrossCheckStateCount();\n            let j = startJ;\n            while(j >= 0 && image.get(j, centerI)){\n                stateCount[2]++;\n                j--;\n            }\n            if (j < 0) {\n                return NaN;\n            }\n            while(j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount){\n                stateCount[1]++;\n                j--;\n            }\n            if (j < 0 || stateCount[1] > maxCount) {\n                return NaN;\n            }\n            while(j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount){\n                stateCount[0]++;\n                j--;\n            }\n            if (stateCount[0] > maxCount) {\n                return NaN;\n            }\n            j = startJ + 1;\n            while(j < maxJ && image.get(j, centerI)){\n                stateCount[2]++;\n                j++;\n            }\n            if (j === maxJ) {\n                return NaN;\n            }\n            while(j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount){\n                stateCount[3]++;\n                j++;\n            }\n            if (j === maxJ || stateCount[3] >= maxCount) {\n                return NaN;\n            }\n            while(j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount){\n                stateCount[4]++;\n                j++;\n            }\n            if (stateCount[4] >= maxCount) {\n                return NaN;\n            }\n            // If we found a finder-pattern-like section, but its size is significantly different than\n            // the original, assume it's a false positive\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {\n                return NaN;\n            }\n            return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j) : NaN;\n        }\n        /**\n         * <p>This is called when a horizontal scan finds a possible alignment pattern. It will\n         * cross check with a vertical scan, and if successful, will, ah, cross-cross-check\n         * with another horizontal scan. This is needed primarily to locate the real horizontal\n         * center of the pattern in cases of extreme skew.\n         * And then we cross-cross-cross check with another diagonal scan.</p>\n         *\n         * <p>If that succeeds the finder pattern location is added to a list that tracks\n         * the number of times each location has been nearly-matched as a finder pattern.\n         * Each additional find is more evidence that the location is in fact a finder\n         * pattern center\n         *\n         * @param stateCount reading state module counts from horizontal scan\n         * @param i row where finder pattern may be found\n         * @param j end of possible finder pattern in row\n         * @param pureBarcode true if in \"pure barcode\" mode\n         * @return true if a finder pattern candidate was found this time\n         */ handlePossibleCenter(stateCount, i /*int*/ , j /*int*/ , pureBarcode) {\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n            let centerJ = FinderPatternFinder.centerFromEnd(stateCount, j);\n            let centerI = this.crossCheckVertical(i, /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal);\n            if (!isNaN(centerI)) {\n                // Re-cross check\n                centerJ = this.crossCheckHorizontal(/*(int) */ Math.floor(centerJ), /*(int) */ Math.floor(centerI), stateCount[2], stateCountTotal);\n                if (!isNaN(centerJ) && (!pureBarcode || this.crossCheckDiagonal(/*(int) */ Math.floor(centerI), /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal))) {\n                    const estimatedModuleSize = stateCountTotal / 7.0;\n                    let found = false;\n                    const possibleCenters = this.possibleCenters;\n                    for(let index = 0, length = possibleCenters.length; index < length; index++){\n                        const center = possibleCenters[index];\n                        // Look for about the same center and module size:\n                        if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n                            possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        const point = new FinderPattern$1(centerJ, centerI, estimatedModuleSize);\n                        possibleCenters.push(point);\n                        if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {\n                            this.resultPointCallback.foundPossibleResultPoint(point);\n                        }\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        /**\n         * @return number of rows we could safely skip during scanning, based on the first\n         *         two finder patterns that have been located. In some cases their position will\n         *         allow us to infer that the third pattern must lie below a certain point farther\n         *         down in the image.\n         */ findRowSkip() {\n            const max = this.possibleCenters.length;\n            if (max <= 1) {\n                return 0;\n            }\n            let firstConfirmedCenter = null;\n            for (const center of this.possibleCenters){\n                if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {\n                    if (firstConfirmedCenter == null) {\n                        firstConfirmedCenter = center;\n                    } else {\n                        // We have two confirmed centers\n                        // How far down can we skip before resuming looking for the next\n                        // pattern? In the worst case, only the difference between the\n                        // difference in the x / y coordinates of the two centers.\n                        // This is the case where you find top left last.\n                        this.hasSkipped = true;\n                        return /*(int) */ Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) - Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);\n                    }\n                }\n            }\n            return 0;\n        }\n        /**\n         * @return true iff we have found at least 3 finder patterns that have been detected\n         *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the\n         *         candidates is \"pretty similar\"\n         */ haveMultiplyConfirmedCenters() {\n            let confirmedCount = 0;\n            let totalModuleSize = 0.0;\n            const max = this.possibleCenters.length;\n            for (const pattern of this.possibleCenters){\n                if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {\n                    confirmedCount++;\n                    totalModuleSize += pattern.getEstimatedModuleSize();\n                }\n            }\n            if (confirmedCount < 3) {\n                return false;\n            }\n            // OK, we have at least 3 confirmed centers, but, it's possible that one is a \"false positive\"\n            // and that we need to keep looking. We detect this by asking if the estimated module sizes\n            // vary too much. We arbitrarily say that when the total deviation from average exceeds\n            // 5% of the total module size estimates, it's too much.\n            const average = totalModuleSize / max;\n            let totalDeviation = 0.0;\n            for (const pattern of this.possibleCenters){\n                totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);\n            }\n            return totalDeviation <= 0.05 * totalModuleSize;\n        }\n        /**\n         * @return the 3 best {@link FinderPattern}s from our list of candidates. The \"best\" are\n         *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module\n         *         size differs from the average among those patterns the least\n         * @throws NotFoundException if 3 such finder patterns do not exist\n         */ selectBestPatterns() {\n            const startSize = this.possibleCenters.length;\n            if (startSize < 3) {\n                // Couldn't find enough finder patterns\n                throw new NotFoundException();\n            }\n            const possibleCenters = this.possibleCenters;\n            let average;\n            // Filter outlier possibilities whose module size is too different\n            if (startSize > 3) {\n                // But we can only afford to do so if we have at least 4 possibilities to choose from\n                let totalModuleSize = 0.0;\n                let square = 0.0;\n                for (const center of this.possibleCenters){\n                    const size = center.getEstimatedModuleSize();\n                    totalModuleSize += size;\n                    square += size * size;\n                }\n                average = totalModuleSize / startSize;\n                let stdDev = Math.sqrt(square / startSize - average * average);\n                possibleCenters.sort(/**\n                 * <p>Orders by furthest from average</p>\n                 */ // FurthestFromAverageComparator implements Comparator<FinderPattern>\n                (center1, center2)=>{\n                    const dA = Math.abs(center2.getEstimatedModuleSize() - average);\n                    const dB = Math.abs(center1.getEstimatedModuleSize() - average);\n                    return dA < dB ? -1 : dA > dB ? 1 : 0;\n                });\n                const limit = Math.max(0.2 * average, stdDev);\n                for(let i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++){\n                    const pattern = possibleCenters[i];\n                    if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {\n                        possibleCenters.splice(i, 1);\n                        i--;\n                    }\n                }\n            }\n            if (possibleCenters.length > 3) {\n                // Throw away all but those first size candidate points we found.\n                let totalModuleSize = 0.0;\n                for (const possibleCenter of possibleCenters){\n                    totalModuleSize += possibleCenter.getEstimatedModuleSize();\n                }\n                average = totalModuleSize / possibleCenters.length;\n                possibleCenters.sort(/**\n                 * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>\n                 */ // CenterComparator implements Comparator<FinderPattern>\n                (center1, center2)=>{\n                    if (center2.getCount() === center1.getCount()) {\n                        const dA = Math.abs(center2.getEstimatedModuleSize() - average);\n                        const dB = Math.abs(center1.getEstimatedModuleSize() - average);\n                        return dA < dB ? 1 : dA > dB ? -1 : 0;\n                    } else {\n                        return center2.getCount() - center1.getCount();\n                    }\n                });\n                possibleCenters.splice(3); // this is not realy necessary as we only return first 3 anyway\n            }\n            return [\n                possibleCenters[0],\n                possibleCenters[1],\n                possibleCenters[2]\n            ];\n        }\n    }\n    FinderPatternFinder.CENTER_QUORUM = 2;\n    FinderPatternFinder.MIN_SKIP = 3; // 1 pixel/module times 3 modules/center\n    FinderPatternFinder.MAX_MODULES = 57; // support up to version 10 for mobile clients\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*import java.util.Map;*/ /**\n     * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code\n     * is rotated or skewed, or partially obscured.</p>\n     *\n     * @author Sean Owen\n     */ class Detector$2 {\n        constructor(image){\n            this.image = image;\n        }\n        getImage() {\n            return this.image;\n        }\n        getResultPointCallback() {\n            return this.resultPointCallback;\n        }\n        /**\n         * <p>Detects a QR Code in an image.</p>\n         *\n         * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n         * @throws NotFoundException if QR Code cannot be found\n         * @throws FormatException if a QR Code cannot be decoded\n         */ // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {\n        //   return detect(null)\n        // }\n        /**\n         * <p>Detects a QR Code in an image.</p>\n         *\n         * @param hints optional hints to detector\n         * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n         * @throws NotFoundException if QR Code cannot be found\n         * @throws FormatException if a QR Code cannot be decoded\n         */ detect(hints) {\n            this.resultPointCallback = hints === null || hints === undefined ? null : /*(ResultPointCallback) */ hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n            const finder = new FinderPatternFinder(this.image, this.resultPointCallback);\n            const info = finder.find(hints);\n            return this.processFinderPatternInfo(info);\n        }\n        processFinderPatternInfo(info) {\n            const topLeft = info.getTopLeft();\n            const topRight = info.getTopRight();\n            const bottomLeft = info.getBottomLeft();\n            const moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);\n            if (moduleSize < 1.0) {\n                throw new NotFoundException(\"No pattern found in proccess finder.\");\n            }\n            const dimension = Detector$2.computeDimension(topLeft, topRight, bottomLeft, moduleSize);\n            const provisionalVersion = Version$1.getProvisionalVersionForDimension(dimension);\n            const modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;\n            let alignmentPattern = null;\n            // Anything above version 1 has an alignment pattern\n            if (provisionalVersion.getAlignmentPatternCenters().length > 0) {\n                // Guess where a \"bottom right\" finder pattern would have been\n                const bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();\n                const bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();\n                // Estimate that alignment pattern is closer by 3 modules\n                // from \"bottom right\" to known top left location\n                const correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;\n                const estAlignmentX = /*(int) */ Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));\n                const estAlignmentY = /*(int) */ Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));\n                // Kind of arbitrary -- expand search radius before giving up\n                for(let i = 4; i <= 16; i <<= 1){\n                    try {\n                        alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);\n                        break;\n                    } catch (re /*NotFoundException*/ ) {\n                        if (!(re instanceof NotFoundException)) {\n                            throw re;\n                        }\n                    // try next round\n                    }\n                }\n            // If we didn't find alignment pattern... well try anyway without it\n            }\n            const transform = Detector$2.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);\n            const bits = Detector$2.sampleGrid(this.image, transform, dimension);\n            let points;\n            if (alignmentPattern === null) {\n                points = [\n                    bottomLeft,\n                    topLeft,\n                    topRight\n                ];\n            } else {\n                points = [\n                    bottomLeft,\n                    topLeft,\n                    topRight,\n                    alignmentPattern\n                ];\n            }\n            return new DetectorResult(bits, points);\n        }\n        static createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension /*int*/ ) {\n            const dimMinusThree = dimension - 3.5;\n            let bottomRightX; /*float*/ \n            let bottomRightY; /*float*/ \n            let sourceBottomRightX; /*float*/ \n            let sourceBottomRightY; /*float*/ \n            if (alignmentPattern !== null) {\n                bottomRightX = alignmentPattern.getX();\n                bottomRightY = alignmentPattern.getY();\n                sourceBottomRightX = dimMinusThree - 3.0;\n                sourceBottomRightY = sourceBottomRightX;\n            } else {\n                // Don't have an alignment pattern, just make up the bottom-right point\n                bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();\n                bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();\n                sourceBottomRightX = dimMinusThree;\n                sourceBottomRightY = dimMinusThree;\n            }\n            return PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());\n        }\n        static sampleGrid(image, transform, dimension /*int*/ ) {\n            const sampler = GridSamplerInstance.getInstance();\n            return sampler.sampleGridWithTransform(image, dimension, dimension, transform);\n        }\n        /**\n         * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position\n         * of the finder patterns and estimated module size.</p>\n         */ static computeDimension(topLeft, topRight, bottomLeft, moduleSize /*float*/ ) {\n            const tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);\n            const tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);\n            let dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;\n            switch(dimension & 0x03){\n                case 0:\n                    dimension++;\n                    break;\n                // 1? do nothing\n                case 2:\n                    dimension--;\n                    break;\n                case 3:\n                    throw new NotFoundException(\"Dimensions could be not found.\");\n            }\n            return dimension;\n        }\n        /**\n         * <p>Computes an average estimated module size based on estimated derived from the positions\n         * of the three finder patterns.</p>\n         *\n         * @param topLeft detected top-left finder pattern center\n         * @param topRight detected top-right finder pattern center\n         * @param bottomLeft detected bottom-left finder pattern center\n         * @return estimated module size\n         */ calculateModuleSize(topLeft, topRight, bottomLeft) {\n            // Take the average\n            return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;\n        }\n        /**\n         * <p>Estimates module size based on two finder patterns -- it uses\n         * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the\n         * width of each, measuring along the axis between their centers.</p>\n         */ calculateModuleSizeOneWay(pattern, otherPattern) {\n            const moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(pattern.getX()), /*(int) */ Math.floor(pattern.getY()), /*(int) */ Math.floor(otherPattern.getX()), /*(int) */ Math.floor(otherPattern.getY()));\n            const moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(otherPattern.getX()), /*(int) */ Math.floor(otherPattern.getY()), /*(int) */ Math.floor(pattern.getX()), /*(int) */ Math.floor(pattern.getY()));\n            if (isNaN(moduleSizeEst1)) {\n                return moduleSizeEst2 / 7.0;\n            }\n            if (isNaN(moduleSizeEst2)) {\n                return moduleSizeEst1 / 7.0;\n            }\n            // Average them, and divide by 7 since we've counted the width of 3 black modules,\n            // and 1 white and 1 black module on either side. Ergo, divide sum by 14.\n            return (moduleSizeEst1 + moduleSizeEst2) / 14.0;\n        }\n        /**\n         * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of\n         * a finder pattern by looking for a black-white-black run from the center in the direction\n         * of another point (another finder pattern center), and in the opposite direction too.\n         */ sizeOfBlackWhiteBlackRunBothWays(fromX /*int*/ , fromY /*int*/ , toX /*int*/ , toY /*int*/ ) {\n            let result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);\n            // Now count other way -- don't run off image though of course\n            let scale = 1.0;\n            let otherToX = fromX - (toX - fromX);\n            if (otherToX < 0) {\n                scale = fromX / /*(float) */ (fromX - otherToX);\n                otherToX = 0;\n            } else if (otherToX >= this.image.getWidth()) {\n                scale = (this.image.getWidth() - 1 - fromX) / /*(float) */ (otherToX - fromX);\n                otherToX = this.image.getWidth() - 1;\n            }\n            let otherToY = /*(int) */ Math.floor(fromY - (toY - fromY) * scale);\n            scale = 1.0;\n            if (otherToY < 0) {\n                scale = fromY / /*(float) */ (fromY - otherToY);\n                otherToY = 0;\n            } else if (otherToY >= this.image.getHeight()) {\n                scale = (this.image.getHeight() - 1 - fromY) / /*(float) */ (otherToY - fromY);\n                otherToY = this.image.getHeight() - 1;\n            }\n            otherToX = /*(int) */ Math.floor(fromX + (otherToX - fromX) * scale);\n            result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);\n            // Middle pixel is double-counted this way; subtract 1\n            return result - 1.0;\n        }\n        /**\n         * <p>This method traces a line from a point in the image, in the direction towards another point.\n         * It begins in a black region, and keeps going until it finds white, then black, then white again.\n         * It reports the distance from the start to this point.</p>\n         *\n         * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern\n         * may be skewed or rotated.</p>\n         */ sizeOfBlackWhiteBlackRun(fromX /*int*/ , fromY /*int*/ , toX /*int*/ , toY /*int*/ ) {\n            // Mild variant of Bresenham's algorithm\n            // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n            const steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n            if (steep) {\n                let temp = fromX;\n                fromX = fromY;\n                fromY = temp;\n                temp = toX;\n                toX = toY;\n                toY = temp;\n            }\n            const dx = Math.abs(toX - fromX);\n            const dy = Math.abs(toY - fromY);\n            let error = -dx / 2;\n            const xstep = fromX < toX ? 1 : -1;\n            const ystep = fromY < toY ? 1 : -1;\n            // In black pixels, looking for white, first or second time.\n            let state = 0;\n            // Loop up until x == toX, but not beyond\n            const xLimit = toX + xstep;\n            for(let x = fromX, y = fromY; x !== xLimit; x += xstep){\n                const realX = steep ? y : x;\n                const realY = steep ? x : y;\n                // Does current pixel mean we have moved white to black or vice versa?\n                // Scanning black in state 0,2 and white in state 1, so if we find the wrong\n                // color, advance to next state or end if we are in state 2 already\n                if (state === 1 === this.image.get(realX, realY)) {\n                    if (state === 2) {\n                        return MathUtils.distance(x, y, fromX, fromY);\n                    }\n                    state++;\n                }\n                error += dy;\n                if (error > 0) {\n                    if (y === toY) {\n                        break;\n                    }\n                    y += ystep;\n                    error -= dx;\n                }\n            }\n            // Found black-white-black; give the benefit of the doubt that the next pixel outside the image\n            // is \"white\" so this last point at (toX+xStep,toY) is the right ending. This is really a\n            // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this.\n            if (state === 2) {\n                return MathUtils.distance(toX + xstep, toY, fromX, fromY);\n            }\n            // else we didn't find even black-white-black; no estimate is really possible\n            return NaN;\n        }\n        /**\n         * <p>Attempts to locate an alignment pattern in a limited region of the image, which is\n         * guessed to contain it. This method uses {@link AlignmentPattern}.</p>\n         *\n         * @param overallEstModuleSize estimated module size so far\n         * @param estAlignmentX x coordinate of center of area probably containing alignment pattern\n         * @param estAlignmentY y coordinate of above\n         * @param allowanceFactor number of pixels in all directions to search from the center\n         * @return {@link AlignmentPattern} if found, or null otherwise\n         * @throws NotFoundException if an unexpected error occurs during detection\n         */ findAlignmentInRegion(overallEstModuleSize /*float*/ , estAlignmentX /*int*/ , estAlignmentY /*int*/ , allowanceFactor /*float*/ ) {\n            // Look for an alignment pattern (3 modules in size) around where it\n            // should be\n            const allowance = /*(int) */ Math.floor(allowanceFactor * overallEstModuleSize);\n            const alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);\n            const alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);\n            if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {\n                throw new NotFoundException(\"Alignment top exceeds estimated module size.\");\n            }\n            const alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);\n            const alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);\n            if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {\n                throw new NotFoundException(\"Alignment bottom exceeds estimated module size.\");\n            }\n            const alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);\n            return alignmentFinder.find();\n        }\n    }\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*import java.util.List;*/ /*import java.util.Map;*/ /**\n     * This implementation can detect and decode QR Codes in an image.\n     *\n     * @author Sean Owen\n     */ class QRCodeReader {\n        constructor(){\n            this.decoder = new Decoder$2();\n        }\n        getDecoder() {\n            return this.decoder;\n        }\n        /**\n         * Locates and decodes a QR code in an image.\n         *\n         * @return a representing: string the content encoded by the QR code\n         * @throws NotFoundException if a QR code cannot be found\n         * @throws FormatException if a QR code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */ /*@Override*/ // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\n        //   return this.decode(image, null)\n        // }\n        /*@Override*/ decode(image, hints) {\n            let decoderResult;\n            let points;\n            if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType$1.PURE_BARCODE)) {\n                const bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\n                decoderResult = this.decoder.decodeBitMatrix(bits, hints);\n                points = QRCodeReader.NO_POINTS;\n            } else {\n                const detectorResult = new Detector$2(image.getBlackMatrix()).detect(hints);\n                decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\n                points = detectorResult.getPoints();\n            }\n            // If the code was mirrored: swap the bottom-left and the top-right points.\n            if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {\n                decoderResult.getOther().applyMirroredCorrection(points);\n            }\n            const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat$1.QR_CODE, undefined);\n            const byteSegments = decoderResult.getByteSegments();\n            if (byteSegments !== null) {\n                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);\n            }\n            const ecLevel = decoderResult.getECLevel();\n            if (ecLevel !== null) {\n                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);\n            }\n            if (decoderResult.hasStructuredAppend()) {\n                result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\n                result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\n            }\n            return result;\n        }\n        /*@Override*/ reset() {\n        // do nothing\n        }\n        /**\n         * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n         * which contains only an unrotated, unskewed, image of a code, with some white border\n         * around it. This is a specialized method that works exceptionally fast in this special\n         * case.\n         *\n         * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\n         */ static extractPureBits(image) {\n            const leftTopBlack = image.getTopLeftOnBit();\n            const rightBottomBlack = image.getBottomRightOnBit();\n            if (leftTopBlack === null || rightBottomBlack === null) {\n                throw new NotFoundException();\n            }\n            const moduleSize = this.moduleSize(leftTopBlack, image);\n            let top = leftTopBlack[1];\n            let bottom = rightBottomBlack[1];\n            let left = leftTopBlack[0];\n            let right = rightBottomBlack[0];\n            // Sanity check!\n            if (left >= right || top >= bottom) {\n                throw new NotFoundException();\n            }\n            if (bottom - top !== right - left) {\n                // Special case, where bottom-right module wasn't black so we found something else in the last row\n                // Assume it's a square, so use height as the width\n                right = left + (bottom - top);\n                if (right >= image.getWidth()) {\n                    // Abort if that would not make sense -- off image\n                    throw new NotFoundException();\n                }\n            }\n            const matrixWidth = Math.round((right - left + 1) / moduleSize);\n            const matrixHeight = Math.round((bottom - top + 1) / moduleSize);\n            if (matrixWidth <= 0 || matrixHeight <= 0) {\n                throw new NotFoundException();\n            }\n            if (matrixHeight !== matrixWidth) {\n                // Only possibly decode square regions\n                throw new NotFoundException();\n            }\n            // Push in the \"border\" by half the module width so that we start\n            // sampling in the middle of the module. Just in case the image is a\n            // little off, this will help recover.\n            const nudge = /*(int) */ Math.floor(moduleSize / 2.0);\n            top += nudge;\n            left += nudge;\n            // But careful that this does not sample off the edge\n            // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\n            // This is positive by how much the inner x loop below would be too large\n            const nudgedTooFarRight = left + /*(int) */ Math.floor((matrixWidth - 1) * moduleSize) - right;\n            if (nudgedTooFarRight > 0) {\n                if (nudgedTooFarRight > nudge) {\n                    // Neither way fits; abort\n                    throw new NotFoundException();\n                }\n                left -= nudgedTooFarRight;\n            }\n            // See logic above\n            const nudgedTooFarDown = top + /*(int) */ Math.floor((matrixHeight - 1) * moduleSize) - bottom;\n            if (nudgedTooFarDown > 0) {\n                if (nudgedTooFarDown > nudge) {\n                    // Neither way fits; abort\n                    throw new NotFoundException();\n                }\n                top -= nudgedTooFarDown;\n            }\n            // Now just read off the bits\n            const bits = new BitMatrix(matrixWidth, matrixHeight);\n            for(let y = 0; y < matrixHeight; y++){\n                const iOffset = top + /*(int) */ Math.floor(y * moduleSize);\n                for(let x = 0; x < matrixWidth; x++){\n                    if (image.get(left + /*(int) */ Math.floor(x * moduleSize), iOffset)) {\n                        bits.set(x, y);\n                    }\n                }\n            }\n            return bits;\n        }\n        static moduleSize(leftTopBlack, image) {\n            const height = image.getHeight();\n            const width = image.getWidth();\n            let x = leftTopBlack[0];\n            let y = leftTopBlack[1];\n            let inBlack = true;\n            let transitions = 0;\n            while(x < width && y < height){\n                if (inBlack !== image.get(x, y)) {\n                    if (++transitions === 5) {\n                        break;\n                    }\n                    inBlack = !inBlack;\n                }\n                x++;\n                y++;\n            }\n            if (x === width || y === height) {\n                throw new NotFoundException();\n            }\n            return (x - leftTopBlack[0]) / 7.0;\n        }\n    }\n    QRCodeReader.NO_POINTS = new Array();\n    /*\n    * Copyright 2009 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */ /**\n     * @author SITA Lab (kevin.osullivan@sita.aero)\n     * @author Guenther Grau\n     */ /*public final*/ class PDF417Common {\n        PDF417Common() {}\n        /**\n         * @param moduleBitCount values to sum\n         * @return sum of values\n         * @deprecated call {@link MathUtils#sum(int[])}\n         */ // @Deprecated\n        static getBitCountSum(moduleBitCount) {\n            return MathUtils.sum(moduleBitCount);\n        }\n        static toIntArray(list) {\n            if (list == null || !list.length) {\n                return PDF417Common.EMPTY_INT_ARRAY;\n            }\n            const result = new Int32Array(list.length);\n            let i = 0;\n            for (const integer of list){\n                result[i++] = integer;\n            }\n            return result;\n        }\n        /**\n         * @param symbol encoded symbol to translate to a codeword\n         * @return the codeword corresponding to the symbol.\n         */ static getCodeword(symbol /*int*/ ) {\n            const i = Arrays.binarySearch(PDF417Common.SYMBOL_TABLE, symbol & 0x3FFFF);\n            if (i < 0) {\n                return -1;\n            }\n            return (PDF417Common.CODEWORD_TABLE[i] - 1) % PDF417Common.NUMBER_OF_CODEWORDS;\n        }\n    }\n    PDF417Common.NUMBER_OF_CODEWORDS = 929;\n    // Maximum Codewords (Data + Error).\n    PDF417Common.MAX_CODEWORDS_IN_BARCODE = PDF417Common.NUMBER_OF_CODEWORDS - 1;\n    PDF417Common.MIN_ROWS_IN_BARCODE = 3;\n    PDF417Common.MAX_ROWS_IN_BARCODE = 90;\n    // One left row indication column + max 30 data columns + one right row indicator column\n    // public static /*final*/ MAX_CODEWORDS_IN_ROW: /*int*/ number = 32;\n    PDF417Common.MODULES_IN_CODEWORD = 17;\n    PDF417Common.MODULES_IN_STOP_PATTERN = 18;\n    PDF417Common.BARS_IN_MODULE = 8;\n    PDF417Common.EMPTY_INT_ARRAY = new Int32Array([]);\n    /**\n     * The sorted table of all possible symbols. Extracted from the PDF417\n     * specification. The index of a symbol in this table corresponds to the\n     * index into the codeword table.\n     */ PDF417Common.SYMBOL_TABLE = Int32Array.from([\n        0x1025e,\n        0x1027a,\n        0x1029e,\n        0x102bc,\n        0x102f2,\n        0x102f4,\n        0x1032e,\n        0x1034e,\n        0x1035c,\n        0x10396,\n        0x103a6,\n        0x103ac,\n        0x10422,\n        0x10428,\n        0x10436,\n        0x10442,\n        0x10444,\n        0x10448,\n        0x10450,\n        0x1045e,\n        0x10466,\n        0x1046c,\n        0x1047a,\n        0x10482,\n        0x1049e,\n        0x104a0,\n        0x104bc,\n        0x104c6,\n        0x104d8,\n        0x104ee,\n        0x104f2,\n        0x104f4,\n        0x10504,\n        0x10508,\n        0x10510,\n        0x1051e,\n        0x10520,\n        0x1053c,\n        0x10540,\n        0x10578,\n        0x10586,\n        0x1058c,\n        0x10598,\n        0x105b0,\n        0x105be,\n        0x105ce,\n        0x105dc,\n        0x105e2,\n        0x105e4,\n        0x105e8,\n        0x105f6,\n        0x1062e,\n        0x1064e,\n        0x1065c,\n        0x1068e,\n        0x1069c,\n        0x106b8,\n        0x106de,\n        0x106fa,\n        0x10716,\n        0x10726,\n        0x1072c,\n        0x10746,\n        0x1074c,\n        0x10758,\n        0x1076e,\n        0x10792,\n        0x10794,\n        0x107a2,\n        0x107a4,\n        0x107a8,\n        0x107b6,\n        0x10822,\n        0x10828,\n        0x10842,\n        0x10848,\n        0x10850,\n        0x1085e,\n        0x10866,\n        0x1086c,\n        0x1087a,\n        0x10882,\n        0x10884,\n        0x10890,\n        0x1089e,\n        0x108a0,\n        0x108bc,\n        0x108c6,\n        0x108cc,\n        0x108d8,\n        0x108ee,\n        0x108f2,\n        0x108f4,\n        0x10902,\n        0x10908,\n        0x1091e,\n        0x10920,\n        0x1093c,\n        0x10940,\n        0x10978,\n        0x10986,\n        0x10998,\n        0x109b0,\n        0x109be,\n        0x109ce,\n        0x109dc,\n        0x109e2,\n        0x109e4,\n        0x109e8,\n        0x109f6,\n        0x10a08,\n        0x10a10,\n        0x10a1e,\n        0x10a20,\n        0x10a3c,\n        0x10a40,\n        0x10a78,\n        0x10af0,\n        0x10b06,\n        0x10b0c,\n        0x10b18,\n        0x10b30,\n        0x10b3e,\n        0x10b60,\n        0x10b7c,\n        0x10b8e,\n        0x10b9c,\n        0x10bb8,\n        0x10bc2,\n        0x10bc4,\n        0x10bc8,\n        0x10bd0,\n        0x10bde,\n        0x10be6,\n        0x10bec,\n        0x10c2e,\n        0x10c4e,\n        0x10c5c,\n        0x10c62,\n        0x10c64,\n        0x10c68,\n        0x10c76,\n        0x10c8e,\n        0x10c9c,\n        0x10cb8,\n        0x10cc2,\n        0x10cc4,\n        0x10cc8,\n        0x10cd0,\n        0x10cde,\n        0x10ce6,\n        0x10cec,\n        0x10cfa,\n        0x10d0e,\n        0x10d1c,\n        0x10d38,\n        0x10d70,\n        0x10d7e,\n        0x10d82,\n        0x10d84,\n        0x10d88,\n        0x10d90,\n        0x10d9e,\n        0x10da0,\n        0x10dbc,\n        0x10dc6,\n        0x10dcc,\n        0x10dd8,\n        0x10dee,\n        0x10df2,\n        0x10df4,\n        0x10e16,\n        0x10e26,\n        0x10e2c,\n        0x10e46,\n        0x10e58,\n        0x10e6e,\n        0x10e86,\n        0x10e8c,\n        0x10e98,\n        0x10eb0,\n        0x10ebe,\n        0x10ece,\n        0x10edc,\n        0x10f0a,\n        0x10f12,\n        0x10f14,\n        0x10f22,\n        0x10f28,\n        0x10f36,\n        0x10f42,\n        0x10f44,\n        0x10f48,\n        0x10f50,\n        0x10f5e,\n        0x10f66,\n        0x10f6c,\n        0x10fb2,\n        0x10fb4,\n        0x11022,\n        0x11028,\n        0x11042,\n        0x11048,\n        0x11050,\n        0x1105e,\n        0x1107a,\n        0x11082,\n        0x11084,\n        0x11090,\n        0x1109e,\n        0x110a0,\n        0x110bc,\n        0x110c6,\n        0x110cc,\n        0x110d8,\n        0x110ee,\n        0x110f2,\n        0x110f4,\n        0x11102,\n        0x1111e,\n        0x11120,\n        0x1113c,\n        0x11140,\n        0x11178,\n        0x11186,\n        0x11198,\n        0x111b0,\n        0x111be,\n        0x111ce,\n        0x111dc,\n        0x111e2,\n        0x111e4,\n        0x111e8,\n        0x111f6,\n        0x11208,\n        0x1121e,\n        0x11220,\n        0x11278,\n        0x112f0,\n        0x1130c,\n        0x11330,\n        0x1133e,\n        0x11360,\n        0x1137c,\n        0x1138e,\n        0x1139c,\n        0x113b8,\n        0x113c2,\n        0x113c8,\n        0x113d0,\n        0x113de,\n        0x113e6,\n        0x113ec,\n        0x11408,\n        0x11410,\n        0x1141e,\n        0x11420,\n        0x1143c,\n        0x11440,\n        0x11478,\n        0x114f0,\n        0x115e0,\n        0x1160c,\n        0x11618,\n        0x11630,\n        0x1163e,\n        0x11660,\n        0x1167c,\n        0x116c0,\n        0x116f8,\n        0x1171c,\n        0x11738,\n        0x11770,\n        0x1177e,\n        0x11782,\n        0x11784,\n        0x11788,\n        0x11790,\n        0x1179e,\n        0x117a0,\n        0x117bc,\n        0x117c6,\n        0x117cc,\n        0x117d8,\n        0x117ee,\n        0x1182e,\n        0x11834,\n        0x1184e,\n        0x1185c,\n        0x11862,\n        0x11864,\n        0x11868,\n        0x11876,\n        0x1188e,\n        0x1189c,\n        0x118b8,\n        0x118c2,\n        0x118c8,\n        0x118d0,\n        0x118de,\n        0x118e6,\n        0x118ec,\n        0x118fa,\n        0x1190e,\n        0x1191c,\n        0x11938,\n        0x11970,\n        0x1197e,\n        0x11982,\n        0x11984,\n        0x11990,\n        0x1199e,\n        0x119a0,\n        0x119bc,\n        0x119c6,\n        0x119cc,\n        0x119d8,\n        0x119ee,\n        0x119f2,\n        0x119f4,\n        0x11a0e,\n        0x11a1c,\n        0x11a38,\n        0x11a70,\n        0x11a7e,\n        0x11ae0,\n        0x11afc,\n        0x11b08,\n        0x11b10,\n        0x11b1e,\n        0x11b20,\n        0x11b3c,\n        0x11b40,\n        0x11b78,\n        0x11b8c,\n        0x11b98,\n        0x11bb0,\n        0x11bbe,\n        0x11bce,\n        0x11bdc,\n        0x11be2,\n        0x11be4,\n        0x11be8,\n        0x11bf6,\n        0x11c16,\n        0x11c26,\n        0x11c2c,\n        0x11c46,\n        0x11c4c,\n        0x11c58,\n        0x11c6e,\n        0x11c86,\n        0x11c98,\n        0x11cb0,\n        0x11cbe,\n        0x11cce,\n        0x11cdc,\n        0x11ce2,\n        0x11ce4,\n        0x11ce8,\n        0x11cf6,\n        0x11d06,\n        0x11d0c,\n        0x11d18,\n        0x11d30,\n        0x11d3e,\n        0x11d60,\n        0x11d7c,\n        0x11d8e,\n        0x11d9c,\n        0x11db8,\n        0x11dc4,\n        0x11dc8,\n        0x11dd0,\n        0x11dde,\n        0x11de6,\n        0x11dec,\n        0x11dfa,\n        0x11e0a,\n        0x11e12,\n        0x11e14,\n        0x11e22,\n        0x11e24,\n        0x11e28,\n        0x11e36,\n        0x11e42,\n        0x11e44,\n        0x11e50,\n        0x11e5e,\n        0x11e66,\n        0x11e6c,\n        0x11e82,\n        0x11e84,\n        0x11e88,\n        0x11e90,\n        0x11e9e,\n        0x11ea0,\n        0x11ebc,\n        0x11ec6,\n        0x11ecc,\n        0x11ed8,\n        0x11eee,\n        0x11f1a,\n        0x11f2e,\n        0x11f32,\n        0x11f34,\n        0x11f4e,\n        0x11f5c,\n        0x11f62,\n        0x11f64,\n        0x11f68,\n        0x11f76,\n        0x12048,\n        0x1205e,\n        0x12082,\n        0x12084,\n        0x12090,\n        0x1209e,\n        0x120a0,\n        0x120bc,\n        0x120d8,\n        0x120f2,\n        0x120f4,\n        0x12108,\n        0x1211e,\n        0x12120,\n        0x1213c,\n        0x12140,\n        0x12178,\n        0x12186,\n        0x12198,\n        0x121b0,\n        0x121be,\n        0x121e2,\n        0x121e4,\n        0x121e8,\n        0x121f6,\n        0x12204,\n        0x12210,\n        0x1221e,\n        0x12220,\n        0x12278,\n        0x122f0,\n        0x12306,\n        0x1230c,\n        0x12330,\n        0x1233e,\n        0x12360,\n        0x1237c,\n        0x1238e,\n        0x1239c,\n        0x123b8,\n        0x123c2,\n        0x123c8,\n        0x123d0,\n        0x123e6,\n        0x123ec,\n        0x1241e,\n        0x12420,\n        0x1243c,\n        0x124f0,\n        0x125e0,\n        0x12618,\n        0x1263e,\n        0x12660,\n        0x1267c,\n        0x126c0,\n        0x126f8,\n        0x12738,\n        0x12770,\n        0x1277e,\n        0x12782,\n        0x12784,\n        0x12790,\n        0x1279e,\n        0x127a0,\n        0x127bc,\n        0x127c6,\n        0x127cc,\n        0x127d8,\n        0x127ee,\n        0x12820,\n        0x1283c,\n        0x12840,\n        0x12878,\n        0x128f0,\n        0x129e0,\n        0x12bc0,\n        0x12c18,\n        0x12c30,\n        0x12c3e,\n        0x12c60,\n        0x12c7c,\n        0x12cc0,\n        0x12cf8,\n        0x12df0,\n        0x12e1c,\n        0x12e38,\n        0x12e70,\n        0x12e7e,\n        0x12ee0,\n        0x12efc,\n        0x12f04,\n        0x12f08,\n        0x12f10,\n        0x12f20,\n        0x12f3c,\n        0x12f40,\n        0x12f78,\n        0x12f86,\n        0x12f8c,\n        0x12f98,\n        0x12fb0,\n        0x12fbe,\n        0x12fce,\n        0x12fdc,\n        0x1302e,\n        0x1304e,\n        0x1305c,\n        0x13062,\n        0x13068,\n        0x1308e,\n        0x1309c,\n        0x130b8,\n        0x130c2,\n        0x130c8,\n        0x130d0,\n        0x130de,\n        0x130ec,\n        0x130fa,\n        0x1310e,\n        0x13138,\n        0x13170,\n        0x1317e,\n        0x13182,\n        0x13184,\n        0x13190,\n        0x1319e,\n        0x131a0,\n        0x131bc,\n        0x131c6,\n        0x131cc,\n        0x131d8,\n        0x131f2,\n        0x131f4,\n        0x1320e,\n        0x1321c,\n        0x13270,\n        0x1327e,\n        0x132e0,\n        0x132fc,\n        0x13308,\n        0x1331e,\n        0x13320,\n        0x1333c,\n        0x13340,\n        0x13378,\n        0x13386,\n        0x13398,\n        0x133b0,\n        0x133be,\n        0x133ce,\n        0x133dc,\n        0x133e2,\n        0x133e4,\n        0x133e8,\n        0x133f6,\n        0x1340e,\n        0x1341c,\n        0x13438,\n        0x13470,\n        0x1347e,\n        0x134e0,\n        0x134fc,\n        0x135c0,\n        0x135f8,\n        0x13608,\n        0x13610,\n        0x1361e,\n        0x13620,\n        0x1363c,\n        0x13640,\n        0x13678,\n        0x136f0,\n        0x1370c,\n        0x13718,\n        0x13730,\n        0x1373e,\n        0x13760,\n        0x1377c,\n        0x1379c,\n        0x137b8,\n        0x137c2,\n        0x137c4,\n        0x137c8,\n        0x137d0,\n        0x137de,\n        0x137e6,\n        0x137ec,\n        0x13816,\n        0x13826,\n        0x1382c,\n        0x13846,\n        0x1384c,\n        0x13858,\n        0x1386e,\n        0x13874,\n        0x13886,\n        0x13898,\n        0x138b0,\n        0x138be,\n        0x138ce,\n        0x138dc,\n        0x138e2,\n        0x138e4,\n        0x138e8,\n        0x13906,\n        0x1390c,\n        0x13930,\n        0x1393e,\n        0x13960,\n        0x1397c,\n        0x1398e,\n        0x1399c,\n        0x139b8,\n        0x139c8,\n        0x139d0,\n        0x139de,\n        0x139e6,\n        0x139ec,\n        0x139fa,\n        0x13a06,\n        0x13a0c,\n        0x13a18,\n        0x13a30,\n        0x13a3e,\n        0x13a60,\n        0x13a7c,\n        0x13ac0,\n        0x13af8,\n        0x13b0e,\n        0x13b1c,\n        0x13b38,\n        0x13b70,\n        0x13b7e,\n        0x13b88,\n        0x13b90,\n        0x13b9e,\n        0x13ba0,\n        0x13bbc,\n        0x13bcc,\n        0x13bd8,\n        0x13bee,\n        0x13bf2,\n        0x13bf4,\n        0x13c12,\n        0x13c14,\n        0x13c22,\n        0x13c24,\n        0x13c28,\n        0x13c36,\n        0x13c42,\n        0x13c48,\n        0x13c50,\n        0x13c5e,\n        0x13c66,\n        0x13c6c,\n        0x13c82,\n        0x13c84,\n        0x13c90,\n        0x13c9e,\n        0x13ca0,\n        0x13cbc,\n        0x13cc6,\n        0x13ccc,\n        0x13cd8,\n        0x13cee,\n        0x13d02,\n        0x13d04,\n        0x13d08,\n        0x13d10,\n        0x13d1e,\n        0x13d20,\n        0x13d3c,\n        0x13d40,\n        0x13d78,\n        0x13d86,\n        0x13d8c,\n        0x13d98,\n        0x13db0,\n        0x13dbe,\n        0x13dce,\n        0x13ddc,\n        0x13de4,\n        0x13de8,\n        0x13df6,\n        0x13e1a,\n        0x13e2e,\n        0x13e32,\n        0x13e34,\n        0x13e4e,\n        0x13e5c,\n        0x13e62,\n        0x13e64,\n        0x13e68,\n        0x13e76,\n        0x13e8e,\n        0x13e9c,\n        0x13eb8,\n        0x13ec2,\n        0x13ec4,\n        0x13ec8,\n        0x13ed0,\n        0x13ede,\n        0x13ee6,\n        0x13eec,\n        0x13f26,\n        0x13f2c,\n        0x13f3a,\n        0x13f46,\n        0x13f4c,\n        0x13f58,\n        0x13f6e,\n        0x13f72,\n        0x13f74,\n        0x14082,\n        0x1409e,\n        0x140a0,\n        0x140bc,\n        0x14104,\n        0x14108,\n        0x14110,\n        0x1411e,\n        0x14120,\n        0x1413c,\n        0x14140,\n        0x14178,\n        0x1418c,\n        0x14198,\n        0x141b0,\n        0x141be,\n        0x141e2,\n        0x141e4,\n        0x141e8,\n        0x14208,\n        0x14210,\n        0x1421e,\n        0x14220,\n        0x1423c,\n        0x14240,\n        0x14278,\n        0x142f0,\n        0x14306,\n        0x1430c,\n        0x14318,\n        0x14330,\n        0x1433e,\n        0x14360,\n        0x1437c,\n        0x1438e,\n        0x143c2,\n        0x143c4,\n        0x143c8,\n        0x143d0,\n        0x143e6,\n        0x143ec,\n        0x14408,\n        0x14410,\n        0x1441e,\n        0x14420,\n        0x1443c,\n        0x14440,\n        0x14478,\n        0x144f0,\n        0x145e0,\n        0x1460c,\n        0x14618,\n        0x14630,\n        0x1463e,\n        0x14660,\n        0x1467c,\n        0x146c0,\n        0x146f8,\n        0x1471c,\n        0x14738,\n        0x14770,\n        0x1477e,\n        0x14782,\n        0x14784,\n        0x14788,\n        0x14790,\n        0x147a0,\n        0x147bc,\n        0x147c6,\n        0x147cc,\n        0x147d8,\n        0x147ee,\n        0x14810,\n        0x14820,\n        0x1483c,\n        0x14840,\n        0x14878,\n        0x148f0,\n        0x149e0,\n        0x14bc0,\n        0x14c30,\n        0x14c3e,\n        0x14c60,\n        0x14c7c,\n        0x14cc0,\n        0x14cf8,\n        0x14df0,\n        0x14e38,\n        0x14e70,\n        0x14e7e,\n        0x14ee0,\n        0x14efc,\n        0x14f04,\n        0x14f08,\n        0x14f10,\n        0x14f1e,\n        0x14f20,\n        0x14f3c,\n        0x14f40,\n        0x14f78,\n        0x14f86,\n        0x14f8c,\n        0x14f98,\n        0x14fb0,\n        0x14fce,\n        0x14fdc,\n        0x15020,\n        0x15040,\n        0x15078,\n        0x150f0,\n        0x151e0,\n        0x153c0,\n        0x15860,\n        0x1587c,\n        0x158c0,\n        0x158f8,\n        0x159f0,\n        0x15be0,\n        0x15c70,\n        0x15c7e,\n        0x15ce0,\n        0x15cfc,\n        0x15dc0,\n        0x15df8,\n        0x15e08,\n        0x15e10,\n        0x15e20,\n        0x15e40,\n        0x15e78,\n        0x15ef0,\n        0x15f0c,\n        0x15f18,\n        0x15f30,\n        0x15f60,\n        0x15f7c,\n        0x15f8e,\n        0x15f9c,\n        0x15fb8,\n        0x1604e,\n        0x1605c,\n        0x1608e,\n        0x1609c,\n        0x160b8,\n        0x160c2,\n        0x160c4,\n        0x160c8,\n        0x160de,\n        0x1610e,\n        0x1611c,\n        0x16138,\n        0x16170,\n        0x1617e,\n        0x16184,\n        0x16188,\n        0x16190,\n        0x1619e,\n        0x161a0,\n        0x161bc,\n        0x161c6,\n        0x161cc,\n        0x161d8,\n        0x161f2,\n        0x161f4,\n        0x1620e,\n        0x1621c,\n        0x16238,\n        0x16270,\n        0x1627e,\n        0x162e0,\n        0x162fc,\n        0x16304,\n        0x16308,\n        0x16310,\n        0x1631e,\n        0x16320,\n        0x1633c,\n        0x16340,\n        0x16378,\n        0x16386,\n        0x1638c,\n        0x16398,\n        0x163b0,\n        0x163be,\n        0x163ce,\n        0x163dc,\n        0x163e2,\n        0x163e4,\n        0x163e8,\n        0x163f6,\n        0x1640e,\n        0x1641c,\n        0x16438,\n        0x16470,\n        0x1647e,\n        0x164e0,\n        0x164fc,\n        0x165c0,\n        0x165f8,\n        0x16610,\n        0x1661e,\n        0x16620,\n        0x1663c,\n        0x16640,\n        0x16678,\n        0x166f0,\n        0x16718,\n        0x16730,\n        0x1673e,\n        0x16760,\n        0x1677c,\n        0x1678e,\n        0x1679c,\n        0x167b8,\n        0x167c2,\n        0x167c4,\n        0x167c8,\n        0x167d0,\n        0x167de,\n        0x167e6,\n        0x167ec,\n        0x1681c,\n        0x16838,\n        0x16870,\n        0x168e0,\n        0x168fc,\n        0x169c0,\n        0x169f8,\n        0x16bf0,\n        0x16c10,\n        0x16c1e,\n        0x16c20,\n        0x16c3c,\n        0x16c40,\n        0x16c78,\n        0x16cf0,\n        0x16de0,\n        0x16e18,\n        0x16e30,\n        0x16e3e,\n        0x16e60,\n        0x16e7c,\n        0x16ec0,\n        0x16ef8,\n        0x16f1c,\n        0x16f38,\n        0x16f70,\n        0x16f7e,\n        0x16f84,\n        0x16f88,\n        0x16f90,\n        0x16f9e,\n        0x16fa0,\n        0x16fbc,\n        0x16fc6,\n        0x16fcc,\n        0x16fd8,\n        0x17026,\n        0x1702c,\n        0x17046,\n        0x1704c,\n        0x17058,\n        0x1706e,\n        0x17086,\n        0x1708c,\n        0x17098,\n        0x170b0,\n        0x170be,\n        0x170ce,\n        0x170dc,\n        0x170e8,\n        0x17106,\n        0x1710c,\n        0x17118,\n        0x17130,\n        0x1713e,\n        0x17160,\n        0x1717c,\n        0x1718e,\n        0x1719c,\n        0x171b8,\n        0x171c2,\n        0x171c4,\n        0x171c8,\n        0x171d0,\n        0x171de,\n        0x171e6,\n        0x171ec,\n        0x171fa,\n        0x17206,\n        0x1720c,\n        0x17218,\n        0x17230,\n        0x1723e,\n        0x17260,\n        0x1727c,\n        0x172c0,\n        0x172f8,\n        0x1730e,\n        0x1731c,\n        0x17338,\n        0x17370,\n        0x1737e,\n        0x17388,\n        0x17390,\n        0x1739e,\n        0x173a0,\n        0x173bc,\n        0x173cc,\n        0x173d8,\n        0x173ee,\n        0x173f2,\n        0x173f4,\n        0x1740c,\n        0x17418,\n        0x17430,\n        0x1743e,\n        0x17460,\n        0x1747c,\n        0x174c0,\n        0x174f8,\n        0x175f0,\n        0x1760e,\n        0x1761c,\n        0x17638,\n        0x17670,\n        0x1767e,\n        0x176e0,\n        0x176fc,\n        0x17708,\n        0x17710,\n        0x1771e,\n        0x17720,\n        0x1773c,\n        0x17740,\n        0x17778,\n        0x17798,\n        0x177b0,\n        0x177be,\n        0x177dc,\n        0x177e2,\n        0x177e4,\n        0x177e8,\n        0x17822,\n        0x17824,\n        0x17828,\n        0x17836,\n        0x17842,\n        0x17844,\n        0x17848,\n        0x17850,\n        0x1785e,\n        0x17866,\n        0x1786c,\n        0x17882,\n        0x17884,\n        0x17888,\n        0x17890,\n        0x1789e,\n        0x178a0,\n        0x178bc,\n        0x178c6,\n        0x178cc,\n        0x178d8,\n        0x178ee,\n        0x178f2,\n        0x178f4,\n        0x17902,\n        0x17904,\n        0x17908,\n        0x17910,\n        0x1791e,\n        0x17920,\n        0x1793c,\n        0x17940,\n        0x17978,\n        0x17986,\n        0x1798c,\n        0x17998,\n        0x179b0,\n        0x179be,\n        0x179ce,\n        0x179dc,\n        0x179e2,\n        0x179e4,\n        0x179e8,\n        0x179f6,\n        0x17a04,\n        0x17a08,\n        0x17a10,\n        0x17a1e,\n        0x17a20,\n        0x17a3c,\n        0x17a40,\n        0x17a78,\n        0x17af0,\n        0x17b06,\n        0x17b0c,\n        0x17b18,\n        0x17b30,\n        0x17b3e,\n        0x17b60,\n        0x17b7c,\n        0x17b8e,\n        0x17b9c,\n        0x17bb8,\n        0x17bc4,\n        0x17bc8,\n        0x17bd0,\n        0x17bde,\n        0x17be6,\n        0x17bec,\n        0x17c2e,\n        0x17c32,\n        0x17c34,\n        0x17c4e,\n        0x17c5c,\n        0x17c62,\n        0x17c64,\n        0x17c68,\n        0x17c76,\n        0x17c8e,\n        0x17c9c,\n        0x17cb8,\n        0x17cc2,\n        0x17cc4,\n        0x17cc8,\n        0x17cd0,\n        0x17cde,\n        0x17ce6,\n        0x17cec,\n        0x17d0e,\n        0x17d1c,\n        0x17d38,\n        0x17d70,\n        0x17d82,\n        0x17d84,\n        0x17d88,\n        0x17d90,\n        0x17d9e,\n        0x17da0,\n        0x17dbc,\n        0x17dc6,\n        0x17dcc,\n        0x17dd8,\n        0x17dee,\n        0x17e26,\n        0x17e2c,\n        0x17e3a,\n        0x17e46,\n        0x17e4c,\n        0x17e58,\n        0x17e6e,\n        0x17e72,\n        0x17e74,\n        0x17e86,\n        0x17e8c,\n        0x17e98,\n        0x17eb0,\n        0x17ece,\n        0x17edc,\n        0x17ee2,\n        0x17ee4,\n        0x17ee8,\n        0x17ef6,\n        0x1813a,\n        0x18172,\n        0x18174,\n        0x18216,\n        0x18226,\n        0x1823a,\n        0x1824c,\n        0x18258,\n        0x1826e,\n        0x18272,\n        0x18274,\n        0x18298,\n        0x182be,\n        0x182e2,\n        0x182e4,\n        0x182e8,\n        0x182f6,\n        0x1835e,\n        0x1837a,\n        0x183ae,\n        0x183d6,\n        0x18416,\n        0x18426,\n        0x1842c,\n        0x1843a,\n        0x18446,\n        0x18458,\n        0x1846e,\n        0x18472,\n        0x18474,\n        0x18486,\n        0x184b0,\n        0x184be,\n        0x184ce,\n        0x184dc,\n        0x184e2,\n        0x184e4,\n        0x184e8,\n        0x184f6,\n        0x18506,\n        0x1850c,\n        0x18518,\n        0x18530,\n        0x1853e,\n        0x18560,\n        0x1857c,\n        0x1858e,\n        0x1859c,\n        0x185b8,\n        0x185c2,\n        0x185c4,\n        0x185c8,\n        0x185d0,\n        0x185de,\n        0x185e6,\n        0x185ec,\n        0x185fa,\n        0x18612,\n        0x18614,\n        0x18622,\n        0x18628,\n        0x18636,\n        0x18642,\n        0x18650,\n        0x1865e,\n        0x1867a,\n        0x18682,\n        0x18684,\n        0x18688,\n        0x18690,\n        0x1869e,\n        0x186a0,\n        0x186bc,\n        0x186c6,\n        0x186cc,\n        0x186d8,\n        0x186ee,\n        0x186f2,\n        0x186f4,\n        0x1872e,\n        0x1874e,\n        0x1875c,\n        0x18796,\n        0x187a6,\n        0x187ac,\n        0x187d2,\n        0x187d4,\n        0x18826,\n        0x1882c,\n        0x1883a,\n        0x18846,\n        0x1884c,\n        0x18858,\n        0x1886e,\n        0x18872,\n        0x18874,\n        0x18886,\n        0x18898,\n        0x188b0,\n        0x188be,\n        0x188ce,\n        0x188dc,\n        0x188e2,\n        0x188e4,\n        0x188e8,\n        0x188f6,\n        0x1890c,\n        0x18930,\n        0x1893e,\n        0x18960,\n        0x1897c,\n        0x1898e,\n        0x189b8,\n        0x189c2,\n        0x189c8,\n        0x189d0,\n        0x189de,\n        0x189e6,\n        0x189ec,\n        0x189fa,\n        0x18a18,\n        0x18a30,\n        0x18a3e,\n        0x18a60,\n        0x18a7c,\n        0x18ac0,\n        0x18af8,\n        0x18b1c,\n        0x18b38,\n        0x18b70,\n        0x18b7e,\n        0x18b82,\n        0x18b84,\n        0x18b88,\n        0x18b90,\n        0x18b9e,\n        0x18ba0,\n        0x18bbc,\n        0x18bc6,\n        0x18bcc,\n        0x18bd8,\n        0x18bee,\n        0x18bf2,\n        0x18bf4,\n        0x18c22,\n        0x18c24,\n        0x18c28,\n        0x18c36,\n        0x18c42,\n        0x18c48,\n        0x18c50,\n        0x18c5e,\n        0x18c66,\n        0x18c7a,\n        0x18c82,\n        0x18c84,\n        0x18c90,\n        0x18c9e,\n        0x18ca0,\n        0x18cbc,\n        0x18ccc,\n        0x18cf2,\n        0x18cf4,\n        0x18d04,\n        0x18d08,\n        0x18d10,\n        0x18d1e,\n        0x18d20,\n        0x18d3c,\n        0x18d40,\n        0x18d78,\n        0x18d86,\n        0x18d98,\n        0x18dce,\n        0x18de2,\n        0x18de4,\n        0x18de8,\n        0x18e2e,\n        0x18e32,\n        0x18e34,\n        0x18e4e,\n        0x18e5c,\n        0x18e62,\n        0x18e64,\n        0x18e68,\n        0x18e8e,\n        0x18e9c,\n        0x18eb8,\n        0x18ec2,\n        0x18ec4,\n        0x18ec8,\n        0x18ed0,\n        0x18efa,\n        0x18f16,\n        0x18f26,\n        0x18f2c,\n        0x18f46,\n        0x18f4c,\n        0x18f58,\n        0x18f6e,\n        0x18f8a,\n        0x18f92,\n        0x18f94,\n        0x18fa2,\n        0x18fa4,\n        0x18fa8,\n        0x18fb6,\n        0x1902c,\n        0x1903a,\n        0x19046,\n        0x1904c,\n        0x19058,\n        0x19072,\n        0x19074,\n        0x19086,\n        0x19098,\n        0x190b0,\n        0x190be,\n        0x190ce,\n        0x190dc,\n        0x190e2,\n        0x190e8,\n        0x190f6,\n        0x19106,\n        0x1910c,\n        0x19130,\n        0x1913e,\n        0x19160,\n        0x1917c,\n        0x1918e,\n        0x1919c,\n        0x191b8,\n        0x191c2,\n        0x191c8,\n        0x191d0,\n        0x191de,\n        0x191e6,\n        0x191ec,\n        0x191fa,\n        0x19218,\n        0x1923e,\n        0x19260,\n        0x1927c,\n        0x192c0,\n        0x192f8,\n        0x19338,\n        0x19370,\n        0x1937e,\n        0x19382,\n        0x19384,\n        0x19390,\n        0x1939e,\n        0x193a0,\n        0x193bc,\n        0x193c6,\n        0x193cc,\n        0x193d8,\n        0x193ee,\n        0x193f2,\n        0x193f4,\n        0x19430,\n        0x1943e,\n        0x19460,\n        0x1947c,\n        0x194c0,\n        0x194f8,\n        0x195f0,\n        0x19638,\n        0x19670,\n        0x1967e,\n        0x196e0,\n        0x196fc,\n        0x19702,\n        0x19704,\n        0x19708,\n        0x19710,\n        0x19720,\n        0x1973c,\n        0x19740,\n        0x19778,\n        0x19786,\n        0x1978c,\n        0x19798,\n        0x197b0,\n        0x197be,\n        0x197ce,\n        0x197dc,\n        0x197e2,\n        0x197e4,\n        0x197e8,\n        0x19822,\n        0x19824,\n        0x19842,\n        0x19848,\n        0x19850,\n        0x1985e,\n        0x19866,\n        0x1987a,\n        0x19882,\n        0x19884,\n        0x19890,\n        0x1989e,\n        0x198a0,\n        0x198bc,\n        0x198cc,\n        0x198f2,\n        0x198f4,\n        0x19902,\n        0x19908,\n        0x1991e,\n        0x19920,\n        0x1993c,\n        0x19940,\n        0x19978,\n        0x19986,\n        0x19998,\n        0x199ce,\n        0x199e2,\n        0x199e4,\n        0x199e8,\n        0x19a08,\n        0x19a10,\n        0x19a1e,\n        0x19a20,\n        0x19a3c,\n        0x19a40,\n        0x19a78,\n        0x19af0,\n        0x19b18,\n        0x19b3e,\n        0x19b60,\n        0x19b9c,\n        0x19bc2,\n        0x19bc4,\n        0x19bc8,\n        0x19bd0,\n        0x19be6,\n        0x19c2e,\n        0x19c34,\n        0x19c4e,\n        0x19c5c,\n        0x19c62,\n        0x19c64,\n        0x19c68,\n        0x19c8e,\n        0x19c9c,\n        0x19cb8,\n        0x19cc2,\n        0x19cc8,\n        0x19cd0,\n        0x19ce6,\n        0x19cfa,\n        0x19d0e,\n        0x19d1c,\n        0x19d38,\n        0x19d70,\n        0x19d7e,\n        0x19d82,\n        0x19d84,\n        0x19d88,\n        0x19d90,\n        0x19da0,\n        0x19dcc,\n        0x19df2,\n        0x19df4,\n        0x19e16,\n        0x19e26,\n        0x19e2c,\n        0x19e46,\n        0x19e4c,\n        0x19e58,\n        0x19e74,\n        0x19e86,\n        0x19e8c,\n        0x19e98,\n        0x19eb0,\n        0x19ebe,\n        0x19ece,\n        0x19ee2,\n        0x19ee4,\n        0x19ee8,\n        0x19f0a,\n        0x19f12,\n        0x19f14,\n        0x19f22,\n        0x19f24,\n        0x19f28,\n        0x19f42,\n        0x19f44,\n        0x19f48,\n        0x19f50,\n        0x19f5e,\n        0x19f6c,\n        0x19f9a,\n        0x19fae,\n        0x19fb2,\n        0x19fb4,\n        0x1a046,\n        0x1a04c,\n        0x1a072,\n        0x1a074,\n        0x1a086,\n        0x1a08c,\n        0x1a098,\n        0x1a0b0,\n        0x1a0be,\n        0x1a0e2,\n        0x1a0e4,\n        0x1a0e8,\n        0x1a0f6,\n        0x1a106,\n        0x1a10c,\n        0x1a118,\n        0x1a130,\n        0x1a13e,\n        0x1a160,\n        0x1a17c,\n        0x1a18e,\n        0x1a19c,\n        0x1a1b8,\n        0x1a1c2,\n        0x1a1c4,\n        0x1a1c8,\n        0x1a1d0,\n        0x1a1de,\n        0x1a1e6,\n        0x1a1ec,\n        0x1a218,\n        0x1a230,\n        0x1a23e,\n        0x1a260,\n        0x1a27c,\n        0x1a2c0,\n        0x1a2f8,\n        0x1a31c,\n        0x1a338,\n        0x1a370,\n        0x1a37e,\n        0x1a382,\n        0x1a384,\n        0x1a388,\n        0x1a390,\n        0x1a39e,\n        0x1a3a0,\n        0x1a3bc,\n        0x1a3c6,\n        0x1a3cc,\n        0x1a3d8,\n        0x1a3ee,\n        0x1a3f2,\n        0x1a3f4,\n        0x1a418,\n        0x1a430,\n        0x1a43e,\n        0x1a460,\n        0x1a47c,\n        0x1a4c0,\n        0x1a4f8,\n        0x1a5f0,\n        0x1a61c,\n        0x1a638,\n        0x1a670,\n        0x1a67e,\n        0x1a6e0,\n        0x1a6fc,\n        0x1a702,\n        0x1a704,\n        0x1a708,\n        0x1a710,\n        0x1a71e,\n        0x1a720,\n        0x1a73c,\n        0x1a740,\n        0x1a778,\n        0x1a786,\n        0x1a78c,\n        0x1a798,\n        0x1a7b0,\n        0x1a7be,\n        0x1a7ce,\n        0x1a7dc,\n        0x1a7e2,\n        0x1a7e4,\n        0x1a7e8,\n        0x1a830,\n        0x1a860,\n        0x1a87c,\n        0x1a8c0,\n        0x1a8f8,\n        0x1a9f0,\n        0x1abe0,\n        0x1ac70,\n        0x1ac7e,\n        0x1ace0,\n        0x1acfc,\n        0x1adc0,\n        0x1adf8,\n        0x1ae04,\n        0x1ae08,\n        0x1ae10,\n        0x1ae20,\n        0x1ae3c,\n        0x1ae40,\n        0x1ae78,\n        0x1aef0,\n        0x1af06,\n        0x1af0c,\n        0x1af18,\n        0x1af30,\n        0x1af3e,\n        0x1af60,\n        0x1af7c,\n        0x1af8e,\n        0x1af9c,\n        0x1afb8,\n        0x1afc4,\n        0x1afc8,\n        0x1afd0,\n        0x1afde,\n        0x1b042,\n        0x1b05e,\n        0x1b07a,\n        0x1b082,\n        0x1b084,\n        0x1b088,\n        0x1b090,\n        0x1b09e,\n        0x1b0a0,\n        0x1b0bc,\n        0x1b0cc,\n        0x1b0f2,\n        0x1b0f4,\n        0x1b102,\n        0x1b104,\n        0x1b108,\n        0x1b110,\n        0x1b11e,\n        0x1b120,\n        0x1b13c,\n        0x1b140,\n        0x1b178,\n        0x1b186,\n        0x1b198,\n        0x1b1ce,\n        0x1b1e2,\n        0x1b1e4,\n        0x1b1e8,\n        0x1b204,\n        0x1b208,\n        0x1b210,\n        0x1b21e,\n        0x1b220,\n        0x1b23c,\n        0x1b240,\n        0x1b278,\n        0x1b2f0,\n        0x1b30c,\n        0x1b33e,\n        0x1b360,\n        0x1b39c,\n        0x1b3c2,\n        0x1b3c4,\n        0x1b3c8,\n        0x1b3d0,\n        0x1b3e6,\n        0x1b410,\n        0x1b41e,\n        0x1b420,\n        0x1b43c,\n        0x1b440,\n        0x1b478,\n        0x1b4f0,\n        0x1b5e0,\n        0x1b618,\n        0x1b660,\n        0x1b67c,\n        0x1b6c0,\n        0x1b738,\n        0x1b782,\n        0x1b784,\n        0x1b788,\n        0x1b790,\n        0x1b79e,\n        0x1b7a0,\n        0x1b7cc,\n        0x1b82e,\n        0x1b84e,\n        0x1b85c,\n        0x1b88e,\n        0x1b89c,\n        0x1b8b8,\n        0x1b8c2,\n        0x1b8c4,\n        0x1b8c8,\n        0x1b8d0,\n        0x1b8e6,\n        0x1b8fa,\n        0x1b90e,\n        0x1b91c,\n        0x1b938,\n        0x1b970,\n        0x1b97e,\n        0x1b982,\n        0x1b984,\n        0x1b988,\n        0x1b990,\n        0x1b99e,\n        0x1b9a0,\n        0x1b9cc,\n        0x1b9f2,\n        0x1b9f4,\n        0x1ba0e,\n        0x1ba1c,\n        0x1ba38,\n        0x1ba70,\n        0x1ba7e,\n        0x1bae0,\n        0x1bafc,\n        0x1bb08,\n        0x1bb10,\n        0x1bb20,\n        0x1bb3c,\n        0x1bb40,\n        0x1bb98,\n        0x1bbce,\n        0x1bbe2,\n        0x1bbe4,\n        0x1bbe8,\n        0x1bc16,\n        0x1bc26,\n        0x1bc2c,\n        0x1bc46,\n        0x1bc4c,\n        0x1bc58,\n        0x1bc72,\n        0x1bc74,\n        0x1bc86,\n        0x1bc8c,\n        0x1bc98,\n        0x1bcb0,\n        0x1bcbe,\n        0x1bcce,\n        0x1bce2,\n        0x1bce4,\n        0x1bce8,\n        0x1bd06,\n        0x1bd0c,\n        0x1bd18,\n        0x1bd30,\n        0x1bd3e,\n        0x1bd60,\n        0x1bd7c,\n        0x1bd9c,\n        0x1bdc2,\n        0x1bdc4,\n        0x1bdc8,\n        0x1bdd0,\n        0x1bde6,\n        0x1bdfa,\n        0x1be12,\n        0x1be14,\n        0x1be22,\n        0x1be24,\n        0x1be28,\n        0x1be42,\n        0x1be44,\n        0x1be48,\n        0x1be50,\n        0x1be5e,\n        0x1be66,\n        0x1be82,\n        0x1be84,\n        0x1be88,\n        0x1be90,\n        0x1be9e,\n        0x1bea0,\n        0x1bebc,\n        0x1becc,\n        0x1bef4,\n        0x1bf1a,\n        0x1bf2e,\n        0x1bf32,\n        0x1bf34,\n        0x1bf4e,\n        0x1bf5c,\n        0x1bf62,\n        0x1bf64,\n        0x1bf68,\n        0x1c09a,\n        0x1c0b2,\n        0x1c0b4,\n        0x1c11a,\n        0x1c132,\n        0x1c134,\n        0x1c162,\n        0x1c164,\n        0x1c168,\n        0x1c176,\n        0x1c1ba,\n        0x1c21a,\n        0x1c232,\n        0x1c234,\n        0x1c24e,\n        0x1c25c,\n        0x1c262,\n        0x1c264,\n        0x1c268,\n        0x1c276,\n        0x1c28e,\n        0x1c2c2,\n        0x1c2c4,\n        0x1c2c8,\n        0x1c2d0,\n        0x1c2de,\n        0x1c2e6,\n        0x1c2ec,\n        0x1c2fa,\n        0x1c316,\n        0x1c326,\n        0x1c33a,\n        0x1c346,\n        0x1c34c,\n        0x1c372,\n        0x1c374,\n        0x1c41a,\n        0x1c42e,\n        0x1c432,\n        0x1c434,\n        0x1c44e,\n        0x1c45c,\n        0x1c462,\n        0x1c464,\n        0x1c468,\n        0x1c476,\n        0x1c48e,\n        0x1c49c,\n        0x1c4b8,\n        0x1c4c2,\n        0x1c4c8,\n        0x1c4d0,\n        0x1c4de,\n        0x1c4e6,\n        0x1c4ec,\n        0x1c4fa,\n        0x1c51c,\n        0x1c538,\n        0x1c570,\n        0x1c57e,\n        0x1c582,\n        0x1c584,\n        0x1c588,\n        0x1c590,\n        0x1c59e,\n        0x1c5a0,\n        0x1c5bc,\n        0x1c5c6,\n        0x1c5cc,\n        0x1c5d8,\n        0x1c5ee,\n        0x1c5f2,\n        0x1c5f4,\n        0x1c616,\n        0x1c626,\n        0x1c62c,\n        0x1c63a,\n        0x1c646,\n        0x1c64c,\n        0x1c658,\n        0x1c66e,\n        0x1c672,\n        0x1c674,\n        0x1c686,\n        0x1c68c,\n        0x1c698,\n        0x1c6b0,\n        0x1c6be,\n        0x1c6ce,\n        0x1c6dc,\n        0x1c6e2,\n        0x1c6e4,\n        0x1c6e8,\n        0x1c712,\n        0x1c714,\n        0x1c722,\n        0x1c728,\n        0x1c736,\n        0x1c742,\n        0x1c744,\n        0x1c748,\n        0x1c750,\n        0x1c75e,\n        0x1c766,\n        0x1c76c,\n        0x1c77a,\n        0x1c7ae,\n        0x1c7d6,\n        0x1c7ea,\n        0x1c81a,\n        0x1c82e,\n        0x1c832,\n        0x1c834,\n        0x1c84e,\n        0x1c85c,\n        0x1c862,\n        0x1c864,\n        0x1c868,\n        0x1c876,\n        0x1c88e,\n        0x1c89c,\n        0x1c8b8,\n        0x1c8c2,\n        0x1c8c8,\n        0x1c8d0,\n        0x1c8de,\n        0x1c8e6,\n        0x1c8ec,\n        0x1c8fa,\n        0x1c90e,\n        0x1c938,\n        0x1c970,\n        0x1c97e,\n        0x1c982,\n        0x1c984,\n        0x1c990,\n        0x1c99e,\n        0x1c9a0,\n        0x1c9bc,\n        0x1c9c6,\n        0x1c9cc,\n        0x1c9d8,\n        0x1c9ee,\n        0x1c9f2,\n        0x1c9f4,\n        0x1ca38,\n        0x1ca70,\n        0x1ca7e,\n        0x1cae0,\n        0x1cafc,\n        0x1cb02,\n        0x1cb04,\n        0x1cb08,\n        0x1cb10,\n        0x1cb20,\n        0x1cb3c,\n        0x1cb40,\n        0x1cb78,\n        0x1cb86,\n        0x1cb8c,\n        0x1cb98,\n        0x1cbb0,\n        0x1cbbe,\n        0x1cbce,\n        0x1cbdc,\n        0x1cbe2,\n        0x1cbe4,\n        0x1cbe8,\n        0x1cbf6,\n        0x1cc16,\n        0x1cc26,\n        0x1cc2c,\n        0x1cc3a,\n        0x1cc46,\n        0x1cc58,\n        0x1cc72,\n        0x1cc74,\n        0x1cc86,\n        0x1ccb0,\n        0x1ccbe,\n        0x1ccce,\n        0x1cce2,\n        0x1cce4,\n        0x1cce8,\n        0x1cd06,\n        0x1cd0c,\n        0x1cd18,\n        0x1cd30,\n        0x1cd3e,\n        0x1cd60,\n        0x1cd7c,\n        0x1cd9c,\n        0x1cdc2,\n        0x1cdc4,\n        0x1cdc8,\n        0x1cdd0,\n        0x1cdde,\n        0x1cde6,\n        0x1cdfa,\n        0x1ce22,\n        0x1ce28,\n        0x1ce42,\n        0x1ce50,\n        0x1ce5e,\n        0x1ce66,\n        0x1ce7a,\n        0x1ce82,\n        0x1ce84,\n        0x1ce88,\n        0x1ce90,\n        0x1ce9e,\n        0x1cea0,\n        0x1cebc,\n        0x1cecc,\n        0x1cef2,\n        0x1cef4,\n        0x1cf2e,\n        0x1cf32,\n        0x1cf34,\n        0x1cf4e,\n        0x1cf5c,\n        0x1cf62,\n        0x1cf64,\n        0x1cf68,\n        0x1cf96,\n        0x1cfa6,\n        0x1cfac,\n        0x1cfca,\n        0x1cfd2,\n        0x1cfd4,\n        0x1d02e,\n        0x1d032,\n        0x1d034,\n        0x1d04e,\n        0x1d05c,\n        0x1d062,\n        0x1d064,\n        0x1d068,\n        0x1d076,\n        0x1d08e,\n        0x1d09c,\n        0x1d0b8,\n        0x1d0c2,\n        0x1d0c4,\n        0x1d0c8,\n        0x1d0d0,\n        0x1d0de,\n        0x1d0e6,\n        0x1d0ec,\n        0x1d0fa,\n        0x1d11c,\n        0x1d138,\n        0x1d170,\n        0x1d17e,\n        0x1d182,\n        0x1d184,\n        0x1d188,\n        0x1d190,\n        0x1d19e,\n        0x1d1a0,\n        0x1d1bc,\n        0x1d1c6,\n        0x1d1cc,\n        0x1d1d8,\n        0x1d1ee,\n        0x1d1f2,\n        0x1d1f4,\n        0x1d21c,\n        0x1d238,\n        0x1d270,\n        0x1d27e,\n        0x1d2e0,\n        0x1d2fc,\n        0x1d302,\n        0x1d304,\n        0x1d308,\n        0x1d310,\n        0x1d31e,\n        0x1d320,\n        0x1d33c,\n        0x1d340,\n        0x1d378,\n        0x1d386,\n        0x1d38c,\n        0x1d398,\n        0x1d3b0,\n        0x1d3be,\n        0x1d3ce,\n        0x1d3dc,\n        0x1d3e2,\n        0x1d3e4,\n        0x1d3e8,\n        0x1d3f6,\n        0x1d470,\n        0x1d47e,\n        0x1d4e0,\n        0x1d4fc,\n        0x1d5c0,\n        0x1d5f8,\n        0x1d604,\n        0x1d608,\n        0x1d610,\n        0x1d620,\n        0x1d640,\n        0x1d678,\n        0x1d6f0,\n        0x1d706,\n        0x1d70c,\n        0x1d718,\n        0x1d730,\n        0x1d73e,\n        0x1d760,\n        0x1d77c,\n        0x1d78e,\n        0x1d79c,\n        0x1d7b8,\n        0x1d7c2,\n        0x1d7c4,\n        0x1d7c8,\n        0x1d7d0,\n        0x1d7de,\n        0x1d7e6,\n        0x1d7ec,\n        0x1d826,\n        0x1d82c,\n        0x1d83a,\n        0x1d846,\n        0x1d84c,\n        0x1d858,\n        0x1d872,\n        0x1d874,\n        0x1d886,\n        0x1d88c,\n        0x1d898,\n        0x1d8b0,\n        0x1d8be,\n        0x1d8ce,\n        0x1d8e2,\n        0x1d8e4,\n        0x1d8e8,\n        0x1d8f6,\n        0x1d90c,\n        0x1d918,\n        0x1d930,\n        0x1d93e,\n        0x1d960,\n        0x1d97c,\n        0x1d99c,\n        0x1d9c2,\n        0x1d9c4,\n        0x1d9c8,\n        0x1d9d0,\n        0x1d9e6,\n        0x1d9fa,\n        0x1da0c,\n        0x1da18,\n        0x1da30,\n        0x1da3e,\n        0x1da60,\n        0x1da7c,\n        0x1dac0,\n        0x1daf8,\n        0x1db38,\n        0x1db82,\n        0x1db84,\n        0x1db88,\n        0x1db90,\n        0x1db9e,\n        0x1dba0,\n        0x1dbcc,\n        0x1dbf2,\n        0x1dbf4,\n        0x1dc22,\n        0x1dc42,\n        0x1dc44,\n        0x1dc48,\n        0x1dc50,\n        0x1dc5e,\n        0x1dc66,\n        0x1dc7a,\n        0x1dc82,\n        0x1dc84,\n        0x1dc88,\n        0x1dc90,\n        0x1dc9e,\n        0x1dca0,\n        0x1dcbc,\n        0x1dccc,\n        0x1dcf2,\n        0x1dcf4,\n        0x1dd04,\n        0x1dd08,\n        0x1dd10,\n        0x1dd1e,\n        0x1dd20,\n        0x1dd3c,\n        0x1dd40,\n        0x1dd78,\n        0x1dd86,\n        0x1dd98,\n        0x1ddce,\n        0x1dde2,\n        0x1dde4,\n        0x1dde8,\n        0x1de2e,\n        0x1de32,\n        0x1de34,\n        0x1de4e,\n        0x1de5c,\n        0x1de62,\n        0x1de64,\n        0x1de68,\n        0x1de8e,\n        0x1de9c,\n        0x1deb8,\n        0x1dec2,\n        0x1dec4,\n        0x1dec8,\n        0x1ded0,\n        0x1dee6,\n        0x1defa,\n        0x1df16,\n        0x1df26,\n        0x1df2c,\n        0x1df46,\n        0x1df4c,\n        0x1df58,\n        0x1df72,\n        0x1df74,\n        0x1df8a,\n        0x1df92,\n        0x1df94,\n        0x1dfa2,\n        0x1dfa4,\n        0x1dfa8,\n        0x1e08a,\n        0x1e092,\n        0x1e094,\n        0x1e0a2,\n        0x1e0a4,\n        0x1e0a8,\n        0x1e0b6,\n        0x1e0da,\n        0x1e10a,\n        0x1e112,\n        0x1e114,\n        0x1e122,\n        0x1e124,\n        0x1e128,\n        0x1e136,\n        0x1e142,\n        0x1e144,\n        0x1e148,\n        0x1e150,\n        0x1e166,\n        0x1e16c,\n        0x1e17a,\n        0x1e19a,\n        0x1e1b2,\n        0x1e1b4,\n        0x1e20a,\n        0x1e212,\n        0x1e214,\n        0x1e222,\n        0x1e224,\n        0x1e228,\n        0x1e236,\n        0x1e242,\n        0x1e248,\n        0x1e250,\n        0x1e25e,\n        0x1e266,\n        0x1e26c,\n        0x1e27a,\n        0x1e282,\n        0x1e284,\n        0x1e288,\n        0x1e290,\n        0x1e2a0,\n        0x1e2bc,\n        0x1e2c6,\n        0x1e2cc,\n        0x1e2d8,\n        0x1e2ee,\n        0x1e2f2,\n        0x1e2f4,\n        0x1e31a,\n        0x1e332,\n        0x1e334,\n        0x1e35c,\n        0x1e362,\n        0x1e364,\n        0x1e368,\n        0x1e3ba,\n        0x1e40a,\n        0x1e412,\n        0x1e414,\n        0x1e422,\n        0x1e428,\n        0x1e436,\n        0x1e442,\n        0x1e448,\n        0x1e450,\n        0x1e45e,\n        0x1e466,\n        0x1e46c,\n        0x1e47a,\n        0x1e482,\n        0x1e484,\n        0x1e490,\n        0x1e49e,\n        0x1e4a0,\n        0x1e4bc,\n        0x1e4c6,\n        0x1e4cc,\n        0x1e4d8,\n        0x1e4ee,\n        0x1e4f2,\n        0x1e4f4,\n        0x1e502,\n        0x1e504,\n        0x1e508,\n        0x1e510,\n        0x1e51e,\n        0x1e520,\n        0x1e53c,\n        0x1e540,\n        0x1e578,\n        0x1e586,\n        0x1e58c,\n        0x1e598,\n        0x1e5b0,\n        0x1e5be,\n        0x1e5ce,\n        0x1e5dc,\n        0x1e5e2,\n        0x1e5e4,\n        0x1e5e8,\n        0x1e5f6,\n        0x1e61a,\n        0x1e62e,\n        0x1e632,\n        0x1e634,\n        0x1e64e,\n        0x1e65c,\n        0x1e662,\n        0x1e668,\n        0x1e68e,\n        0x1e69c,\n        0x1e6b8,\n        0x1e6c2,\n        0x1e6c4,\n        0x1e6c8,\n        0x1e6d0,\n        0x1e6e6,\n        0x1e6fa,\n        0x1e716,\n        0x1e726,\n        0x1e72c,\n        0x1e73a,\n        0x1e746,\n        0x1e74c,\n        0x1e758,\n        0x1e772,\n        0x1e774,\n        0x1e792,\n        0x1e794,\n        0x1e7a2,\n        0x1e7a4,\n        0x1e7a8,\n        0x1e7b6,\n        0x1e812,\n        0x1e814,\n        0x1e822,\n        0x1e824,\n        0x1e828,\n        0x1e836,\n        0x1e842,\n        0x1e844,\n        0x1e848,\n        0x1e850,\n        0x1e85e,\n        0x1e866,\n        0x1e86c,\n        0x1e87a,\n        0x1e882,\n        0x1e884,\n        0x1e888,\n        0x1e890,\n        0x1e89e,\n        0x1e8a0,\n        0x1e8bc,\n        0x1e8c6,\n        0x1e8cc,\n        0x1e8d8,\n        0x1e8ee,\n        0x1e8f2,\n        0x1e8f4,\n        0x1e902,\n        0x1e904,\n        0x1e908,\n        0x1e910,\n        0x1e920,\n        0x1e93c,\n        0x1e940,\n        0x1e978,\n        0x1e986,\n        0x1e98c,\n        0x1e998,\n        0x1e9b0,\n        0x1e9be,\n        0x1e9ce,\n        0x1e9dc,\n        0x1e9e2,\n        0x1e9e4,\n        0x1e9e8,\n        0x1e9f6,\n        0x1ea04,\n        0x1ea08,\n        0x1ea10,\n        0x1ea20,\n        0x1ea40,\n        0x1ea78,\n        0x1eaf0,\n        0x1eb06,\n        0x1eb0c,\n        0x1eb18,\n        0x1eb30,\n        0x1eb3e,\n        0x1eb60,\n        0x1eb7c,\n        0x1eb8e,\n        0x1eb9c,\n        0x1ebb8,\n        0x1ebc2,\n        0x1ebc4,\n        0x1ebc8,\n        0x1ebd0,\n        0x1ebde,\n        0x1ebe6,\n        0x1ebec,\n        0x1ec1a,\n        0x1ec2e,\n        0x1ec32,\n        0x1ec34,\n        0x1ec4e,\n        0x1ec5c,\n        0x1ec62,\n        0x1ec64,\n        0x1ec68,\n        0x1ec8e,\n        0x1ec9c,\n        0x1ecb8,\n        0x1ecc2,\n        0x1ecc4,\n        0x1ecc8,\n        0x1ecd0,\n        0x1ece6,\n        0x1ecfa,\n        0x1ed0e,\n        0x1ed1c,\n        0x1ed38,\n        0x1ed70,\n        0x1ed7e,\n        0x1ed82,\n        0x1ed84,\n        0x1ed88,\n        0x1ed90,\n        0x1ed9e,\n        0x1eda0,\n        0x1edcc,\n        0x1edf2,\n        0x1edf4,\n        0x1ee16,\n        0x1ee26,\n        0x1ee2c,\n        0x1ee3a,\n        0x1ee46,\n        0x1ee4c,\n        0x1ee58,\n        0x1ee6e,\n        0x1ee72,\n        0x1ee74,\n        0x1ee86,\n        0x1ee8c,\n        0x1ee98,\n        0x1eeb0,\n        0x1eebe,\n        0x1eece,\n        0x1eedc,\n        0x1eee2,\n        0x1eee4,\n        0x1eee8,\n        0x1ef12,\n        0x1ef22,\n        0x1ef24,\n        0x1ef28,\n        0x1ef36,\n        0x1ef42,\n        0x1ef44,\n        0x1ef48,\n        0x1ef50,\n        0x1ef5e,\n        0x1ef66,\n        0x1ef6c,\n        0x1ef7a,\n        0x1efae,\n        0x1efb2,\n        0x1efb4,\n        0x1efd6,\n        0x1f096,\n        0x1f0a6,\n        0x1f0ac,\n        0x1f0ba,\n        0x1f0ca,\n        0x1f0d2,\n        0x1f0d4,\n        0x1f116,\n        0x1f126,\n        0x1f12c,\n        0x1f13a,\n        0x1f146,\n        0x1f14c,\n        0x1f158,\n        0x1f16e,\n        0x1f172,\n        0x1f174,\n        0x1f18a,\n        0x1f192,\n        0x1f194,\n        0x1f1a2,\n        0x1f1a4,\n        0x1f1a8,\n        0x1f1da,\n        0x1f216,\n        0x1f226,\n        0x1f22c,\n        0x1f23a,\n        0x1f246,\n        0x1f258,\n        0x1f26e,\n        0x1f272,\n        0x1f274,\n        0x1f286,\n        0x1f28c,\n        0x1f298,\n        0x1f2b0,\n        0x1f2be,\n        0x1f2ce,\n        0x1f2dc,\n        0x1f2e2,\n        0x1f2e4,\n        0x1f2e8,\n        0x1f2f6,\n        0x1f30a,\n        0x1f312,\n        0x1f314,\n        0x1f322,\n        0x1f328,\n        0x1f342,\n        0x1f344,\n        0x1f348,\n        0x1f350,\n        0x1f35e,\n        0x1f366,\n        0x1f37a,\n        0x1f39a,\n        0x1f3ae,\n        0x1f3b2,\n        0x1f3b4,\n        0x1f416,\n        0x1f426,\n        0x1f42c,\n        0x1f43a,\n        0x1f446,\n        0x1f44c,\n        0x1f458,\n        0x1f46e,\n        0x1f472,\n        0x1f474,\n        0x1f486,\n        0x1f48c,\n        0x1f498,\n        0x1f4b0,\n        0x1f4be,\n        0x1f4ce,\n        0x1f4dc,\n        0x1f4e2,\n        0x1f4e4,\n        0x1f4e8,\n        0x1f4f6,\n        0x1f506,\n        0x1f50c,\n        0x1f518,\n        0x1f530,\n        0x1f53e,\n        0x1f560,\n        0x1f57c,\n        0x1f58e,\n        0x1f59c,\n        0x1f5b8,\n        0x1f5c2,\n        0x1f5c4,\n        0x1f5c8,\n        0x1f5d0,\n        0x1f5de,\n        0x1f5e6,\n        0x1f5ec,\n        0x1f5fa,\n        0x1f60a,\n        0x1f612,\n        0x1f614,\n        0x1f622,\n        0x1f624,\n        0x1f628,\n        0x1f636,\n        0x1f642,\n        0x1f644,\n        0x1f648,\n        0x1f650,\n        0x1f65e,\n        0x1f666,\n        0x1f67a,\n        0x1f682,\n        0x1f684,\n        0x1f688,\n        0x1f690,\n        0x1f69e,\n        0x1f6a0,\n        0x1f6bc,\n        0x1f6cc,\n        0x1f6f2,\n        0x1f6f4,\n        0x1f71a,\n        0x1f72e,\n        0x1f732,\n        0x1f734,\n        0x1f74e,\n        0x1f75c,\n        0x1f762,\n        0x1f764,\n        0x1f768,\n        0x1f776,\n        0x1f796,\n        0x1f7a6,\n        0x1f7ac,\n        0x1f7ba,\n        0x1f7d2,\n        0x1f7d4,\n        0x1f89a,\n        0x1f8ae,\n        0x1f8b2,\n        0x1f8b4,\n        0x1f8d6,\n        0x1f8ea,\n        0x1f91a,\n        0x1f92e,\n        0x1f932,\n        0x1f934,\n        0x1f94e,\n        0x1f95c,\n        0x1f962,\n        0x1f964,\n        0x1f968,\n        0x1f976,\n        0x1f996,\n        0x1f9a6,\n        0x1f9ac,\n        0x1f9ba,\n        0x1f9ca,\n        0x1f9d2,\n        0x1f9d4,\n        0x1fa1a,\n        0x1fa2e,\n        0x1fa32,\n        0x1fa34,\n        0x1fa4e,\n        0x1fa5c,\n        0x1fa62,\n        0x1fa64,\n        0x1fa68,\n        0x1fa76,\n        0x1fa8e,\n        0x1fa9c,\n        0x1fab8,\n        0x1fac2,\n        0x1fac4,\n        0x1fac8,\n        0x1fad0,\n        0x1fade,\n        0x1fae6,\n        0x1faec,\n        0x1fb16,\n        0x1fb26,\n        0x1fb2c,\n        0x1fb3a,\n        0x1fb46,\n        0x1fb4c,\n        0x1fb58,\n        0x1fb6e,\n        0x1fb72,\n        0x1fb74,\n        0x1fb8a,\n        0x1fb92,\n        0x1fb94,\n        0x1fba2,\n        0x1fba4,\n        0x1fba8,\n        0x1fbb6,\n        0x1fbda\n    ]);\n    /**\n     * This table contains to codewords for all symbols.\n     */ PDF417Common.CODEWORD_TABLE = Int32Array.from([\n        2627,\n        1819,\n        2622,\n        2621,\n        1813,\n        1812,\n        2729,\n        2724,\n        2723,\n        2779,\n        2774,\n        2773,\n        902,\n        896,\n        908,\n        868,\n        865,\n        861,\n        859,\n        2511,\n        873,\n        871,\n        1780,\n        835,\n        2493,\n        825,\n        2491,\n        842,\n        837,\n        844,\n        1764,\n        1762,\n        811,\n        810,\n        809,\n        2483,\n        807,\n        2482,\n        806,\n        2480,\n        815,\n        814,\n        813,\n        812,\n        2484,\n        817,\n        816,\n        1745,\n        1744,\n        1742,\n        1746,\n        2655,\n        2637,\n        2635,\n        2626,\n        2625,\n        2623,\n        2628,\n        1820,\n        2752,\n        2739,\n        2737,\n        2728,\n        2727,\n        2725,\n        2730,\n        2785,\n        2783,\n        2778,\n        2777,\n        2775,\n        2780,\n        787,\n        781,\n        747,\n        739,\n        736,\n        2413,\n        754,\n        752,\n        1719,\n        692,\n        689,\n        681,\n        2371,\n        678,\n        2369,\n        700,\n        697,\n        694,\n        703,\n        1688,\n        1686,\n        642,\n        638,\n        2343,\n        631,\n        2341,\n        627,\n        2338,\n        651,\n        646,\n        643,\n        2345,\n        654,\n        652,\n        1652,\n        1650,\n        1647,\n        1654,\n        601,\n        599,\n        2322,\n        596,\n        2321,\n        594,\n        2319,\n        2317,\n        611,\n        610,\n        608,\n        606,\n        2324,\n        603,\n        2323,\n        615,\n        614,\n        612,\n        1617,\n        1616,\n        1614,\n        1612,\n        616,\n        1619,\n        1618,\n        2575,\n        2538,\n        2536,\n        905,\n        901,\n        898,\n        909,\n        2509,\n        2507,\n        2504,\n        870,\n        867,\n        864,\n        860,\n        2512,\n        875,\n        872,\n        1781,\n        2490,\n        2489,\n        2487,\n        2485,\n        1748,\n        836,\n        834,\n        832,\n        830,\n        2494,\n        827,\n        2492,\n        843,\n        841,\n        839,\n        845,\n        1765,\n        1763,\n        2701,\n        2676,\n        2674,\n        2653,\n        2648,\n        2656,\n        2634,\n        2633,\n        2631,\n        2629,\n        1821,\n        2638,\n        2636,\n        2770,\n        2763,\n        2761,\n        2750,\n        2745,\n        2753,\n        2736,\n        2735,\n        2733,\n        2731,\n        1848,\n        2740,\n        2738,\n        2786,\n        2784,\n        591,\n        588,\n        576,\n        569,\n        566,\n        2296,\n        1590,\n        537,\n        534,\n        526,\n        2276,\n        522,\n        2274,\n        545,\n        542,\n        539,\n        548,\n        1572,\n        1570,\n        481,\n        2245,\n        466,\n        2242,\n        462,\n        2239,\n        492,\n        485,\n        482,\n        2249,\n        496,\n        494,\n        1534,\n        1531,\n        1528,\n        1538,\n        413,\n        2196,\n        406,\n        2191,\n        2188,\n        425,\n        419,\n        2202,\n        415,\n        2199,\n        432,\n        430,\n        427,\n        1472,\n        1467,\n        1464,\n        433,\n        1476,\n        1474,\n        368,\n        367,\n        2160,\n        365,\n        2159,\n        362,\n        2157,\n        2155,\n        2152,\n        378,\n        377,\n        375,\n        2166,\n        372,\n        2165,\n        369,\n        2162,\n        383,\n        381,\n        379,\n        2168,\n        1419,\n        1418,\n        1416,\n        1414,\n        385,\n        1411,\n        384,\n        1423,\n        1422,\n        1420,\n        1424,\n        2461,\n        802,\n        2441,\n        2439,\n        790,\n        786,\n        783,\n        794,\n        2409,\n        2406,\n        2403,\n        750,\n        742,\n        738,\n        2414,\n        756,\n        753,\n        1720,\n        2367,\n        2365,\n        2362,\n        2359,\n        1663,\n        693,\n        691,\n        684,\n        2373,\n        680,\n        2370,\n        702,\n        699,\n        696,\n        704,\n        1690,\n        1687,\n        2337,\n        2336,\n        2334,\n        2332,\n        1624,\n        2329,\n        1622,\n        640,\n        637,\n        2344,\n        634,\n        2342,\n        630,\n        2340,\n        650,\n        648,\n        645,\n        2346,\n        655,\n        653,\n        1653,\n        1651,\n        1649,\n        1655,\n        2612,\n        2597,\n        2595,\n        2571,\n        2568,\n        2565,\n        2576,\n        2534,\n        2529,\n        2526,\n        1787,\n        2540,\n        2537,\n        907,\n        904,\n        900,\n        910,\n        2503,\n        2502,\n        2500,\n        2498,\n        1768,\n        2495,\n        1767,\n        2510,\n        2508,\n        2506,\n        869,\n        866,\n        863,\n        2513,\n        876,\n        874,\n        1782,\n        2720,\n        2713,\n        2711,\n        2697,\n        2694,\n        2691,\n        2702,\n        2672,\n        2670,\n        2664,\n        1828,\n        2678,\n        2675,\n        2647,\n        2646,\n        2644,\n        2642,\n        1823,\n        2639,\n        1822,\n        2654,\n        2652,\n        2650,\n        2657,\n        2771,\n        1855,\n        2765,\n        2762,\n        1850,\n        1849,\n        2751,\n        2749,\n        2747,\n        2754,\n        353,\n        2148,\n        344,\n        342,\n        336,\n        2142,\n        332,\n        2140,\n        345,\n        1375,\n        1373,\n        306,\n        2130,\n        299,\n        2128,\n        295,\n        2125,\n        319,\n        314,\n        311,\n        2132,\n        1354,\n        1352,\n        1349,\n        1356,\n        262,\n        257,\n        2101,\n        253,\n        2096,\n        2093,\n        274,\n        273,\n        267,\n        2107,\n        263,\n        2104,\n        280,\n        278,\n        275,\n        1316,\n        1311,\n        1308,\n        1320,\n        1318,\n        2052,\n        202,\n        2050,\n        2044,\n        2040,\n        219,\n        2063,\n        212,\n        2060,\n        208,\n        2055,\n        224,\n        221,\n        2066,\n        1260,\n        1258,\n        1252,\n        231,\n        1248,\n        229,\n        1266,\n        1264,\n        1261,\n        1268,\n        155,\n        1998,\n        153,\n        1996,\n        1994,\n        1991,\n        1988,\n        165,\n        164,\n        2007,\n        162,\n        2006,\n        159,\n        2003,\n        2000,\n        172,\n        171,\n        169,\n        2012,\n        166,\n        2010,\n        1186,\n        1184,\n        1182,\n        1179,\n        175,\n        1176,\n        173,\n        1192,\n        1191,\n        1189,\n        1187,\n        176,\n        1194,\n        1193,\n        2313,\n        2307,\n        2305,\n        592,\n        589,\n        2294,\n        2292,\n        2289,\n        578,\n        572,\n        568,\n        2297,\n        580,\n        1591,\n        2272,\n        2267,\n        2264,\n        1547,\n        538,\n        536,\n        529,\n        2278,\n        525,\n        2275,\n        547,\n        544,\n        541,\n        1574,\n        1571,\n        2237,\n        2235,\n        2229,\n        1493,\n        2225,\n        1489,\n        478,\n        2247,\n        470,\n        2244,\n        465,\n        2241,\n        493,\n        488,\n        484,\n        2250,\n        498,\n        495,\n        1536,\n        1533,\n        1530,\n        1539,\n        2187,\n        2186,\n        2184,\n        2182,\n        1432,\n        2179,\n        1430,\n        2176,\n        1427,\n        414,\n        412,\n        2197,\n        409,\n        2195,\n        405,\n        2193,\n        2190,\n        426,\n        424,\n        421,\n        2203,\n        418,\n        2201,\n        431,\n        429,\n        1473,\n        1471,\n        1469,\n        1466,\n        434,\n        1477,\n        1475,\n        2478,\n        2472,\n        2470,\n        2459,\n        2457,\n        2454,\n        2462,\n        803,\n        2437,\n        2432,\n        2429,\n        1726,\n        2443,\n        2440,\n        792,\n        789,\n        785,\n        2401,\n        2399,\n        2393,\n        1702,\n        2389,\n        1699,\n        2411,\n        2408,\n        2405,\n        745,\n        741,\n        2415,\n        758,\n        755,\n        1721,\n        2358,\n        2357,\n        2355,\n        2353,\n        1661,\n        2350,\n        1660,\n        2347,\n        1657,\n        2368,\n        2366,\n        2364,\n        2361,\n        1666,\n        690,\n        687,\n        2374,\n        683,\n        2372,\n        701,\n        698,\n        705,\n        1691,\n        1689,\n        2619,\n        2617,\n        2610,\n        2608,\n        2605,\n        2613,\n        2593,\n        2588,\n        2585,\n        1803,\n        2599,\n        2596,\n        2563,\n        2561,\n        2555,\n        1797,\n        2551,\n        1795,\n        2573,\n        2570,\n        2567,\n        2577,\n        2525,\n        2524,\n        2522,\n        2520,\n        1786,\n        2517,\n        1785,\n        2514,\n        1783,\n        2535,\n        2533,\n        2531,\n        2528,\n        1788,\n        2541,\n        2539,\n        906,\n        903,\n        911,\n        2721,\n        1844,\n        2715,\n        2712,\n        1838,\n        1836,\n        2699,\n        2696,\n        2693,\n        2703,\n        1827,\n        1826,\n        1824,\n        2673,\n        2671,\n        2669,\n        2666,\n        1829,\n        2679,\n        2677,\n        1858,\n        1857,\n        2772,\n        1854,\n        1853,\n        1851,\n        1856,\n        2766,\n        2764,\n        143,\n        1987,\n        139,\n        1986,\n        135,\n        133,\n        131,\n        1984,\n        128,\n        1983,\n        125,\n        1981,\n        138,\n        137,\n        136,\n        1985,\n        1133,\n        1132,\n        1130,\n        112,\n        110,\n        1974,\n        107,\n        1973,\n        104,\n        1971,\n        1969,\n        122,\n        121,\n        119,\n        117,\n        1977,\n        114,\n        1976,\n        124,\n        1115,\n        1114,\n        1112,\n        1110,\n        1117,\n        1116,\n        84,\n        83,\n        1953,\n        81,\n        1952,\n        78,\n        1950,\n        1948,\n        1945,\n        94,\n        93,\n        91,\n        1959,\n        88,\n        1958,\n        85,\n        1955,\n        99,\n        97,\n        95,\n        1961,\n        1086,\n        1085,\n        1083,\n        1081,\n        1078,\n        100,\n        1090,\n        1089,\n        1087,\n        1091,\n        49,\n        47,\n        1917,\n        44,\n        1915,\n        1913,\n        1910,\n        1907,\n        59,\n        1926,\n        56,\n        1925,\n        53,\n        1922,\n        1919,\n        66,\n        64,\n        1931,\n        61,\n        1929,\n        1042,\n        1040,\n        1038,\n        71,\n        1035,\n        70,\n        1032,\n        68,\n        1048,\n        1047,\n        1045,\n        1043,\n        1050,\n        1049,\n        12,\n        10,\n        1869,\n        1867,\n        1864,\n        1861,\n        21,\n        1880,\n        19,\n        1877,\n        1874,\n        1871,\n        28,\n        1888,\n        25,\n        1886,\n        22,\n        1883,\n        982,\n        980,\n        977,\n        974,\n        32,\n        30,\n        991,\n        989,\n        987,\n        984,\n        34,\n        995,\n        994,\n        992,\n        2151,\n        2150,\n        2147,\n        2146,\n        2144,\n        356,\n        355,\n        354,\n        2149,\n        2139,\n        2138,\n        2136,\n        2134,\n        1359,\n        343,\n        341,\n        338,\n        2143,\n        335,\n        2141,\n        348,\n        347,\n        346,\n        1376,\n        1374,\n        2124,\n        2123,\n        2121,\n        2119,\n        1326,\n        2116,\n        1324,\n        310,\n        308,\n        305,\n        2131,\n        302,\n        2129,\n        298,\n        2127,\n        320,\n        318,\n        316,\n        313,\n        2133,\n        322,\n        321,\n        1355,\n        1353,\n        1351,\n        1357,\n        2092,\n        2091,\n        2089,\n        2087,\n        1276,\n        2084,\n        1274,\n        2081,\n        1271,\n        259,\n        2102,\n        256,\n        2100,\n        252,\n        2098,\n        2095,\n        272,\n        269,\n        2108,\n        266,\n        2106,\n        281,\n        279,\n        277,\n        1317,\n        1315,\n        1313,\n        1310,\n        282,\n        1321,\n        1319,\n        2039,\n        2037,\n        2035,\n        2032,\n        1203,\n        2029,\n        1200,\n        1197,\n        207,\n        2053,\n        205,\n        2051,\n        201,\n        2049,\n        2046,\n        2043,\n        220,\n        218,\n        2064,\n        215,\n        2062,\n        211,\n        2059,\n        228,\n        226,\n        223,\n        2069,\n        1259,\n        1257,\n        1254,\n        232,\n        1251,\n        230,\n        1267,\n        1265,\n        1263,\n        2316,\n        2315,\n        2312,\n        2311,\n        2309,\n        2314,\n        2304,\n        2303,\n        2301,\n        2299,\n        1593,\n        2308,\n        2306,\n        590,\n        2288,\n        2287,\n        2285,\n        2283,\n        1578,\n        2280,\n        1577,\n        2295,\n        2293,\n        2291,\n        579,\n        577,\n        574,\n        571,\n        2298,\n        582,\n        581,\n        1592,\n        2263,\n        2262,\n        2260,\n        2258,\n        1545,\n        2255,\n        1544,\n        2252,\n        1541,\n        2273,\n        2271,\n        2269,\n        2266,\n        1550,\n        535,\n        532,\n        2279,\n        528,\n        2277,\n        546,\n        543,\n        549,\n        1575,\n        1573,\n        2224,\n        2222,\n        2220,\n        1486,\n        2217,\n        1485,\n        2214,\n        1482,\n        1479,\n        2238,\n        2236,\n        2234,\n        2231,\n        1496,\n        2228,\n        1492,\n        480,\n        477,\n        2248,\n        473,\n        2246,\n        469,\n        2243,\n        490,\n        487,\n        2251,\n        497,\n        1537,\n        1535,\n        1532,\n        2477,\n        2476,\n        2474,\n        2479,\n        2469,\n        2468,\n        2466,\n        2464,\n        1730,\n        2473,\n        2471,\n        2453,\n        2452,\n        2450,\n        2448,\n        1729,\n        2445,\n        1728,\n        2460,\n        2458,\n        2456,\n        2463,\n        805,\n        804,\n        2428,\n        2427,\n        2425,\n        2423,\n        1725,\n        2420,\n        1724,\n        2417,\n        1722,\n        2438,\n        2436,\n        2434,\n        2431,\n        1727,\n        2444,\n        2442,\n        793,\n        791,\n        788,\n        795,\n        2388,\n        2386,\n        2384,\n        1697,\n        2381,\n        1696,\n        2378,\n        1694,\n        1692,\n        2402,\n        2400,\n        2398,\n        2395,\n        1703,\n        2392,\n        1701,\n        2412,\n        2410,\n        2407,\n        751,\n        748,\n        744,\n        2416,\n        759,\n        757,\n        1807,\n        2620,\n        2618,\n        1806,\n        1805,\n        2611,\n        2609,\n        2607,\n        2614,\n        1802,\n        1801,\n        1799,\n        2594,\n        2592,\n        2590,\n        2587,\n        1804,\n        2600,\n        2598,\n        1794,\n        1793,\n        1791,\n        1789,\n        2564,\n        2562,\n        2560,\n        2557,\n        1798,\n        2554,\n        1796,\n        2574,\n        2572,\n        2569,\n        2578,\n        1847,\n        1846,\n        2722,\n        1843,\n        1842,\n        1840,\n        1845,\n        2716,\n        2714,\n        1835,\n        1834,\n        1832,\n        1830,\n        1839,\n        1837,\n        2700,\n        2698,\n        2695,\n        2704,\n        1817,\n        1811,\n        1810,\n        897,\n        862,\n        1777,\n        829,\n        826,\n        838,\n        1760,\n        1758,\n        808,\n        2481,\n        1741,\n        1740,\n        1738,\n        1743,\n        2624,\n        1818,\n        2726,\n        2776,\n        782,\n        740,\n        737,\n        1715,\n        686,\n        679,\n        695,\n        1682,\n        1680,\n        639,\n        628,\n        2339,\n        647,\n        644,\n        1645,\n        1643,\n        1640,\n        1648,\n        602,\n        600,\n        597,\n        595,\n        2320,\n        593,\n        2318,\n        609,\n        607,\n        604,\n        1611,\n        1610,\n        1608,\n        1606,\n        613,\n        1615,\n        1613,\n        2328,\n        926,\n        924,\n        892,\n        886,\n        899,\n        857,\n        850,\n        2505,\n        1778,\n        824,\n        823,\n        821,\n        819,\n        2488,\n        818,\n        2486,\n        833,\n        831,\n        828,\n        840,\n        1761,\n        1759,\n        2649,\n        2632,\n        2630,\n        2746,\n        2734,\n        2732,\n        2782,\n        2781,\n        570,\n        567,\n        1587,\n        531,\n        527,\n        523,\n        540,\n        1566,\n        1564,\n        476,\n        467,\n        463,\n        2240,\n        486,\n        483,\n        1524,\n        1521,\n        1518,\n        1529,\n        411,\n        403,\n        2192,\n        399,\n        2189,\n        423,\n        416,\n        1462,\n        1457,\n        1454,\n        428,\n        1468,\n        1465,\n        2210,\n        366,\n        363,\n        2158,\n        360,\n        2156,\n        357,\n        2153,\n        376,\n        373,\n        370,\n        2163,\n        1410,\n        1409,\n        1407,\n        1405,\n        382,\n        1402,\n        380,\n        1417,\n        1415,\n        1412,\n        1421,\n        2175,\n        2174,\n        777,\n        774,\n        771,\n        784,\n        732,\n        725,\n        722,\n        2404,\n        743,\n        1716,\n        676,\n        674,\n        668,\n        2363,\n        665,\n        2360,\n        685,\n        1684,\n        1681,\n        626,\n        624,\n        622,\n        2335,\n        620,\n        2333,\n        617,\n        2330,\n        641,\n        635,\n        649,\n        1646,\n        1644,\n        1642,\n        2566,\n        928,\n        925,\n        2530,\n        2527,\n        894,\n        891,\n        888,\n        2501,\n        2499,\n        2496,\n        858,\n        856,\n        854,\n        851,\n        1779,\n        2692,\n        2668,\n        2665,\n        2645,\n        2643,\n        2640,\n        2651,\n        2768,\n        2759,\n        2757,\n        2744,\n        2743,\n        2741,\n        2748,\n        352,\n        1382,\n        340,\n        337,\n        333,\n        1371,\n        1369,\n        307,\n        300,\n        296,\n        2126,\n        315,\n        312,\n        1347,\n        1342,\n        1350,\n        261,\n        258,\n        250,\n        2097,\n        246,\n        2094,\n        271,\n        268,\n        264,\n        1306,\n        1301,\n        1298,\n        276,\n        1312,\n        1309,\n        2115,\n        203,\n        2048,\n        195,\n        2045,\n        191,\n        2041,\n        213,\n        209,\n        2056,\n        1246,\n        1244,\n        1238,\n        225,\n        1234,\n        222,\n        1256,\n        1253,\n        1249,\n        1262,\n        2080,\n        2079,\n        154,\n        1997,\n        150,\n        1995,\n        147,\n        1992,\n        1989,\n        163,\n        160,\n        2004,\n        156,\n        2001,\n        1175,\n        1174,\n        1172,\n        1170,\n        1167,\n        170,\n        1164,\n        167,\n        1185,\n        1183,\n        1180,\n        1177,\n        174,\n        1190,\n        1188,\n        2025,\n        2024,\n        2022,\n        587,\n        586,\n        564,\n        559,\n        556,\n        2290,\n        573,\n        1588,\n        520,\n        518,\n        512,\n        2268,\n        508,\n        2265,\n        530,\n        1568,\n        1565,\n        461,\n        457,\n        2233,\n        450,\n        2230,\n        446,\n        2226,\n        479,\n        471,\n        489,\n        1526,\n        1523,\n        1520,\n        397,\n        395,\n        2185,\n        392,\n        2183,\n        389,\n        2180,\n        2177,\n        410,\n        2194,\n        402,\n        422,\n        1463,\n        1461,\n        1459,\n        1456,\n        1470,\n        2455,\n        799,\n        2433,\n        2430,\n        779,\n        776,\n        773,\n        2397,\n        2394,\n        2390,\n        734,\n        728,\n        724,\n        746,\n        1717,\n        2356,\n        2354,\n        2351,\n        2348,\n        1658,\n        677,\n        675,\n        673,\n        670,\n        667,\n        688,\n        1685,\n        1683,\n        2606,\n        2589,\n        2586,\n        2559,\n        2556,\n        2552,\n        927,\n        2523,\n        2521,\n        2518,\n        2515,\n        1784,\n        2532,\n        895,\n        893,\n        890,\n        2718,\n        2709,\n        2707,\n        2689,\n        2687,\n        2684,\n        2663,\n        2662,\n        2660,\n        2658,\n        1825,\n        2667,\n        2769,\n        1852,\n        2760,\n        2758,\n        142,\n        141,\n        1139,\n        1138,\n        134,\n        132,\n        129,\n        126,\n        1982,\n        1129,\n        1128,\n        1126,\n        1131,\n        113,\n        111,\n        108,\n        105,\n        1972,\n        101,\n        1970,\n        120,\n        118,\n        115,\n        1109,\n        1108,\n        1106,\n        1104,\n        123,\n        1113,\n        1111,\n        82,\n        79,\n        1951,\n        75,\n        1949,\n        72,\n        1946,\n        92,\n        89,\n        86,\n        1956,\n        1077,\n        1076,\n        1074,\n        1072,\n        98,\n        1069,\n        96,\n        1084,\n        1082,\n        1079,\n        1088,\n        1968,\n        1967,\n        48,\n        45,\n        1916,\n        42,\n        1914,\n        39,\n        1911,\n        1908,\n        60,\n        57,\n        54,\n        1923,\n        50,\n        1920,\n        1031,\n        1030,\n        1028,\n        1026,\n        67,\n        1023,\n        65,\n        1020,\n        62,\n        1041,\n        1039,\n        1036,\n        1033,\n        69,\n        1046,\n        1044,\n        1944,\n        1943,\n        1941,\n        11,\n        9,\n        1868,\n        7,\n        1865,\n        1862,\n        1859,\n        20,\n        1878,\n        16,\n        1875,\n        13,\n        1872,\n        970,\n        968,\n        966,\n        963,\n        29,\n        960,\n        26,\n        23,\n        983,\n        981,\n        978,\n        975,\n        33,\n        971,\n        31,\n        990,\n        988,\n        985,\n        1906,\n        1904,\n        1902,\n        993,\n        351,\n        2145,\n        1383,\n        331,\n        330,\n        328,\n        326,\n        2137,\n        323,\n        2135,\n        339,\n        1372,\n        1370,\n        294,\n        293,\n        291,\n        289,\n        2122,\n        286,\n        2120,\n        283,\n        2117,\n        309,\n        303,\n        317,\n        1348,\n        1346,\n        1344,\n        245,\n        244,\n        242,\n        2090,\n        239,\n        2088,\n        236,\n        2085,\n        2082,\n        260,\n        2099,\n        249,\n        270,\n        1307,\n        1305,\n        1303,\n        1300,\n        1314,\n        189,\n        2038,\n        186,\n        2036,\n        183,\n        2033,\n        2030,\n        2026,\n        206,\n        198,\n        2047,\n        194,\n        216,\n        1247,\n        1245,\n        1243,\n        1240,\n        227,\n        1237,\n        1255,\n        2310,\n        2302,\n        2300,\n        2286,\n        2284,\n        2281,\n        565,\n        563,\n        561,\n        558,\n        575,\n        1589,\n        2261,\n        2259,\n        2256,\n        2253,\n        1542,\n        521,\n        519,\n        517,\n        514,\n        2270,\n        511,\n        533,\n        1569,\n        1567,\n        2223,\n        2221,\n        2218,\n        2215,\n        1483,\n        2211,\n        1480,\n        459,\n        456,\n        453,\n        2232,\n        449,\n        474,\n        491,\n        1527,\n        1525,\n        1522,\n        2475,\n        2467,\n        2465,\n        2451,\n        2449,\n        2446,\n        801,\n        800,\n        2426,\n        2424,\n        2421,\n        2418,\n        1723,\n        2435,\n        780,\n        778,\n        775,\n        2387,\n        2385,\n        2382,\n        2379,\n        1695,\n        2375,\n        1693,\n        2396,\n        735,\n        733,\n        730,\n        727,\n        749,\n        1718,\n        2616,\n        2615,\n        2604,\n        2603,\n        2601,\n        2584,\n        2583,\n        2581,\n        2579,\n        1800,\n        2591,\n        2550,\n        2549,\n        2547,\n        2545,\n        1792,\n        2542,\n        1790,\n        2558,\n        929,\n        2719,\n        1841,\n        2710,\n        2708,\n        1833,\n        1831,\n        2690,\n        2688,\n        2686,\n        1815,\n        1809,\n        1808,\n        1774,\n        1756,\n        1754,\n        1737,\n        1736,\n        1734,\n        1739,\n        1816,\n        1711,\n        1676,\n        1674,\n        633,\n        629,\n        1638,\n        1636,\n        1633,\n        1641,\n        598,\n        1605,\n        1604,\n        1602,\n        1600,\n        605,\n        1609,\n        1607,\n        2327,\n        887,\n        853,\n        1775,\n        822,\n        820,\n        1757,\n        1755,\n        1584,\n        524,\n        1560,\n        1558,\n        468,\n        464,\n        1514,\n        1511,\n        1508,\n        1519,\n        408,\n        404,\n        400,\n        1452,\n        1447,\n        1444,\n        417,\n        1458,\n        1455,\n        2208,\n        364,\n        361,\n        358,\n        2154,\n        1401,\n        1400,\n        1398,\n        1396,\n        374,\n        1393,\n        371,\n        1408,\n        1406,\n        1403,\n        1413,\n        2173,\n        2172,\n        772,\n        726,\n        723,\n        1712,\n        672,\n        669,\n        666,\n        682,\n        1678,\n        1675,\n        625,\n        623,\n        621,\n        618,\n        2331,\n        636,\n        632,\n        1639,\n        1637,\n        1635,\n        920,\n        918,\n        884,\n        880,\n        889,\n        849,\n        848,\n        847,\n        846,\n        2497,\n        855,\n        852,\n        1776,\n        2641,\n        2742,\n        2787,\n        1380,\n        334,\n        1367,\n        1365,\n        301,\n        297,\n        1340,\n        1338,\n        1335,\n        1343,\n        255,\n        251,\n        247,\n        1296,\n        1291,\n        1288,\n        265,\n        1302,\n        1299,\n        2113,\n        204,\n        196,\n        192,\n        2042,\n        1232,\n        1230,\n        1224,\n        214,\n        1220,\n        210,\n        1242,\n        1239,\n        1235,\n        1250,\n        2077,\n        2075,\n        151,\n        148,\n        1993,\n        144,\n        1990,\n        1163,\n        1162,\n        1160,\n        1158,\n        1155,\n        161,\n        1152,\n        157,\n        1173,\n        1171,\n        1168,\n        1165,\n        168,\n        1181,\n        1178,\n        2021,\n        2020,\n        2018,\n        2023,\n        585,\n        560,\n        557,\n        1585,\n        516,\n        509,\n        1562,\n        1559,\n        458,\n        447,\n        2227,\n        472,\n        1516,\n        1513,\n        1510,\n        398,\n        396,\n        393,\n        390,\n        2181,\n        386,\n        2178,\n        407,\n        1453,\n        1451,\n        1449,\n        1446,\n        420,\n        1460,\n        2209,\n        769,\n        764,\n        720,\n        712,\n        2391,\n        729,\n        1713,\n        664,\n        663,\n        661,\n        659,\n        2352,\n        656,\n        2349,\n        671,\n        1679,\n        1677,\n        2553,\n        922,\n        919,\n        2519,\n        2516,\n        885,\n        883,\n        881,\n        2685,\n        2661,\n        2659,\n        2767,\n        2756,\n        2755,\n        140,\n        1137,\n        1136,\n        130,\n        127,\n        1125,\n        1124,\n        1122,\n        1127,\n        109,\n        106,\n        102,\n        1103,\n        1102,\n        1100,\n        1098,\n        116,\n        1107,\n        1105,\n        1980,\n        80,\n        76,\n        73,\n        1947,\n        1068,\n        1067,\n        1065,\n        1063,\n        90,\n        1060,\n        87,\n        1075,\n        1073,\n        1070,\n        1080,\n        1966,\n        1965,\n        46,\n        43,\n        40,\n        1912,\n        36,\n        1909,\n        1019,\n        1018,\n        1016,\n        1014,\n        58,\n        1011,\n        55,\n        1008,\n        51,\n        1029,\n        1027,\n        1024,\n        1021,\n        63,\n        1037,\n        1034,\n        1940,\n        1939,\n        1937,\n        1942,\n        8,\n        1866,\n        4,\n        1863,\n        1,\n        1860,\n        956,\n        954,\n        952,\n        949,\n        946,\n        17,\n        14,\n        969,\n        967,\n        964,\n        961,\n        27,\n        957,\n        24,\n        979,\n        976,\n        972,\n        1901,\n        1900,\n        1898,\n        1896,\n        986,\n        1905,\n        1903,\n        350,\n        349,\n        1381,\n        329,\n        327,\n        324,\n        1368,\n        1366,\n        292,\n        290,\n        287,\n        284,\n        2118,\n        304,\n        1341,\n        1339,\n        1337,\n        1345,\n        243,\n        240,\n        237,\n        2086,\n        233,\n        2083,\n        254,\n        1297,\n        1295,\n        1293,\n        1290,\n        1304,\n        2114,\n        190,\n        187,\n        184,\n        2034,\n        180,\n        2031,\n        177,\n        2027,\n        199,\n        1233,\n        1231,\n        1229,\n        1226,\n        217,\n        1223,\n        1241,\n        2078,\n        2076,\n        584,\n        555,\n        554,\n        552,\n        550,\n        2282,\n        562,\n        1586,\n        507,\n        506,\n        504,\n        502,\n        2257,\n        499,\n        2254,\n        515,\n        1563,\n        1561,\n        445,\n        443,\n        441,\n        2219,\n        438,\n        2216,\n        435,\n        2212,\n        460,\n        454,\n        475,\n        1517,\n        1515,\n        1512,\n        2447,\n        798,\n        797,\n        2422,\n        2419,\n        770,\n        768,\n        766,\n        2383,\n        2380,\n        2376,\n        721,\n        719,\n        717,\n        714,\n        731,\n        1714,\n        2602,\n        2582,\n        2580,\n        2548,\n        2546,\n        2543,\n        923,\n        921,\n        2717,\n        2706,\n        2705,\n        2683,\n        2682,\n        2680,\n        1771,\n        1752,\n        1750,\n        1733,\n        1732,\n        1731,\n        1735,\n        1814,\n        1707,\n        1670,\n        1668,\n        1631,\n        1629,\n        1626,\n        1634,\n        1599,\n        1598,\n        1596,\n        1594,\n        1603,\n        1601,\n        2326,\n        1772,\n        1753,\n        1751,\n        1581,\n        1554,\n        1552,\n        1504,\n        1501,\n        1498,\n        1509,\n        1442,\n        1437,\n        1434,\n        401,\n        1448,\n        1445,\n        2206,\n        1392,\n        1391,\n        1389,\n        1387,\n        1384,\n        359,\n        1399,\n        1397,\n        1394,\n        1404,\n        2171,\n        2170,\n        1708,\n        1672,\n        1669,\n        619,\n        1632,\n        1630,\n        1628,\n        1773,\n        1378,\n        1363,\n        1361,\n        1333,\n        1328,\n        1336,\n        1286,\n        1281,\n        1278,\n        248,\n        1292,\n        1289,\n        2111,\n        1218,\n        1216,\n        1210,\n        197,\n        1206,\n        193,\n        1228,\n        1225,\n        1221,\n        1236,\n        2073,\n        2071,\n        1151,\n        1150,\n        1148,\n        1146,\n        152,\n        1143,\n        149,\n        1140,\n        145,\n        1161,\n        1159,\n        1156,\n        1153,\n        158,\n        1169,\n        1166,\n        2017,\n        2016,\n        2014,\n        2019,\n        1582,\n        510,\n        1556,\n        1553,\n        452,\n        448,\n        1506,\n        1500,\n        394,\n        391,\n        387,\n        1443,\n        1441,\n        1439,\n        1436,\n        1450,\n        2207,\n        765,\n        716,\n        713,\n        1709,\n        662,\n        660,\n        657,\n        1673,\n        1671,\n        916,\n        914,\n        879,\n        878,\n        877,\n        882,\n        1135,\n        1134,\n        1121,\n        1120,\n        1118,\n        1123,\n        1097,\n        1096,\n        1094,\n        1092,\n        103,\n        1101,\n        1099,\n        1979,\n        1059,\n        1058,\n        1056,\n        1054,\n        77,\n        1051,\n        74,\n        1066,\n        1064,\n        1061,\n        1071,\n        1964,\n        1963,\n        1007,\n        1006,\n        1004,\n        1002,\n        999,\n        41,\n        996,\n        37,\n        1017,\n        1015,\n        1012,\n        1009,\n        52,\n        1025,\n        1022,\n        1936,\n        1935,\n        1933,\n        1938,\n        942,\n        940,\n        938,\n        935,\n        932,\n        5,\n        2,\n        955,\n        953,\n        950,\n        947,\n        18,\n        943,\n        15,\n        965,\n        962,\n        958,\n        1895,\n        1894,\n        1892,\n        1890,\n        973,\n        1899,\n        1897,\n        1379,\n        325,\n        1364,\n        1362,\n        288,\n        285,\n        1334,\n        1332,\n        1330,\n        241,\n        238,\n        234,\n        1287,\n        1285,\n        1283,\n        1280,\n        1294,\n        2112,\n        188,\n        185,\n        181,\n        178,\n        2028,\n        1219,\n        1217,\n        1215,\n        1212,\n        200,\n        1209,\n        1227,\n        2074,\n        2072,\n        583,\n        553,\n        551,\n        1583,\n        505,\n        503,\n        500,\n        513,\n        1557,\n        1555,\n        444,\n        442,\n        439,\n        436,\n        2213,\n        455,\n        451,\n        1507,\n        1505,\n        1502,\n        796,\n        763,\n        762,\n        760,\n        767,\n        711,\n        710,\n        708,\n        706,\n        2377,\n        718,\n        715,\n        1710,\n        2544,\n        917,\n        915,\n        2681,\n        1627,\n        1597,\n        1595,\n        2325,\n        1769,\n        1749,\n        1747,\n        1499,\n        1438,\n        1435,\n        2204,\n        1390,\n        1388,\n        1385,\n        1395,\n        2169,\n        2167,\n        1704,\n        1665,\n        1662,\n        1625,\n        1623,\n        1620,\n        1770,\n        1329,\n        1282,\n        1279,\n        2109,\n        1214,\n        1207,\n        1222,\n        2068,\n        2065,\n        1149,\n        1147,\n        1144,\n        1141,\n        146,\n        1157,\n        1154,\n        2013,\n        2011,\n        2008,\n        2015,\n        1579,\n        1549,\n        1546,\n        1495,\n        1487,\n        1433,\n        1431,\n        1428,\n        1425,\n        388,\n        1440,\n        2205,\n        1705,\n        658,\n        1667,\n        1664,\n        1119,\n        1095,\n        1093,\n        1978,\n        1057,\n        1055,\n        1052,\n        1062,\n        1962,\n        1960,\n        1005,\n        1003,\n        1000,\n        997,\n        38,\n        1013,\n        1010,\n        1932,\n        1930,\n        1927,\n        1934,\n        941,\n        939,\n        936,\n        933,\n        6,\n        930,\n        3,\n        951,\n        948,\n        944,\n        1889,\n        1887,\n        1884,\n        1881,\n        959,\n        1893,\n        1891,\n        35,\n        1377,\n        1360,\n        1358,\n        1327,\n        1325,\n        1322,\n        1331,\n        1277,\n        1275,\n        1272,\n        1269,\n        235,\n        1284,\n        2110,\n        1205,\n        1204,\n        1201,\n        1198,\n        182,\n        1195,\n        179,\n        1213,\n        2070,\n        2067,\n        1580,\n        501,\n        1551,\n        1548,\n        440,\n        437,\n        1497,\n        1494,\n        1490,\n        1503,\n        761,\n        709,\n        707,\n        1706,\n        913,\n        912,\n        2198,\n        1386,\n        2164,\n        2161,\n        1621,\n        1766,\n        2103,\n        1208,\n        2058,\n        2054,\n        1145,\n        1142,\n        2005,\n        2002,\n        1999,\n        2009,\n        1488,\n        1429,\n        1426,\n        2200,\n        1698,\n        1659,\n        1656,\n        1975,\n        1053,\n        1957,\n        1954,\n        1001,\n        998,\n        1924,\n        1921,\n        1918,\n        1928,\n        937,\n        934,\n        931,\n        1879,\n        1876,\n        1873,\n        1870,\n        945,\n        1885,\n        1882,\n        1323,\n        1273,\n        1270,\n        2105,\n        1202,\n        1199,\n        1196,\n        1211,\n        2061,\n        2057,\n        1576,\n        1543,\n        1540,\n        1484,\n        1481,\n        1478,\n        1491,\n        1700\n    ]);\n    /*\n    * Copyright 2007 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */ // import java.util.List;\n    /**\n     * @author Guenther Grau\n     */ /*public final*/ class PDF417DetectorResult {\n        constructor(bits, points){\n            this.bits = bits;\n            this.points = points;\n        }\n        getBits() {\n            return this.bits;\n        }\n        getPoints() {\n            return this.points;\n        }\n    }\n    /*\n    * Copyright 2009 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */ // import java.util.ArrayList;\n    // import java.util.Arrays;\n    // import java.util.List;\n    // import java.util.Map;\n    /**\n     * <p>Encapsulates logic that can detect a PDF417 Code in an image, even if the\n     * PDF417 Code is rotated or skewed, or partially obscured.</p>\n     *\n     * @author SITA Lab (kevin.osullivan@sita.aero)\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Guenther Grau\n     */ /*public*/ /*final*/ class Detector$3 {\n        /**\n         * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>\n         *\n         * @param image barcode image to decode\n         * @param hints optional hints to detector\n         * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\n         * be found and returned\n         * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code\n         * @throws NotFoundException if no PDF417 Code can be found\n         */ static detectMultiple(image, hints, multiple) {\n            // TODO detection improvement, tryHarder could try several different luminance thresholds/blackpoints or even\n            // different binarizers\n            // boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);\n            let bitMatrix = image.getBlackMatrix();\n            let barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);\n            if (!barcodeCoordinates.length) {\n                bitMatrix = bitMatrix.clone();\n                bitMatrix.rotate180();\n                barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);\n            }\n            return new PDF417DetectorResult(bitMatrix, barcodeCoordinates);\n        }\n        /**\n         * Detects PDF417 codes in an image. Only checks 0 degree rotation\n         * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\n         * be found and returned\n         * @param bitMatrix bit matrix to detect barcodes in\n         * @return List of ResultPoint arrays containing the coordinates of found barcodes\n         */ static detect(multiple, bitMatrix) {\n            const barcodeCoordinates = new Array();\n            let row = 0;\n            let column = 0;\n            let foundBarcodeInRow = false;\n            while(row < bitMatrix.getHeight()){\n                const vertices = Detector$3.findVertices(bitMatrix, row, column);\n                if (vertices[0] == null && vertices[3] == null) {\n                    if (!foundBarcodeInRow) {\n                        break;\n                    }\n                    // we didn't find a barcode starting at the given column and row. Try again from the first column and slightly\n                    // below the lowest barcode we found so far.\n                    foundBarcodeInRow = false;\n                    column = 0;\n                    for (const barcodeCoordinate of barcodeCoordinates){\n                        if (barcodeCoordinate[1] != null) {\n                            row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));\n                        }\n                        if (barcodeCoordinate[3] != null) {\n                            row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));\n                        }\n                    }\n                    row += Detector$3.ROW_STEP;\n                    continue;\n                }\n                foundBarcodeInRow = true;\n                barcodeCoordinates.push(vertices);\n                if (!multiple) {\n                    break;\n                }\n                // if we didn't find a right row indicator column, then continue the search for the next barcode after the\n                // start pattern of the barcode just found.\n                if (vertices[2] != null) {\n                    column = Math.trunc(vertices[2].getX());\n                    row = Math.trunc(vertices[2].getY());\n                } else {\n                    column = Math.trunc(vertices[4].getX());\n                    row = Math.trunc(vertices[4].getY());\n                }\n            }\n            return barcodeCoordinates;\n        }\n        /**\n         * Locate the vertices and the codewords area of a black blob using the Start\n         * and Stop patterns as locators.\n         *\n         * @param matrix the scanned barcode image.\n         * @return an array containing the vertices:\n         *           vertices[0] x, y top left barcode\n         *           vertices[1] x, y bottom left barcode\n         *           vertices[2] x, y top right barcode\n         *           vertices[3] x, y bottom right barcode\n         *           vertices[4] x, y top left codeword area\n         *           vertices[5] x, y bottom left codeword area\n         *           vertices[6] x, y top right codeword area\n         *           vertices[7] x, y bottom right codeword area\n         */ static findVertices(matrix, startRow, startColumn) {\n            const height = matrix.getHeight();\n            const width = matrix.getWidth();\n            // const result = new ResultPoint[8];\n            const result = new Array(8);\n            Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.START_PATTERN), Detector$3.INDEXES_START_PATTERN);\n            if (result[4] != null) {\n                startColumn = Math.trunc(result[4].getX());\n                startRow = Math.trunc(result[4].getY());\n            }\n            Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.STOP_PATTERN), Detector$3.INDEXES_STOP_PATTERN);\n            return result;\n        }\n        static copyToResult(result, tmpResult, destinationIndexes) {\n            for(let i = 0; i < destinationIndexes.length; i++){\n                result[destinationIndexes[i]] = tmpResult[i];\n            }\n        }\n        static findRowsWithPattern(matrix, height, width, startRow, startColumn, pattern) {\n            // const result = new ResultPoint[4];\n            const result = new Array(4);\n            let found = false;\n            const counters = new Int32Array(pattern.length);\n            for(; startRow < height; startRow += Detector$3.ROW_STEP){\n                let loc = Detector$3.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);\n                if (loc != null) {\n                    while(startRow > 0){\n                        const previousRowLoc = Detector$3.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);\n                        if (previousRowLoc != null) {\n                            loc = previousRowLoc;\n                        } else {\n                            startRow++;\n                            break;\n                        }\n                    }\n                    result[0] = new ResultPoint(loc[0], startRow);\n                    result[1] = new ResultPoint(loc[1], startRow);\n                    found = true;\n                    break;\n                }\n            }\n            let stopRow = startRow + 1;\n            // Last row of the current symbol that contains pattern\n            if (found) {\n                let skippedRowCount = 0;\n                let previousRowLoc = Int32Array.from([\n                    Math.trunc(result[0].getX()),\n                    Math.trunc(result[1].getX())\n                ]);\n                for(; stopRow < height; stopRow++){\n                    const loc = Detector$3.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);\n                    // a found pattern is only considered to belong to the same barcode if the start and end positions\n                    // don't differ too much. Pattern drift should be not bigger than two for consecutive rows. With\n                    // a higher number of skipped rows drift could be larger. To keep it simple for now, we allow a slightly\n                    // larger drift and don't check for skipped rows.\n                    if (loc != null && Math.abs(previousRowLoc[0] - loc[0]) < Detector$3.MAX_PATTERN_DRIFT && Math.abs(previousRowLoc[1] - loc[1]) < Detector$3.MAX_PATTERN_DRIFT) {\n                        previousRowLoc = loc;\n                        skippedRowCount = 0;\n                    } else {\n                        if (skippedRowCount > Detector$3.SKIPPED_ROW_COUNT_MAX) {\n                            break;\n                        } else {\n                            skippedRowCount++;\n                        }\n                    }\n                }\n                stopRow -= skippedRowCount + 1;\n                result[2] = new ResultPoint(previousRowLoc[0], stopRow);\n                result[3] = new ResultPoint(previousRowLoc[1], stopRow);\n            }\n            if (stopRow - startRow < Detector$3.BARCODE_MIN_HEIGHT) {\n                Arrays.fill(result, null);\n            }\n            return result;\n        }\n        /**\n         * @param matrix row of black/white values to search\n         * @param column x position to start search\n         * @param row y position to start search\n         * @param width the number of pixels to search on this row\n         * @param pattern pattern of counts of number of black and white pixels that are\n         *                 being searched for as a pattern\n         * @param counters array of counters, as long as pattern, to re-use\n         * @return start/end horizontal offset of guard pattern, as an array of two ints.\n         */ static findGuardPattern(matrix, column, row, width, whiteFirst, pattern, counters) {\n            Arrays.fillWithin(counters, 0, counters.length, 0);\n            let patternStart = column;\n            let pixelDrift = 0;\n            // if there are black pixels left of the current pixel shift to the left, but only for MAX_PIXEL_DRIFT pixels\n            while(matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector$3.MAX_PIXEL_DRIFT){\n                patternStart--;\n            }\n            let x = patternStart;\n            let counterPosition = 0;\n            let patternLength = pattern.length;\n            for(let isWhite = whiteFirst; x < width; x++){\n                let pixel = matrix.get(x, row);\n                if (pixel !== isWhite) {\n                    counters[counterPosition]++;\n                } else {\n                    if (counterPosition === patternLength - 1) {\n                        if (Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {\n                            return new Int32Array([\n                                patternStart,\n                                x\n                            ]);\n                        }\n                        patternStart += counters[0] + counters[1];\n                        System.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    } else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            if (counterPosition === patternLength - 1 && Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {\n                return new Int32Array([\n                    patternStart,\n                    x - 1\n                ]);\n            }\n            return null;\n        }\n        /**\n         * Determines how closely a set of observed counts of runs of black/white\n         * values matches a given target pattern. This is reported as the ratio of\n         * the total variance from the expected pattern proportions across all\n         * pattern elements, to the length of the pattern.\n         *\n         * @param counters observed counters\n         * @param pattern expected pattern\n         * @param maxIndividualVariance The most any counter can differ before we give up\n         * @return ratio of total variance between counters and pattern compared to total pattern size\n         */ static patternMatchVariance(counters, pattern, maxIndividualVariance) {\n            let numCounters = counters.length;\n            let total = 0;\n            let patternLength = 0;\n            for(let i = 0; i < numCounters; i++){\n                total += counters[i];\n                patternLength += pattern[i];\n            }\n            if (total < patternLength) {\n                // If we don't even have one pixel per unit of bar width, assume this\n                // is too small to reliably match, so fail:\n                return /*Float.POSITIVE_INFINITY*/ Infinity;\n            }\n            // We're going to fake floating-point math in integers. We just need to use more bits.\n            // Scale up patternLength so that intermediate values below like scaledCounter will have\n            // more \"significant digits\".\n            let unitBarWidth = total / patternLength;\n            maxIndividualVariance *= unitBarWidth;\n            let totalVariance = 0.0;\n            for(let x = 0; x < numCounters; x++){\n                let counter = counters[x];\n                let scaledPattern = pattern[x] * unitBarWidth;\n                let variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n                if (variance > maxIndividualVariance) {\n                    return /*Float.POSITIVE_INFINITY*/ Infinity;\n                }\n                totalVariance += variance;\n            }\n            return totalVariance / total;\n        }\n    }\n    Detector$3.INDEXES_START_PATTERN = Int32Array.from([\n        0,\n        4,\n        1,\n        5\n    ]);\n    Detector$3.INDEXES_STOP_PATTERN = Int32Array.from([\n        6,\n        2,\n        7,\n        3\n    ]);\n    Detector$3.MAX_AVG_VARIANCE = 0.42;\n    Detector$3.MAX_INDIVIDUAL_VARIANCE = 0.8;\n    // B S B S B S B S Bar/Space pattern\n    // 11111111 0 1 0 1 0 1 000\n    Detector$3.START_PATTERN = Int32Array.from([\n        8,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        3\n    ]);\n    // 1111111 0 1 000 1 0 1 00 1\n    Detector$3.STOP_PATTERN = Int32Array.from([\n        7,\n        1,\n        1,\n        3,\n        1,\n        1,\n        1,\n        2,\n        1\n    ]);\n    Detector$3.MAX_PIXEL_DRIFT = 3;\n    Detector$3.MAX_PATTERN_DRIFT = 5;\n    // if we set the value too low, then we don't detect the correct height of the bar if the start patterns are damaged.\n    // if we set the value too high, then we might detect the start pattern from a neighbor barcode.\n    Detector$3.SKIPPED_ROW_COUNT_MAX = 25;\n    // A PDF471 barcode should have at least 3 rows, with each row being >= 3 times the module width. Therefore it should be at least\n    // 9 pixels tall. To be conservative, we use about half the size to ensure we don't miss it.\n    Detector$3.ROW_STEP = 5;\n    Detector$3.BARCODE_MIN_HEIGHT = 10;\n    /*\n    * Copyright 2012 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */ /**\n     * @author Sean Owen\n     * @see com.google.zxing.common.reedsolomon.GenericGFPoly\n     */ /*final*/ class ModulusPoly {\n        constructor(field, coefficients){\n            if (coefficients.length === 0) {\n                throw new IllegalArgumentException();\n            }\n            this.field = field;\n            let coefficientsLength = /*int*/ coefficients.length;\n            if (coefficientsLength > 1 && coefficients[0] === 0) {\n                // Leading term must be non-zero for anything except the constant polynomial \"0\"\n                let firstNonZero = /*int*/ 1;\n                while(firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0){\n                    firstNonZero++;\n                }\n                if (firstNonZero === coefficientsLength) {\n                    this.coefficients = new Int32Array([\n                        0\n                    ]);\n                } else {\n                    this.coefficients = new Int32Array(coefficientsLength - firstNonZero);\n                    System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);\n                }\n            } else {\n                this.coefficients = coefficients;\n            }\n        }\n        getCoefficients() {\n            return this.coefficients;\n        }\n        /**\n         * @return degree of this polynomial\n         */ getDegree() {\n            return this.coefficients.length - 1;\n        }\n        /**\n         * @return true iff this polynomial is the monomial \"0\"\n         */ isZero() {\n            return this.coefficients[0] === 0;\n        }\n        /**\n         * @return coefficient of x^degree term in this polynomial\n         */ getCoefficient(degree) {\n            return this.coefficients[this.coefficients.length - 1 - degree];\n        }\n        /**\n         * @return evaluation of this polynomial at a given point\n         */ evaluateAt(a) {\n            if (a === 0) {\n                // Just return the x^0 coefficient\n                return this.getCoefficient(0);\n            }\n            if (a === 1) {\n                // Just the sum of the coefficients\n                let sum = /*int*/ 0;\n                for (let coefficient /*int*/  of this.coefficients){\n                    sum = this.field.add(sum, coefficient);\n                }\n                return sum;\n            }\n            let result = /*int*/ this.coefficients[0];\n            let size = /*int*/ this.coefficients.length;\n            for(let i /*int*/  = 1; i < size; i++){\n                result = this.field.add(this.field.multiply(a, result), this.coefficients[i]);\n            }\n            return result;\n        }\n        add(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException(\"ModulusPolys do not have same ModulusGF field\");\n            }\n            if (this.isZero()) {\n                return other;\n            }\n            if (other.isZero()) {\n                return this;\n            }\n            let smallerCoefficients = this.coefficients;\n            let largerCoefficients = other.coefficients;\n            if (smallerCoefficients.length > largerCoefficients.length) {\n                let temp = smallerCoefficients;\n                smallerCoefficients = largerCoefficients;\n                largerCoefficients = temp;\n            }\n            let sumDiff = new Int32Array(largerCoefficients.length);\n            let lengthDiff = /*int*/ largerCoefficients.length - smallerCoefficients.length;\n            // Copy high-order terms only found in higher-degree polynomial's coefficients\n            System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);\n            for(let i /*int*/  = lengthDiff; i < largerCoefficients.length; i++){\n                sumDiff[i] = this.field.add(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n            }\n            return new ModulusPoly(this.field, sumDiff);\n        }\n        subtract(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException(\"ModulusPolys do not have same ModulusGF field\");\n            }\n            if (other.isZero()) {\n                return this;\n            }\n            return this.add(other.negative());\n        }\n        multiply(other) {\n            if (other instanceof ModulusPoly) {\n                return this.multiplyOther(other);\n            }\n            return this.multiplyScalar(other);\n        }\n        multiplyOther(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException(\"ModulusPolys do not have same ModulusGF field\");\n            }\n            if (this.isZero() || other.isZero()) {\n                // return this.field.getZero();\n                return new ModulusPoly(this.field, new Int32Array([\n                    0\n                ]));\n            }\n            let aCoefficients = this.coefficients;\n            let aLength = /*int*/ aCoefficients.length;\n            let bCoefficients = other.coefficients;\n            let bLength = /*int*/ bCoefficients.length;\n            let product = new Int32Array(aLength + bLength - 1);\n            for(let i /*int*/  = 0; i < aLength; i++){\n                let aCoeff = /*int*/ aCoefficients[i];\n                for(let j /*int*/  = 0; j < bLength; j++){\n                    product[i + j] = this.field.add(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));\n                }\n            }\n            return new ModulusPoly(this.field, product);\n        }\n        negative() {\n            let size = /*int*/ this.coefficients.length;\n            let negativeCoefficients = new Int32Array(size);\n            for(let i /*int*/  = 0; i < size; i++){\n                negativeCoefficients[i] = this.field.subtract(0, this.coefficients[i]);\n            }\n            return new ModulusPoly(this.field, negativeCoefficients);\n        }\n        multiplyScalar(scalar) {\n            if (scalar === 0) {\n                return new ModulusPoly(this.field, new Int32Array([\n                    0\n                ]));\n            }\n            if (scalar === 1) {\n                return this;\n            }\n            let size = /*int*/ this.coefficients.length;\n            let product = new Int32Array(size);\n            for(let i /*int*/  = 0; i < size; i++){\n                product[i] = this.field.multiply(this.coefficients[i], scalar);\n            }\n            return new ModulusPoly(this.field, product);\n        }\n        multiplyByMonomial(degree, coefficient) {\n            if (degree < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (coefficient === 0) {\n                return new ModulusPoly(this.field, new Int32Array([\n                    0\n                ]));\n            }\n            let size = /*int*/ this.coefficients.length;\n            let product = new Int32Array(size + degree);\n            for(let i /*int*/  = 0; i < size; i++){\n                product[i] = this.field.multiply(this.coefficients[i], coefficient);\n            }\n            return new ModulusPoly(this.field, product);\n        }\n        /*\n        ModulusPoly[] divide(other: ModulusPoly) {\n          if (!field.equals(other.field)) {\n            throw new IllegalArgumentException(\"ModulusPolys do not have same ModulusGF field\");\n          }\n          if (other.isZero()) {\n            throw new IllegalArgumentException(\"Divide by 0\");\n          }\n      \n          let quotient: ModulusPoly = field.getZero();\n          let remainder: ModulusPoly = this;\n      \n          let denominatorLeadingTerm: /*int/ number = other.getCoefficient(other.getDegree());\n          let inverseDenominatorLeadingTerm: /*int/ number = field.inverse(denominatorLeadingTerm);\n      \n          while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {\n            let degreeDifference: /*int/ number = remainder.getDegree() - other.getDegree();\n            let scale: /*int/ number = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);\n            let term: ModulusPoly = other.multiplyByMonomial(degreeDifference, scale);\n            let iterationQuotient: ModulusPoly = field.buildMonomial(degreeDifference, scale);\n            quotient = quotient.add(iterationQuotient);\n            remainder = remainder.subtract(term);\n          }\n      \n          return new ModulusPoly[] { quotient, remainder };\n        }\n        */ // @Override\n        toString() {\n            let result = new StringBuilder(); // dynamic string size in JS\n            for(let degree /*int*/  = this.getDegree(); degree >= 0; degree--){\n                let coefficient = /*int*/ this.getCoefficient(degree);\n                if (coefficient !== 0) {\n                    if (coefficient < 0) {\n                        result.append(\" - \");\n                        coefficient = -coefficient;\n                    } else {\n                        if (result.length() > 0) {\n                            result.append(\" + \");\n                        }\n                    }\n                    if (degree === 0 || coefficient !== 1) {\n                        result.append(coefficient);\n                    }\n                    if (degree !== 0) {\n                        if (degree === 1) {\n                            result.append(\"x\");\n                        } else {\n                            result.append(\"x^\");\n                            result.append(degree);\n                        }\n                    }\n                }\n            }\n            return result.toString();\n        }\n    }\n    class ModulusBase {\n        add(a, b) {\n            return (a + b) % this.modulus;\n        }\n        subtract(a, b) {\n            return (this.modulus + a - b) % this.modulus;\n        }\n        exp(a) {\n            return this.expTable[a];\n        }\n        log(a) {\n            if (a === 0) {\n                throw new IllegalArgumentException();\n            }\n            return this.logTable[a];\n        }\n        inverse(a) {\n            if (a === 0) {\n                throw new ArithmeticException();\n            }\n            return this.expTable[this.modulus - this.logTable[a] - 1];\n        }\n        multiply(a, b) {\n            if (a === 0 || b === 0) {\n                return 0;\n            }\n            return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.modulus - 1)];\n        }\n        getSize() {\n            return this.modulus;\n        }\n        equals(o) {\n            return o === this;\n        }\n    }\n    /*\n     * Copyright 2012 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * <p>A field based on powers of a generator integer, modulo some modulus.</p>\n     *\n     * @author Sean Owen\n     * @see com.google.zxing.common.reedsolomon.GenericGF\n     */ /*public final*/ class ModulusGF extends ModulusBase {\n        // private /*final*/ modulus: /*int*/ number;\n        constructor(modulus, generator){\n            super();\n            this.modulus = modulus;\n            this.expTable = new Int32Array(modulus);\n            this.logTable = new Int32Array(modulus);\n            let x = /*int*/ 1;\n            for(let i /*int*/  = 0; i < modulus; i++){\n                this.expTable[i] = x;\n                x = x * generator % modulus;\n            }\n            for(let i /*int*/  = 0; i < modulus - 1; i++){\n                this.logTable[this.expTable[i]] = i;\n            }\n            // logTable[0] == 0 but this should never be used\n            this.zero = new ModulusPoly(this, new Int32Array([\n                0\n            ]));\n            this.one = new ModulusPoly(this, new Int32Array([\n                1\n            ]));\n        }\n        getZero() {\n            return this.zero;\n        }\n        getOne() {\n            return this.one;\n        }\n        buildMonomial(degree, coefficient) {\n            if (degree < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (coefficient === 0) {\n                return this.zero;\n            }\n            let coefficients = new Int32Array(degree + 1);\n            coefficients[0] = coefficient;\n            return new ModulusPoly(this, coefficients);\n        }\n    }\n    ModulusGF.PDF417_GF = new ModulusGF(PDF417Common.NUMBER_OF_CODEWORDS, 3);\n    /*\n    * Copyright 2012 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */ /**\n     * <p>PDF417 error correction implementation.</p>\n     *\n     * <p>This <a href=\"http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example\">example</a>\n     * is quite useful in understanding the algorithm.</p>\n     *\n     * @author Sean Owen\n     * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder\n     */ /*public final*/ class ErrorCorrection {\n        constructor(){\n            this.field = ModulusGF.PDF417_GF;\n        }\n        /**\n         * @param received received codewords\n         * @param numECCodewords number of those codewords used for EC\n         * @param erasures location of erasures\n         * @return number of errors\n         * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors\n         */ decode(received, numECCodewords, erasures) {\n            let poly = new ModulusPoly(this.field, received);\n            let S = new Int32Array(numECCodewords);\n            let error = false;\n            for(let i /*int*/  = numECCodewords; i > 0; i--){\n                let evaluation = poly.evaluateAt(this.field.exp(i));\n                S[numECCodewords - i] = evaluation;\n                if (evaluation !== 0) {\n                    error = true;\n                }\n            }\n            if (!error) {\n                return 0;\n            }\n            let knownErrors = this.field.getOne();\n            if (erasures != null) {\n                for (const erasure of erasures){\n                    let b = this.field.exp(received.length - 1 - erasure);\n                    // Add (1 - bx) term:\n                    let term = new ModulusPoly(this.field, new Int32Array([\n                        this.field.subtract(0, b),\n                        1\n                    ]));\n                    knownErrors = knownErrors.multiply(term);\n                }\n            }\n            let syndrome = new ModulusPoly(this.field, S);\n            // syndrome = syndrome.multiply(knownErrors);\n            let sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);\n            let sigma = sigmaOmega[0];\n            let omega = sigmaOmega[1];\n            // sigma = sigma.multiply(knownErrors);\n            let errorLocations = this.findErrorLocations(sigma);\n            let errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);\n            for(let i /*int*/  = 0; i < errorLocations.length; i++){\n                let position = received.length - 1 - this.field.log(errorLocations[i]);\n                if (position < 0) {\n                    throw ChecksumException.getChecksumInstance();\n                }\n                received[position] = this.field.subtract(received[position], errorMagnitudes[i]);\n            }\n            return errorLocations.length;\n        }\n        /**\n         *\n         * @param ModulusPoly\n         * @param a\n         * @param ModulusPoly\n         * @param b\n         * @param int\n         * @param R\n         * @throws ChecksumException\n         */ runEuclideanAlgorithm(a, b, R) {\n            // Assume a's degree is >= b's\n            if (a.getDegree() < b.getDegree()) {\n                let temp = a;\n                a = b;\n                b = temp;\n            }\n            let rLast = a;\n            let r = b;\n            let tLast = this.field.getZero();\n            let t = this.field.getOne();\n            // Run Euclidean algorithm until r's degree is less than R/2\n            while(r.getDegree() >= Math.round(R / 2)){\n                let rLastLast = rLast;\n                let tLastLast = tLast;\n                rLast = r;\n                tLast = t;\n                // Divide rLastLast by rLast, with quotient in q and remainder in r\n                if (rLast.isZero()) {\n                    // Oops, Euclidean algorithm already terminated?\n                    throw ChecksumException.getChecksumInstance();\n                }\n                r = rLastLast;\n                let q = this.field.getZero();\n                let denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n                let dltInverse = this.field.inverse(denominatorLeadingTerm);\n                while(r.getDegree() >= rLast.getDegree() && !r.isZero()){\n                    let degreeDiff = r.getDegree() - rLast.getDegree();\n                    let scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n                    q = q.add(this.field.buildMonomial(degreeDiff, scale));\n                    r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));\n                }\n                t = q.multiply(tLast).subtract(tLastLast).negative();\n            }\n            let sigmaTildeAtZero = t.getCoefficient(0);\n            if (sigmaTildeAtZero === 0) {\n                throw ChecksumException.getChecksumInstance();\n            }\n            let inverse = this.field.inverse(sigmaTildeAtZero);\n            let sigma = t.multiply(inverse);\n            let omega = r.multiply(inverse);\n            return [\n                sigma,\n                omega\n            ];\n        }\n        /**\n         *\n         * @param errorLocator\n         * @throws ChecksumException\n         */ findErrorLocations(errorLocator) {\n            // This is a direct application of Chien's search\n            let numErrors = errorLocator.getDegree();\n            let result = new Int32Array(numErrors);\n            let e = 0;\n            for(let i /*int*/  = 1; i < this.field.getSize() && e < numErrors; i++){\n                if (errorLocator.evaluateAt(i) === 0) {\n                    result[e] = this.field.inverse(i);\n                    e++;\n                }\n            }\n            if (e !== numErrors) {\n                throw ChecksumException.getChecksumInstance();\n            }\n            return result;\n        }\n        findErrorMagnitudes(errorEvaluator, errorLocator, errorLocations) {\n            let errorLocatorDegree = errorLocator.getDegree();\n            let formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);\n            for(let i /*int*/  = 1; i <= errorLocatorDegree; i++){\n                formalDerivativeCoefficients[errorLocatorDegree - i] = this.field.multiply(i, errorLocator.getCoefficient(i));\n            }\n            let formalDerivative = new ModulusPoly(this.field, formalDerivativeCoefficients);\n            // This is directly applying Forney's Formula\n            let s = errorLocations.length;\n            let result = new Int32Array(s);\n            for(let i /*int*/  = 0; i < s; i++){\n                let xiInverse = this.field.inverse(errorLocations[i]);\n                let numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));\n                let denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));\n                result[i] = this.field.multiply(numerator, denominator);\n            }\n            return result;\n        }\n    }\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */ /**\n     * @author Guenther Grau\n     */ /*final*/ class BoundingBox {\n        constructor(image, topLeft, bottomLeft, topRight, bottomRight){\n            if (image instanceof BoundingBox) {\n                this.constructor_2(image);\n            } else {\n                this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);\n            }\n        }\n        /**\n         *\n         * @param image\n         * @param topLeft\n         * @param bottomLeft\n         * @param topRight\n         * @param bottomRight\n         *\n         * @throws NotFoundException\n         */ constructor_1(image, topLeft, bottomLeft, topRight, bottomRight) {\n            const leftUnspecified = topLeft == null || bottomLeft == null;\n            const rightUnspecified = topRight == null || bottomRight == null;\n            if (leftUnspecified && rightUnspecified) {\n                throw new NotFoundException();\n            }\n            if (leftUnspecified) {\n                topLeft = new ResultPoint(0, topRight.getY());\n                bottomLeft = new ResultPoint(0, bottomRight.getY());\n            } else if (rightUnspecified) {\n                topRight = new ResultPoint(image.getWidth() - 1, topLeft.getY());\n                bottomRight = new ResultPoint(image.getWidth() - 1, bottomLeft.getY());\n            }\n            this.image = image;\n            this.topLeft = topLeft;\n            this.bottomLeft = bottomLeft;\n            this.topRight = topRight;\n            this.bottomRight = bottomRight;\n            this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));\n            this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));\n            this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));\n            this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));\n        }\n        constructor_2(boundingBox) {\n            this.image = boundingBox.image;\n            this.topLeft = boundingBox.getTopLeft();\n            this.bottomLeft = boundingBox.getBottomLeft();\n            this.topRight = boundingBox.getTopRight();\n            this.bottomRight = boundingBox.getBottomRight();\n            this.minX = boundingBox.getMinX();\n            this.maxX = boundingBox.getMaxX();\n            this.minY = boundingBox.getMinY();\n            this.maxY = boundingBox.getMaxY();\n        }\n        /**\n         * @throws NotFoundException\n         */ static merge(leftBox, rightBox) {\n            if (leftBox == null) {\n                return rightBox;\n            }\n            if (rightBox == null) {\n                return leftBox;\n            }\n            return new BoundingBox(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);\n        }\n        /**\n         * @throws NotFoundException\n         */ addMissingRows(missingStartRows, missingEndRows, isLeft) {\n            let newTopLeft = this.topLeft;\n            let newBottomLeft = this.bottomLeft;\n            let newTopRight = this.topRight;\n            let newBottomRight = this.bottomRight;\n            if (missingStartRows > 0) {\n                let top = isLeft ? this.topLeft : this.topRight;\n                let newMinY = Math.trunc(top.getY() - missingStartRows);\n                if (newMinY < 0) {\n                    newMinY = 0;\n                }\n                let newTop = new ResultPoint(top.getX(), newMinY);\n                if (isLeft) {\n                    newTopLeft = newTop;\n                } else {\n                    newTopRight = newTop;\n                }\n            }\n            if (missingEndRows > 0) {\n                let bottom = isLeft ? this.bottomLeft : this.bottomRight;\n                let newMaxY = Math.trunc(bottom.getY() + missingEndRows);\n                if (newMaxY >= this.image.getHeight()) {\n                    newMaxY = this.image.getHeight() - 1;\n                }\n                let newBottom = new ResultPoint(bottom.getX(), newMaxY);\n                if (isLeft) {\n                    newBottomLeft = newBottom;\n                } else {\n                    newBottomRight = newBottom;\n                }\n            }\n            return new BoundingBox(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);\n        }\n        getMinX() {\n            return this.minX;\n        }\n        getMaxX() {\n            return this.maxX;\n        }\n        getMinY() {\n            return this.minY;\n        }\n        getMaxY() {\n            return this.maxY;\n        }\n        getTopLeft() {\n            return this.topLeft;\n        }\n        getTopRight() {\n            return this.topRight;\n        }\n        getBottomLeft() {\n            return this.bottomLeft;\n        }\n        getBottomRight() {\n            return this.bottomRight;\n        }\n    }\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ // package com.google.zxing.pdf417.decoder;\n    /**\n     * @author Guenther Grau\n     */ /*final*/ class BarcodeMetadata {\n        constructor(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel){\n            this.columnCount = columnCount;\n            this.errorCorrectionLevel = errorCorrectionLevel;\n            this.rowCountUpperPart = rowCountUpperPart;\n            this.rowCountLowerPart = rowCountLowerPart;\n            this.rowCount = rowCountUpperPart + rowCountLowerPart;\n        }\n        getColumnCount() {\n            return this.columnCount;\n        }\n        getErrorCorrectionLevel() {\n            return this.errorCorrectionLevel;\n        }\n        getRowCount() {\n            return this.rowCount;\n        }\n        getRowCountUpperPart() {\n            return this.rowCountUpperPart;\n        }\n        getRowCountLowerPart() {\n            return this.rowCountLowerPart;\n        }\n    }\n    /**\n     * Java Formatter class polyfill that works in the JS way.\n     */ class Formatter {\n        constructor(){\n            this.buffer = \"\";\n        }\n        /**\n         *\n         * @see https://stackoverflow.com/a/13439711/4367683\n         *\n         * @param str\n         * @param arr\n         */ static form(str, arr) {\n            let i = -1;\n            function callback(exp, p0, p1, p2, p3, p4) {\n                if (exp === \"%%\") return \"%\";\n                if (arr[++i] === undefined) return undefined;\n                exp = p2 ? parseInt(p2.substr(1)) : undefined;\n                let base = p3 ? parseInt(p3.substr(1)) : undefined;\n                let val;\n                switch(p4){\n                    case \"s\":\n                        val = arr[i];\n                        break;\n                    case \"c\":\n                        val = arr[i][0];\n                        break;\n                    case \"f\":\n                        val = parseFloat(arr[i]).toFixed(exp);\n                        break;\n                    case \"p\":\n                        val = parseFloat(arr[i]).toPrecision(exp);\n                        break;\n                    case \"e\":\n                        val = parseFloat(arr[i]).toExponential(exp);\n                        break;\n                    case \"x\":\n                        val = parseInt(arr[i]).toString(base ? base : 16);\n                        break;\n                    case \"d\":\n                        val = parseFloat(parseInt(arr[i], base ? base : 10).toPrecision(exp)).toFixed(0);\n                        break;\n                }\n                val = typeof val === \"object\" ? JSON.stringify(val) : (+val).toString(base);\n                let size = parseInt(p1); /* padding size */ \n                let ch = p1 && p1[0] + \"\" === \"0\" ? \"0\" : \" \"; /* isnull? */ \n                while(val.length < size)val = p0 !== undefined ? val + ch : ch + val; /* isminus? */ \n                return val;\n            }\n            let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\n            return str.replace(regex, callback);\n        }\n        /**\n         *\n         * @param append The new string to append.\n         * @param args Argumets values to be formated.\n         */ format(append, ...args) {\n            this.buffer += Formatter.form(append, args);\n        }\n        /**\n         * Returns the Formatter string value.\n         */ toString() {\n            return this.buffer;\n        }\n    }\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * @author Guenther Grau\n     */ class DetectionResultColumn {\n        constructor(boundingBox){\n            this.boundingBox = new BoundingBox(boundingBox);\n            // this.codewords = new Codeword[boundingBox.getMaxY() - boundingBox.getMinY() + 1];\n            this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);\n        }\n        /*final*/ getCodewordNearby(imageRow) {\n            let codeword = this.getCodeword(imageRow);\n            if (codeword != null) {\n                return codeword;\n            }\n            for(let i = 1; i < DetectionResultColumn.MAX_NEARBY_DISTANCE; i++){\n                let nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;\n                if (nearImageRow >= 0) {\n                    codeword = this.codewords[nearImageRow];\n                    if (codeword != null) {\n                        return codeword;\n                    }\n                }\n                nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;\n                if (nearImageRow < this.codewords.length) {\n                    codeword = this.codewords[nearImageRow];\n                    if (codeword != null) {\n                        return codeword;\n                    }\n                }\n            }\n            return null;\n        }\n        /*final int*/ imageRowToCodewordIndex(imageRow) {\n            return imageRow - this.boundingBox.getMinY();\n        }\n        /*final void*/ setCodeword(imageRow, codeword) {\n            this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;\n        }\n        /*final*/ getCodeword(imageRow) {\n            return this.codewords[this.imageRowToCodewordIndex(imageRow)];\n        }\n        /*final*/ getBoundingBox() {\n            return this.boundingBox;\n        }\n        /*final*/ getCodewords() {\n            return this.codewords;\n        }\n        // @Override\n        toString() {\n            const formatter = new Formatter();\n            let row = 0;\n            for (const codeword of this.codewords){\n                if (codeword == null) {\n                    formatter.format(\"%3d:    |   %n\", row++);\n                    continue;\n                }\n                formatter.format(\"%3d: %3d|%3d%n\", row++, codeword.getRowNumber(), codeword.getValue());\n            }\n            return formatter.toString();\n        }\n    }\n    DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ // import java.util.ArrayList;\n    // import java.util.Collection;\n    // import java.util.HashMap;\n    // import java.util.Map;\n    // import java.util.Map.Entry;\n    /**\n     * @author Guenther Grau\n     */ /*final*/ class BarcodeValue {\n        constructor(){\n            this.values = new Map();\n        }\n        /**\n         * Add an occurrence of a value\n         */ setValue(value) {\n            value = Math.trunc(value);\n            let confidence = this.values.get(value);\n            if (confidence == null) {\n                confidence = 0;\n            }\n            confidence++;\n            this.values.set(value, confidence);\n        }\n        /**\n         * Determines the maximum occurrence of a set value and returns all values which were set with this occurrence.\n         * @return an array of int, containing the values with the highest occurrence, or null, if no value was set\n         */ getValue() {\n            let maxConfidence = -1;\n            let result = new Array();\n            for (const [key, value] of this.values.entries()){\n                const entry = {\n                    getKey: ()=>key,\n                    getValue: ()=>value\n                };\n                if (entry.getValue() > maxConfidence) {\n                    maxConfidence = entry.getValue();\n                    result = [];\n                    result.push(entry.getKey());\n                } else if (entry.getValue() === maxConfidence) {\n                    result.push(entry.getKey());\n                }\n            }\n            return PDF417Common.toIntArray(result);\n        }\n        getConfidence(value) {\n            return this.values.get(value);\n        }\n    }\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * @author Guenther Grau\n     */ /*final*/ class DetectionResultRowIndicatorColumn extends DetectionResultColumn {\n        constructor(boundingBox, isLeft){\n            super(boundingBox);\n            this._isLeft = isLeft;\n        }\n        setRowNumbers() {\n            for (let codeword /*Codeword*/  of this.getCodewords()){\n                if (codeword != null) {\n                    codeword.setRowNumberAsRowIndicatorColumn();\n                }\n            }\n        }\n        // TODO implement properly\n        // TODO maybe we should add missing codewords to store the correct row number to make\n        // finding row numbers for other columns easier\n        // use row height count to make detection of invalid row numbers more reliable\n        adjustCompleteIndicatorColumnRowNumbers(barcodeMetadata) {\n            let codewords = this.getCodewords();\n            this.setRowNumbers();\n            this.removeIncorrectCodewords(codewords, barcodeMetadata);\n            let boundingBox = this.getBoundingBox();\n            let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();\n            let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();\n            let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));\n            let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));\n            // We need to be careful using the average row height. Barcode could be skewed so that we have smaller and\n            // taller rows\n            // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();\n            let barcodeRow = -1;\n            let maxRowHeight = 1;\n            let currentRowHeight = 0;\n            for(let codewordsRow /*int*/  = firstRow; codewordsRow < lastRow; codewordsRow++){\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                let codeword = codewords[codewordsRow];\n                //      float expectedRowNumber = (codewordsRow - firstRow) / averageRowHeight;\n                //      if (Math.abs(codeword.getRowNumber() - expectedRowNumber) > 2) {\n                //        SimpleLog.log(LEVEL.WARNING,\n                //            \"Removing codeword, rowNumberSkew too high, codeword[\" + codewordsRow + \"]: Expected Row: \" +\n                //                expectedRowNumber + \", RealRow: \" + codeword.getRowNumber() + \", value: \" + codeword.getValue());\n                //        codewords[codewordsRow] = null;\n                //      }\n                let rowDifference = codeword.getRowNumber() - barcodeRow;\n                // TODO improve handling with case where first row indicator doesn't start with 0\n                if (rowDifference === 0) {\n                    currentRowHeight++;\n                } else if (rowDifference === 1) {\n                    maxRowHeight = Math.max(maxRowHeight, currentRowHeight);\n                    currentRowHeight = 1;\n                    barcodeRow = codeword.getRowNumber();\n                } else if (rowDifference < 0 || codeword.getRowNumber() >= barcodeMetadata.getRowCount() || rowDifference > codewordsRow) {\n                    codewords[codewordsRow] = null;\n                } else {\n                    let checkedRows;\n                    if (maxRowHeight > 2) {\n                        checkedRows = (maxRowHeight - 2) * rowDifference;\n                    } else {\n                        checkedRows = rowDifference;\n                    }\n                    let closePreviousCodewordFound = checkedRows >= codewordsRow;\n                    for(let i /*int*/  = 1; i <= checkedRows && !closePreviousCodewordFound; i++){\n                        // there must be (height * rowDifference) number of codewords missing. For now we assume height = 1.\n                        // This should hopefully get rid of most problems already.\n                        closePreviousCodewordFound = codewords[codewordsRow - i] != null;\n                    }\n                    if (closePreviousCodewordFound) {\n                        codewords[codewordsRow] = null;\n                    } else {\n                        barcodeRow = codeword.getRowNumber();\n                        currentRowHeight = 1;\n                    }\n                }\n            }\n        // return (int) (averageRowHeight + 0.5);\n        }\n        getRowHeights() {\n            let barcodeMetadata = this.getBarcodeMetadata();\n            if (barcodeMetadata == null) {\n                return null;\n            }\n            this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);\n            let result = new Int32Array(barcodeMetadata.getRowCount());\n            for (let codeword /*Codeword*/  of this.getCodewords()){\n                if (codeword != null) {\n                    let rowNumber = codeword.getRowNumber();\n                    if (rowNumber >= result.length) {\n                        continue;\n                    }\n                    result[rowNumber]++;\n                } // else throw exception?\n            }\n            return result;\n        }\n        // TODO maybe we should add missing codewords to store the correct row number to make\n        // finding row numbers for other columns easier\n        // use row height count to make detection of invalid row numbers more reliable\n        adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata) {\n            let boundingBox = this.getBoundingBox();\n            let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();\n            let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();\n            let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));\n            let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));\n            // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();\n            let codewords = this.getCodewords();\n            let barcodeRow = -1;\n            for(let codewordsRow /*int*/  = firstRow; codewordsRow < lastRow; codewordsRow++){\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                let codeword = codewords[codewordsRow];\n                codeword.setRowNumberAsRowIndicatorColumn();\n                let rowDifference = codeword.getRowNumber() - barcodeRow;\n                // TODO improve handling with case where first row indicator doesn't start with 0\n                if (rowDifference === 0) ;\n                else if (rowDifference === 1) {\n                    barcodeRow = codeword.getRowNumber();\n                } else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {\n                    codewords[codewordsRow] = null;\n                } else {\n                    barcodeRow = codeword.getRowNumber();\n                }\n            }\n        // return (int) (averageRowHeight + 0.5);\n        }\n        getBarcodeMetadata() {\n            let codewords = this.getCodewords();\n            let barcodeColumnCount = new BarcodeValue();\n            let barcodeRowCountUpperPart = new BarcodeValue();\n            let barcodeRowCountLowerPart = new BarcodeValue();\n            let barcodeECLevel = new BarcodeValue();\n            for (let codeword /*Codeword*/  of codewords){\n                if (codeword == null) {\n                    continue;\n                }\n                codeword.setRowNumberAsRowIndicatorColumn();\n                let rowIndicatorValue = codeword.getValue() % 30;\n                let codewordRowNumber = codeword.getRowNumber();\n                if (!this._isLeft) {\n                    codewordRowNumber += 2;\n                }\n                switch(codewordRowNumber % 3){\n                    case 0:\n                        barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);\n                        break;\n                    case 1:\n                        barcodeECLevel.setValue(rowIndicatorValue / 3);\n                        barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);\n                        break;\n                    case 2:\n                        barcodeColumnCount.setValue(rowIndicatorValue + 1);\n                        break;\n                }\n            }\n            // Maybe we should check if we have ambiguous values?\n            if (barcodeColumnCount.getValue().length === 0 || barcodeRowCountUpperPart.getValue().length === 0 || barcodeRowCountLowerPart.getValue().length === 0 || barcodeECLevel.getValue().length === 0 || barcodeColumnCount.getValue()[0] < 1 || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common.MIN_ROWS_IN_BARCODE || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common.MAX_ROWS_IN_BARCODE) {\n                return null;\n            }\n            let barcodeMetadata = new BarcodeMetadata(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);\n            this.removeIncorrectCodewords(codewords, barcodeMetadata);\n            return barcodeMetadata;\n        }\n        removeIncorrectCodewords(codewords, barcodeMetadata) {\n            // Remove codewords which do not match the metadata\n            // TODO Maybe we should keep the incorrect codewords for the start and end positions?\n            for(let codewordRow /*int*/  = 0; codewordRow < codewords.length; codewordRow++){\n                let codeword = codewords[codewordRow];\n                if (codewords[codewordRow] == null) {\n                    continue;\n                }\n                let rowIndicatorValue = codeword.getValue() % 30;\n                let codewordRowNumber = codeword.getRowNumber();\n                if (codewordRowNumber > barcodeMetadata.getRowCount()) {\n                    codewords[codewordRow] = null;\n                    continue;\n                }\n                if (!this._isLeft) {\n                    codewordRowNumber += 2;\n                }\n                switch(codewordRowNumber % 3){\n                    case 0:\n                        if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {\n                            codewords[codewordRow] = null;\n                        }\n                        break;\n                    case 1:\n                        if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() || rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {\n                            codewords[codewordRow] = null;\n                        }\n                        break;\n                    case 2:\n                        if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {\n                            codewords[codewordRow] = null;\n                        }\n                        break;\n                }\n            }\n        }\n        isLeft() {\n            return this._isLeft;\n        }\n        // @Override\n        toString() {\n            return \"IsLeft: \" + this._isLeft + \"\\n\" + super.toString();\n        }\n    }\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * @author Guenther Grau\n     */ /*final*/ class DetectionResult {\n        constructor(barcodeMetadata, boundingBox){\n            /*final*/ this.ADJUST_ROW_NUMBER_SKIP = 2;\n            this.barcodeMetadata = barcodeMetadata;\n            this.barcodeColumnCount = barcodeMetadata.getColumnCount();\n            this.boundingBox = boundingBox;\n            // this.detectionResultColumns = new DetectionResultColumn[this.barcodeColumnCount + 2];\n            this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);\n        }\n        getDetectionResultColumns() {\n            this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);\n            this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);\n            let unadjustedCodewordCount = PDF417Common.MAX_CODEWORDS_IN_BARCODE;\n            let previousUnadjustedCount;\n            do {\n                previousUnadjustedCount = unadjustedCodewordCount;\n                unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();\n            }while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);\n            return this.detectionResultColumns;\n        }\n        adjustIndicatorColumnRowNumbers(detectionResultColumn) {\n            if (detectionResultColumn != null) {\n                detectionResultColumn.adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);\n            }\n        }\n        // TODO ensure that no detected codewords with unknown row number are left\n        // we should be able to estimate the row height and use it as a hint for the row number\n        // we should also fill the rows top to bottom and bottom to top\n        /**\n         * @return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords\n         * will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers\n         */ adjustRowNumbersAndGetCount() {\n            let unadjustedCount = this.adjustRowNumbersByRow();\n            if (unadjustedCount === 0) {\n                return 0;\n            }\n            for(let barcodeColumn /*int*/  = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++){\n                let codewords = this.detectionResultColumns[barcodeColumn].getCodewords();\n                for(let codewordsRow /*int*/  = 0; codewordsRow < codewords.length; codewordsRow++){\n                    if (codewords[codewordsRow] == null) {\n                        continue;\n                    }\n                    if (!codewords[codewordsRow].hasValidRowNumber()) {\n                        this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);\n                    }\n                }\n            }\n            return unadjustedCount;\n        }\n        adjustRowNumbersByRow() {\n            this.adjustRowNumbersFromBothRI();\n            // TODO we should only do full row adjustments if row numbers of left and right row indicator column match.\n            // Maybe it's even better to calculated the height (rows: d) and divide it by the number of barcode\n            // rows. This, together with the LRI and RRI row numbers should allow us to get a good estimate where a row\n            // number starts and ends.\n            let unadjustedCount = this.adjustRowNumbersFromLRI();\n            return unadjustedCount + this.adjustRowNumbersFromRRI();\n        }\n        adjustRowNumbersFromBothRI() {\n            if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {\n                return;\n            }\n            let LRIcodewords = this.detectionResultColumns[0].getCodewords();\n            let RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();\n            for(let codewordsRow /*int*/  = 0; codewordsRow < LRIcodewords.length; codewordsRow++){\n                if (LRIcodewords[codewordsRow] != null && RRIcodewords[codewordsRow] != null && LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {\n                    for(let barcodeColumn /*int*/  = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++){\n                        let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                        if (codeword == null) {\n                            continue;\n                        }\n                        codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());\n                        if (!codeword.hasValidRowNumber()) {\n                            this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;\n                        }\n                    }\n                }\n            }\n        }\n        adjustRowNumbersFromRRI() {\n            if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {\n                return 0;\n            }\n            let unadjustedCount = 0;\n            let codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();\n            for(let codewordsRow /*int*/  = 0; codewordsRow < codewords.length; codewordsRow++){\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();\n                let invalidRowCounts = 0;\n                for(let barcodeColumn /*int*/  = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--){\n                    let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                    if (codeword != null) {\n                        invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);\n                        if (!codeword.hasValidRowNumber()) {\n                            unadjustedCount++;\n                        }\n                    }\n                }\n            }\n            return unadjustedCount;\n        }\n        adjustRowNumbersFromLRI() {\n            if (this.detectionResultColumns[0] == null) {\n                return 0;\n            }\n            let unadjustedCount = 0;\n            let codewords = this.detectionResultColumns[0].getCodewords();\n            for(let codewordsRow /*int*/  = 0; codewordsRow < codewords.length; codewordsRow++){\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();\n                let invalidRowCounts = 0;\n                for(let barcodeColumn /*int*/  = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++){\n                    let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                    if (codeword != null) {\n                        invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);\n                        if (!codeword.hasValidRowNumber()) {\n                            unadjustedCount++;\n                        }\n                    }\n                }\n            }\n            return unadjustedCount;\n        }\n        static adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword) {\n            if (codeword == null) {\n                return invalidRowCounts;\n            }\n            if (!codeword.hasValidRowNumber()) {\n                if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {\n                    codeword.setRowNumber(rowIndicatorRowNumber);\n                    invalidRowCounts = 0;\n                } else {\n                    ++invalidRowCounts;\n                }\n            }\n            return invalidRowCounts;\n        }\n        adjustRowNumbers(barcodeColumn, codewordsRow, codewords) {\n            if (!this.detectionResultColumns[barcodeColumn - 1]) {\n                return;\n            }\n            let codeword = codewords[codewordsRow];\n            let previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();\n            let nextColumnCodewords = previousColumnCodewords;\n            if (this.detectionResultColumns[barcodeColumn + 1] != null) {\n                nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();\n            }\n            // let otherCodewords: Codeword[] = new Codeword[14];\n            let otherCodewords = new Array(14);\n            otherCodewords[2] = previousColumnCodewords[codewordsRow];\n            otherCodewords[3] = nextColumnCodewords[codewordsRow];\n            if (codewordsRow > 0) {\n                otherCodewords[0] = codewords[codewordsRow - 1];\n                otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];\n                otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];\n            }\n            if (codewordsRow > 1) {\n                otherCodewords[8] = codewords[codewordsRow - 2];\n                otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];\n                otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];\n            }\n            if (codewordsRow < codewords.length - 1) {\n                otherCodewords[1] = codewords[codewordsRow + 1];\n                otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];\n                otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];\n            }\n            if (codewordsRow < codewords.length - 2) {\n                otherCodewords[9] = codewords[codewordsRow + 2];\n                otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];\n                otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];\n            }\n            for (let otherCodeword of otherCodewords){\n                if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {\n                    return;\n                }\n            }\n        }\n        /**\n         * @return true, if row number was adjusted, false otherwise\n         */ static adjustRowNumber(codeword, otherCodeword) {\n            if (otherCodeword == null) {\n                return false;\n            }\n            if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {\n                codeword.setRowNumber(otherCodeword.getRowNumber());\n                return true;\n            }\n            return false;\n        }\n        getBarcodeColumnCount() {\n            return this.barcodeColumnCount;\n        }\n        getBarcodeRowCount() {\n            return this.barcodeMetadata.getRowCount();\n        }\n        getBarcodeECLevel() {\n            return this.barcodeMetadata.getErrorCorrectionLevel();\n        }\n        setBoundingBox(boundingBox) {\n            this.boundingBox = boundingBox;\n        }\n        getBoundingBox() {\n            return this.boundingBox;\n        }\n        setDetectionResultColumn(barcodeColumn, detectionResultColumn) {\n            this.detectionResultColumns[barcodeColumn] = detectionResultColumn;\n        }\n        getDetectionResultColumn(barcodeColumn) {\n            return this.detectionResultColumns[barcodeColumn];\n        }\n        // @Override\n        toString() {\n            let rowIndicatorColumn = this.detectionResultColumns[0];\n            if (rowIndicatorColumn == null) {\n                rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];\n            }\n            // try (\n            let formatter = new Formatter();\n            // ) {\n            for(let codewordsRow /*int*/  = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++){\n                formatter.format(\"CW %3d:\", codewordsRow);\n                for(let barcodeColumn /*int*/  = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++){\n                    if (this.detectionResultColumns[barcodeColumn] == null) {\n                        formatter.format(\"    |   \");\n                        continue;\n                    }\n                    let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                    if (codeword == null) {\n                        formatter.format(\"    |   \");\n                        continue;\n                    }\n                    formatter.format(\" %3d|%3d\", codeword.getRowNumber(), codeword.getValue());\n                }\n                formatter.format(\"%n\");\n            }\n            return formatter.toString();\n        // }\n        }\n    }\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ // package com.google.zxing.pdf417.decoder;\n    /**\n     * @author Guenther Grau\n     */ /*final*/ class Codeword {\n        constructor(startX, endX, bucket, value){\n            this.rowNumber = Codeword.BARCODE_ROW_UNKNOWN;\n            this.startX = Math.trunc(startX);\n            this.endX = Math.trunc(endX);\n            this.bucket = Math.trunc(bucket);\n            this.value = Math.trunc(value);\n        }\n        hasValidRowNumber() {\n            return this.isValidRowNumber(this.rowNumber);\n        }\n        isValidRowNumber(rowNumber) {\n            return rowNumber !== Codeword.BARCODE_ROW_UNKNOWN && this.bucket === rowNumber % 3 * 3;\n        }\n        setRowNumberAsRowIndicatorColumn() {\n            this.rowNumber = Math.trunc(Math.trunc(this.value / 30) * 3 + Math.trunc(this.bucket / 3));\n        }\n        getWidth() {\n            return this.endX - this.startX;\n        }\n        getStartX() {\n            return this.startX;\n        }\n        getEndX() {\n            return this.endX;\n        }\n        getBucket() {\n            return this.bucket;\n        }\n        getValue() {\n            return this.value;\n        }\n        getRowNumber() {\n            return this.rowNumber;\n        }\n        setRowNumber(rowNumber) {\n            this.rowNumber = rowNumber;\n        }\n        //   @Override\n        toString() {\n            return this.rowNumber + \"|\" + this.value;\n        }\n    }\n    Codeword.BARCODE_ROW_UNKNOWN = -1;\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */ /**\n     * @author Guenther Grau\n     * @author creatale GmbH (christoph.schulz@creatale.de)\n     */ /*final*/ class PDF417CodewordDecoder {\n        /* @note\n         * this action have to be performed before first use of class\n         * - static constructor\n         * working with 32bit float (based from Java logic)\n        */ static initialize() {\n            // Pre-computes the symbol ratio table.\n            for(/*int*/ let i = 0; i < PDF417Common.SYMBOL_TABLE.length; i++){\n                let currentSymbol = PDF417Common.SYMBOL_TABLE[i];\n                let currentBit = currentSymbol & 0x1;\n                for(/*int*/ let j = 0; j < PDF417Common.BARS_IN_MODULE; j++){\n                    let size = 0.0;\n                    while((currentSymbol & 0x1) === currentBit){\n                        size += 1.0;\n                        currentSymbol >>= 1;\n                    }\n                    currentBit = currentSymbol & 0x1;\n                    if (!PDF417CodewordDecoder.RATIOS_TABLE[i]) {\n                        PDF417CodewordDecoder.RATIOS_TABLE[i] = new Array(PDF417Common.BARS_IN_MODULE);\n                    }\n                    PDF417CodewordDecoder.RATIOS_TABLE[i][PDF417Common.BARS_IN_MODULE - j - 1] = Math.fround(size / PDF417Common.MODULES_IN_CODEWORD);\n                }\n            }\n            this.bSymbolTableReady = true;\n        }\n        static getDecodedValue(moduleBitCount) {\n            let decodedValue = PDF417CodewordDecoder.getDecodedCodewordValue(PDF417CodewordDecoder.sampleBitCounts(moduleBitCount));\n            if (decodedValue !== -1) {\n                return decodedValue;\n            }\n            return PDF417CodewordDecoder.getClosestDecodedValue(moduleBitCount);\n        }\n        static sampleBitCounts(moduleBitCount) {\n            let bitCountSum = MathUtils.sum(moduleBitCount);\n            let result = new Int32Array(PDF417Common.BARS_IN_MODULE);\n            let bitCountIndex = 0;\n            let sumPreviousBits = 0;\n            for(/*int*/ let i = 0; i < PDF417Common.MODULES_IN_CODEWORD; i++){\n                let sampleIndex = bitCountSum / (2 * PDF417Common.MODULES_IN_CODEWORD) + i * bitCountSum / PDF417Common.MODULES_IN_CODEWORD;\n                if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {\n                    sumPreviousBits += moduleBitCount[bitCountIndex];\n                    bitCountIndex++;\n                }\n                result[bitCountIndex]++;\n            }\n            return result;\n        }\n        static getDecodedCodewordValue(moduleBitCount) {\n            let decodedValue = PDF417CodewordDecoder.getBitValue(moduleBitCount);\n            return PDF417Common.getCodeword(decodedValue) === -1 ? -1 : decodedValue;\n        }\n        static getBitValue(moduleBitCount) {\n            let result = /*long*/ 0;\n            for(let /*int*/ i = 0; i < moduleBitCount.length; i++){\n                for(/*int*/ let bit = 0; bit < moduleBitCount[i]; bit++){\n                    result = result << 1 | (i % 2 === 0 ? 1 : 0);\n                }\n            }\n            return Math.trunc(result);\n        }\n        // working with 32bit float (as in Java)\n        static getClosestDecodedValue(moduleBitCount) {\n            let bitCountSum = MathUtils.sum(moduleBitCount);\n            let bitCountRatios = new Array(PDF417Common.BARS_IN_MODULE);\n            if (bitCountSum > 1) {\n                for(let /*int*/ i = 0; i < bitCountRatios.length; i++){\n                    bitCountRatios[i] = Math.fround(moduleBitCount[i] / bitCountSum);\n                }\n            }\n            let bestMatchError = Float.MAX_VALUE;\n            let bestMatch = -1;\n            if (!this.bSymbolTableReady) {\n                PDF417CodewordDecoder.initialize();\n            }\n            for(/*int*/ let j = 0; j < PDF417CodewordDecoder.RATIOS_TABLE.length; j++){\n                let error = 0.0;\n                let ratioTableRow = PDF417CodewordDecoder.RATIOS_TABLE[j];\n                for(/*int*/ let k = 0; k < PDF417Common.BARS_IN_MODULE; k++){\n                    let diff = Math.fround(ratioTableRow[k] - bitCountRatios[k]);\n                    error += Math.fround(diff * diff);\n                    if (error >= bestMatchError) {\n                        break;\n                    }\n                }\n                if (error < bestMatchError) {\n                    bestMatchError = error;\n                    bestMatch = PDF417Common.SYMBOL_TABLE[j];\n                }\n            }\n            return bestMatch;\n        }\n    }\n    // flag that the table is ready for use\n    PDF417CodewordDecoder.bSymbolTableReady = false;\n    PDF417CodewordDecoder.RATIOS_TABLE = new Array(PDF417Common.SYMBOL_TABLE.length).map((x)=>x = new Array(PDF417Common.BARS_IN_MODULE));\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ // package com.google.zxing.pdf417;\n    /**\n     * @author Guenther Grau\n     */ /*public final*/ class PDF417ResultMetadata {\n        constructor(){\n            this.segmentCount = -1;\n            this.fileSize = -1;\n            this.timestamp = -1;\n            this.checksum = -1;\n        }\n        /**\n         * The Segment ID represents the segment of the whole file distributed over different symbols.\n         *\n         * @return File segment index\n         */ getSegmentIndex() {\n            return this.segmentIndex;\n        }\n        setSegmentIndex(segmentIndex) {\n            this.segmentIndex = segmentIndex;\n        }\n        /**\n         * Is the same for each related PDF417 symbol\n         *\n         * @return File ID\n         */ getFileId() {\n            return this.fileId;\n        }\n        setFileId(fileId) {\n            this.fileId = fileId;\n        }\n        /**\n         * @return always null\n         * @deprecated use dedicated already parsed fields\n         */ //   @Deprecated\n        getOptionalData() {\n            return this.optionalData;\n        }\n        /**\n         * @param optionalData old optional data format as int array\n         * @deprecated parse and use new fields\n         */ //   @Deprecated\n        setOptionalData(optionalData) {\n            this.optionalData = optionalData;\n        }\n        /**\n         * @return true if it is the last segment\n         */ isLastSegment() {\n            return this.lastSegment;\n        }\n        setLastSegment(lastSegment) {\n            this.lastSegment = lastSegment;\n        }\n        /**\n         * @return count of segments, -1 if not set\n         */ getSegmentCount() {\n            return this.segmentCount;\n        }\n        setSegmentCount(segmentCount /*int*/ ) {\n            this.segmentCount = segmentCount;\n        }\n        getSender() {\n            return this.sender || null;\n        }\n        setSender(sender) {\n            this.sender = sender;\n        }\n        getAddressee() {\n            return this.addressee || null;\n        }\n        setAddressee(addressee) {\n            this.addressee = addressee;\n        }\n        /**\n         * Filename of the encoded file\n         *\n         * @return filename\n         */ getFileName() {\n            return this.fileName;\n        }\n        setFileName(fileName) {\n            this.fileName = fileName;\n        }\n        /**\n         * filesize in bytes of the encoded file\n         *\n         * @return filesize in bytes, -1 if not set\n         */ getFileSize() {\n            return this.fileSize;\n        }\n        setFileSize(fileSize /*long*/ ) {\n            this.fileSize = fileSize;\n        }\n        /**\n         * 16-bit CRC checksum using CCITT-16\n         *\n         * @return crc checksum, -1 if not set\n         */ getChecksum() {\n            return this.checksum;\n        }\n        setChecksum(checksum /*int*/ ) {\n            this.checksum = checksum;\n        }\n        /**\n         * unix epock timestamp, elapsed seconds since 1970-01-01\n         *\n         * @return elapsed seconds, -1 if not set\n         */ getTimestamp() {\n            return this.timestamp;\n        }\n        setTimestamp(timestamp /*long*/ ) {\n            this.timestamp = timestamp;\n        }\n    }\n    /**\n     * Ponyfill for Java's Long class.\n     */ class Long {\n        /**\n         * Parses a string to a number, since JS has no really Int64.\n         *\n         * @param num Numeric string.\n         * @param radix Destination radix.\n         */ static parseLong(num, radix = undefined) {\n            return parseInt(num, radix);\n        }\n    }\n    /**\n     * Custom Error class of type Exception.\n     */ class NullPointerException extends Exception {\n    }\n    NullPointerException.kind = \"NullPointerException\";\n    /*\n     * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.\n     * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n     *\n     * This code is free software; you can redistribute it and/or modify it\n     * under the terms of the GNU General Public License version 2 only, as\n     * published by the Free Software Foundation.  Oracle designates this\n     * particular file as subject to the \"Classpath\" exception as provided\n     * by Oracle in the LICENSE file that accompanied this code.\n     *\n     * This code is distributed in the hope that it will be useful, but WITHOUT\n     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n     * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n     * version 2 for more details (a copy is included in the LICENSE file that\n     * accompanied this code).\n     *\n     * You should have received a copy of the GNU General Public License version\n     * 2 along with this work; if not, write to the Free Software Foundation,\n     * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n     *\n     * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n     * or visit www.oracle.com if you need additional information or have any\n     * questions.\n     */ // package java.io;\n    /**\n     * This abstract class is the superclass of all classes representing\n     * an output stream of bytes. An output stream accepts output bytes\n     * and sends them to some sink.\n     * <p>\n     * Applications that need to define a subclass of\n     * <code>OutputStream</code> must always provide at least a method\n     * that writes one byte of output.\n     *\n     * @author  Arthur van Hoff\n     * @see     java.io.BufferedOutputStream\n     * @see     java.io.ByteArrayOutputStream\n     * @see     java.io.DataOutputStream\n     * @see     java.io.FilterOutputStream\n     * @see     java.io.InputStream\n     * @see     java.io.OutputStream#write(int)\n     * @since   JDK1.0\n     */ /*public*/ class OutputStream {\n        /**\n         * Writes <code>b.length</code> bytes from the specified byte array\n         * to this output stream. The general contract for <code>write(b)</code>\n         * is that it should have exactly the same effect as the call\n         * <code>write(b, 0, b.length)</code>.\n         *\n         * @param      b   the data.\n         * @exception  IOException  if an I/O error occurs.\n         * @see        java.io.OutputStream#write(byte[], int, int)\n         */ writeBytes(b) {\n            this.writeBytesOffset(b, 0, b.length);\n        }\n        /**\n         * Writes <code>len</code> bytes from the specified byte array\n         * starting at offset <code>off</code> to this output stream.\n         * The general contract for <code>write(b, off, len)</code> is that\n         * some of the bytes in the array <code>b</code> are written to the\n         * output stream in order; element <code>b[off]</code> is the first\n         * byte written and <code>b[off+len-1]</code> is the last byte written\n         * by this operation.\n         * <p>\n         * The <code>write</code> method of <code>OutputStream</code> calls\n         * the write method of one argument on each of the bytes to be\n         * written out. Subclasses are encouraged to override this method and\n         * provide a more efficient implementation.\n         * <p>\n         * If <code>b</code> is <code>null</code>, a\n         * <code>NullPointerException</code> is thrown.\n         * <p>\n         * If <code>off</code> is negative, or <code>len</code> is negative, or\n         * <code>off+len</code> is greater than the length of the array\n         * <code>b</code>, then an <tt>IndexOutOfBoundsException</tt> is thrown.\n         *\n         * @param      b     the data.\n         * @param      off   the start offset in the data.\n         * @param      len   the number of bytes to write.\n         * @exception  IOException  if an I/O error occurs. In particular,\n         *             an <code>IOException</code> is thrown if the output\n         *             stream is closed.\n         */ writeBytesOffset(b, off, len) {\n            if (b == null) {\n                throw new NullPointerException();\n            } else if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {\n                throw new IndexOutOfBoundsException();\n            } else if (len === 0) {\n                return;\n            }\n            for(let i = 0; i < len; i++){\n                this.write(b[off + i]);\n            }\n        }\n        /**\n         * Flushes this output stream and forces any buffered output bytes\n         * to be written out. The general contract of <code>flush</code> is\n         * that calling it is an indication that, if any bytes previously\n         * written have been buffered by the implementation of the output\n         * stream, such bytes should immediately be written to their\n         * intended destination.\n         * <p>\n         * If the intended destination of this stream is an abstraction provided by\n         * the underlying operating system, for example a file, then flushing the\n         * stream guarantees only that bytes previously written to the stream are\n         * passed to the operating system for writing; it does not guarantee that\n         * they are actually written to a physical device such as a disk drive.\n         * <p>\n         * The <code>flush</code> method of <code>OutputStream</code> does nothing.\n         *\n         * @exception  IOException  if an I/O error occurs.\n         */ flush() {}\n        /**\n         * Closes this output stream and releases any system resources\n         * associated with this stream. The general contract of <code>close</code>\n         * is that it closes the output stream. A closed stream cannot perform\n         * output operations and cannot be reopened.\n         * <p>\n         * The <code>close</code> method of <code>OutputStream</code> does nothing.\n         *\n         * @exception  IOException  if an I/O error occurs.\n         */ close() {}\n    }\n    /**\n     * Custom Error class of type Exception.\n     */ class OutOfMemoryError extends Exception {\n    }\n    /*\n     * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.\n     * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n     *\n     * This code is free software; you can redistribute it and/or modify it\n     * under the terms of the GNU General Public License version 2 only, as\n     * published by the Free Software Foundation.  Oracle designates this\n     * particular file as subject to the \"Classpath\" exception as provided\n     * by Oracle in the LICENSE file that accompanied this code.\n     *\n     * This code is distributed in the hope that it will be useful, but WITHOUT\n     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n     * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n     * version 2 for more details (a copy is included in the LICENSE file that\n     * accompanied this code).\n     *\n     * You should have received a copy of the GNU General Public License version\n     * 2 along with this work; if not, write to the Free Software Foundation,\n     * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n     *\n     * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n     * or visit www.oracle.com if you need additional information or have any\n     * questions.\n     */ /**\n     * This class implements an output stream in which the data is\n     * written into a byte array. The buffer automatically grows as data\n     * is written to it.\n     * The data can be retrieved using <code>toByteArray()</code> and\n     * <code>toString()</code>.\n     * <p>\n     * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an <tt>IOException</tt>.\n     *\n     * @author  Arthur van Hoff\n     * @since   JDK1.0\n     */ /*public*/ class ByteArrayOutputStream extends OutputStream {\n        /**\n         * Creates a new byte array output stream. The buffer capacity is\n         * initially 32 bytes, though its size increases if necessary.\n         */ // public constructor() {\n        //     this(32);\n        // }\n        /**\n         * Creates a new byte array output stream, with a buffer capacity of\n         * the specified size, in bytes.\n         *\n         * @param   size   the initial size.\n         * @exception  IllegalArgumentException if size is negative.\n         */ constructor(size = 32){\n            super();\n            /**\n             * The number of valid bytes in the buffer.\n             */ this.count = 0;\n            if (size < 0) {\n                throw new IllegalArgumentException(\"Negative initial size: \" + size);\n            }\n            this.buf = new Uint8Array(size);\n        }\n        /**\n         * Increases the capacity if necessary to ensure that it can hold\n         * at least the number of elements specified by the minimum\n         * capacity argument.\n         *\n         * @param minCapacity the desired minimum capacity\n         * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is\n         * interpreted as a request for the unsatisfiably large capacity\n         * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.\n         */ ensureCapacity(minCapacity) {\n            // overflow-conscious code\n            if (minCapacity - this.buf.length > 0) this.grow(minCapacity);\n        }\n        /**\n         * Increases the capacity to ensure that it can hold at least the\n         * number of elements specified by the minimum capacity argument.\n         *\n         * @param minCapacity the desired minimum capacity\n         */ grow(minCapacity) {\n            // overflow-conscious code\n            let oldCapacity = this.buf.length;\n            let newCapacity = oldCapacity << 1;\n            if (newCapacity - minCapacity < 0) newCapacity = minCapacity;\n            if (newCapacity < 0) {\n                if (minCapacity < 0) throw new OutOfMemoryError();\n                newCapacity = Integer.MAX_VALUE;\n            }\n            this.buf = Arrays.copyOfUint8Array(this.buf, newCapacity);\n        }\n        /**\n         * Writes the specified byte to this byte array output stream.\n         *\n         * @param   b   the byte to be written.\n         */ write(b) {\n            this.ensureCapacity(this.count + 1);\n            this.buf[this.count] = /*(byte)*/ b;\n            this.count += 1;\n        }\n        /**\n         * Writes <code>len</code> bytes from the specified byte array\n         * starting at offset <code>off</code> to this byte array output stream.\n         *\n         * @param   b     the data.\n         * @param   off   the start offset in the data.\n         * @param   len   the number of bytes to write.\n         */ writeBytesOffset(b, off, len) {\n            if (off < 0 || off > b.length || len < 0 || off + len - b.length > 0) {\n                throw new IndexOutOfBoundsException();\n            }\n            this.ensureCapacity(this.count + len);\n            System.arraycopy(b, off, this.buf, this.count, len);\n            this.count += len;\n        }\n        /**\n         * Writes the complete contents of this byte array output stream to\n         * the specified output stream argument, as if by calling the output\n         * stream's write method using <code>out.write(buf, 0, count)</code>.\n         *\n         * @param      out   the output stream to which to write the data.\n         * @exception  IOException  if an I/O error occurs.\n         */ writeTo(out) {\n            out.writeBytesOffset(this.buf, 0, this.count);\n        }\n        /**\n         * Resets the <code>count</code> field of this byte array output\n         * stream to zero, so that all currently accumulated output in the\n         * output stream is discarded. The output stream can be used again,\n         * reusing the already allocated buffer space.\n         *\n         * @see     java.io.ByteArrayInputStream#count\n         */ reset() {\n            this.count = 0;\n        }\n        /**\n         * Creates a newly allocated byte array. Its size is the current\n         * size of this output stream and the valid contents of the buffer\n         * have been copied into it.\n         *\n         * @return  the current contents of this output stream, as a byte array.\n         * @see     java.io.ByteArrayOutputStream#size()\n         */ toByteArray() {\n            return Arrays.copyOfUint8Array(this.buf, this.count);\n        }\n        /**\n         * Returns the current size of the buffer.\n         *\n         * @return  the value of the <code>count</code> field, which is the number\n         *          of valid bytes in this output stream.\n         * @see     java.io.ByteArrayOutputStream#count\n         */ size() {\n            return this.count;\n        }\n        toString(param) {\n            if (!param) {\n                return this.toString_void();\n            }\n            if (typeof param === \"string\") {\n                return this.toString_string(param);\n            }\n            return this.toString_number(param);\n        }\n        /**\n         * Converts the buffer's contents into a string decoding bytes using the\n         * platform's default character set. The length of the new <tt>String</tt>\n         * is a function of the character set, and hence may not be equal to the\n         * size of the buffer.\n         *\n         * <p> This method always replaces malformed-input and unmappable-character\n         * sequences with the default replacement string for the platform's\n         * default character set. The {@linkplain java.nio.charset.CharsetDecoder}\n         * class should be used when more control over the decoding process is\n         * required.\n         *\n         * @return String decoded from the buffer's contents.\n         * @since  JDK1.1\n         */ toString_void() {\n            return new String(this.buf /*, 0, this.count*/ ).toString();\n        }\n        /**\n         * Converts the buffer's contents into a string by decoding the bytes using\n         * the specified {@link java.nio.charset.Charset charsetName}. The length of\n         * the new <tt>String</tt> is a function of the charset, and hence may not be\n         * equal to the length of the byte array.\n         *\n         * <p> This method always replaces malformed-input and unmappable-character\n         * sequences with this charset's default replacement string. The {@link\n         * java.nio.charset.CharsetDecoder} class should be used when more control\n         * over the decoding process is required.\n         *\n         * @param  charsetName  the name of a supported\n         *              {@linkplain java.nio.charset.Charset </code>charset<code>}\n         * @return String decoded from the buffer's contents.\n         * @exception  UnsupportedEncodingException\n         *             If the named charset is not supported\n         * @since   JDK1.1\n         */ toString_string(charsetName) {\n            return new String(this.buf /*, 0, this.count, charsetName*/ ).toString();\n        }\n        /**\n         * Creates a newly allocated string. Its size is the current size of\n         * the output stream and the valid contents of the buffer have been\n         * copied into it. Each character <i>c</i> in the resulting string is\n         * constructed from the corresponding element <i>b</i> in the byte\n         * array such that:\n         * <blockquote><pre>\n         *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))\n         * </pre></blockquote>\n         *\n         * @deprecated This method does not properly convert bytes into characters.\n         * As of JDK&nbsp;1.1, the preferred way to do this is via the\n         * <code>toString(String enc)</code> method, which takes an encoding-name\n         * argument, or the <code>toString()</code> method, which uses the\n         * platform's default character encoding.\n         *\n         * @param      hibyte    the high byte of each resulting Unicode character.\n         * @return     the current contents of the output stream, as a string.\n         * @see        java.io.ByteArrayOutputStream#size()\n         * @see        java.io.ByteArrayOutputStream#toString(String)\n         * @see        java.io.ByteArrayOutputStream#toString()\n         */ // @Deprecated\n        toString_number(hibyte) {\n            return new String(this.buf /*, hibyte, 0, this.count*/ ).toString();\n        }\n        /**\n         * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\n         * this class can be called after the stream has been closed without\n         * generating an <tt>IOException</tt>.\n         * <p>\n         *\n         * @throws IOException\n         */ close() {}\n    }\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*private*/ var Mode$2;\n    (function(Mode) {\n        Mode[Mode[\"ALPHA\"] = 0] = \"ALPHA\";\n        Mode[Mode[\"LOWER\"] = 1] = \"LOWER\";\n        Mode[Mode[\"MIXED\"] = 2] = \"MIXED\";\n        Mode[Mode[\"PUNCT\"] = 3] = \"PUNCT\";\n        Mode[Mode[\"ALPHA_SHIFT\"] = 4] = \"ALPHA_SHIFT\";\n        Mode[Mode[\"PUNCT_SHIFT\"] = 5] = \"PUNCT_SHIFT\";\n    })(Mode$2 || (Mode$2 = {}));\n    /**\n     * Indirectly access the global BigInt constructor, it\n     * allows browsers that doesn't support BigInt to run\n     * the library without breaking due to \"undefined BigInt\"\n     * errors.\n     */ function getBigIntConstructor() {\n        if (false) {}\n        if (typeof global !== \"undefined\") {\n            return global[\"BigInt\"] || null;\n        }\n        if (typeof self !== \"undefined\") {\n            return self[\"BigInt\"] || null;\n        }\n        throw new Error(\"Can't search globals for BigInt!\");\n    }\n    /**\n     * Used to store the BigInt constructor.\n     */ let BigInteger;\n    /**\n     * This function creates a bigint value. It allows browsers\n     * that doesn't support BigInt to run the rest of the library\n     * by not directly accessing the BigInt constructor.\n     */ function createBigInt(num) {\n        if (typeof BigInteger === \"undefined\") {\n            BigInteger = getBigIntConstructor();\n        }\n        if (BigInteger === null) {\n            throw new Error(\"BigInt is not supported!\");\n        }\n        return BigInteger(num);\n    }\n    function getEXP900() {\n        // in Java - array with length = 16\n        let EXP900 = [];\n        EXP900[0] = createBigInt(1);\n        let nineHundred = createBigInt(900);\n        EXP900[1] = nineHundred;\n        // in Java - array with length = 16\n        for(let i /*int*/  = 2; i < 16; i++){\n            EXP900[i] = EXP900[i - 1] * nineHundred;\n        }\n        return EXP900;\n    }\n    /**\n     * <p>This class contains the methods for decoding the PDF417 codewords.</p>\n     *\n     * @author SITA Lab (kevin.osullivan@sita.aero)\n     * @author Guenther Grau\n     */ /*final*/ class DecodedBitStreamParser$2 {\n        //   private DecodedBitStreamParser() {\n        // }\n        /**\n         *\n         * @param codewords\n         * @param ecLevel\n         *\n         * @throws FormatException\n         */ static decode(codewords, ecLevel) {\n            // pass encoding to result (will be used for decode symbols in byte mode)\n            let result = new StringBuilder(\"\");\n            // let encoding: Charset = StandardCharsets.ISO_8859_1;\n            let encoding = CharacterSetECI.ISO8859_1;\n            /**\n             * @note the next command is specific from this TypeScript library\n             * because TS can't properly cast some values to char and\n             * convert it to string later correctly due to encoding\n             * differences from Java version. As reported here:\n             * https://github.com/zxing-js/library/pull/264/files#r382831593\n             */ result.enableDecoding(encoding);\n            // Get compaction mode\n            let codeIndex = 1;\n            let code = codewords[codeIndex++];\n            let resultMetadata = new PDF417ResultMetadata();\n            while(codeIndex < codewords[0]){\n                switch(code){\n                    case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                        codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);\n                        break;\n                    case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                    case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                        codeIndex = DecodedBitStreamParser$2.byteCompaction(code, codewords, encoding, codeIndex, result);\n                        break;\n                    case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                        result.append(/*(char)*/ codewords[codeIndex++]);\n                        break;\n                    case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:\n                        codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex, result);\n                        break;\n                    case DecodedBitStreamParser$2.ECI_CHARSET:\n                        let charsetECI = CharacterSetECI.getCharacterSetECIByValue(codewords[codeIndex++]);\n                        break;\n                    case DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE:\n                        // Can't do anything with generic ECI; skip its 2 characters\n                        codeIndex += 2;\n                        break;\n                    case DecodedBitStreamParser$2.ECI_USER_DEFINED:\n                        // Can't do anything with user ECI; skip its 1 character\n                        codeIndex++;\n                        break;\n                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                        codeIndex = DecodedBitStreamParser$2.decodeMacroBlock(codewords, codeIndex, resultMetadata);\n                        break;\n                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                    case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                        // Should not see these outside a macro block\n                        throw new FormatException();\n                    default:\n                        // Default to text compaction. During testing numerous barcodes\n                        // appeared to be missing the starting mode. In these cases defaulting\n                        // to text compaction seems to work.\n                        codeIndex--;\n                        codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);\n                        break;\n                }\n                if (codeIndex < codewords.length) {\n                    code = codewords[codeIndex++];\n                } else {\n                    throw FormatException.getFormatInstance();\n                }\n            }\n            if (result.length() === 0) {\n                throw FormatException.getFormatInstance();\n            }\n            let decoderResult = new DecoderResult(null, result.toString(), null, ecLevel);\n            decoderResult.setOther(resultMetadata);\n            return decoderResult;\n        }\n        /**\n         *\n         * @param int\n         * @param param1\n         * @param codewords\n         * @param int\n         * @param codeIndex\n         * @param PDF417ResultMetadata\n         * @param resultMetadata\n         *\n         * @throws FormatException\n         */ // @SuppressWarnings(\"deprecation\")\n        static decodeMacroBlock(codewords, codeIndex, resultMetadata) {\n            if (codeIndex + DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {\n                // we must have at least two bytes left for the segment index\n                throw FormatException.getFormatInstance();\n            }\n            let segmentIndexArray = new Int32Array(DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS);\n            for(let i /*int*/  = 0; i < DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++){\n                segmentIndexArray[i] = codewords[codeIndex];\n            }\n            resultMetadata.setSegmentIndex(Integer.parseInt(DecodedBitStreamParser$2.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS)));\n            let fileId = new StringBuilder();\n            codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, fileId);\n            resultMetadata.setFileId(fileId.toString());\n            let optionalFieldsStart = -1;\n            if (codewords[codeIndex] === DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {\n                optionalFieldsStart = codeIndex + 1;\n            }\n            while(codeIndex < codewords[0]){\n                switch(codewords[codeIndex]){\n                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                        codeIndex++;\n                        switch(codewords[codeIndex]){\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:\n                                let fileName = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, fileName);\n                                resultMetadata.setFileName(fileName.toString());\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER:\n                                let sender = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, sender);\n                                resultMetadata.setSender(sender.toString());\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:\n                                let addressee = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, addressee);\n                                resultMetadata.setAddressee(addressee.toString());\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:\n                                let segmentCount = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, segmentCount);\n                                resultMetadata.setSegmentCount(Integer.parseInt(segmentCount.toString()));\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:\n                                let timestamp = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, timestamp);\n                                resultMetadata.setTimestamp(Long.parseLong(timestamp.toString()));\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:\n                                let checksum = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, checksum);\n                                resultMetadata.setChecksum(Integer.parseInt(checksum.toString()));\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:\n                                let fileSize = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, fileSize);\n                                resultMetadata.setFileSize(Long.parseLong(fileSize.toString()));\n                                break;\n                            default:\n                                throw FormatException.getFormatInstance();\n                        }\n                        break;\n                    case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                        codeIndex++;\n                        resultMetadata.setLastSegment(true);\n                        break;\n                    default:\n                        throw FormatException.getFormatInstance();\n                }\n            }\n            // copy optional fields to additional options\n            if (optionalFieldsStart !== -1) {\n                let optionalFieldsLength = codeIndex - optionalFieldsStart;\n                if (resultMetadata.isLastSegment()) {\n                    // do not include terminator\n                    optionalFieldsLength--;\n                }\n                resultMetadata.setOptionalData(Arrays.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));\n            }\n            return codeIndex;\n        }\n        /**\n         * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be\n         * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as\n         * well as selected control characters.\n         *\n         * @param codewords The array of codewords (data + error)\n         * @param codeIndex The current index into the codeword array.\n         * @param result    The decoded data is appended to the result.\n         * @return The next index into the codeword array.\n         */ static textCompaction(codewords, codeIndex, result) {\n            // 2 character per codeword\n            let textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);\n            // Used to hold the byte compaction value if there is a mode shift\n            let byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);\n            let index = 0;\n            let end = false;\n            while(codeIndex < codewords[0] && !end){\n                let code = codewords[codeIndex++];\n                if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {\n                    textCompactionData[index] = code / 30;\n                    textCompactionData[index + 1] = code % 30;\n                    index += 2;\n                } else {\n                    switch(code){\n                        case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                            // reinitialize text compaction mode to alpha sub mode\n                            textCompactionData[index++] = DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH;\n                            break;\n                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                        case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                        case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                            codeIndex--;\n                            end = true;\n                            break;\n                        case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                            // The Mode Shift codeword 913 shall cause a temporary\n                            // switch from Text Compaction mode to Byte Compaction mode.\n                            // This switch shall be in effect for only the next codeword,\n                            // after which the mode shall revert to the prevailing sub-mode\n                            // of the Text Compaction mode. Codeword 913 is only available\n                            // in Text Compaction mode; its use is described in 5.4.2.4.\n                            textCompactionData[index] = DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;\n                            code = codewords[codeIndex++];\n                            byteCompactionData[index] = code;\n                            index++;\n                            break;\n                    }\n                }\n            }\n            DecodedBitStreamParser$2.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);\n            return codeIndex;\n        }\n        /**\n         * The Text Compaction mode includes all the printable ASCII characters\n         * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab\n         * (9: e), LF or line feed (10: e), and CR or carriage\n         * return (13: e). The Text Compaction mode also includes various latch\n         * and shift characters which are used exclusively within the mode. The Text\n         * Compaction mode encodes up to 2 characters per codeword. The compaction rules\n         * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode\n         * switches are defined in 5.4.2.3.\n         *\n         * @param textCompactionData The text compaction data.\n         * @param byteCompactionData The byte compaction data if there\n         *                           was a mode shift.\n         * @param length             The size of the text compaction and byte compaction data.\n         * @param result             The decoded data is appended to the result.\n         */ static decodeTextCompaction(textCompactionData, byteCompactionData, length, result) {\n            // Beginning from an initial state of the Alpha sub-mode\n            // The default compaction mode for PDF417 in effect at the start of each symbol shall always be Text\n            // Compaction mode Alpha sub-mode (alphabetic: uppercase). A latch codeword from another mode to the Text\n            // Compaction mode shall always switch to the Text Compaction Alpha sub-mode.\n            let subMode = Mode$2.ALPHA;\n            let priorToShiftMode = Mode$2.ALPHA;\n            let i = 0;\n            while(i < length){\n                let subModeCh = textCompactionData[i];\n                let ch = /*char*/ \"\";\n                switch(subMode){\n                    case Mode$2.ALPHA:\n                        // Alpha (alphabetic: uppercase)\n                        if (subModeCh < 26) {\n                            // Upper case Alpha Character\n                            // Note: 65 = 'A' ASCII -> there is byte code of symbol\n                            ch = /*(char)('A' + subModeCh) */ String.fromCharCode(65 + subModeCh);\n                        } else {\n                            switch(subModeCh){\n                                case 26:\n                                    ch = \" \";\n                                    break;\n                                case DecodedBitStreamParser$2.LL:\n                                    subMode = Mode$2.LOWER;\n                                    break;\n                                case DecodedBitStreamParser$2.ML:\n                                    subMode = Mode$2.MIXED;\n                                    break;\n                                case DecodedBitStreamParser$2.PS:\n                                    // Shift to punctuation\n                                    priorToShiftMode = subMode;\n                                    subMode = Mode$2.PUNCT_SHIFT;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.LOWER:\n                        // Lower (alphabetic: lowercase)\n                        if (subModeCh < 26) {\n                            ch = /*(char)('a' + subModeCh)*/ String.fromCharCode(97 + subModeCh);\n                        } else {\n                            switch(subModeCh){\n                                case 26:\n                                    ch = \" \";\n                                    break;\n                                case DecodedBitStreamParser$2.AS:\n                                    // Shift to alpha\n                                    priorToShiftMode = subMode;\n                                    subMode = Mode$2.ALPHA_SHIFT;\n                                    break;\n                                case DecodedBitStreamParser$2.ML:\n                                    subMode = Mode$2.MIXED;\n                                    break;\n                                case DecodedBitStreamParser$2.PS:\n                                    // Shift to punctuation\n                                    priorToShiftMode = subMode;\n                                    subMode = Mode$2.PUNCT_SHIFT;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    // TODO Does this need to use the current character encoding? See other occurrences below\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.MIXED:\n                        // Mixed (punctuation: e)\n                        if (subModeCh < DecodedBitStreamParser$2.PL) {\n                            ch = DecodedBitStreamParser$2.MIXED_CHARS[subModeCh];\n                        } else {\n                            switch(subModeCh){\n                                case DecodedBitStreamParser$2.PL:\n                                    subMode = Mode$2.PUNCT;\n                                    break;\n                                case 26:\n                                    ch = \" \";\n                                    break;\n                                case DecodedBitStreamParser$2.LL:\n                                    subMode = Mode$2.LOWER;\n                                    break;\n                                case DecodedBitStreamParser$2.AL:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                                case DecodedBitStreamParser$2.PS:\n                                    // Shift to punctuation\n                                    priorToShiftMode = subMode;\n                                    subMode = Mode$2.PUNCT_SHIFT;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.PUNCT:\n                        // Punctuation\n                        if (subModeCh < DecodedBitStreamParser$2.PAL) {\n                            ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];\n                        } else {\n                            switch(subModeCh){\n                                case DecodedBitStreamParser$2.PAL:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.ALPHA_SHIFT:\n                        // Restore sub-mode\n                        subMode = priorToShiftMode;\n                        if (subModeCh < 26) {\n                            ch = /*(char)('A' + subModeCh)*/ String.fromCharCode(65 + subModeCh);\n                        } else {\n                            switch(subModeCh){\n                                case 26:\n                                    ch = \" \";\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.PUNCT_SHIFT:\n                        // Restore sub-mode\n                        subMode = priorToShiftMode;\n                        if (subModeCh < DecodedBitStreamParser$2.PAL) {\n                            ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];\n                        } else {\n                            switch(subModeCh){\n                                case DecodedBitStreamParser$2.PAL:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    // PS before Shift-to-Byte is used as a padding character,\n                                    // see 5.4.2.4 of the specification\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                }\n                // if (ch !== 0) {\n                if (ch !== \"\") {\n                    // Append decoded character to result\n                    result.append(ch);\n                }\n                i++;\n            }\n        }\n        /**\n         * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.\n         * This includes all ASCII characters value 0 to 127 inclusive and provides for international\n         * character set support.\n         *\n         * @param mode      The byte compaction mode i.e. 901 or 924\n         * @param codewords The array of codewords (data + error)\n         * @param encoding  Currently active character encoding\n         * @param codeIndex The current index into the codeword array.\n         * @param result    The decoded data is appended to the result.\n         * @return The next index into the codeword array.\n         */ static byteCompaction(mode, codewords, encoding, codeIndex, result) {\n            let decodedBytes = new ByteArrayOutputStream();\n            let count = 0;\n            let value = /*long*/ 0;\n            let end = false;\n            switch(mode){\n                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                    // Total number of Byte Compaction characters to be encoded\n                    // is not a multiple of 6\n                    let byteCompactedCodewords = new Int32Array(6);\n                    let nextCode = codewords[codeIndex++];\n                    while(codeIndex < codewords[0] && !end){\n                        byteCompactedCodewords[count++] = nextCode;\n                        // Base 900\n                        value = 900 * value + nextCode;\n                        nextCode = codewords[codeIndex++];\n                        // perhaps it should be ok to check only nextCode >= TEXT_COMPACTION_MODE_LATCH\n                        switch(nextCode){\n                            case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                            case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                                codeIndex--;\n                                end = true;\n                                break;\n                            default:\n                                if (count % 5 === 0 && count > 0) {\n                                    // Decode every 5 codewords\n                                    // Convert to Base 256\n                                    for(let j /*int*/  = 0; j < 6; ++j){\n                                        /* @note\n                                         * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n                                         * So the next bitwise operation could not be done with simple numbers\n                                         */ decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n                                    }\n                                    value = 0;\n                                    count = 0;\n                                }\n                                break;\n                        }\n                    }\n                    // if the end of all codewords is reached the last codeword needs to be added\n                    if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {\n                        byteCompactedCodewords[count++] = nextCode;\n                    }\n                    // If Byte Compaction mode is invoked with codeword 901,\n                    // the last group of codewords is interpreted directly\n                    // as one byte per codeword, without compaction.\n                    for(let i /*int*/  = 0; i < count; i++){\n                        decodedBytes.write(/*(byte)*/ byteCompactedCodewords[i]);\n                    }\n                    break;\n                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                    // Total number of Byte Compaction characters to be encoded\n                    // is an integer multiple of 6\n                    while(codeIndex < codewords[0] && !end){\n                        let code = codewords[codeIndex++];\n                        if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {\n                            count++;\n                            // Base 900\n                            value = 900 * value + code;\n                        } else {\n                            switch(code){\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                                case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:\n                                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                                case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                                    codeIndex--;\n                                    end = true;\n                                    break;\n                            }\n                        }\n                        if (count % 5 === 0 && count > 0) {\n                            // Decode every 5 codewords\n                            // Convert to Base 256\n                            /* @note\n                             * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n                             * So the next bitwise operation could not be done with simple numbers\n                            */ for(let j /*int*/  = 0; j < 6; ++j){\n                                decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n                            }\n                            value = 0;\n                            count = 0;\n                        }\n                    }\n                    break;\n            }\n            result.append(StringEncoding.decode(decodedBytes.toByteArray(), encoding));\n            return codeIndex;\n        }\n        /**\n         * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.\n         *\n         * @param codewords The array of codewords (data + error)\n         * @param codeIndex The current index into the codeword array.\n         * @param result    The decoded data is appended to the result.\n         * @return The next index into the codeword array.\n         *\n         * @throws FormatException\n         */ static numericCompaction(codewords, codeIndex /*int*/ , result) {\n            let count = 0;\n            let end = false;\n            let numericCodewords = new Int32Array(DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS);\n            while(codeIndex < codewords[0] && !end){\n                let code = codewords[codeIndex++];\n                if (codeIndex === codewords[0]) {\n                    end = true;\n                }\n                if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {\n                    numericCodewords[count] = code;\n                    count++;\n                } else {\n                    switch(code){\n                        case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                        case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                            codeIndex--;\n                            end = true;\n                            break;\n                    }\n                }\n                if ((count % DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {\n                    // Re-invoking Numeric Compaction mode (by using codeword 902\n                    // while in Numeric Compaction mode) serves  to terminate the\n                    // current Numeric Compaction mode grouping as described in 5.4.4.2,\n                    // and then to start a new one grouping.\n                    result.append(DecodedBitStreamParser$2.decodeBase900toBase10(numericCodewords, count));\n                    count = 0;\n                }\n            }\n            return codeIndex;\n        }\n        /**\n         * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.\n         *\n         * @param codewords The array of codewords\n         * @param count     The number of codewords\n         * @return The decoded string representing the Numeric data.\n         *\n         * EXAMPLE\n         * Encode the fifteen digit numeric string 000213298174000\n         * Prefix the numeric string with a 1 and set the initial value of\n         * t = 1 000 213 298 174 000\n         * Calculate codeword 0\n         * d0 = 1 000 213 298 174 000 mod 900 = 200\n         *\n         * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082\n         * Calculate codeword 1\n         * d1 = 1 111 348 109 082 mod 900 = 282\n         *\n         * t = 1 111 348 109 082 div 900 = 1 234 831 232\n         * Calculate codeword 2\n         * d2 = 1 234 831 232 mod 900 = 632\n         *\n         * t = 1 234 831 232 div 900 = 1 372 034\n         * Calculate codeword 3\n         * d3 = 1 372 034 mod 900 = 434\n         *\n         * t = 1 372 034 div 900 = 1 524\n         * Calculate codeword 4\n         * d4 = 1 524 mod 900 = 624\n         *\n         * t = 1 524 div 900 = 1\n         * Calculate codeword 5\n         * d5 = 1 mod 900 = 1\n         * t = 1 div 900 = 0\n         * Codeword sequence is: 1, 624, 434, 632, 282, 200\n         *\n         * Decode the above codewords involves\n         *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +\n         * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000\n         *\n         * Remove leading 1 =>  Result is 000213298174000\n         *\n         * @throws FormatException\n         */ static decodeBase900toBase10(codewords, count) {\n            let result = createBigInt(0);\n            for(let i /*int*/  = 0; i < count; i++){\n                result += DecodedBitStreamParser$2.EXP900[count - i - 1] * createBigInt(codewords[i]);\n            }\n            let resultString = result.toString();\n            if (resultString.charAt(0) !== \"1\") {\n                throw new FormatException();\n            }\n            return resultString.substring(1);\n        }\n    }\n    DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH = 900;\n    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH = 901;\n    DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH = 902;\n    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6 = 924;\n    DecodedBitStreamParser$2.ECI_USER_DEFINED = 925;\n    DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE = 926;\n    DecodedBitStreamParser$2.ECI_CHARSET = 927;\n    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;\n    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;\n    DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR = 922;\n    DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;\n    DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS = 15;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;\n    DecodedBitStreamParser$2.PL = 25;\n    DecodedBitStreamParser$2.LL = 27;\n    DecodedBitStreamParser$2.AS = 27;\n    DecodedBitStreamParser$2.ML = 28;\n    DecodedBitStreamParser$2.AL = 28;\n    DecodedBitStreamParser$2.PS = 29;\n    DecodedBitStreamParser$2.PAL = 29;\n    DecodedBitStreamParser$2.PUNCT_CHARS = \";<>@[\\\\]_`~!\\r\t,:\\n-.$/\\\"|*()?{}'\";\n    DecodedBitStreamParser$2.MIXED_CHARS = \"0123456789&\\r\t,:#-.$/+%*=^\";\n    /**\n     * Table containing values for the exponent of 900.\n     * This is used in the numeric compaction decode algorithm.\n     */ DecodedBitStreamParser$2.EXP900 = getBigIntConstructor() ? getEXP900() : [];\n    DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS = 2;\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */ // import java.util.ArrayList;\n    // import java.util.Collection;\n    // import java.util.Formatter;\n    // import java.util.List;\n    /**\n     * @author Guenther Grau\n     */ /*public final*/ class PDF417ScanningDecoder {\n        constructor(){}\n        /**\n         * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern\n         *\n         * columns. That way width can be deducted from the pattern column.\n         * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider\n         * than it should be. This can happen if the scanner used a bad blackpoint.\n         *\n         * @param BitMatrix\n         * @param image\n         * @param ResultPoint\n         * @param imageTopLeft\n         * @param ResultPoint\n         * @param imageBottomLeft\n         * @param ResultPoint\n         * @param imageTopRight\n         * @param ResultPoint\n         * @param imageBottomRight\n         * @param int\n         * @param minCodewordWidth\n         * @param int\n         * @param maxCodewordWidth\n         *\n         * @throws NotFoundException\n         * @throws FormatException\n         * @throws ChecksumException\n         */ static decode(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {\n            let boundingBox = new BoundingBox(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);\n            let leftRowIndicatorColumn = null;\n            let rightRowIndicatorColumn = null;\n            let detectionResult;\n            for(let firstPass /*boolean*/  = true;; firstPass = false){\n                if (imageTopLeft != null) {\n                    leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);\n                }\n                if (imageTopRight != null) {\n                    rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);\n                }\n                detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);\n                if (detectionResult == null) {\n                    throw NotFoundException.getNotFoundInstance();\n                }\n                let resultBox = detectionResult.getBoundingBox();\n                if (firstPass && resultBox != null && (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {\n                    boundingBox = resultBox;\n                } else {\n                    break;\n                }\n            }\n            detectionResult.setBoundingBox(boundingBox);\n            let maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;\n            detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);\n            detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);\n            let leftToRight = leftRowIndicatorColumn != null;\n            for(let barcodeColumnCount /*int*/  = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++){\n                let barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;\n                if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */ undefined) {\n                    continue;\n                }\n                let detectionResultColumn;\n                if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {\n                    detectionResultColumn = new DetectionResultRowIndicatorColumn(boundingBox, barcodeColumn === 0);\n                } else {\n                    detectionResultColumn = new DetectionResultColumn(boundingBox);\n                }\n                detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);\n                let startColumn = -1;\n                let previousStartColumn = startColumn;\n                // TODO start at a row for which we know the start position, then detect upwards and downwards from there.\n                for(let imageRow /*int*/  = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++){\n                    startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);\n                    if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {\n                        if (previousStartColumn === -1) {\n                            continue;\n                        }\n                        startColumn = previousStartColumn;\n                    }\n                    let codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n                    if (codeword != null) {\n                        detectionResultColumn.setCodeword(imageRow, codeword);\n                        previousStartColumn = startColumn;\n                        minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());\n                        maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());\n                    }\n                }\n            }\n            return PDF417ScanningDecoder.createDecoderResult(detectionResult);\n        }\n        /**\n         *\n         * @param leftRowIndicatorColumn\n         * @param rightRowIndicatorColumn\n         *\n         * @throws NotFoundException\n         */ static merge(leftRowIndicatorColumn, rightRowIndicatorColumn) {\n            if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {\n                return null;\n            }\n            let barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);\n            if (barcodeMetadata == null) {\n                return null;\n            }\n            let boundingBox = BoundingBox.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));\n            return new DetectionResult(barcodeMetadata, boundingBox);\n        }\n        /**\n         *\n         * @param rowIndicatorColumn\n         *\n         * @throws NotFoundException\n         */ static adjustBoundingBox(rowIndicatorColumn) {\n            if (rowIndicatorColumn == null) {\n                return null;\n            }\n            let rowHeights = rowIndicatorColumn.getRowHeights();\n            if (rowHeights == null) {\n                return null;\n            }\n            let maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);\n            let missingStartRows = 0;\n            for (let rowHeight /*int*/  of rowHeights){\n                missingStartRows += maxRowHeight - rowHeight;\n                if (rowHeight > 0) {\n                    break;\n                }\n            }\n            let codewords = rowIndicatorColumn.getCodewords();\n            for(let row /*int*/  = 0; missingStartRows > 0 && codewords[row] == null; row++){\n                missingStartRows--;\n            }\n            let missingEndRows = 0;\n            for(let row /*int*/  = rowHeights.length - 1; row >= 0; row--){\n                missingEndRows += maxRowHeight - rowHeights[row];\n                if (rowHeights[row] > 0) {\n                    break;\n                }\n            }\n            for(let row /*int*/  = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--){\n                missingEndRows--;\n            }\n            return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());\n        }\n        static getMax(values) {\n            let maxValue = -1;\n            for (let value /*int*/  of values){\n                maxValue = Math.max(maxValue, value);\n            }\n            return maxValue;\n        }\n        static getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn) {\n            let leftBarcodeMetadata;\n            if (leftRowIndicatorColumn == null || (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {\n                return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();\n            }\n            let rightBarcodeMetadata;\n            if (rightRowIndicatorColumn == null || (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {\n                return leftBarcodeMetadata;\n            }\n            if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() && leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() && leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {\n                return null;\n            }\n            return leftBarcodeMetadata;\n        }\n        static getRowIndicatorColumn(image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {\n            let rowIndicatorColumn = new DetectionResultRowIndicatorColumn(boundingBox, leftToRight);\n            for(let i /*int*/  = 0; i < 2; i++){\n                let increment = i === 0 ? 1 : -1;\n                let startColumn = Math.trunc(Math.trunc(startPoint.getX()));\n                for(let imageRow /*int*/  = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() && imageRow >= boundingBox.getMinY(); imageRow += increment){\n                    let codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n                    if (codeword != null) {\n                        rowIndicatorColumn.setCodeword(imageRow, codeword);\n                        if (leftToRight) {\n                            startColumn = codeword.getStartX();\n                        } else {\n                            startColumn = codeword.getEndX();\n                        }\n                    }\n                }\n            }\n            return rowIndicatorColumn;\n        }\n        /**\n         *\n         * @param detectionResult\n         * @param BarcodeValue\n         * @param param2\n         * @param param3\n         * @param barcodeMatrix\n         *\n         * @throws NotFoundException\n         */ static adjustCodewordCount(detectionResult, barcodeMatrix) {\n            let barcodeMatrix01 = barcodeMatrix[0][1];\n            let numberOfCodewords = barcodeMatrix01.getValue();\n            let calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() * detectionResult.getBarcodeRowCount() - PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());\n            if (numberOfCodewords.length === 0) {\n                if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common.MAX_CODEWORDS_IN_BARCODE) {\n                    throw NotFoundException.getNotFoundInstance();\n                }\n                barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n            } else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {\n                // The calculated one is more reliable as it is derived from the row indicator columns\n                barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n            }\n        }\n        /**\n         *\n         * @param detectionResult\n         *\n         * @throws FormatException\n         * @throws ChecksumException\n         * @throws NotFoundException\n         */ static createDecoderResult(detectionResult) {\n            let barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);\n            PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);\n            let erasures /*Collection<Integer>*/  = new Array();\n            let codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());\n            let ambiguousIndexValuesList = /*List<int[]>*/ [];\n            let ambiguousIndexesList = /*Collection<Integer>*/ new Array();\n            for(let row /*int*/  = 0; row < detectionResult.getBarcodeRowCount(); row++){\n                for(let column /*int*/  = 0; column < detectionResult.getBarcodeColumnCount(); column++){\n                    let values = barcodeMatrix[row][column + 1].getValue();\n                    let codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;\n                    if (values.length === 0) {\n                        erasures.push(codewordIndex);\n                    } else if (values.length === 1) {\n                        codewords[codewordIndex] = values[0];\n                    } else {\n                        ambiguousIndexesList.push(codewordIndex);\n                        ambiguousIndexValuesList.push(values);\n                    }\n                }\n            }\n            let ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);\n            for(let i /*int*/  = 0; i < ambiguousIndexValues.length; i++){\n                ambiguousIndexValues[i] = ambiguousIndexValuesList[i];\n            }\n            return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common.toIntArray(erasures), PDF417Common.toIntArray(ambiguousIndexesList), ambiguousIndexValues);\n        }\n        /**\n         * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The\n         * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value\n         * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of\n         * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the\n         * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,\n         * so decoding the normal barcodes is not affected by this.\n         *\n         * @param erasureArray contains the indexes of erasures\n         * @param ambiguousIndexes array with the indexes that have more than one most likely value\n         * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must\n         * be the same length as the ambiguousIndexes array\n         *\n         * @throws FormatException\n         * @throws ChecksumException\n         */ static createDecoderResultFromAmbiguousValues(ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {\n            let ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);\n            let tries = 100;\n            while(tries-- > 0){\n                for(let i /*int*/  = 0; i < ambiguousIndexCount.length; i++){\n                    codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];\n                }\n                try {\n                    return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);\n                } catch (err) {\n                    let ignored = err instanceof ChecksumException;\n                    if (!ignored) {\n                        throw err;\n                    }\n                }\n                if (ambiguousIndexCount.length === 0) {\n                    throw ChecksumException.getChecksumInstance();\n                }\n                for(let i /*int*/  = 0; i < ambiguousIndexCount.length; i++){\n                    if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {\n                        ambiguousIndexCount[i]++;\n                        break;\n                    } else {\n                        ambiguousIndexCount[i] = 0;\n                        if (i === ambiguousIndexCount.length - 1) {\n                            throw ChecksumException.getChecksumInstance();\n                        }\n                    }\n                }\n            }\n            throw ChecksumException.getChecksumInstance();\n        }\n        static createBarcodeMatrix(detectionResult) {\n            // let barcodeMatrix: BarcodeValue[][] =\n            // new BarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount() + 2];\n            let barcodeMatrix = Array.from({\n                length: detectionResult.getBarcodeRowCount()\n            }, ()=>new Array(detectionResult.getBarcodeColumnCount() + 2));\n            for(let row /*int*/  = 0; row < barcodeMatrix.length; row++){\n                for(let column /*int*/  = 0; column < barcodeMatrix[row].length; column++){\n                    barcodeMatrix[row][column] = new BarcodeValue();\n                }\n            }\n            let column = 0;\n            for (let detectionResultColumn /*DetectionResultColumn*/  of detectionResult.getDetectionResultColumns()){\n                if (detectionResultColumn != null) {\n                    for (let codeword /*Codeword*/  of detectionResultColumn.getCodewords()){\n                        if (codeword != null) {\n                            let rowNumber = codeword.getRowNumber();\n                            if (rowNumber >= 0) {\n                                if (rowNumber >= barcodeMatrix.length) {\n                                    continue;\n                                }\n                                barcodeMatrix[rowNumber][column].setValue(codeword.getValue());\n                            }\n                        }\n                    }\n                }\n                column++;\n            }\n            return barcodeMatrix;\n        }\n        static isValidBarcodeColumn(detectionResult, barcodeColumn) {\n            return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;\n        }\n        static getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight) {\n            let offset = leftToRight ? 1 : -1;\n            let codeword = null;\n            if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n                codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);\n            }\n            if (codeword != null) {\n                return leftToRight ? codeword.getEndX() : codeword.getStartX();\n            }\n            codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);\n            if (codeword != null) {\n                return leftToRight ? codeword.getStartX() : codeword.getEndX();\n            }\n            if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n                codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);\n            }\n            if (codeword != null) {\n                return leftToRight ? codeword.getEndX() : codeword.getStartX();\n            }\n            let skippedColumns = 0;\n            while(PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)){\n                barcodeColumn -= offset;\n                for (let previousRowCodeword /*Codeword*/  of detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()){\n                    if (previousRowCodeword != null) {\n                        return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) + offset * skippedColumns * (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());\n                    }\n                }\n                skippedColumns++;\n            }\n            return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();\n        }\n        static detectCodeword(image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {\n            startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n            // we usually know fairly exact now how long a codeword is. We should provide minimum and maximum expected length\n            // and try to adjust the read pixels, e.g. remove single pixel errors or try to cut off exceeding pixels.\n            // min and maxCodewordWidth should not be used as they are calculated for the whole barcode an can be inaccurate\n            // for the current position\n            let moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n            if (moduleBitCount == null) {\n                return null;\n            }\n            let endColumn;\n            let codewordBitCount = MathUtils.sum(moduleBitCount);\n            if (leftToRight) {\n                endColumn = startColumn + codewordBitCount;\n            } else {\n                for(let i /*int*/  = 0; i < moduleBitCount.length / 2; i++){\n                    let tmpCount = moduleBitCount[i];\n                    moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];\n                    moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;\n                }\n                endColumn = startColumn;\n                startColumn = endColumn - codewordBitCount;\n            }\n            // TODO implement check for width and correction of black and white bars\n            // use start (and maybe stop pattern) to determine if black bars are wider than white bars. If so, adjust.\n            // should probably done only for codewords with a lot more than 17 bits.\n            // The following fixes 10-1.png, which has wide black bars and small white bars\n            //    for (let i /*int*/ = 0; i < moduleBitCount.length; i++) {\n            //      if (i % 2 === 0) {\n            //        moduleBitCount[i]--;\n            //      } else {\n            //        moduleBitCount[i]++;\n            //      }\n            //    }\n            // We could also use the width of surrounding codewords for more accurate results, but this seems\n            // sufficient for now\n            if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {\n                // We could try to use the startX and endX position of the codeword in the same column in the previous row,\n                // create the bit count from it and normalize it to 8. This would help with single pixel errors.\n                return null;\n            }\n            let decodedValue = PDF417CodewordDecoder.getDecodedValue(moduleBitCount);\n            let codeword = PDF417Common.getCodeword(decodedValue);\n            if (codeword === -1) {\n                return null;\n            }\n            return new Codeword(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);\n        }\n        static getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {\n            let imageColumn = startColumn;\n            let moduleBitCount = new Int32Array(8);\n            let moduleNumber = 0;\n            let increment = leftToRight ? 1 : -1;\n            let previousPixelValue = leftToRight;\n            while((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) && moduleNumber < moduleBitCount.length){\n                if (image.get(imageColumn, imageRow) === previousPixelValue) {\n                    moduleBitCount[moduleNumber]++;\n                    imageColumn += increment;\n                } else {\n                    moduleNumber++;\n                    previousPixelValue = !previousPixelValue;\n                }\n            }\n            if (moduleNumber === moduleBitCount.length || imageColumn === (leftToRight ? maxColumn : minColumn) && moduleNumber === moduleBitCount.length - 1) {\n                return moduleBitCount;\n            }\n            return null;\n        }\n        static getNumberOfECCodeWords(barcodeECLevel) {\n            return 2 << barcodeECLevel;\n        }\n        static adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {\n            let correctedStartColumn = codewordStartColumn;\n            let increment = leftToRight ? -1 : 1;\n            // there should be no black pixels before the start column. If there are, then we need to start earlier.\n            for(let i /*int*/  = 0; i < 2; i++){\n                while((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) && leftToRight === image.get(correctedStartColumn, imageRow)){\n                    if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {\n                        return codewordStartColumn;\n                    }\n                    correctedStartColumn += increment;\n                }\n                increment = -increment;\n                leftToRight = !leftToRight;\n            }\n            return correctedStartColumn;\n        }\n        static checkCodewordSkew(codewordSize, minCodewordWidth, maxCodewordWidth) {\n            return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize && codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;\n        }\n        /**\n         * @throws FormatException,\n         * @throws ChecksumException\n         */ static decodeCodewords(codewords, ecLevel, erasures) {\n            if (codewords.length === 0) {\n                throw FormatException.getFormatInstance();\n            }\n            let numECCodewords = 1 << ecLevel + 1;\n            let correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);\n            PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);\n            // Decode the codewords\n            let decoderResult = DecodedBitStreamParser$2.decode(codewords, \"\" + ecLevel);\n            decoderResult.setErrorsCorrected(correctedErrorsCount);\n            decoderResult.setErasures(erasures.length);\n            return decoderResult;\n        }\n        /**\n         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n         * correct the errors in-place.</p>\n         *\n         * @param codewords   data and error correction codewords\n         * @param erasures positions of any known erasures\n         * @param numECCodewords number of error correction codewords that are available in codewords\n         * @throws ChecksumException if error correction fails\n         */ static correctErrors(codewords, erasures, numECCodewords) {\n            if (erasures != null && erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS || numECCodewords < 0 || numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {\n                // Too many errors or EC Codewords is corrupted\n                throw ChecksumException.getChecksumInstance();\n            }\n            return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);\n        }\n        /**\n         * Verify that all is OK with the codeword array.\n         * @throws FormatException\n         */ static verifyCodewordCount(codewords, numECCodewords) {\n            if (codewords.length < 4) {\n                // Codeword array size should be at least 4 allowing for\n                // Count CW, At least one Data CW, Error Correction CW, Error Correction CW\n                throw FormatException.getFormatInstance();\n            }\n            // The first codeword, the Symbol Length Descriptor, shall always encode the total number of data\n            // codewords in the symbol, including the Symbol Length Descriptor itself, data codewords and pad\n            // codewords, but excluding the number of error correction codewords.\n            let numberOfCodewords = codewords[0];\n            if (numberOfCodewords > codewords.length) {\n                throw FormatException.getFormatInstance();\n            }\n            if (numberOfCodewords === 0) {\n                // Reset to the length of the array - 8 (Allow for at least level 3 Error Correction (8 Error Codewords)\n                if (numECCodewords < codewords.length) {\n                    codewords[0] = codewords.length - numECCodewords;\n                } else {\n                    throw FormatException.getFormatInstance();\n                }\n            }\n        }\n        static getBitCountForCodeword(codeword) {\n            let result = new Int32Array(8);\n            let previousValue = 0;\n            let i = result.length - 1;\n            while(true){\n                if ((codeword & 0x1) !== previousValue) {\n                    previousValue = codeword & 0x1;\n                    i--;\n                    if (i < 0) {\n                        break;\n                    }\n                }\n                result[i]++;\n                codeword >>= 1;\n            }\n            return result;\n        }\n        static getCodewordBucketNumber(codeword) {\n            if (codeword instanceof Int32Array) {\n                return this.getCodewordBucketNumber_Int32Array(codeword);\n            }\n            return this.getCodewordBucketNumber_number(codeword);\n        }\n        static getCodewordBucketNumber_number(codeword) {\n            return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));\n        }\n        static getCodewordBucketNumber_Int32Array(moduleBitCount) {\n            return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;\n        }\n        static toString(barcodeMatrix) {\n            let formatter = new Formatter();\n            // try (let formatter = new Formatter()) {\n            for(let row /*int*/  = 0; row < barcodeMatrix.length; row++){\n                formatter.format(\"Row %2d: \", row);\n                for(let column /*int*/  = 0; column < barcodeMatrix[row].length; column++){\n                    let barcodeValue = barcodeMatrix[row][column];\n                    if (barcodeValue.getValue().length === 0) {\n                        formatter.format(\"        \", null);\n                    } else {\n                        formatter.format(\"%4d(%2d)\", barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));\n                    }\n                }\n                formatter.format(\"%n\");\n            }\n            return formatter.toString();\n        // }\n        }\n    }\n    /*final*/ PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;\n    /*final*/ PDF417ScanningDecoder.MAX_ERRORS = 3;\n    /*final*/ PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;\n    /*final*/ PDF417ScanningDecoder.errorCorrection = new ErrorCorrection();\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ // import java.util.ArrayList;\n    // import java.util.List;\n    // import java.util.Map;\n    /**\n     * This implementation can detect and decode PDF417 codes in an image.\n     *\n     * @author Guenther Grau\n     */ /*public final*/ class PDF417Reader {\n        // private static /*final Result[]*/ EMPTY_RESULT_ARRAY: Result[] = new Result([0]);\n        /**\n         * Locates and decodes a PDF417 code in an image.\n         *\n         * @return a String representing the content encoded by the PDF417 code\n         * @throws NotFoundException if a PDF417 code cannot be found,\n         * @throws FormatException if a PDF417 cannot be decoded\n         * @throws ChecksumException\n         */ // @Override\n        decode(image, hints = null) {\n            let result = PDF417Reader.decode(image, hints, false);\n            if (result == null || result.length === 0 || result[0] == null) {\n                throw NotFoundException.getNotFoundInstance();\n            }\n            return result[0];\n        }\n        /**\n         *\n         * @param BinaryBitmap\n         * @param image\n         * @throws NotFoundException\n         */ //   @Override\n        decodeMultiple(image, hints = null) {\n            try {\n                return PDF417Reader.decode(image, hints, true);\n            } catch (ignored) {\n                if (ignored instanceof FormatException || ignored instanceof ChecksumException) {\n                    throw NotFoundException.getNotFoundInstance();\n                }\n                throw ignored;\n            }\n        }\n        /**\n         *\n         * @param image\n         * @param hints\n         * @param multiple\n         *\n         * @throws NotFoundException\n         * @throws FormatExceptionß\n         * @throws ChecksumException\n         */ static decode(image, hints, multiple) {\n            const results = new Array();\n            const detectorResult = Detector$3.detectMultiple(image, hints, multiple);\n            for (const points of detectorResult.getPoints()){\n                const decoderResult = PDF417ScanningDecoder.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader.getMinCodewordWidth(points), PDF417Reader.getMaxCodewordWidth(points));\n                const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat$1.PDF_417);\n                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());\n                const pdf417ResultMetadata = decoderResult.getOther();\n                if (pdf417ResultMetadata != null) {\n                    result.putMetadata(ResultMetadataType$1.PDF417_EXTRA_METADATA, pdf417ResultMetadata);\n                }\n                results.push(result);\n            }\n            return results.map((x)=>x);\n        }\n        static getMaxWidth(p1, p2) {\n            if (p1 == null || p2 == null) {\n                return 0;\n            }\n            return Math.trunc(Math.abs(p1.getX() - p2.getX()));\n        }\n        static getMinWidth(p1, p2) {\n            if (p1 == null || p2 == null) {\n                return Integer.MAX_VALUE;\n            }\n            return Math.trunc(Math.abs(p1.getX() - p2.getX()));\n        }\n        static getMaxCodewordWidth(p) {\n            return Math.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p[0], p[4]), PDF417Reader.getMaxWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader.getMaxWidth(p[1], p[5]), PDF417Reader.getMaxWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN)));\n        }\n        static getMinCodewordWidth(p) {\n            return Math.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p[0], p[4]), PDF417Reader.getMinWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader.getMinWidth(p[1], p[5]), PDF417Reader.getMinWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN)));\n        }\n        // @Override\n        reset() {\n        // nothing needs to be reset\n        }\n    }\n    /**\n     * Custom Error class of type Exception.\n     */ class ReaderException extends Exception {\n    }\n    ReaderException.kind = \"ReaderException\";\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*namespace com.google.zxing {*/ /**\n     * MultiFormatReader is a convenience class and the main entry point into the library for most uses.\n     * By default it attempts to decode all barcode formats that the library supports. Optionally, you\n     * can provide a hints object to request different behavior, for example only decoding QR codes.\n     *\n     * @author Sean Owen\n     * @author dswitkin@google.com (Daniel Switkin)\n     */ class MultiFormatReader {\n        /**\n         * Creates an instance of this class\n         * \n         * @param {Boolean} verbose if 'true' logs will be dumped to console, otherwise hidden.\n         * @param hints The hints to use, clearing the previous state.\n         */ constructor(verbose, hints){\n            this.verbose = verbose === true;\n            if (hints) {\n                this.setHints(hints);\n            }\n        }\n        /**\n         * This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it\n         * passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.\n         * Use setHints() followed by decodeWithState() for continuous scan applications.\n         *\n         * @param image The pixel data to decode\n         * @return The contents of the image\n         *\n         * @throws NotFoundException Any errors which occurred\n         */ /*@Override*/ // public decode(image: BinaryBitmap): Result {\n        //   setHints(null)\n        //   return decodeInternal(image)\n        // }\n        /**\n         * Decode an image using the hints provided. Does not honor existing state.\n         *\n         * @param image The pixel data to decode\n         * @param hints The hints to use, clearing the previous state.\n         * @return The contents of the image\n         *\n         * @throws NotFoundException Any errors which occurred\n         */ /*@Override*/ decode(image, hints) {\n            if (hints) {\n                this.setHints(hints);\n            }\n            return this.decodeInternal(image);\n        }\n        /**\n         * Decode an image using the state set up by calling setHints() previously. Continuous scan\n         * clients will get a <b>large</b> speed increase by using this instead of decode().\n         *\n         * @param image The pixel data to decode\n         * @return The contents of the image\n         *\n         * @throws NotFoundException Any errors which occurred\n         */ decodeWithState(image) {\n            // Make sure to set up the default state so we don't crash\n            if (this.readers === null || this.readers === undefined) {\n                this.setHints(null);\n            }\n            return this.decodeInternal(image);\n        }\n        /**\n         * This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls\n         * to decodeWithState(image) can reuse the same set of readers without reallocating memory. This\n         * is important for performance in continuous scan clients.\n         *\n         * @param hints The set of hints to use for subsequent calls to decode(image)\n         */ setHints(hints) {\n            this.hints = hints;\n            const tryHarder = !isNullOrUndefined(hints) && hints.get(DecodeHintType$1.TRY_HARDER) === true;\n            const formats = isNullOrUndefined(hints) ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);\n            const readers = new Array();\n            if (!isNullOrUndefined(formats)) {\n                const addOneDReader = formats.some((f)=>{\n                    return f === BarcodeFormat$1.UPC_A || f === BarcodeFormat$1.UPC_E || f === BarcodeFormat$1.EAN_13 || f === BarcodeFormat$1.EAN_8 || f === BarcodeFormat$1.CODABAR || f === BarcodeFormat$1.CODE_39 || f === BarcodeFormat$1.CODE_93 || f === BarcodeFormat$1.CODE_128 || f === BarcodeFormat$1.ITF || f === BarcodeFormat$1.RSS_14 || f === BarcodeFormat$1.RSS_EXPANDED;\n                });\n                // Put 1D readers upfront in \"normal\" mode\n                if (addOneDReader && !tryHarder) {\n                    readers.push(new MultiFormatOneDReader(hints, this.verbose));\n                }\n                if (formats.includes(BarcodeFormat$1.QR_CODE)) {\n                    readers.push(new QRCodeReader());\n                }\n                if (formats.includes(BarcodeFormat$1.DATA_MATRIX)) {\n                    readers.push(new DataMatrixReader());\n                }\n                if (formats.includes(BarcodeFormat$1.AZTEC)) {\n                    readers.push(new AztecReader());\n                }\n                if (formats.includes(BarcodeFormat$1.PDF_417)) {\n                    readers.push(new PDF417Reader());\n                }\n                // if (formats.includes(BarcodeFormat.MAXICODE)) {\n                //    readers.push(new MaxiCodeReader())\n                // }\n                // At end in \"try harder\" mode\n                if (addOneDReader && tryHarder) {\n                    readers.push(new MultiFormatOneDReader(hints, this.verbose));\n                }\n            }\n            if (readers.length === 0) {\n                if (!tryHarder) {\n                    readers.push(new MultiFormatOneDReader(hints, this.verbose));\n                }\n                readers.push(new QRCodeReader());\n                readers.push(new DataMatrixReader());\n                readers.push(new AztecReader());\n                readers.push(new PDF417Reader());\n                // readers.push(new MaxiCodeReader())\n                if (tryHarder) {\n                    readers.push(new MultiFormatOneDReader(hints, this.verbose));\n                }\n            }\n            this.readers = readers; // .toArray(new Reader[readers.size()])\n        }\n        /*@Override*/ reset() {\n            if (this.readers !== null) {\n                for (const reader of this.readers){\n                    reader.reset();\n                }\n            }\n        }\n        /**\n         * @throws NotFoundException\n         */ decodeInternal(image) {\n            if (this.readers === null) {\n                throw new ReaderException(\"No readers where selected, nothing can be read.\");\n            }\n            for (const reader of this.readers){\n                // Trying to decode with ${reader} reader.\n                try {\n                    return reader.decode(image, this.hints);\n                } catch (ex) {\n                    if (ex instanceof ReaderException) {\n                        continue;\n                    }\n                // Bad Exception.\n                }\n            }\n            throw new NotFoundException(\"No MultiFormat Readers were able to detect the code.\");\n        }\n    }\n    class BrowserMultiFormatReader extends BrowserCodeReader {\n        constructor(hints = null, timeBetweenScansMillis = 500){\n            const reader = new MultiFormatReader();\n            reader.setHints(hints);\n            super(reader, timeBetweenScansMillis);\n        }\n        /**\n         * Overwrite decodeBitmap to call decodeWithState, which will pay\n         * attention to the hints set in the constructor function\n         */ decodeBitmap(binaryBitmap) {\n            return this.reader.decodeWithState(binaryBitmap);\n        }\n    }\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * QR Code reader to use from browser.\n     */ class BrowserPDF417Reader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserPDF417Reader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         */ constructor(timeBetweenScansMillis = 500){\n            super(new PDF417Reader(), timeBetweenScansMillis);\n        }\n    }\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * QR Code reader to use from browser.\n     */ class BrowserQRCodeReader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserQRCodeReader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         */ constructor(timeBetweenScansMillis = 500){\n            super(new QRCodeReader(), timeBetweenScansMillis);\n        }\n    }\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /*namespace com.google.zxing {*/ /**\n     * These are a set of hints that you may pass to Writers to specify their behavior.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */ var EncodeHintType;\n    (function(EncodeHintType) {\n        /**\n         * Specifies what degree of error correction to use, for example in QR Codes.\n         * Type depends on the encoder. For example for QR codes it's type\n         * {@link com.google.zxing.qrcode.decoder.ErrorCorrectionLevel ErrorCorrectionLevel}.\n         * For Aztec it is of type {@link Integer}, representing the minimal percentage of error correction words.\n         * For PDF417 it is of type {@link Integer}, valid values being 0 to 8.\n         * In all cases, it can also be a {@link String} representation of the desired value as well.\n         * Note: an Aztec symbol should have a minimum of 25% EC words.\n         */ EncodeHintType[EncodeHintType[\"ERROR_CORRECTION\"] = 0] = \"ERROR_CORRECTION\";\n        /**\n         * Specifies what character encoding to use where applicable (type {@link String})\n         */ EncodeHintType[EncodeHintType[\"CHARACTER_SET\"] = 1] = \"CHARACTER_SET\";\n        /**\n         * Specifies the matrix shape for Data Matrix (type {@link com.google.zxing.datamatrix.encoder.SymbolShapeHint})\n         */ EncodeHintType[EncodeHintType[\"DATA_MATRIX_SHAPE\"] = 2] = \"DATA_MATRIX_SHAPE\";\n        /**\n         * Specifies a minimum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.\n         *\n         * @deprecated use width/height params in\n         * {@link com.google.zxing.datamatrix.DataMatrixWriter#encode(String, BarcodeFormat, int, int)}\n         */ /*@Deprecated*/ EncodeHintType[EncodeHintType[\"MIN_SIZE\"] = 3] = \"MIN_SIZE\";\n        /**\n         * Specifies a maximum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.\n         *\n         * @deprecated without replacement\n         */ /*@Deprecated*/ EncodeHintType[EncodeHintType[\"MAX_SIZE\"] = 4] = \"MAX_SIZE\";\n        /**\n         * Specifies margin, in pixels, to use when generating the barcode. The meaning can vary\n         * by format; for example it controls margin before and after the barcode horizontally for\n         * most 1D formats. (Type {@link Integer}, or {@link String} representation of the integer value).\n         */ EncodeHintType[EncodeHintType[\"MARGIN\"] = 5] = \"MARGIN\";\n        /**\n         * Specifies whether to use compact mode for PDF417 (type {@link Boolean}, or \"true\" or \"false\"\n         * {@link String} value).\n         */ EncodeHintType[EncodeHintType[\"PDF417_COMPACT\"] = 6] = \"PDF417_COMPACT\";\n        /**\n         * Specifies what compaction mode to use for PDF417 (type\n         * {@link com.google.zxing.pdf417.encoder.Compaction Compaction} or {@link String} value of one of its\n         * enum values).\n         */ EncodeHintType[EncodeHintType[\"PDF417_COMPACTION\"] = 7] = \"PDF417_COMPACTION\";\n        /**\n         * Specifies the minimum and maximum number of rows and columns for PDF417 (type\n         * {@link com.google.zxing.pdf417.encoder.Dimensions Dimensions}).\n         */ EncodeHintType[EncodeHintType[\"PDF417_DIMENSIONS\"] = 8] = \"PDF417_DIMENSIONS\";\n        /**\n         * Specifies the required number of layers for an Aztec code.\n         * A negative number (-1, -2, -3, -4) specifies a compact Aztec code.\n         * 0 indicates to use the minimum number of layers (the default).\n         * A positive number (1, 2, .. 32) specifies a normal (non-compact) Aztec code.\n         * (Type {@link Integer}, or {@link String} representation of the integer value).\n         */ EncodeHintType[EncodeHintType[\"AZTEC_LAYERS\"] = 9] = \"AZTEC_LAYERS\";\n        /**\n         * Specifies the exact version of QR code to be encoded.\n         * (Type {@link Integer}, or {@link String} representation of the integer value).\n         */ EncodeHintType[EncodeHintType[\"QR_VERSION\"] = 10] = \"QR_VERSION\";\n    })(EncodeHintType || (EncodeHintType = {}));\n    var EncodeHintType$1 = EncodeHintType;\n    /**\n     * <p>Implements Reed-Solomon encoding, as the name implies.</p>\n     *\n     * @author Sean Owen\n     * @author William Rucklidge\n     */ class ReedSolomonEncoder {\n        /**\n         * A reed solomon error-correcting encoding constructor is created by\n         * passing as Galois Field with of size equal to the number of code\n         * words (symbols) in the alphabet (the number of values in each\n         * element of arrays that are encoded/decoded).\n         * @param field A galois field with a number of elements equal to the size\n         * of the alphabet of symbols to encode.\n         */ constructor(field){\n            this.field = field;\n            this.cachedGenerators = [];\n            this.cachedGenerators.push(new GenericGFPoly(field, Int32Array.from([\n                1\n            ])));\n        }\n        buildGenerator(degree /*int*/ ) {\n            const cachedGenerators = this.cachedGenerators;\n            if (degree >= cachedGenerators.length) {\n                let lastGenerator = cachedGenerators[cachedGenerators.length - 1];\n                const field = this.field;\n                for(let d = cachedGenerators.length; d <= degree; d++){\n                    const nextGenerator = lastGenerator.multiply(new GenericGFPoly(field, Int32Array.from([\n                        1,\n                        field.exp(d - 1 + field.getGeneratorBase())\n                    ])));\n                    cachedGenerators.push(nextGenerator);\n                    lastGenerator = nextGenerator;\n                }\n            }\n            return cachedGenerators[degree];\n        }\n        /**\n         * <p>Encode a sequence of code words (symbols) using Reed-Solomon to allow decoders\n         * to detect and correct errors that may have been introduced when the resulting\n         * data is stored or transmitted.</p>\n         *\n         * @param toEncode array used for both and output. Caller initializes the array with\n         * the code words (symbols) to be encoded followed by empty elements allocated to make\n         * space for error-correction code words in the encoded output. The array contains\n         * the encdoded output when encode returns. Code words are encoded as numbers from\n         * 0 to n-1, where n is the number of possible code words (symbols), as determined\n         * by the size of the Galois Field passed in the constructor of this object.\n         * @param ecBytes the number of elements reserved in the array (first parameter)\n         * to store error-correction code words. Thus, the number of code words (symbols)\n         * to encode in the first parameter is thus toEncode.length - ecBytes.\n         * Note, the use of \"bytes\" in the name of this parameter is misleading, as there may\n         * be more or fewer than 256 symbols being encoded, as determined by the number of\n         * elements in the Galois Field passed as a constructor to this object.\n         * @throws IllegalArgumentException thrown in response to validation errros.\n         */ encode(toEncode, ecBytes /*int*/ ) {\n            if (ecBytes === 0) {\n                throw new IllegalArgumentException(\"No error correction bytes\");\n            }\n            const dataBytes = toEncode.length - ecBytes;\n            if (dataBytes <= 0) {\n                throw new IllegalArgumentException(\"No data bytes provided\");\n            }\n            const generator = this.buildGenerator(ecBytes);\n            const infoCoefficients = new Int32Array(dataBytes);\n            System.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);\n            let info = new GenericGFPoly(this.field, infoCoefficients);\n            info = info.multiplyByMonomial(ecBytes, 1);\n            const remainder = info.divide(generator)[1];\n            const coefficients = remainder.getCoefficients();\n            const numZeroCoefficients = ecBytes - coefficients.length;\n            for(let i = 0; i < numZeroCoefficients; i++){\n                toEncode[dataBytes + i] = 0;\n            }\n            System.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);\n        }\n    }\n    /**\n     * @author Satoru Takabayashi\n     * @author Daniel Switkin\n     * @author Sean Owen\n     */ class MaskUtil {\n        constructor(){\n        // do nothing\n        }\n        /**\n         * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and\n         * give penalty to them. Example: 00000 or 11111.\n         */ static applyMaskPenaltyRule1(matrix) {\n            return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);\n        }\n        /**\n         * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give\n         * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a\n         * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.\n         */ static applyMaskPenaltyRule2(matrix) {\n            let penalty = 0;\n            const array = matrix.getArray();\n            const width = matrix.getWidth();\n            const height = matrix.getHeight();\n            for(let y = 0; y < height - 1; y++){\n                const arrayY = array[y];\n                for(let x = 0; x < width - 1; x++){\n                    const value = arrayY[x];\n                    if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {\n                        penalty++;\n                    }\n                }\n            }\n            return MaskUtil.N2 * penalty;\n        }\n        /**\n         * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4\n         * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we\n         * find patterns like 000010111010000, we give penalty once.\n         */ static applyMaskPenaltyRule3(matrix) {\n            let numPenalties = 0;\n            const array = matrix.getArray();\n            const width = matrix.getWidth();\n            const height = matrix.getHeight();\n            for(let y = 0; y < height; y++){\n                for(let x = 0; x < width; x++){\n                    const arrayY = array[y]; // We can at least optimize this access\n                    if (x + 6 < width && arrayY[x] === 1 && arrayY[x + 1] === 0 && arrayY[x + 2] === 1 && arrayY[x + 3] === 1 && arrayY[x + 4] === 1 && arrayY[x + 5] === 0 && arrayY[x + 6] === 1 && (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {\n                        numPenalties++;\n                    }\n                    if (y + 6 < height && array[y][x] === 1 && array[y + 1][x] === 0 && array[y + 2][x] === 1 && array[y + 3][x] === 1 && array[y + 4][x] === 1 && array[y + 5][x] === 0 && array[y + 6][x] === 1 && (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {\n                        numPenalties++;\n                    }\n                }\n            }\n            return numPenalties * MaskUtil.N3;\n        }\n        static isWhiteHorizontal(rowArray, from /*int*/ , to /*int*/ ) {\n            from = Math.max(from, 0);\n            to = Math.min(to, rowArray.length);\n            for(let i = from; i < to; i++){\n                if (rowArray[i] === 1) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static isWhiteVertical(array, col /*int*/ , from /*int*/ , to /*int*/ ) {\n            from = Math.max(from, 0);\n            to = Math.min(to, array.length);\n            for(let i = from; i < to; i++){\n                if (array[i][col] === 1) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give\n         * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.\n         */ static applyMaskPenaltyRule4(matrix) {\n            let numDarkCells = 0;\n            const array = matrix.getArray();\n            const width = matrix.getWidth();\n            const height = matrix.getHeight();\n            for(let y = 0; y < height; y++){\n                const arrayY = array[y];\n                for(let x = 0; x < width; x++){\n                    if (arrayY[x] === 1) {\n                        numDarkCells++;\n                    }\n                }\n            }\n            const numTotalCells = matrix.getHeight() * matrix.getWidth();\n            const fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);\n            return fivePercentVariances * MaskUtil.N4;\n        }\n        /**\n         * Return the mask bit for \"getMaskPattern\" at \"x\" and \"y\". See 8.8 of JISX0510:2004 for mask\n         * pattern conditions.\n         */ static getDataMaskBit(maskPattern /*int*/ , x /*int*/ , y /*int*/ ) {\n            let intermediate; /*int*/ \n            let temp; /*int*/ \n            switch(maskPattern){\n                case 0:\n                    intermediate = y + x & 0x1;\n                    break;\n                case 1:\n                    intermediate = y & 0x1;\n                    break;\n                case 2:\n                    intermediate = x % 3;\n                    break;\n                case 3:\n                    intermediate = (y + x) % 3;\n                    break;\n                case 4:\n                    intermediate = Math.floor(y / 2) + Math.floor(x / 3) & 0x1;\n                    break;\n                case 5:\n                    temp = y * x;\n                    intermediate = (temp & 0x1) + temp % 3;\n                    break;\n                case 6:\n                    temp = y * x;\n                    intermediate = (temp & 0x1) + temp % 3 & 0x1;\n                    break;\n                case 7:\n                    temp = y * x;\n                    intermediate = temp % 3 + (y + x & 0x1) & 0x1;\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Invalid mask pattern: \" + maskPattern);\n            }\n            return intermediate === 0;\n        }\n        /**\n         * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both\n         * vertical and horizontal orders respectively.\n         */ static applyMaskPenaltyRule1Internal(matrix, isHorizontal) {\n            let penalty = 0;\n            const iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();\n            const jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();\n            const array = matrix.getArray();\n            for(let i = 0; i < iLimit; i++){\n                let numSameBitCells = 0;\n                let prevBit = -1;\n                for(let j = 0; j < jLimit; j++){\n                    const bit = isHorizontal ? array[i][j] : array[j][i];\n                    if (bit === prevBit) {\n                        numSameBitCells++;\n                    } else {\n                        if (numSameBitCells >= 5) {\n                            penalty += MaskUtil.N1 + (numSameBitCells - 5);\n                        }\n                        numSameBitCells = 1; // Include the cell itself.\n                        prevBit = bit;\n                    }\n                }\n                if (numSameBitCells >= 5) {\n                    penalty += MaskUtil.N1 + (numSameBitCells - 5);\n                }\n            }\n            return penalty;\n        }\n    }\n    // Penalty weights from section 6.8.2.1\n    MaskUtil.N1 = 3;\n    MaskUtil.N2 = 3;\n    MaskUtil.N3 = 40;\n    MaskUtil.N4 = 10;\n    /**\n     * JAVAPORT: The original code was a 2D array of ints, but since it only ever gets assigned\n     * -1, 0, and 1, I'm going to use less memory and go with bytes.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */ class ByteMatrix {\n        constructor(width /*int*/ , height /*int*/ ){\n            this.width = width;\n            this.height = height;\n            const bytes = new Array(height); // [height][width]\n            for(let i = 0; i !== height; i++){\n                bytes[i] = new Uint8Array(width);\n            }\n            this.bytes = bytes;\n        }\n        getHeight() {\n            return this.height;\n        }\n        getWidth() {\n            return this.width;\n        }\n        get(x /*int*/ , y /*int*/ ) {\n            return this.bytes[y][x];\n        }\n        /**\n         * @return an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)\n         */ getArray() {\n            return this.bytes;\n        }\n        // TYPESCRIPTPORT: preffer to let two methods instead of override to avoid type comparison inside\n        setNumber(x /*int*/ , y /*int*/ , value /*byte|int*/ ) {\n            this.bytes[y][x] = value;\n        }\n        // public set(x: number /*int*/, y: number /*int*/, value: number /*int*/): void {\n        //   bytes[y][x] = (byte) value\n        // }\n        setBoolean(x /*int*/ , y /*int*/ , value) {\n            this.bytes[y][x] = /*(byte) */ value ? 1 : 0;\n        }\n        clear(value /*byte*/ ) {\n            for (const aByte of this.bytes){\n                Arrays.fill(aByte, value);\n            }\n        }\n        equals(o) {\n            if (!(o instanceof ByteMatrix)) {\n                return false;\n            }\n            const other = o;\n            if (this.width !== other.width) {\n                return false;\n            }\n            if (this.height !== other.height) {\n                return false;\n            }\n            for(let y = 0, height = this.height; y < height; ++y){\n                const bytesY = this.bytes[y];\n                const otherBytesY = other.bytes[y];\n                for(let x = 0, width = this.width; x < width; ++x){\n                    if (bytesY[x] !== otherBytesY[x]) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        /*@Override*/ toString() {\n            const result = new StringBuilder(); // (2 * width * height + 2)\n            for(let y = 0, height = this.height; y < height; ++y){\n                const bytesY = this.bytes[y];\n                for(let x = 0, width = this.width; x < width; ++x){\n                    switch(bytesY[x]){\n                        case 0:\n                            result.append(\" 0\");\n                            break;\n                        case 1:\n                            result.append(\" 1\");\n                            break;\n                        default:\n                            result.append(\"  \");\n                            break;\n                    }\n                }\n                result.append(\"\\n\");\n            }\n            return result.toString();\n        }\n    }\n    /**\n     * @author satorux@google.com (Satoru Takabayashi) - creator\n     * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n     */ class QRCode {\n        constructor(){\n            this.maskPattern = -1;\n        }\n        getMode() {\n            return this.mode;\n        }\n        getECLevel() {\n            return this.ecLevel;\n        }\n        getVersion() {\n            return this.version;\n        }\n        getMaskPattern() {\n            return this.maskPattern;\n        }\n        getMatrix() {\n            return this.matrix;\n        }\n        /*@Override*/ toString() {\n            const result = new StringBuilder(); // (200)\n            result.append(\"<<\\n\");\n            result.append(\" mode: \");\n            result.append(this.mode ? this.mode.toString() : \"null\");\n            result.append(\"\\n ecLevel: \");\n            result.append(this.ecLevel ? this.ecLevel.toString() : \"null\");\n            result.append(\"\\n version: \");\n            result.append(this.version ? this.version.toString() : \"null\");\n            result.append(\"\\n maskPattern: \");\n            result.append(this.maskPattern.toString());\n            if (this.matrix) {\n                result.append(\"\\n matrix:\\n\");\n                result.append(this.matrix.toString());\n            } else {\n                result.append(\"\\n matrix: null\\n\");\n            }\n            result.append(\">>\\n\");\n            return result.toString();\n        }\n        setMode(value) {\n            this.mode = value;\n        }\n        setECLevel(value) {\n            this.ecLevel = value;\n        }\n        setVersion(version) {\n            this.version = version;\n        }\n        setMaskPattern(value /*int*/ ) {\n            this.maskPattern = value;\n        }\n        setMatrix(value) {\n            this.matrix = value;\n        }\n        // Check if \"mask_pattern\" is valid.\n        static isValidMaskPattern(maskPattern /*int*/ ) {\n            return maskPattern >= 0 && maskPattern < QRCode.NUM_MASK_PATTERNS;\n        }\n    }\n    QRCode.NUM_MASK_PATTERNS = 8;\n    /**\n     * Custom Error class of type Exception.\n     */ class WriterException extends Exception {\n    }\n    WriterException.kind = \"WriterException\";\n    /**\n     * @author satorux@google.com (Satoru Takabayashi) - creator\n     * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n     */ class MatrixUtil {\n        constructor(){\n        // do nothing\n        }\n        // Set all cells to -1 (TYPESCRIPTPORT: 255).  -1 (TYPESCRIPTPORT: 255) means that the cell is empty (not set yet).\n        //\n        // JAVAPORT: We shouldn't need to do this at all. The code should be rewritten to begin encoding\n        // with the ByteMatrix initialized all to zero.\n        static clearMatrix(matrix) {\n            // TYPESCRIPTPORT: we use UintArray se changed here from -1 to 255\n            matrix.clear(/*(byte) */ /*-1*/ 255);\n        }\n        // Build 2D matrix of QR Code from \"dataBits\" with \"ecLevel\", \"version\" and \"getMaskPattern\". On\n        // success, store the result in \"matrix\" and return true.\n        static buildMatrix(dataBits, ecLevel, version, maskPattern /*int*/ , matrix) {\n            MatrixUtil.clearMatrix(matrix);\n            MatrixUtil.embedBasicPatterns(version, matrix);\n            // Type information appear with any version.\n            MatrixUtil.embedTypeInfo(ecLevel, maskPattern, matrix);\n            // Version info appear if version >= 7.\n            MatrixUtil.maybeEmbedVersionInfo(version, matrix);\n            // Data should be embedded at end.\n            MatrixUtil.embedDataBits(dataBits, maskPattern, matrix);\n        }\n        // Embed basic patterns. On success, modify the matrix and return true.\n        // The basic patterns are:\n        // - Position detection patterns\n        // - Timing patterns\n        // - Dark dot at the left bottom corner\n        // - Position adjustment patterns, if need be\n        static embedBasicPatterns(version, matrix) {\n            // Let's get started with embedding big squares at corners.\n            MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);\n            // Then, embed the dark dot at the left bottom corner.\n            MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);\n            // Position adjustment patterns appear if version >= 2.\n            MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version, matrix);\n            // Timing patterns should be embedded after position adj. patterns.\n            MatrixUtil.embedTimingPatterns(matrix);\n        }\n        // Embed type information. On success, modify the matrix.\n        static embedTypeInfo(ecLevel, maskPattern /*int*/ , matrix) {\n            const typeInfoBits = new BitArray();\n            MatrixUtil.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);\n            for(let i = 0, size = typeInfoBits.getSize(); i < size; ++i){\n                // Place bits in LSB to MSB order.  LSB (least significant bit) is the last value in\n                // \"typeInfoBits\".\n                const bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i);\n                // Type info bits at the left top corner. See 8.9 of JISX0510:2004 (p.46).\n                const coordinates = MatrixUtil.TYPE_INFO_COORDINATES[i];\n                const x1 = coordinates[0];\n                const y1 = coordinates[1];\n                matrix.setBoolean(x1, y1, bit);\n                if (i < 8) {\n                    // Right top corner.\n                    const x2 = matrix.getWidth() - i - 1;\n                    const y2 = 8;\n                    matrix.setBoolean(x2, y2, bit);\n                } else {\n                    // Left bottom corner.\n                    const x2 = 8;\n                    const y2 = matrix.getHeight() - 7 + (i - 8);\n                    matrix.setBoolean(x2, y2, bit);\n                }\n            }\n        }\n        // Embed version information if need be. On success, modify the matrix and return true.\n        // See 8.10 of JISX0510:2004 (p.47) for how to embed version information.\n        static maybeEmbedVersionInfo(version, matrix) {\n            if (version.getVersionNumber() < 7) {\n                return; // Don't need version info.\n            }\n            const versionInfoBits = new BitArray();\n            MatrixUtil.makeVersionInfoBits(version, versionInfoBits);\n            let bitIndex = 6 * 3 - 1; // It will decrease from 17 to 0.\n            for(let i = 0; i < 6; ++i){\n                for(let j = 0; j < 3; ++j){\n                    // Place bits in LSB (least significant bit) to MSB order.\n                    const bit = versionInfoBits.get(bitIndex);\n                    bitIndex--;\n                    // Left bottom corner.\n                    matrix.setBoolean(i, matrix.getHeight() - 11 + j, bit);\n                    // Right bottom corner.\n                    matrix.setBoolean(matrix.getHeight() - 11 + j, i, bit);\n                }\n            }\n        }\n        // Embed \"dataBits\" using \"getMaskPattern\". On success, modify the matrix and return true.\n        // For debugging purposes, it skips masking process if \"getMaskPattern\" is -1(TYPESCRIPTPORT: 255).\n        // See 8.7 of JISX0510:2004 (p.38) for how to embed data bits.\n        static embedDataBits(dataBits, maskPattern /*int*/ , matrix) {\n            let bitIndex = 0;\n            let direction = -1;\n            // Start from the right bottom cell.\n            let x = matrix.getWidth() - 1;\n            let y = matrix.getHeight() - 1;\n            while(x > 0){\n                // Skip the vertical timing pattern.\n                if (x === 6) {\n                    x -= 1;\n                }\n                while(y >= 0 && y < matrix.getHeight()){\n                    for(let i = 0; i < 2; ++i){\n                        const xx = x - i;\n                        // Skip the cell if it's not empty.\n                        if (!MatrixUtil.isEmpty(matrix.get(xx, y))) {\n                            continue;\n                        }\n                        let bit;\n                        if (bitIndex < dataBits.getSize()) {\n                            bit = dataBits.get(bitIndex);\n                            ++bitIndex;\n                        } else {\n                            // Padding bit. If there is no bit left, we'll fill the left cells with 0, as described\n                            // in 8.4.9 of JISX0510:2004 (p. 24).\n                            bit = false;\n                        }\n                        // Skip masking if mask_pattern is -1 (TYPESCRIPTPORT: 255).\n                        if (maskPattern !== 255 && MaskUtil.getDataMaskBit(maskPattern, xx, y)) {\n                            bit = !bit;\n                        }\n                        matrix.setBoolean(xx, y, bit);\n                    }\n                    y += direction;\n                }\n                direction = -direction; // Reverse the direction.\n                y += direction;\n                x -= 2; // Move to the left.\n            }\n            // All bits should be consumed.\n            if (bitIndex !== dataBits.getSize()) {\n                throw new WriterException(\"Not all bits consumed: \" + bitIndex + \"/\" + dataBits.getSize());\n            }\n        }\n        // Return the position of the most significant bit set (one: to) in the \"value\". The most\n        // significant bit is position 32. If there is no bit set, return 0. Examples:\n        // - findMSBSet(0) => 0\n        // - findMSBSet(1) => 1\n        // - findMSBSet(255) => 8\n        static findMSBSet(value /*int*/ ) {\n            return 32 - Integer.numberOfLeadingZeros(value);\n        }\n        // Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for \"value\" using polynomial \"poly\". The BCH\n        // code is used for encoding type information and version information.\n        // Example: Calculation of version information of 7.\n        // f(x) is created from 7.\n        //   - 7 = 000111 in 6 bits\n        //   - f(x) = x^2 + x^1 + x^0\n        // g(x) is given by the standard (p. 67)\n        //   - g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1\n        // Multiply f(x) by x^(18 - 6)\n        //   - f'(x) = f(x) * x^(18 - 6)\n        //   - f'(x) = x^14 + x^13 + x^12\n        // Calculate the remainder of f'(x) / g(x)\n        //         x^2\n        //         __________________________________________________\n        //   g(x) )x^14 + x^13 + x^12\n        //         x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2\n        //         --------------------------------------------------\n        //                              x^11 + x^10 + x^7 + x^4 + x^2\n        //\n        // The remainder is x^11 + x^10 + x^7 + x^4 + x^2\n        // Encode it in binary: 110010010100\n        // The return value is 0xc94 (1100 1001 0100)\n        //\n        // Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit\n        // operations. We don't care if coefficients are positive or negative.\n        static calculateBCHCode(value /*int*/ , poly /*int*/ ) {\n            if (poly === 0) {\n                throw new IllegalArgumentException(\"0 polynomial\");\n            }\n            // If poly is \"1 1111 0010 0101\" (version info poly), msbSetInPoly is 13. We'll subtract 1\n            // from 13 to make it 12.\n            const msbSetInPoly = MatrixUtil.findMSBSet(poly);\n            value <<= msbSetInPoly - 1;\n            // Do the division business using exclusive-or operations.\n            while(MatrixUtil.findMSBSet(value) >= msbSetInPoly){\n                value ^= poly << MatrixUtil.findMSBSet(value) - msbSetInPoly;\n            }\n            // Now the \"value\" is the remainder (i.e. the BCH code)\n            return value;\n        }\n        // Make bit vector of type information. On success, store the result in \"bits\" and return true.\n        // Encode error correction level and mask pattern. See 8.9 of\n        // JISX0510:2004 (p.45) for details.\n        static makeTypeInfoBits(ecLevel, maskPattern /*int*/ , bits) {\n            if (!QRCode.isValidMaskPattern(maskPattern)) {\n                throw new WriterException(\"Invalid mask pattern\");\n            }\n            const typeInfo = ecLevel.getBits() << 3 | maskPattern;\n            bits.appendBits(typeInfo, 5);\n            const bchCode = MatrixUtil.calculateBCHCode(typeInfo, MatrixUtil.TYPE_INFO_POLY);\n            bits.appendBits(bchCode, 10);\n            const maskBits = new BitArray();\n            maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN, 15);\n            bits.xor(maskBits);\n            if (bits.getSize() !== 15) {\n                throw new WriterException(\"should not happen but we got: \" + bits.getSize());\n            }\n        }\n        // Make bit vector of version information. On success, store the result in \"bits\" and return true.\n        // See 8.10 of JISX0510:2004 (p.45) for details.\n        static makeVersionInfoBits(version, bits) {\n            bits.appendBits(version.getVersionNumber(), 6);\n            const bchCode = MatrixUtil.calculateBCHCode(version.getVersionNumber(), MatrixUtil.VERSION_INFO_POLY);\n            bits.appendBits(bchCode, 12);\n            if (bits.getSize() !== 18) {\n                throw new WriterException(\"should not happen but we got: \" + bits.getSize());\n            }\n        }\n        // Check if \"value\" is empty.\n        static isEmpty(value /*int*/ ) {\n            return value === 255; // -1\n        }\n        static embedTimingPatterns(matrix) {\n            // -8 is for skipping position detection patterns (7: size), and two horizontal/vertical\n            // separation patterns (1: size). Thus, 8 = 7 + 1.\n            for(let i = 8; i < matrix.getWidth() - 8; ++i){\n                const bit = (i + 1) % 2;\n                // Horizontal line.\n                if (MatrixUtil.isEmpty(matrix.get(i, 6))) {\n                    matrix.setNumber(i, 6, bit);\n                }\n                // Vertical line.\n                if (MatrixUtil.isEmpty(matrix.get(6, i))) {\n                    matrix.setNumber(6, i, bit);\n                }\n            }\n        }\n        // Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)\n        static embedDarkDotAtLeftBottomCorner(matrix) {\n            if (matrix.get(8, matrix.getHeight() - 8) === 0) {\n                throw new WriterException();\n            }\n            matrix.setNumber(8, matrix.getHeight() - 8, 1);\n        }\n        static embedHorizontalSeparationPattern(xStart /*int*/ , yStart /*int*/ , matrix) {\n            for(let x = 0; x < 8; ++x){\n                if (!MatrixUtil.isEmpty(matrix.get(xStart + x, yStart))) {\n                    throw new WriterException();\n                }\n                matrix.setNumber(xStart + x, yStart, 0);\n            }\n        }\n        static embedVerticalSeparationPattern(xStart /*int*/ , yStart /*int*/ , matrix) {\n            for(let y = 0; y < 7; ++y){\n                if (!MatrixUtil.isEmpty(matrix.get(xStart, yStart + y))) {\n                    throw new WriterException();\n                }\n                matrix.setNumber(xStart, yStart + y, 0);\n            }\n        }\n        static embedPositionAdjustmentPattern(xStart /*int*/ , yStart /*int*/ , matrix) {\n            for(let y = 0; y < 5; ++y){\n                const patternY = MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y];\n                for(let x = 0; x < 5; ++x){\n                    matrix.setNumber(xStart + x, yStart + y, patternY[x]);\n                }\n            }\n        }\n        static embedPositionDetectionPattern(xStart /*int*/ , yStart /*int*/ , matrix) {\n            for(let y = 0; y < 7; ++y){\n                const patternY = MatrixUtil.POSITION_DETECTION_PATTERN[y];\n                for(let x = 0; x < 7; ++x){\n                    matrix.setNumber(xStart + x, yStart + y, patternY[x]);\n                }\n            }\n        }\n        // Embed position detection patterns and surrounding vertical/horizontal separators.\n        static embedPositionDetectionPatternsAndSeparators(matrix) {\n            // Embed three big squares at corners.\n            const pdpWidth = MatrixUtil.POSITION_DETECTION_PATTERN[0].length;\n            // Left top corner.\n            MatrixUtil.embedPositionDetectionPattern(0, 0, matrix);\n            // Right top corner.\n            MatrixUtil.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);\n            // Left bottom corner.\n            MatrixUtil.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);\n            // Embed horizontal separation patterns around the squares.\n            const hspWidth = 8;\n            // Left top corner.\n            MatrixUtil.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);\n            // Right top corner.\n            MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);\n            // Left bottom corner.\n            MatrixUtil.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);\n            // Embed vertical separation patterns around the squares.\n            const vspSize = 7;\n            // Left top corner.\n            MatrixUtil.embedVerticalSeparationPattern(vspSize, 0, matrix);\n            // Right top corner.\n            MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);\n            // Left bottom corner.\n            MatrixUtil.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);\n        }\n        // Embed position adjustment patterns if need be.\n        static maybeEmbedPositionAdjustmentPatterns(version, matrix) {\n            if (version.getVersionNumber() < 2) {\n                return;\n            }\n            const index = version.getVersionNumber() - 1;\n            const coordinates = MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];\n            for(let i = 0, length = coordinates.length; i !== length; i++){\n                const y = coordinates[i];\n                if (y >= 0) {\n                    for(let j = 0; j !== length; j++){\n                        const x = coordinates[j];\n                        if (x >= 0 && MatrixUtil.isEmpty(matrix.get(x, y))) {\n                            // If the cell is unset, we embed the position adjustment pattern here.\n                            // -2 is necessary since the x/y coordinates point to the center of the pattern, not the\n                            // left top corner.\n                            MatrixUtil.embedPositionAdjustmentPattern(x - 2, y - 2, matrix);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    MatrixUtil.POSITION_DETECTION_PATTERN = Array.from([\n        Int32Array.from([\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            0,\n            1,\n            1,\n            1,\n            0,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            0,\n            1,\n            1,\n            1,\n            0,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            0,\n            1,\n            1,\n            1,\n            0,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1\n        ])\n    ]);\n    MatrixUtil.POSITION_ADJUSTMENT_PATTERN = Array.from([\n        Int32Array.from([\n            1,\n            1,\n            1,\n            1,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            0,\n            0,\n            0,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            0,\n            1,\n            0,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            0,\n            0,\n            0,\n            1\n        ]),\n        Int32Array.from([\n            1,\n            1,\n            1,\n            1,\n            1\n        ])\n    ]);\n    // From Appendix E. Table 1, JIS0510X:2004 (71: p). The table was double-checked by komatsu.\n    MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([\n        Int32Array.from([\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            18,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            22,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            26,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            30,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            34,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            22,\n            38,\n            -1,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            24,\n            42,\n            -1,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            26,\n            46,\n            -1,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            28,\n            50,\n            -1,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            30,\n            54,\n            -1,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            32,\n            58,\n            -1,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            34,\n            62,\n            -1,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            26,\n            46,\n            66,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            26,\n            48,\n            70,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            26,\n            50,\n            74,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            30,\n            54,\n            78,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            30,\n            56,\n            82,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            30,\n            58,\n            86,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            34,\n            62,\n            90,\n            -1,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            28,\n            50,\n            72,\n            94,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            26,\n            50,\n            74,\n            98,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            30,\n            54,\n            78,\n            102,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            28,\n            54,\n            80,\n            106,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            32,\n            58,\n            84,\n            110,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            30,\n            58,\n            86,\n            114,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            34,\n            62,\n            90,\n            118,\n            -1,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            26,\n            50,\n            74,\n            98,\n            122,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            30,\n            54,\n            78,\n            102,\n            126,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            26,\n            52,\n            78,\n            104,\n            130,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            30,\n            56,\n            82,\n            108,\n            134,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            34,\n            60,\n            86,\n            112,\n            138,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            30,\n            58,\n            86,\n            114,\n            142,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            34,\n            62,\n            90,\n            118,\n            146,\n            -1\n        ]),\n        Int32Array.from([\n            6,\n            30,\n            54,\n            78,\n            102,\n            126,\n            150\n        ]),\n        Int32Array.from([\n            6,\n            24,\n            50,\n            76,\n            102,\n            128,\n            154\n        ]),\n        Int32Array.from([\n            6,\n            28,\n            54,\n            80,\n            106,\n            132,\n            158\n        ]),\n        Int32Array.from([\n            6,\n            32,\n            58,\n            84,\n            110,\n            136,\n            162\n        ]),\n        Int32Array.from([\n            6,\n            26,\n            54,\n            82,\n            110,\n            138,\n            166\n        ]),\n        Int32Array.from([\n            6,\n            30,\n            58,\n            86,\n            114,\n            142,\n            170\n        ])\n    ]);\n    // Type info cells at the left top corner.\n    MatrixUtil.TYPE_INFO_COORDINATES = Array.from([\n        Int32Array.from([\n            8,\n            0\n        ]),\n        Int32Array.from([\n            8,\n            1\n        ]),\n        Int32Array.from([\n            8,\n            2\n        ]),\n        Int32Array.from([\n            8,\n            3\n        ]),\n        Int32Array.from([\n            8,\n            4\n        ]),\n        Int32Array.from([\n            8,\n            5\n        ]),\n        Int32Array.from([\n            8,\n            7\n        ]),\n        Int32Array.from([\n            8,\n            8\n        ]),\n        Int32Array.from([\n            7,\n            8\n        ]),\n        Int32Array.from([\n            5,\n            8\n        ]),\n        Int32Array.from([\n            4,\n            8\n        ]),\n        Int32Array.from([\n            3,\n            8\n        ]),\n        Int32Array.from([\n            2,\n            8\n        ]),\n        Int32Array.from([\n            1,\n            8\n        ]),\n        Int32Array.from([\n            0,\n            8\n        ])\n    ]);\n    // From Appendix D in JISX0510:2004 (p. 67)\n    MatrixUtil.VERSION_INFO_POLY = 0x1f25; // 1 1111 0010 0101\n    // From Appendix C in JISX0510:2004 (p.65).\n    MatrixUtil.TYPE_INFO_POLY = 0x537;\n    MatrixUtil.TYPE_INFO_MASK_PATTERN = 0x5412;\n    /*namespace com.google.zxing.qrcode.encoder {*/ class BlockPair {\n        constructor(dataBytes, errorCorrectionBytes){\n            this.dataBytes = dataBytes;\n            this.errorCorrectionBytes = errorCorrectionBytes;\n        }\n        getDataBytes() {\n            return this.dataBytes;\n        }\n        getErrorCorrectionBytes() {\n            return this.errorCorrectionBytes;\n        }\n    }\n    /*import java.io.UnsupportedEncodingException;*/ /*import java.util.ArrayList;*/ /*import java.util.Collection;*/ /*import java.util.Map;*/ /**\n     * @author satorux@google.com (Satoru Takabayashi) - creator\n     * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n     */ class Encoder {\n        // TYPESCRIPTPORT: changed to UTF8, the default for js\n        constructor(){}\n        // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.\n        // Basically it applies four rules and summate all penalties.\n        static calculateMaskPenalty(matrix) {\n            return MaskUtil.applyMaskPenaltyRule1(matrix) + MaskUtil.applyMaskPenaltyRule2(matrix) + MaskUtil.applyMaskPenaltyRule3(matrix) + MaskUtil.applyMaskPenaltyRule4(matrix);\n        }\n        /**\n         * @param content text to encode\n         * @param ecLevel error correction level to use\n         * @return {@link QRCode} representing the encoded QR code\n         * @throws WriterException if encoding can't succeed, because of for example invalid content\n         *   or configuration\n         */ // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {\n        //   return encode(content, ecLevel, null)\n        // }\n        static encode(content, ecLevel, hints = null) {\n            // Determine what character encoding has been specified by the caller, if any\n            let encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;\n            const hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType$1.CHARACTER_SET);\n            if (hasEncodingHint) {\n                encoding = hints.get(EncodeHintType$1.CHARACTER_SET).toString();\n            }\n            // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n            // multiple modes / segments even if that were more efficient. Twould be nice.\n            const mode = this.chooseMode(content, encoding);\n            // This will store the header information, like mode and\n            // length, as well as \"header\" segments like an ECI segment.\n            const headerBits = new BitArray();\n            // Append ECI segment if applicable\n            if (mode === Mode$1.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {\n                const eci = CharacterSetECI.getCharacterSetECIByName(encoding);\n                if (eci !== undefined) {\n                    this.appendECI(eci, headerBits);\n                }\n            }\n            // (With ECI in place,) Write the mode marker\n            this.appendModeInfo(mode, headerBits);\n            // Collect data within the main segment, separately, to count its size if needed. Don't add it to\n            // main payload yet.\n            const dataBits = new BitArray();\n            this.appendBytes(content, mode, dataBits, encoding);\n            let version;\n            if (hints !== null && undefined !== hints.get(EncodeHintType$1.QR_VERSION)) {\n                const versionNumber = Number.parseInt(hints.get(EncodeHintType$1.QR_VERSION).toString(), 10);\n                version = Version$1.getVersionForNumber(versionNumber);\n                const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);\n                if (!this.willFit(bitsNeeded, version, ecLevel)) {\n                    throw new WriterException(\"Data too big for requested version\");\n                }\n            } else {\n                version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);\n            }\n            const headerAndDataBits = new BitArray();\n            headerAndDataBits.appendBitArray(headerBits);\n            // Find \"length\" of main segment and write it\n            const numLetters = mode === Mode$1.BYTE ? dataBits.getSizeInBytes() : content.length;\n            this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);\n            // Put data together into the overall payload\n            headerAndDataBits.appendBitArray(dataBits);\n            const ecBlocks = version.getECBlocksForLevel(ecLevel);\n            const numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();\n            // Terminate the bits properly.\n            this.terminateBits(numDataBytes, headerAndDataBits);\n            // Interleave data bits with error correction code.\n            const finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());\n            const qrCode = new QRCode();\n            qrCode.setECLevel(ecLevel);\n            qrCode.setMode(mode);\n            qrCode.setVersion(version);\n            //  Choose the mask pattern and set to \"qrCode\".\n            const dimension = version.getDimensionForVersion();\n            const matrix = new ByteMatrix(dimension, dimension);\n            const maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);\n            qrCode.setMaskPattern(maskPattern);\n            // Build the matrix and set it to \"qrCode\".\n            MatrixUtil.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);\n            qrCode.setMatrix(matrix);\n            return qrCode;\n        }\n        /**\n         * Decides the smallest version of QR code that will contain all of the provided data.\n         *\n         * @throws WriterException if the data cannot fit in any version\n         */ static recommendVersion(ecLevel, mode, headerBits, dataBits) {\n            // Hard part: need to know version to know how many bits length takes. But need to know how many\n            // bits it takes to know version. First we take a guess at version by assuming version will be\n            // the minimum, 1:\n            const provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version$1.getVersionForNumber(1));\n            const provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);\n            // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.\n            const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);\n            return this.chooseVersion(bitsNeeded, ecLevel);\n        }\n        static calculateBitsNeeded(mode, headerBits, dataBits, version) {\n            return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();\n        }\n        /**\n         * @return the code point of the table used in alphanumeric mode or\n         *  -1 if there is no corresponding code in the table.\n         */ static getAlphanumericCode(code /*int*/ ) {\n            if (code < Encoder.ALPHANUMERIC_TABLE.length) {\n                return Encoder.ALPHANUMERIC_TABLE[code];\n            }\n            return -1;\n        }\n        // public static chooseMode(content: string): Mode {\n        //   return chooseMode(content, null);\n        // }\n        /**\n         * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;\n         * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.\n         */ static chooseMode(content, encoding = null) {\n            if (CharacterSetECI.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {\n                // Choose Kanji mode if all input are double-byte characters\n                return Mode$1.KANJI;\n            }\n            let hasNumeric = false;\n            let hasAlphanumeric = false;\n            for(let i = 0, length = content.length; i < length; ++i){\n                const c = content.charAt(i);\n                if (Encoder.isDigit(c)) {\n                    hasNumeric = true;\n                } else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {\n                    hasAlphanumeric = true;\n                } else {\n                    return Mode$1.BYTE;\n                }\n            }\n            if (hasAlphanumeric) {\n                return Mode$1.ALPHANUMERIC;\n            }\n            if (hasNumeric) {\n                return Mode$1.NUMERIC;\n            }\n            return Mode$1.BYTE;\n        }\n        static isOnlyDoubleByteKanji(content) {\n            let bytes;\n            try {\n                bytes = StringEncoding.encode(content, CharacterSetECI.SJIS); // content.getBytes(\"Shift_JIS\"))\n            } catch (ignored /*: UnsupportedEncodingException*/ ) {\n                return false;\n            }\n            const length = bytes.length;\n            if (length % 2 !== 0) {\n                return false;\n            }\n            for(let i = 0; i < length; i += 2){\n                const byte1 = bytes[i] & 0xFF;\n                if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static chooseMaskPattern(bits, ecLevel, version, matrix) {\n            let minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.\n            let bestMaskPattern = -1;\n            // We try all mask patterns to choose the best one.\n            for(let maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++){\n                MatrixUtil.buildMatrix(bits, ecLevel, version, maskPattern, matrix);\n                let penalty = this.calculateMaskPenalty(matrix);\n                if (penalty < minPenalty) {\n                    minPenalty = penalty;\n                    bestMaskPattern = maskPattern;\n                }\n            }\n            return bestMaskPattern;\n        }\n        static chooseVersion(numInputBits /*int*/ , ecLevel) {\n            for(let versionNum = 1; versionNum <= 40; versionNum++){\n                const version = Version$1.getVersionForNumber(versionNum);\n                if (Encoder.willFit(numInputBits, version, ecLevel)) {\n                    return version;\n                }\n            }\n            throw new WriterException(\"Data too big\");\n        }\n        /**\n         * @return true if the number of input bits will fit in a code with the specified version and\n         * error correction level.\n         */ static willFit(numInputBits /*int*/ , version, ecLevel) {\n            // In the following comments, we use numbers of Version 7-H.\n            // numBytes = 196\n            const numBytes = version.getTotalCodewords();\n            // getNumECBytes = 130\n            const ecBlocks = version.getECBlocksForLevel(ecLevel);\n            const numEcBytes = ecBlocks.getTotalECCodewords();\n            // getNumDataBytes = 196 - 130 = 66\n            const numDataBytes = numBytes - numEcBytes;\n            const totalInputBytes = (numInputBits + 7) / 8;\n            return numDataBytes >= totalInputBytes;\n        }\n        /**\n         * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).\n         */ static terminateBits(numDataBytes /*int*/ , bits) {\n            const capacity = numDataBytes * 8;\n            if (bits.getSize() > capacity) {\n                throw new WriterException(\"data bits cannot fit in the QR Code\" + bits.getSize() + \" > \" + capacity);\n            }\n            for(let i = 0; i < 4 && bits.getSize() < capacity; ++i){\n                bits.appendBit(false);\n            }\n            // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.\n            // If the last byte isn't 8-bit aligned, we'll add padding bits.\n            const numBitsInLastByte = bits.getSize() & 0x07;\n            if (numBitsInLastByte > 0) {\n                for(let i = numBitsInLastByte; i < 8; i++){\n                    bits.appendBit(false);\n                }\n            }\n            // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).\n            const numPaddingBytes = numDataBytes - bits.getSizeInBytes();\n            for(let i = 0; i < numPaddingBytes; ++i){\n                bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);\n            }\n            if (bits.getSize() !== capacity) {\n                throw new WriterException(\"Bits size does not equal capacity\");\n            }\n        }\n        /**\n         * Get number of data bytes and number of error correction bytes for block id \"blockID\". Store\n         * the result in \"numDataBytesInBlock\", and \"numECBytesInBlock\". See table 12 in 8.5.1 of\n         * JISX0510:2004 (p.30)\n         */ static getNumDataBytesAndNumECBytesForBlockID(numTotalBytes /*int*/ , numDataBytes /*int*/ , numRSBlocks /*int*/ , blockID /*int*/ , numDataBytesInBlock, numECBytesInBlock) {\n            if (blockID >= numRSBlocks) {\n                throw new WriterException(\"Block ID too large\");\n            }\n            // numRsBlocksInGroup2 = 196 % 5 = 1\n            const numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;\n            // numRsBlocksInGroup1 = 5 - 1 = 4\n            const numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;\n            // numTotalBytesInGroup1 = 196 / 5 = 39\n            const numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);\n            // numTotalBytesInGroup2 = 39 + 1 = 40\n            const numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;\n            // numDataBytesInGroup1 = 66 / 5 = 13\n            const numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);\n            // numDataBytesInGroup2 = 13 + 1 = 14\n            const numDataBytesInGroup2 = numDataBytesInGroup1 + 1;\n            // numEcBytesInGroup1 = 39 - 13 = 26\n            const numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;\n            // numEcBytesInGroup2 = 40 - 14 = 26\n            const numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;\n            // Sanity checks.\n            // 26 = 26\n            if (numEcBytesInGroup1 !== numEcBytesInGroup2) {\n                throw new WriterException(\"EC bytes mismatch\");\n            }\n            // 5 = 4 + 1.\n            if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {\n                throw new WriterException(\"RS blocks mismatch\");\n            }\n            // 196 = (13 + 26) * 4 + (14 + 26) * 1\n            if (numTotalBytes !== (numDataBytesInGroup1 + numEcBytesInGroup1) * numRsBlocksInGroup1 + (numDataBytesInGroup2 + numEcBytesInGroup2) * numRsBlocksInGroup2) {\n                throw new WriterException(\"Total bytes mismatch\");\n            }\n            if (blockID < numRsBlocksInGroup1) {\n                numDataBytesInBlock[0] = numDataBytesInGroup1;\n                numECBytesInBlock[0] = numEcBytesInGroup1;\n            } else {\n                numDataBytesInBlock[0] = numDataBytesInGroup2;\n                numECBytesInBlock[0] = numEcBytesInGroup2;\n            }\n        }\n        /**\n         * Interleave \"bits\" with corresponding error correction bytes. On success, store the result in\n         * \"result\". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.\n         */ static interleaveWithECBytes(bits, numTotalBytes /*int*/ , numDataBytes /*int*/ , numRSBlocks /*int*/ ) {\n            // \"bits\" must have \"getNumDataBytes\" bytes of data.\n            if (bits.getSizeInBytes() !== numDataBytes) {\n                throw new WriterException(\"Number of bits and data bytes does not match\");\n            }\n            // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll\n            // store the divided data bytes blocks and error correction bytes blocks into \"blocks\".\n            let dataBytesOffset = 0;\n            let maxNumDataBytes = 0;\n            let maxNumEcBytes = 0;\n            // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.\n            const blocks = new Array(); // new Array<BlockPair>(numRSBlocks)\n            for(let i = 0; i < numRSBlocks; ++i){\n                const numDataBytesInBlock = new Int32Array(1);\n                const numEcBytesInBlock = new Int32Array(1);\n                Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);\n                const size = numDataBytesInBlock[0];\n                const dataBytes = new Uint8Array(size);\n                bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);\n                const ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);\n                blocks.push(new BlockPair(dataBytes, ecBytes));\n                maxNumDataBytes = Math.max(maxNumDataBytes, size);\n                maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);\n                dataBytesOffset += numDataBytesInBlock[0];\n            }\n            if (numDataBytes !== dataBytesOffset) {\n                throw new WriterException(\"Data bytes does not match offset\");\n            }\n            const result = new BitArray();\n            // First, place data blocks.\n            for(let i = 0; i < maxNumDataBytes; ++i){\n                for (const block of blocks){\n                    const dataBytes = block.getDataBytes();\n                    if (i < dataBytes.length) {\n                        result.appendBits(dataBytes[i], 8);\n                    }\n                }\n            }\n            // Then, place error correction blocks.\n            for(let i = 0; i < maxNumEcBytes; ++i){\n                for (const block of blocks){\n                    const ecBytes = block.getErrorCorrectionBytes();\n                    if (i < ecBytes.length) {\n                        result.appendBits(ecBytes[i], 8);\n                    }\n                }\n            }\n            if (numTotalBytes !== result.getSizeInBytes()) {\n                throw new WriterException(\"Interleaving error: \" + numTotalBytes + \" and \" + result.getSizeInBytes() + \" differ.\");\n            }\n            return result;\n        }\n        static generateECBytes(dataBytes, numEcBytesInBlock /*int*/ ) {\n            const numDataBytes = dataBytes.length;\n            const toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock]\n            for(let i = 0; i < numDataBytes; i++){\n                toEncode[i] = dataBytes[i] & 0xFF;\n            }\n            new ReedSolomonEncoder(GenericGF.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);\n            const ecBytes = new Uint8Array(numEcBytesInBlock);\n            for(let i = 0; i < numEcBytesInBlock; i++){\n                ecBytes[i] = /*(byte) */ toEncode[numDataBytes + i];\n            }\n            return ecBytes;\n        }\n        /**\n         * Append mode info. On success, store the result in \"bits\".\n         */ static appendModeInfo(mode, bits) {\n            bits.appendBits(mode.getBits(), 4);\n        }\n        /**\n         * Append length info. On success, store the result in \"bits\".\n         */ static appendLengthInfo(numLetters /*int*/ , version, mode, bits) {\n            const numBits = mode.getCharacterCountBits(version);\n            if (numLetters >= 1 << numBits) {\n                throw new WriterException(numLetters + \" is bigger than \" + ((1 << numBits) - 1));\n            }\n            bits.appendBits(numLetters, numBits);\n        }\n        /**\n         * Append \"bytes\" in \"mode\" mode (encoding) into \"bits\". On success, store the result in \"bits\".\n         */ static appendBytes(content, mode, bits, encoding) {\n            switch(mode){\n                case Mode$1.NUMERIC:\n                    Encoder.appendNumericBytes(content, bits);\n                    break;\n                case Mode$1.ALPHANUMERIC:\n                    Encoder.appendAlphanumericBytes(content, bits);\n                    break;\n                case Mode$1.BYTE:\n                    Encoder.append8BitBytes(content, bits, encoding);\n                    break;\n                case Mode$1.KANJI:\n                    Encoder.appendKanjiBytes(content, bits);\n                    break;\n                default:\n                    throw new WriterException(\"Invalid mode: \" + mode);\n            }\n        }\n        static getDigit(singleCharacter) {\n            return singleCharacter.charCodeAt(0) - 48;\n        }\n        static isDigit(singleCharacter) {\n            const cn = Encoder.getDigit(singleCharacter);\n            return cn >= 0 && cn <= 9;\n        }\n        static appendNumericBytes(content, bits) {\n            const length = content.length;\n            let i = 0;\n            while(i < length){\n                const num1 = Encoder.getDigit(content.charAt(i));\n                if (i + 2 < length) {\n                    // Encode three numeric letters in ten bits.\n                    const num2 = Encoder.getDigit(content.charAt(i + 1));\n                    const num3 = Encoder.getDigit(content.charAt(i + 2));\n                    bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);\n                    i += 3;\n                } else if (i + 1 < length) {\n                    // Encode two numeric letters in seven bits.\n                    const num2 = Encoder.getDigit(content.charAt(i + 1));\n                    bits.appendBits(num1 * 10 + num2, 7);\n                    i += 2;\n                } else {\n                    // Encode one numeric letter in four bits.\n                    bits.appendBits(num1, 4);\n                    i++;\n                }\n            }\n        }\n        static appendAlphanumericBytes(content, bits) {\n            const length = content.length;\n            let i = 0;\n            while(i < length){\n                const code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));\n                if (code1 === -1) {\n                    throw new WriterException();\n                }\n                if (i + 1 < length) {\n                    const code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));\n                    if (code2 === -1) {\n                        throw new WriterException();\n                    }\n                    // Encode two alphanumeric letters in 11 bits.\n                    bits.appendBits(code1 * 45 + code2, 11);\n                    i += 2;\n                } else {\n                    // Encode one alphanumeric letter in six bits.\n                    bits.appendBits(code1, 6);\n                    i++;\n                }\n            }\n        }\n        static append8BitBytes(content, bits, encoding) {\n            let bytes;\n            try {\n                bytes = StringEncoding.encode(content, encoding);\n            } catch (uee /*: UnsupportedEncodingException*/ ) {\n                throw new WriterException(uee);\n            }\n            for(let i = 0, length = bytes.length; i !== length; i++){\n                const b = bytes[i];\n                bits.appendBits(b, 8);\n            }\n        }\n        /**\n         * @throws WriterException\n         */ static appendKanjiBytes(content, bits) {\n            let bytes;\n            try {\n                bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);\n            } catch (uee /*: UnsupportedEncodingException*/ ) {\n                throw new WriterException(uee);\n            }\n            const length = bytes.length;\n            for(let i = 0; i < length; i += 2){\n                const byte1 = bytes[i] & 0xFF;\n                const byte2 = bytes[i + 1] & 0xFF;\n                const code = byte1 << 8 & 0xFFFFFFFF | byte2;\n                let subtracted = -1;\n                if (code >= 0x8140 && code <= 0x9ffc) {\n                    subtracted = code - 0x8140;\n                } else if (code >= 0xe040 && code <= 0xebbf) {\n                    subtracted = code - 0xc140;\n                }\n                if (subtracted === -1) {\n                    throw new WriterException(\"Invalid byte sequence\");\n                }\n                const encoded = (subtracted >> 8) * 0xc0 + (subtracted & 0xff);\n                bits.appendBits(encoded, 13);\n            }\n        }\n        static appendECI(eci, bits) {\n            bits.appendBits(Mode$1.ECI.getBits(), 4);\n            // This is correct for values up to 127, which is all we need now.\n            bits.appendBits(eci.getValue(), 8);\n        }\n    }\n    // The original table is defined in the table 5 of JISX0510:2004 (p.19).\n    Encoder.ALPHANUMERIC_TABLE = Int32Array.from([\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        36,\n        -1,\n        -1,\n        -1,\n        37,\n        38,\n        -1,\n        -1,\n        -1,\n        -1,\n        39,\n        40,\n        -1,\n        41,\n        42,\n        43,\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        44,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        10,\n        11,\n        12,\n        13,\n        14,\n        15,\n        16,\n        17,\n        18,\n        19,\n        20,\n        21,\n        22,\n        23,\n        24,\n        25,\n        26,\n        27,\n        28,\n        29,\n        30,\n        31,\n        32,\n        33,\n        34,\n        35,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1\n    ]);\n    Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI.UTF8.getName(); // \"ISO-8859-1\"\n    /**\n     * @deprecated Moving to @zxing/browser\n     */ class BrowserQRCodeSvgWriter {\n        /**\n         * Writes and renders a QRCode SVG element.\n         *\n         * @param contents\n         * @param width\n         * @param height\n         * @param hints\n         */ write(contents, width, height, hints = null) {\n            if (contents.length === 0) {\n                throw new IllegalArgumentException(\"Found empty contents\");\n            }\n            // if (format != BarcodeFormat.QR_CODE) {\n            //   throw new IllegalArgumentException(\"Can only encode QR_CODE, but got \" + format)\n            // }\n            if (width < 0 || height < 0) {\n                throw new IllegalArgumentException(\"Requested dimensions are too small: \" + width + \"x\" + height);\n            }\n            let errorCorrectionLevel = ErrorCorrectionLevel.L;\n            let quietZone = BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;\n            if (hints !== null) {\n                if (undefined !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {\n                    errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());\n                }\n                if (undefined !== hints.get(EncodeHintType$1.MARGIN)) {\n                    quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);\n                }\n            }\n            const code = Encoder.encode(contents, errorCorrectionLevel, hints);\n            return this.renderResult(code, width, height, quietZone);\n        }\n        /**\n         * Renders the result and then appends it to the DOM.\n         */ writeToDom(containerElement, contents, width, height, hints = null) {\n            if (typeof containerElement === \"string\") {\n                containerElement = document.querySelector(containerElement);\n            }\n            const svgElement = this.write(contents, width, height, hints);\n            if (containerElement) containerElement.appendChild(svgElement);\n        }\n        /**\n         * Note that the input matrix uses 0 == white, 1 == black.\n         * The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n         */ renderResult(code, width /*int*/ , height /*int*/ , quietZone /*int*/ ) {\n            const input = code.getMatrix();\n            if (input === null) {\n                throw new IllegalStateException();\n            }\n            const inputWidth = input.getWidth();\n            const inputHeight = input.getHeight();\n            const qrWidth = inputWidth + quietZone * 2;\n            const qrHeight = inputHeight + quietZone * 2;\n            const outputWidth = Math.max(width, qrWidth);\n            const outputHeight = Math.max(height, qrHeight);\n            const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));\n            // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n            // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n            // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n            // handle all the padding from 100x100 (the actual QR) up to 200x160.\n            const leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);\n            const topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);\n            const svgElement = this.createSVGElement(outputWidth, outputHeight);\n            for(let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple){\n                // Write the contents of this row of the barcode\n                for(let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple){\n                    if (input.get(inputX, inputY) === 1) {\n                        const svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);\n                        svgElement.appendChild(svgRectElement);\n                    }\n                }\n            }\n            return svgElement;\n        }\n        /**\n         * Creates a SVG element.\n         *\n         * @param w SVG's width attribute\n         * @param h SVG's height attribute\n         */ createSVGElement(w, h) {\n            const svgElement = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, \"svg\");\n            svgElement.setAttributeNS(null, \"height\", w.toString());\n            svgElement.setAttributeNS(null, \"width\", h.toString());\n            return svgElement;\n        }\n        /**\n         * Creates a SVG rect element.\n         *\n         * @param x Element's x coordinate\n         * @param y Element's y coordinate\n         * @param w Element's width attribute\n         * @param h Element's height attribute\n         */ createSvgRectElement(x, y, w, h) {\n            const rect = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, \"rect\");\n            rect.setAttributeNS(null, \"x\", x.toString());\n            rect.setAttributeNS(null, \"y\", y.toString());\n            rect.setAttributeNS(null, \"height\", w.toString());\n            rect.setAttributeNS(null, \"width\", h.toString());\n            rect.setAttributeNS(null, \"fill\", \"#000000\");\n            return rect;\n        }\n    }\n    BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE = 4;\n    /**\n     * SVG markup NameSpace\n     */ BrowserQRCodeSvgWriter.SVG_NS = \"http://www.w3.org/2000/svg\";\n    /*import java.util.Map;*/ /**\n     * This object renders a QR Code as a BitMatrix 2D array of greyscale values.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */ class QRCodeWriter {\n        /*@Override*/ // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix\n        //     /*throws WriterException */ {\n        //   return encode(contents, format, width, height, null)\n        // }\n        /*@Override*/ encode(contents, format, width /*int*/ , height /*int*/ , hints) {\n            if (contents.length === 0) {\n                throw new IllegalArgumentException(\"Found empty contents\");\n            }\n            if (format !== BarcodeFormat$1.QR_CODE) {\n                throw new IllegalArgumentException(\"Can only encode QR_CODE, but got \" + format);\n            }\n            if (width < 0 || height < 0) {\n                throw new IllegalArgumentException(`Requested dimensions are too small: ${width}x${height}`);\n            }\n            let errorCorrectionLevel = ErrorCorrectionLevel.L;\n            let quietZone = QRCodeWriter.QUIET_ZONE_SIZE;\n            if (hints !== null) {\n                if (undefined !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {\n                    errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());\n                }\n                if (undefined !== hints.get(EncodeHintType$1.MARGIN)) {\n                    quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);\n                }\n            }\n            const code = Encoder.encode(contents, errorCorrectionLevel, hints);\n            return QRCodeWriter.renderResult(code, width, height, quietZone);\n        }\n        // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses\n        // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n        static renderResult(code, width /*int*/ , height /*int*/ , quietZone /*int*/ ) {\n            const input = code.getMatrix();\n            if (input === null) {\n                throw new IllegalStateException();\n            }\n            const inputWidth = input.getWidth();\n            const inputHeight = input.getHeight();\n            const qrWidth = inputWidth + quietZone * 2;\n            const qrHeight = inputHeight + quietZone * 2;\n            const outputWidth = Math.max(width, qrWidth);\n            const outputHeight = Math.max(height, qrHeight);\n            const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));\n            // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n            // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n            // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n            // handle all the padding from 100x100 (the actual QR) up to 200x160.\n            const leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);\n            const topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);\n            const output = new BitMatrix(outputWidth, outputHeight);\n            for(let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple){\n                // Write the contents of this row of the barcode\n                for(let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple){\n                    if (input.get(inputX, inputY) === 1) {\n                        output.setRegion(outputX, outputY, multiple, multiple);\n                    }\n                }\n            }\n            return output;\n        }\n    }\n    QRCodeWriter.QUIET_ZONE_SIZE = 4;\n    /*import java.util.Map;*/ /**\n     * This is a factory class which finds the appropriate Writer subclass for the BarcodeFormat\n     * requested and encodes the barcode with the supplied contents.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */ class MultiFormatWriter {\n        /*@Override*/ // public encode(contents: string,\n        //                         format: BarcodeFormat,\n        //                         width: number /*int*/,\n        //                         height: number /*int*/): BitMatrix /*throws WriterException */ {\n        //   return encode(contents, format, width, height, null)\n        // }\n        /*@Override*/ encode(contents, format, width /*int*/ , height /*int*/ , hints) {\n            let writer;\n            switch(format){\n                // case BarcodeFormat.EAN_8:\n                //   writer = new EAN8Writer()\n                //   break\n                // case BarcodeFormat.UPC_E:\n                //   writer = new UPCEWriter()\n                //   break\n                // case BarcodeFormat.EAN_13:\n                //   writer = new EAN13Writer()\n                //   break\n                // case BarcodeFormat.UPC_A:\n                //   writer = new UPCAWriter()\n                //   break\n                case BarcodeFormat$1.QR_CODE:\n                    writer = new QRCodeWriter();\n                    break;\n                // case BarcodeFormat.CODE_39:\n                //   writer = new Code39Writer()\n                //   break\n                // case BarcodeFormat.CODE_93:\n                //   writer = new Code93Writer()\n                //   break\n                // case BarcodeFormat.CODE_128:\n                //   writer = new Code128Writer()\n                //   break\n                // case BarcodeFormat.ITF:\n                //   writer = new ITFWriter()\n                //   break\n                // case BarcodeFormat.PDF_417:\n                //   writer = new PDF417Writer()\n                //   break\n                // case BarcodeFormat.CODABAR:\n                //   writer = new CodaBarWriter()\n                //   break\n                // case BarcodeFormat.DATA_MATRIX:\n                //   writer = new DataMatrixWriter()\n                //   break\n                // case BarcodeFormat.AZTEC:\n                //   writer = new AztecWriter()\n                //   break\n                default:\n                    throw new IllegalArgumentException(\"No encoder available for format \" + format);\n            }\n            return writer.encode(contents, format, width, height, hints);\n        }\n    }\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * This object extends LuminanceSource around an array of YUV data returned from the camera driver,\n     * with the option to crop to a rectangle within the full data. This can be used to exclude\n     * superfluous pixels around the perimeter and speed up decoding.\n     *\n     * It works for any pixel format where the Y channel is planar and appears first, including\n     * YCbCr_420_SP and YCbCr_422_SP.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */ class PlanarYUVLuminanceSource extends LuminanceSource {\n        constructor(yuvData, dataWidth /*int*/ , dataHeight /*int*/ , left /*int*/ , top /*int*/ , width /*int*/ , height /*int*/ , reverseHorizontal){\n            super(width, height);\n            this.yuvData = yuvData;\n            this.dataWidth = dataWidth;\n            this.dataHeight = dataHeight;\n            this.left = left;\n            this.top = top;\n            if (left + width > dataWidth || top + height > dataHeight) {\n                throw new IllegalArgumentException(\"Crop rectangle does not fit within image data.\");\n            }\n            if (reverseHorizontal) {\n                this.reverseHorizontal(width, height);\n            }\n        }\n        /*@Override*/ getRow(y /*int*/ , row) {\n            if (y < 0 || y >= this.getHeight()) {\n                throw new IllegalArgumentException(\"Requested row is outside the image: \" + y);\n            }\n            const width = this.getWidth();\n            if (row === null || row === undefined || row.length < width) {\n                row = new Uint8ClampedArray(width);\n            }\n            const offset = (y + this.top) * this.dataWidth + this.left;\n            System.arraycopy(this.yuvData, offset, row, 0, width);\n            return row;\n        }\n        /*@Override*/ getMatrix() {\n            const width = this.getWidth();\n            const height = this.getHeight();\n            // If the caller asks for the entire underlying image, save the copy and give them the\n            // original data. The docs specifically warn that result.length must be ignored.\n            if (width === this.dataWidth && height === this.dataHeight) {\n                return this.yuvData;\n            }\n            const area = width * height;\n            const matrix = new Uint8ClampedArray(area);\n            let inputOffset = this.top * this.dataWidth + this.left;\n            // If the width matches the full width of the underlying data, perform a single copy.\n            if (width === this.dataWidth) {\n                System.arraycopy(this.yuvData, inputOffset, matrix, 0, area);\n                return matrix;\n            }\n            // Otherwise copy one cropped row at a time.\n            for(let y = 0; y < height; y++){\n                const outputOffset = y * width;\n                System.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);\n                inputOffset += this.dataWidth;\n            }\n            return matrix;\n        }\n        /*@Override*/ isCropSupported() {\n            return true;\n        }\n        /*@Override*/ crop(left /*int*/ , top /*int*/ , width /*int*/ , height /*int*/ ) {\n            return new PlanarYUVLuminanceSource(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);\n        }\n        renderThumbnail() {\n            const width = this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n            const height = this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n            const pixels = new Int32Array(width * height);\n            const yuv = this.yuvData;\n            let inputOffset = this.top * this.dataWidth + this.left;\n            for(let y = 0; y < height; y++){\n                const outputOffset = y * width;\n                for(let x = 0; x < width; x++){\n                    const grey = yuv[inputOffset + x * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR] & 0xff;\n                    pixels[outputOffset + x] = 0xFF000000 | grey * 0x00010101;\n                }\n                inputOffset += this.dataWidth * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n            }\n            return pixels;\n        }\n        /**\n         * @return width of image from {@link #renderThumbnail()}\n         */ getThumbnailWidth() {\n            return this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n        }\n        /**\n         * @return height of image from {@link #renderThumbnail()}\n         */ getThumbnailHeight() {\n            return this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n        }\n        reverseHorizontal(width /*int*/ , height /*int*/ ) {\n            const yuvData = this.yuvData;\n            for(let y = 0, rowStart = this.top * this.dataWidth + this.left; y < height; y++, rowStart += this.dataWidth){\n                const middle = rowStart + width / 2;\n                for(let x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--){\n                    const temp = yuvData[x1];\n                    yuvData[x1] = yuvData[x2];\n                    yuvData[x2] = temp;\n                }\n            }\n        }\n        invert() {\n            return new InvertedLuminanceSource(this);\n        }\n    }\n    PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR = 2;\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * This class is used to help decode images from files which arrive as RGB data from\n     * an ARGB pixel array. It does not support rotation.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Betaminos\n     */ class RGBLuminanceSource extends LuminanceSource {\n        constructor(luminances, width /*int*/ , height /*int*/ , dataWidth /*int*/ , dataHeight /*int*/ , left /*int*/ , top /*int*/ ){\n            super(width, height);\n            this.dataWidth = dataWidth;\n            this.dataHeight = dataHeight;\n            this.left = left;\n            this.top = top;\n            if (luminances.BYTES_PER_ELEMENT === 4) {\n                const size = width * height;\n                const luminancesUint8Array = new Uint8ClampedArray(size);\n                for(let offset = 0; offset < size; offset++){\n                    const pixel = luminances[offset];\n                    const r = pixel >> 16 & 0xff; // red\n                    const g2 = pixel >> 7 & 0x1fe; // 2 * green\n                    const b = pixel & 0xff; // blue\n                    // Calculate green-favouring average cheaply\n                    luminancesUint8Array[offset] = (r + g2 + b) / 4 & 0xFF;\n                }\n                this.luminances = luminancesUint8Array;\n            } else {\n                this.luminances = luminances;\n            }\n            if (undefined === dataWidth) {\n                this.dataWidth = width;\n            }\n            if (undefined === dataHeight) {\n                this.dataHeight = height;\n            }\n            if (undefined === left) {\n                this.left = 0;\n            }\n            if (undefined === top) {\n                this.top = 0;\n            }\n            if (this.left + width > this.dataWidth || this.top + height > this.dataHeight) {\n                throw new IllegalArgumentException(\"Crop rectangle does not fit within image data.\");\n            }\n        }\n        /*@Override*/ getRow(y /*int*/ , row) {\n            if (y < 0 || y >= this.getHeight()) {\n                throw new IllegalArgumentException(\"Requested row is outside the image: \" + y);\n            }\n            const width = this.getWidth();\n            if (row === null || row === undefined || row.length < width) {\n                row = new Uint8ClampedArray(width);\n            }\n            const offset = (y + this.top) * this.dataWidth + this.left;\n            System.arraycopy(this.luminances, offset, row, 0, width);\n            return row;\n        }\n        /*@Override*/ getMatrix() {\n            const width = this.getWidth();\n            const height = this.getHeight();\n            // If the caller asks for the entire underlying image, save the copy and give them the\n            // original data. The docs specifically warn that result.length must be ignored.\n            if (width === this.dataWidth && height === this.dataHeight) {\n                return this.luminances;\n            }\n            const area = width * height;\n            const matrix = new Uint8ClampedArray(area);\n            let inputOffset = this.top * this.dataWidth + this.left;\n            // If the width matches the full width of the underlying data, perform a single copy.\n            if (width === this.dataWidth) {\n                System.arraycopy(this.luminances, inputOffset, matrix, 0, area);\n                return matrix;\n            }\n            // Otherwise copy one cropped row at a time.\n            for(let y = 0; y < height; y++){\n                const outputOffset = y * width;\n                System.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);\n                inputOffset += this.dataWidth;\n            }\n            return matrix;\n        }\n        /*@Override*/ isCropSupported() {\n            return true;\n        }\n        /*@Override*/ crop(left /*int*/ , top /*int*/ , width /*int*/ , height /*int*/ ) {\n            return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);\n        }\n        invert() {\n            return new InvertedLuminanceSource(this);\n        }\n    }\n    /**\n     * Just to make a shortcut between Java code and TS code.\n     */ class Charset extends CharacterSetECI {\n        static forName(name) {\n            return this.getCharacterSetECIByName(name);\n        }\n    }\n    /**\n     * Just to make a shortcut between Java code and TS code.\n     */ class StandardCharsets {\n    }\n    StandardCharsets.ISO_8859_1 = CharacterSetECI.ISO8859_1;\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */ /**\n     * Aztec 2D code representation\n     *\n     * @author Rustam Abdullaev\n     */ /*public final*/ class AztecCode {\n        /**\n         * @return {@code true} if compact instead of full mode\n         */ isCompact() {\n            return this.compact;\n        }\n        setCompact(compact) {\n            this.compact = compact;\n        }\n        /**\n         * @return size in pixels (width and height)\n         */ getSize() {\n            return this.size;\n        }\n        setSize(size) {\n            this.size = size;\n        }\n        /**\n         * @return number of levels\n         */ getLayers() {\n            return this.layers;\n        }\n        setLayers(layers) {\n            this.layers = layers;\n        }\n        /**\n         * @return number of data codewords\n         */ getCodeWords() {\n            return this.codeWords;\n        }\n        setCodeWords(codeWords) {\n            this.codeWords = codeWords;\n        }\n        /**\n         * @return the symbol image\n         */ getMatrix() {\n            return this.matrix;\n        }\n        setMatrix(matrix) {\n            this.matrix = matrix;\n        }\n    }\n    class Collections {\n        /**\n         * The singletonList(T) method is used to return an immutable list containing only the specified object.\n         */ static singletonList(item) {\n            return [\n                item\n            ];\n        }\n        /**\n         * The min(Collection<? extends T>, Comparator<? super T>) method is used to return the minimum element of the given collection, according to the order induced by the specified comparator.\n         */ static min(collection, comparator) {\n            return collection.sort(comparator)[0];\n        }\n    }\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */ class Token {\n        constructor(previous){\n            this.previous = previous;\n        }\n        getPrevious() {\n            return this.previous;\n        }\n    }\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */ /*final*/ class SimpleToken extends Token {\n        constructor(previous, value, bitCount){\n            super(previous);\n            this.value = value;\n            this.bitCount = bitCount;\n        }\n        /**\n         * @Override\n         */ appendTo(bitArray, text) {\n            bitArray.appendBits(this.value, this.bitCount);\n        }\n        add(value, bitCount) {\n            return new SimpleToken(this, value, bitCount);\n        }\n        addBinaryShift(start, byteCount) {\n            // no-op can't binary shift a simple token\n            console.warn(\"addBinaryShift on SimpleToken, this simply returns a copy of this token\");\n            return new SimpleToken(this, start, byteCount);\n        }\n        /**\n         * @Override\n         */ toString() {\n            let value = this.value & (1 << this.bitCount) - 1;\n            value |= 1 << this.bitCount;\n            return \"<\" + Integer.toBinaryString(value | 1 << this.bitCount).substring(1) + \">\";\n        }\n    }\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */ /*final*/ class BinaryShiftToken extends SimpleToken {\n        constructor(previous, binaryShiftStart, binaryShiftByteCount){\n            super(previous, 0, 0);\n            this.binaryShiftStart = binaryShiftStart;\n            this.binaryShiftByteCount = binaryShiftByteCount;\n        }\n        /**\n         * @Override\n         */ appendTo(bitArray, text) {\n            for(let i = 0; i < this.binaryShiftByteCount; i++){\n                if (i === 0 || i === 31 && this.binaryShiftByteCount <= 62) {\n                    // We need a header before the first character, and before\n                    // character 31 when the total byte code is <= 62\n                    bitArray.appendBits(31, 5); // BINARY_SHIFT\n                    if (this.binaryShiftByteCount > 62) {\n                        bitArray.appendBits(this.binaryShiftByteCount - 31, 16);\n                    } else if (i === 0) {\n                        // 1 <= binaryShiftByteCode <= 62\n                        bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);\n                    } else {\n                        // 32 <= binaryShiftCount <= 62 and i == 31\n                        bitArray.appendBits(this.binaryShiftByteCount - 31, 5);\n                    }\n                }\n                bitArray.appendBits(text[this.binaryShiftStart + i], 8);\n            }\n        }\n        addBinaryShift(start, byteCount) {\n            // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);\n            return new BinaryShiftToken(this, start, byteCount);\n        }\n        /**\n         * @Override\n         */ toString() {\n            return \"<\" + this.binaryShiftStart + \"::\" + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + \">\";\n        }\n    }\n    function addBinaryShift(token, start, byteCount) {\n        // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);\n        return new BinaryShiftToken(token, start, byteCount);\n    }\n    function add(token, value, bitCount) {\n        return new SimpleToken(token, value, bitCount);\n    }\n    const /*final*/ MODE_NAMES = [\n        \"UPPER\",\n        \"LOWER\",\n        \"DIGIT\",\n        \"MIXED\",\n        \"PUNCT\"\n    ];\n    const /*final*/ MODE_UPPER = 0; // 5 bits\n    const /*final*/ MODE_LOWER = 1; // 5 bits\n    const /*final*/ MODE_DIGIT = 2; // 4 bits\n    const /*final*/ MODE_MIXED = 3; // 5 bits\n    const /*final*/ MODE_PUNCT = 4; // 5 bits\n    const EMPTY_TOKEN = new SimpleToken(null, 0, 0);\n    // The Latch Table shows, for each pair of Modes, the optimal method for\n    // getting from one mode to another.  In the worst possible case, this can\n    // be up to 14 bits.  In the best possible case, we are already there!\n    // The high half-word of each entry gives the number of bits.\n    // The low half-word of each entry are the actual bits necessary to change\n    const LATCH_TABLE = [\n        Int32Array.from([\n            0,\n            (5 << 16) + 28,\n            (5 << 16) + 30,\n            (5 << 16) + 29,\n            (10 << 16) + (29 << 5) + 30 // UPPER -> MIXED -> PUNCT\n        ]),\n        Int32Array.from([\n            (9 << 16) + (30 << 4) + 14,\n            0,\n            (5 << 16) + 30,\n            (5 << 16) + 29,\n            (10 << 16) + (29 << 5) + 30 // LOWER -> MIXED -> PUNCT\n        ]),\n        Int32Array.from([\n            (4 << 16) + 14,\n            (9 << 16) + (14 << 5) + 28,\n            0,\n            (9 << 16) + (14 << 5) + 29,\n            (14 << 16) + (14 << 10) + (29 << 5) + 30\n        ]),\n        Int32Array.from([\n            (5 << 16) + 29,\n            (5 << 16) + 28,\n            (10 << 16) + (29 << 5) + 30,\n            0,\n            (5 << 16) + 30 // MIXED -> PUNCT\n        ]),\n        Int32Array.from([\n            (5 << 16) + 31,\n            (10 << 16) + (31 << 5) + 28,\n            (10 << 16) + (31 << 5) + 30,\n            (10 << 16) + (31 << 5) + 29,\n            0\n        ])\n    ];\n    function static_SHIFT_TABLE(SHIFT_TABLE) {\n        for (let table /*Int32Array*/  of SHIFT_TABLE){\n            Arrays.fill(table, -1);\n        }\n        SHIFT_TABLE[MODE_UPPER][MODE_PUNCT] = 0;\n        SHIFT_TABLE[MODE_LOWER][MODE_PUNCT] = 0;\n        SHIFT_TABLE[MODE_LOWER][MODE_UPPER] = 28;\n        SHIFT_TABLE[MODE_MIXED][MODE_PUNCT] = 0;\n        SHIFT_TABLE[MODE_DIGIT][MODE_PUNCT] = 0;\n        SHIFT_TABLE[MODE_DIGIT][MODE_UPPER] = 15;\n        return SHIFT_TABLE;\n    }\n    const /*final*/ SHIFT_TABLE = static_SHIFT_TABLE(Arrays.createInt32Array(6, 6)); // mode shift codes, per table\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * State represents all information about a sequence necessary to generate the current output.\n     * Note that a state is immutable.\n     */ /*final*/ class State {\n        constructor(token, mode, binaryBytes, bitCount){\n            this.token = token;\n            this.mode = mode;\n            this.binaryShiftByteCount = binaryBytes;\n            this.bitCount = bitCount;\n        // Make sure we match the token\n        // int binaryShiftBitCount = (binaryShiftByteCount * 8) +\n        //    (binaryShiftByteCount === 0 ? 0 :\n        //     binaryShiftByteCount <= 31 ? 10 :\n        //     binaryShiftByteCount <= 62 ? 20 : 21);\n        // assert this.bitCount === token.getTotalBitCount() + binaryShiftBitCount;\n        }\n        getMode() {\n            return this.mode;\n        }\n        getToken() {\n            return this.token;\n        }\n        getBinaryShiftByteCount() {\n            return this.binaryShiftByteCount;\n        }\n        getBitCount() {\n            return this.bitCount;\n        }\n        // Create a new state representing this state with a latch to a (not\n        // necessary different) mode, and then a code.\n        latchAndAppend(mode, value) {\n            // assert binaryShiftByteCount === 0;\n            let bitCount = this.bitCount;\n            let token = this.token;\n            if (mode !== this.mode) {\n                let latch = LATCH_TABLE[this.mode][mode];\n                token = add(token, latch & 0xffff, latch >> 16);\n                bitCount += latch >> 16;\n            }\n            let latchModeBitCount = mode === MODE_DIGIT ? 4 : 5;\n            token = add(token, value, latchModeBitCount);\n            return new State(token, mode, 0, bitCount + latchModeBitCount);\n        }\n        // Create a new state representing this state, with a temporary shift\n        // to a different mode to output a single value.\n        shiftAndAppend(mode, value) {\n            // assert binaryShiftByteCount === 0 && this.mode !== mode;\n            let token = this.token;\n            let thisModeBitCount = this.mode === MODE_DIGIT ? 4 : 5;\n            // Shifts exist only to UPPER and PUNCT, both with tokens size 5.\n            token = add(token, SHIFT_TABLE[this.mode][mode], thisModeBitCount);\n            token = add(token, value, 5);\n            return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);\n        }\n        // Create a new state representing this state, but an additional character\n        // output in Binary Shift mode.\n        addBinaryShiftChar(index) {\n            let token = this.token;\n            let mode = this.mode;\n            let bitCount = this.bitCount;\n            if (this.mode === MODE_PUNCT || this.mode === MODE_DIGIT) {\n                // assert binaryShiftByteCount === 0;\n                let latch = LATCH_TABLE[mode][MODE_UPPER];\n                token = add(token, latch & 0xffff, latch >> 16);\n                bitCount += latch >> 16;\n                mode = MODE_UPPER;\n            }\n            let deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31 ? 18 : this.binaryShiftByteCount === 62 ? 9 : 8;\n            let result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);\n            if (result.binaryShiftByteCount === 2047 + 31) {\n                // The string is as long as it's allowed to be.  We should end it.\n                result = result.endBinaryShift(index + 1);\n            }\n            return result;\n        }\n        // Create the state identical to this one, but we are no longer in\n        // Binary Shift mode.\n        endBinaryShift(index) {\n            if (this.binaryShiftByteCount === 0) {\n                return this;\n            }\n            let token = this.token;\n            token = addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);\n            // assert token.getTotalBitCount() === this.bitCount;\n            return new State(token, this.mode, 0, this.bitCount);\n        }\n        // Returns true if \"this\" state is better (equal: or) to be in than \"that\"\n        // state under all possible circumstances.\n        isBetterThanOrEqualTo(other) {\n            let newModeBitCount = this.bitCount + (LATCH_TABLE[this.mode][other.mode] >> 16);\n            if (this.binaryShiftByteCount < other.binaryShiftByteCount) {\n                // add additional B/S encoding cost of other, if any\n                newModeBitCount += State.calculateBinaryShiftCost(other) - State.calculateBinaryShiftCost(this);\n            } else if (this.binaryShiftByteCount > other.binaryShiftByteCount && other.binaryShiftByteCount > 0) {\n                // maximum possible additional cost (it: h)\n                newModeBitCount += 10;\n            }\n            return newModeBitCount <= other.bitCount;\n        }\n        toBitArray(text) {\n            // Reverse the tokens, so that they are in the order that they should\n            // be output\n            let symbols = [];\n            for(let token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()){\n                symbols.unshift(token);\n            }\n            let bitArray = new BitArray();\n            // Add each token to the result.\n            for (const symbol of symbols){\n                symbol.appendTo(bitArray, text);\n            }\n            // assert bitArray.getSize() === this.bitCount;\n            return bitArray;\n        }\n        /**\n         * @Override\n         */ toString() {\n            return StringUtils.format(\"%s bits=%d bytes=%d\", MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);\n        }\n        static calculateBinaryShiftCost(state) {\n            if (state.binaryShiftByteCount > 62) {\n                return 21; // B/S with extended length\n            }\n            if (state.binaryShiftByteCount > 31) {\n                return 20; // two B/S\n            }\n            if (state.binaryShiftByteCount > 0) {\n                return 10; // one B/S\n            }\n            return 0;\n        }\n    }\n    State.INITIAL_STATE = new State(EMPTY_TOKEN, MODE_UPPER, 0, 0);\n    function static_CHAR_MAP(CHAR_MAP) {\n        const spaceCharCode = StringUtils.getCharCode(\" \");\n        const pointCharCode = StringUtils.getCharCode(\".\");\n        const commaCharCode = StringUtils.getCharCode(\",\");\n        CHAR_MAP[MODE_UPPER][spaceCharCode] = 1;\n        const zUpperCharCode = StringUtils.getCharCode(\"Z\");\n        const aUpperCharCode = StringUtils.getCharCode(\"A\");\n        for(let c = aUpperCharCode; c <= zUpperCharCode; c++){\n            CHAR_MAP[MODE_UPPER][c] = c - aUpperCharCode + 2;\n        }\n        CHAR_MAP[MODE_LOWER][spaceCharCode] = 1;\n        const zLowerCharCode = StringUtils.getCharCode(\"z\");\n        const aLowerCharCode = StringUtils.getCharCode(\"a\");\n        for(let c = aLowerCharCode; c <= zLowerCharCode; c++){\n            CHAR_MAP[MODE_LOWER][c] = c - aLowerCharCode + 2;\n        }\n        CHAR_MAP[MODE_DIGIT][spaceCharCode] = 1;\n        const nineCharCode = StringUtils.getCharCode(\"9\");\n        const zeroCharCode = StringUtils.getCharCode(\"0\");\n        for(let c = zeroCharCode; c <= nineCharCode; c++){\n            CHAR_MAP[MODE_DIGIT][c] = c - zeroCharCode + 2;\n        }\n        CHAR_MAP[MODE_DIGIT][commaCharCode] = 12;\n        CHAR_MAP[MODE_DIGIT][pointCharCode] = 13;\n        const mixedTable = [\n            \"\\x00\",\n            \" \",\n            \"\\x01\",\n            \"\\x02\",\n            \"\\x03\",\n            \"\\x04\",\n            \"\\x05\",\n            \"\\x06\",\n            \"\\x07\",\n            \"\\b\",\n            \"\t\",\n            \"\\n\",\n            \"\\v\",\n            \"\\f\",\n            \"\\r\",\n            \"\\x1b\",\n            \"\\x1c\",\n            \"\\x1d\",\n            \"\\x1e\",\n            \"\\x1f\",\n            \"@\",\n            \"\\\\\",\n            \"^\",\n            \"_\",\n            \"`\",\n            \"|\",\n            \"~\",\n            \"\\x7f\"\n        ];\n        for(let i = 0; i < mixedTable.length; i++){\n            CHAR_MAP[MODE_MIXED][StringUtils.getCharCode(mixedTable[i])] = i;\n        }\n        const punctTable = [\n            \"\\x00\",\n            \"\\r\",\n            \"\\x00\",\n            \"\\x00\",\n            \"\\x00\",\n            \"\\x00\",\n            \"!\",\n            \"'\",\n            \"#\",\n            \"$\",\n            \"%\",\n            \"&\",\n            \"'\",\n            \"(\",\n            \")\",\n            \"*\",\n            \"+\",\n            \",\",\n            \"-\",\n            \".\",\n            \"/\",\n            \":\",\n            \";\",\n            \"<\",\n            \"=\",\n            \">\",\n            \"?\",\n            \"[\",\n            \"]\",\n            \"{\",\n            \"}\"\n        ];\n        for(let i = 0; i < punctTable.length; i++){\n            if (StringUtils.getCharCode(punctTable[i]) > 0) {\n                CHAR_MAP[MODE_PUNCT][StringUtils.getCharCode(punctTable[i])] = i;\n            }\n        }\n        return CHAR_MAP;\n    }\n    const CHAR_MAP = static_CHAR_MAP(Arrays.createInt32Array(5, 256));\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ /**\n     * This produces nearly optimal encodings of text into the first-level of\n     * encoding used by Aztec code.\n     *\n     * It uses a dynamic algorithm.  For each prefix of the string, it determines\n     * a set of encodings that could lead to this prefix.  We repeatedly add a\n     * character and generate a new set of optimal encodings until we have read\n     * through the entire input.\n     *\n     * @author Frank Yellin\n     * @author Rustam Abdullaev\n     */ /*public final*/ class HighLevelEncoder {\n        constructor(text){\n            this.text = text;\n        }\n        /**\n         * @return text represented by this encoder encoded as a {@link BitArray}\n         */ encode() {\n            const spaceCharCode = StringUtils.getCharCode(\" \");\n            const lineBreakCharCode = StringUtils.getCharCode(\"\\n\");\n            let states = Collections.singletonList(State.INITIAL_STATE);\n            for(let index = 0; index < this.text.length; index++){\n                let pairCode;\n                let nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;\n                switch(this.text[index]){\n                    case StringUtils.getCharCode(\"\\r\"):\n                        pairCode = nextChar === lineBreakCharCode ? 2 : 0;\n                        break;\n                    case StringUtils.getCharCode(\".\"):\n                        pairCode = nextChar === spaceCharCode ? 3 : 0;\n                        break;\n                    case StringUtils.getCharCode(\",\"):\n                        pairCode = nextChar === spaceCharCode ? 4 : 0;\n                        break;\n                    case StringUtils.getCharCode(\":\"):\n                        pairCode = nextChar === spaceCharCode ? 5 : 0;\n                        break;\n                    default:\n                        pairCode = 0;\n                }\n                if (pairCode > 0) {\n                    // We have one of the four special PUNCT pairs.  Treat them specially.\n                    // Get a new set of states for the two new characters.\n                    states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);\n                    index++;\n                } else {\n                    // Get a new set of states for the new character.\n                    states = this.updateStateListForChar(states, index);\n                }\n            }\n            // We are left with a set of states.  Find the shortest one.\n            const minState = Collections.min(states, (a, b)=>{\n                return a.getBitCount() - b.getBitCount();\n            });\n            // Convert it to a bit array, and return.\n            return minState.toBitArray(this.text);\n        }\n        // We update a set of states for a new character by updating each state\n        // for the new character, merging the results, and then removing the\n        // non-optimal states.\n        updateStateListForChar(states, index) {\n            const result = [];\n            for (let state /*State*/  of states){\n                this.updateStateForChar(state, index, result);\n            }\n            return HighLevelEncoder.simplifyStates(result);\n        }\n        // Return a set of states that represent the possible ways of updating this\n        // state for the next character.  The resulting set of states are added to\n        // the \"result\" list.\n        updateStateForChar(state, index, result) {\n            let ch = this.text[index] & 0xff;\n            let charInCurrentTable = CHAR_MAP[state.getMode()][ch] > 0;\n            let stateNoBinary = null;\n            for(let mode /*int*/  = 0; mode <= MODE_PUNCT; mode++){\n                let charInMode = CHAR_MAP[mode][ch];\n                if (charInMode > 0) {\n                    if (stateNoBinary == null) {\n                        // Only create stateNoBinary the first time it's required.\n                        stateNoBinary = state.endBinaryShift(index);\n                    }\n                    // Try generating the character by latching to its mode\n                    if (!charInCurrentTable || mode === state.getMode() || mode === MODE_DIGIT) {\n                        // If the character is in the current table, we don't want to latch to\n                        // any other mode except possibly digit (which uses only 4 bits).  Any\n                        // other latch would be equally successful *after* this character, and\n                        // so wouldn't save any bits.\n                        const latchState = stateNoBinary.latchAndAppend(mode, charInMode);\n                        result.push(latchState);\n                    }\n                    // Try generating the character by switching to its mode.\n                    if (!charInCurrentTable && SHIFT_TABLE[state.getMode()][mode] >= 0) {\n                        // It never makes sense to temporarily shift to another mode if the\n                        // character exists in the current mode.  That can never save bits.\n                        const shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);\n                        result.push(shiftState);\n                    }\n                }\n            }\n            if (state.getBinaryShiftByteCount() > 0 || CHAR_MAP[state.getMode()][ch] === 0) {\n                // It's never worthwhile to go into binary shift mode if you're not already\n                // in binary shift mode, and the character exists in your current mode.\n                // That can never save bits over just outputting the char in the current mode.\n                let binaryState = state.addBinaryShiftChar(index);\n                result.push(binaryState);\n            }\n        }\n        static updateStateListForPair(states, index, pairCode) {\n            const result = [];\n            for (let state /*State*/  of states){\n                this.updateStateForPair(state, index, pairCode, result);\n            }\n            return this.simplifyStates(result);\n        }\n        static updateStateForPair(state, index, pairCode, result) {\n            let stateNoBinary = state.endBinaryShift(index);\n            // Possibility 1.  Latch to C.MODE_PUNCT, and then append this code\n            result.push(stateNoBinary.latchAndAppend(MODE_PUNCT, pairCode));\n            if (state.getMode() !== MODE_PUNCT) {\n                // Possibility 2.  Shift to C.MODE_PUNCT, and then append this code.\n                // Every state except C.MODE_PUNCT (handled above) can shift\n                result.push(stateNoBinary.shiftAndAppend(MODE_PUNCT, pairCode));\n            }\n            if (pairCode === 3 || pairCode === 4) {\n                // both characters are in DIGITS.  Sometimes better to just add two digits\n                let digitState = stateNoBinary.latchAndAppend(MODE_DIGIT, 16 - pairCode) // period or comma in DIGIT\n                .latchAndAppend(MODE_DIGIT, 1); // space in DIGIT\n                result.push(digitState);\n            }\n            if (state.getBinaryShiftByteCount() > 0) {\n                // It only makes sense to do the characters as binary if we're already\n                // in binary mode.\n                let binaryState = state.addBinaryShiftChar(index).addBinaryShiftChar(index + 1);\n                result.push(binaryState);\n            }\n        }\n        static simplifyStates(states) {\n            let result = [];\n            for (const newState of states){\n                let add = true;\n                for (const oldState of result){\n                    if (oldState.isBetterThanOrEqualTo(newState)) {\n                        add = false;\n                        break;\n                    }\n                    if (newState.isBetterThanOrEqualTo(oldState)) {\n                        // iterator.remove();\n                        result = result.filter((x)=>x !== oldState); // remove old state\n                    }\n                }\n                if (add) {\n                    result.push(newState);\n                }\n            }\n            return result;\n        }\n    }\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */ // package com.google.zxing.aztec.encoder;\n    // import com.google.zxing.common.BitArray;\n    // import com.google.zxing.common.BitMatrix;\n    // import com.google.zxing.common.reedsolomon.GenericGF;\n    // import com.google.zxing.common.reedsolomon.ReedSolomonEncoder;\n    /**\n     * Generates Aztec 2D barcodes.\n     *\n     * @author Rustam Abdullaev\n     */ /*public final*/ class Encoder$1 {\n        constructor(){}\n        /**\n         * Encodes the given binary content as an Aztec symbol\n         *\n         * @param data input data string\n         * @return Aztec symbol matrix with metadata\n         */ static encodeBytes(data) {\n            return Encoder$1.encode(data, Encoder$1.DEFAULT_EC_PERCENT, Encoder$1.DEFAULT_AZTEC_LAYERS);\n        }\n        /**\n         * Encodes the given binary content as an Aztec symbol\n         *\n         * @param data input data string\n         * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,\n         *                      a minimum of 23% + 3 words is recommended)\n         * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers\n         * @return Aztec symbol matrix with metadata\n         */ static encode(data, minECCPercent, userSpecifiedLayers) {\n            // High-level encode\n            let bits = new HighLevelEncoder(data).encode();\n            // stuff bits and choose symbol size\n            let eccBits = Integer.truncDivision(bits.getSize() * minECCPercent, 100) + 11;\n            let totalSizeBits = bits.getSize() + eccBits;\n            let compact;\n            let layers;\n            let totalBitsInLayer;\n            let wordSize;\n            let stuffedBits;\n            if (userSpecifiedLayers !== Encoder$1.DEFAULT_AZTEC_LAYERS) {\n                compact = userSpecifiedLayers < 0;\n                layers = Math.abs(userSpecifiedLayers);\n                if (layers > (compact ? Encoder$1.MAX_NB_BITS_COMPACT : Encoder$1.MAX_NB_BITS)) {\n                    throw new IllegalArgumentException(StringUtils.format(\"Illegal value %s for layers\", userSpecifiedLayers));\n                }\n                totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);\n                wordSize = Encoder$1.WORD_SIZE[layers];\n                let usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;\n                stuffedBits = Encoder$1.stuffBits(bits, wordSize);\n                if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {\n                    throw new IllegalArgumentException(\"Data to large for user specified layer\");\n                }\n                if (compact && stuffedBits.getSize() > wordSize * 64) {\n                    // Compact format only allows 64 data words, though C4 can hold more words than that\n                    throw new IllegalArgumentException(\"Data to large for user specified layer\");\n                }\n            } else {\n                wordSize = 0;\n                stuffedBits = null;\n                // We look at the possible table sizes in the order Compact1, Compact2, Compact3,\n                // Compact4, Normal4,...  Normal(i) for i < 4 isn't typically used since Compact(i+1)\n                // is the same size, but has more data.\n                for(let i /*int*/  = 0;; i++){\n                    if (i > Encoder$1.MAX_NB_BITS) {\n                        throw new IllegalArgumentException(\"Data too large for an Aztec code\");\n                    }\n                    compact = i <= 3;\n                    layers = compact ? i + 1 : i;\n                    totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);\n                    if (totalSizeBits > totalBitsInLayer) {\n                        continue;\n                    }\n                    // [Re]stuff the bits if this is the first opportunity, or if the\n                    // wordSize has changed\n                    if (stuffedBits == null || wordSize !== Encoder$1.WORD_SIZE[layers]) {\n                        wordSize = Encoder$1.WORD_SIZE[layers];\n                        stuffedBits = Encoder$1.stuffBits(bits, wordSize);\n                    }\n                    let usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;\n                    if (compact && stuffedBits.getSize() > wordSize * 64) {\n                        continue;\n                    }\n                    if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {\n                        break;\n                    }\n                }\n            }\n            let messageBits = Encoder$1.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);\n            // generate mode message\n            let messageSizeInWords = stuffedBits.getSize() / wordSize;\n            let modeMessage = Encoder$1.generateModeMessage(compact, layers, messageSizeInWords);\n            // allocate symbol\n            let baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n            let alignmentMap = new Int32Array(baseMatrixSize);\n            let matrixSize;\n            if (compact) {\n                // no alignment marks in compact mode, alignmentMap is a no-op\n                matrixSize = baseMatrixSize;\n                for(let i /*int*/  = 0; i < alignmentMap.length; i++){\n                    alignmentMap[i] = i;\n                }\n            } else {\n                matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);\n                let origCenter = Integer.truncDivision(baseMatrixSize, 2);\n                let center = Integer.truncDivision(matrixSize, 2);\n                for(let i /*int*/  = 0; i < origCenter; i++){\n                    let newOffset = i + Integer.truncDivision(i, 15);\n                    alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n                    alignmentMap[origCenter + i] = center + newOffset + 1;\n                }\n            }\n            let matrix = new BitMatrix(matrixSize);\n            // draw data bits\n            for(let i /*int*/  = 0, rowOffset = 0; i < layers; i++){\n                let rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n                for(let j /*int*/  = 0; j < rowSize; j++){\n                    let columnOffset = j * 2;\n                    for(let k /*int*/  = 0; k < 2; k++){\n                        if (messageBits.get(rowOffset + columnOffset + k)) {\n                            matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);\n                        }\n                        if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {\n                            matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);\n                        }\n                        if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {\n                            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);\n                        }\n                        if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {\n                            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);\n                        }\n                    }\n                }\n                rowOffset += rowSize * 8;\n            }\n            // draw mode message\n            Encoder$1.drawModeMessage(matrix, compact, matrixSize, modeMessage);\n            // draw alignment marks\n            if (compact) {\n                Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 5);\n            } else {\n                Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 7);\n                for(let i /*int*/  = 0, j = 0; i < Integer.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16){\n                    for(let k /*int*/  = Integer.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2){\n                        matrix.set(Integer.truncDivision(matrixSize, 2) - j, k);\n                        matrix.set(Integer.truncDivision(matrixSize, 2) + j, k);\n                        matrix.set(k, Integer.truncDivision(matrixSize, 2) - j);\n                        matrix.set(k, Integer.truncDivision(matrixSize, 2) + j);\n                    }\n                }\n            }\n            let aztec = new AztecCode();\n            aztec.setCompact(compact);\n            aztec.setSize(matrixSize);\n            aztec.setLayers(layers);\n            aztec.setCodeWords(messageSizeInWords);\n            aztec.setMatrix(matrix);\n            return aztec;\n        }\n        static drawBullsEye(matrix, center, size) {\n            for(let i /*int*/  = 0; i < size; i += 2){\n                for(let j /*int*/  = center - i; j <= center + i; j++){\n                    matrix.set(j, center - i);\n                    matrix.set(j, center + i);\n                    matrix.set(center - i, j);\n                    matrix.set(center + i, j);\n                }\n            }\n            matrix.set(center - size, center - size);\n            matrix.set(center - size + 1, center - size);\n            matrix.set(center - size, center - size + 1);\n            matrix.set(center + size, center - size);\n            matrix.set(center + size, center - size + 1);\n            matrix.set(center + size, center + size - 1);\n        }\n        static generateModeMessage(compact, layers, messageSizeInWords) {\n            let modeMessage = new BitArray();\n            if (compact) {\n                modeMessage.appendBits(layers - 1, 2);\n                modeMessage.appendBits(messageSizeInWords - 1, 6);\n                modeMessage = Encoder$1.generateCheckWords(modeMessage, 28, 4);\n            } else {\n                modeMessage.appendBits(layers - 1, 5);\n                modeMessage.appendBits(messageSizeInWords - 1, 11);\n                modeMessage = Encoder$1.generateCheckWords(modeMessage, 40, 4);\n            }\n            return modeMessage;\n        }\n        static drawModeMessage(matrix, compact, matrixSize, modeMessage) {\n            let center = Integer.truncDivision(matrixSize, 2);\n            if (compact) {\n                for(let i /*int*/  = 0; i < 7; i++){\n                    let offset = center - 3 + i;\n                    if (modeMessage.get(i)) {\n                        matrix.set(offset, center - 5);\n                    }\n                    if (modeMessage.get(i + 7)) {\n                        matrix.set(center + 5, offset);\n                    }\n                    if (modeMessage.get(20 - i)) {\n                        matrix.set(offset, center + 5);\n                    }\n                    if (modeMessage.get(27 - i)) {\n                        matrix.set(center - 5, offset);\n                    }\n                }\n            } else {\n                for(let i /*int*/  = 0; i < 10; i++){\n                    let offset = center - 5 + i + Integer.truncDivision(i, 5);\n                    if (modeMessage.get(i)) {\n                        matrix.set(offset, center - 7);\n                    }\n                    if (modeMessage.get(i + 10)) {\n                        matrix.set(center + 7, offset);\n                    }\n                    if (modeMessage.get(29 - i)) {\n                        matrix.set(offset, center + 7);\n                    }\n                    if (modeMessage.get(39 - i)) {\n                        matrix.set(center - 7, offset);\n                    }\n                }\n            }\n        }\n        static generateCheckWords(bitArray, totalBits, wordSize) {\n            // bitArray is guaranteed to be a multiple of the wordSize, so no padding needed\n            let messageSizeInWords = bitArray.getSize() / wordSize;\n            let rs = new ReedSolomonEncoder(Encoder$1.getGF(wordSize));\n            let totalWords = Integer.truncDivision(totalBits, wordSize);\n            let messageWords = Encoder$1.bitsToWords(bitArray, wordSize, totalWords);\n            rs.encode(messageWords, totalWords - messageSizeInWords);\n            let startPad = totalBits % wordSize;\n            let messageBits = new BitArray();\n            messageBits.appendBits(0, startPad);\n            for (const messageWord /*: int*/  of Array.from(messageWords)){\n                messageBits.appendBits(messageWord, wordSize);\n            }\n            return messageBits;\n        }\n        static bitsToWords(stuffedBits, wordSize, totalWords) {\n            let message = new Int32Array(totalWords);\n            let i;\n            let n;\n            for(i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++){\n                let value = 0;\n                for(let j /*int*/  = 0; j < wordSize; j++){\n                    value |= stuffedBits.get(i * wordSize + j) ? 1 << wordSize - j - 1 : 0;\n                }\n                message[i] = value;\n            }\n            return message;\n        }\n        static getGF(wordSize) {\n            switch(wordSize){\n                case 4:\n                    return GenericGF.AZTEC_PARAM;\n                case 6:\n                    return GenericGF.AZTEC_DATA_6;\n                case 8:\n                    return GenericGF.AZTEC_DATA_8;\n                case 10:\n                    return GenericGF.AZTEC_DATA_10;\n                case 12:\n                    return GenericGF.AZTEC_DATA_12;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported word size \" + wordSize);\n            }\n        }\n        static stuffBits(bits, wordSize) {\n            let out = new BitArray();\n            let n = bits.getSize();\n            let mask = (1 << wordSize) - 2;\n            for(let i /*int*/  = 0; i < n; i += wordSize){\n                let word = 0;\n                for(let j /*int*/  = 0; j < wordSize; j++){\n                    if (i + j >= n || bits.get(i + j)) {\n                        word |= 1 << wordSize - 1 - j;\n                    }\n                }\n                if ((word & mask) === mask) {\n                    out.appendBits(word & mask, wordSize);\n                    i--;\n                } else if ((word & mask) === 0) {\n                    out.appendBits(word | 1, wordSize);\n                    i--;\n                } else {\n                    out.appendBits(word, wordSize);\n                }\n            }\n            return out;\n        }\n        static totalBitsInLayer(layers, compact) {\n            return ((compact ? 88 : 112) + 16 * layers) * layers;\n        }\n    }\n    Encoder$1.DEFAULT_EC_PERCENT = 33; // default minimal percentage of error check words\n    Encoder$1.DEFAULT_AZTEC_LAYERS = 0;\n    Encoder$1.MAX_NB_BITS = 32;\n    Encoder$1.MAX_NB_BITS_COMPACT = 4;\n    Encoder$1.WORD_SIZE = Int32Array.from([\n        4,\n        6,\n        6,\n        8,\n        8,\n        8,\n        8,\n        8,\n        8,\n        10,\n        10,\n        10,\n        10,\n        10,\n        10,\n        10,\n        10,\n        10,\n        10,\n        10,\n        10,\n        10,\n        10,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12\n    ]);\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */ /**\n     * Renders an Aztec code as a {@link BitMatrix}.\n     */ /*public final*/ class AztecWriter {\n        // @Override\n        encode(contents, format, width, height) {\n            return this.encodeWithHints(contents, format, width, height, null);\n        }\n        // @Override\n        encodeWithHints(contents, format, width, height, hints) {\n            let charset = StandardCharsets.ISO_8859_1;\n            let eccPercent = Encoder$1.DEFAULT_EC_PERCENT;\n            let layers = Encoder$1.DEFAULT_AZTEC_LAYERS;\n            if (hints != null) {\n                if (hints.has(EncodeHintType$1.CHARACTER_SET)) {\n                    charset = Charset.forName(hints.get(EncodeHintType$1.CHARACTER_SET).toString());\n                }\n                if (hints.has(EncodeHintType$1.ERROR_CORRECTION)) {\n                    eccPercent = Integer.parseInt(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());\n                }\n                if (hints.has(EncodeHintType$1.AZTEC_LAYERS)) {\n                    layers = Integer.parseInt(hints.get(EncodeHintType$1.AZTEC_LAYERS).toString());\n                }\n            }\n            return AztecWriter.encodeLayers(contents, format, width, height, charset, eccPercent, layers);\n        }\n        static encodeLayers(contents, format, width, height, charset, eccPercent, layers) {\n            if (format !== BarcodeFormat$1.AZTEC) {\n                throw new IllegalArgumentException(\"Can only encode AZTEC, but got \" + format);\n            }\n            let aztec = Encoder$1.encode(StringUtils.getBytes(contents, charset), eccPercent, layers);\n            return AztecWriter.renderResult(aztec, width, height);\n        }\n        static renderResult(code, width, height) {\n            let input = code.getMatrix();\n            if (input == null) {\n                throw new IllegalStateException();\n            }\n            let inputWidth = input.getWidth();\n            let inputHeight = input.getHeight();\n            let outputWidth = Math.max(width, inputWidth);\n            let outputHeight = Math.max(height, inputHeight);\n            let multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);\n            let leftPadding = (outputWidth - inputWidth * multiple) / 2;\n            let topPadding = (outputHeight - inputHeight * multiple) / 2;\n            let output = new BitMatrix(outputWidth, outputHeight);\n            for(let inputY /*int*/  = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple){\n                // Write the contents of this row of the barcode\n                for(let inputX /*int*/  = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple){\n                    if (input.get(inputX, inputY)) {\n                        output.setRegion(outputX, outputY, multiple, multiple);\n                    }\n                }\n            }\n            return output;\n        }\n    }\n    exports1.AbstractExpandedDecoder = AbstractExpandedDecoder;\n    exports1.ArgumentException = ArgumentException;\n    exports1.ArithmeticException = ArithmeticException;\n    exports1.AztecCode = AztecCode;\n    exports1.AztecCodeReader = AztecReader;\n    exports1.AztecCodeWriter = AztecWriter;\n    exports1.AztecDecoder = Decoder;\n    exports1.AztecDetector = Detector;\n    exports1.AztecDetectorResult = AztecDetectorResult;\n    exports1.AztecEncoder = Encoder$1;\n    exports1.AztecHighLevelEncoder = HighLevelEncoder;\n    exports1.AztecPoint = Point;\n    exports1.BarcodeFormat = BarcodeFormat$1;\n    exports1.Binarizer = Binarizer;\n    exports1.BinaryBitmap = BinaryBitmap;\n    exports1.BitArray = BitArray;\n    exports1.BitMatrix = BitMatrix;\n    exports1.BitSource = BitSource;\n    exports1.BrowserAztecCodeReader = BrowserAztecCodeReader;\n    exports1.BrowserBarcodeReader = BrowserBarcodeReader;\n    exports1.BrowserCodeReader = BrowserCodeReader;\n    exports1.BrowserDatamatrixCodeReader = BrowserDatamatrixCodeReader;\n    exports1.BrowserMultiFormatReader = BrowserMultiFormatReader;\n    exports1.BrowserPDF417Reader = BrowserPDF417Reader;\n    exports1.BrowserQRCodeReader = BrowserQRCodeReader;\n    exports1.BrowserQRCodeSvgWriter = BrowserQRCodeSvgWriter;\n    exports1.CharacterSetECI = CharacterSetECI;\n    exports1.ChecksumException = ChecksumException;\n    exports1.Code128Reader = Code128Reader;\n    exports1.Code39Reader = Code39Reader;\n    exports1.DataMatrixDecodedBitStreamParser = DecodedBitStreamParser;\n    exports1.DataMatrixReader = DataMatrixReader;\n    exports1.DecodeHintType = DecodeHintType$1;\n    exports1.DecoderResult = DecoderResult;\n    exports1.DefaultGridSampler = DefaultGridSampler;\n    exports1.DetectorResult = DetectorResult;\n    exports1.EAN13Reader = EAN13Reader;\n    exports1.EncodeHintType = EncodeHintType$1;\n    exports1.Exception = Exception;\n    exports1.FormatException = FormatException;\n    exports1.GenericGF = GenericGF;\n    exports1.GenericGFPoly = GenericGFPoly;\n    exports1.GlobalHistogramBinarizer = GlobalHistogramBinarizer;\n    exports1.GridSampler = GridSampler;\n    exports1.GridSamplerInstance = GridSamplerInstance;\n    exports1.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;\n    exports1.HybridBinarizer = HybridBinarizer;\n    exports1.ITFReader = ITFReader;\n    exports1.IllegalArgumentException = IllegalArgumentException;\n    exports1.IllegalStateException = IllegalStateException;\n    exports1.InvertedLuminanceSource = InvertedLuminanceSource;\n    exports1.LuminanceSource = LuminanceSource;\n    exports1.MathUtils = MathUtils;\n    exports1.MultiFormatOneDReader = MultiFormatOneDReader;\n    exports1.MultiFormatReader = MultiFormatReader;\n    exports1.MultiFormatWriter = MultiFormatWriter;\n    exports1.NotFoundException = NotFoundException;\n    exports1.OneDReader = OneDReader;\n    exports1.PDF417DecodedBitStreamParser = DecodedBitStreamParser$2;\n    exports1.PDF417DecoderErrorCorrection = ErrorCorrection;\n    exports1.PDF417Reader = PDF417Reader;\n    exports1.PDF417ResultMetadata = PDF417ResultMetadata;\n    exports1.PerspectiveTransform = PerspectiveTransform;\n    exports1.PlanarYUVLuminanceSource = PlanarYUVLuminanceSource;\n    exports1.QRCodeByteMatrix = ByteMatrix;\n    exports1.QRCodeDataMask = DataMask;\n    exports1.QRCodeDecodedBitStreamParser = DecodedBitStreamParser$1;\n    exports1.QRCodeDecoderErrorCorrectionLevel = ErrorCorrectionLevel;\n    exports1.QRCodeDecoderFormatInformation = FormatInformation;\n    exports1.QRCodeEncoder = Encoder;\n    exports1.QRCodeEncoderQRCode = QRCode;\n    exports1.QRCodeMaskUtil = MaskUtil;\n    exports1.QRCodeMatrixUtil = MatrixUtil;\n    exports1.QRCodeMode = Mode$1;\n    exports1.QRCodeReader = QRCodeReader;\n    exports1.QRCodeVersion = Version$1;\n    exports1.QRCodeWriter = QRCodeWriter;\n    exports1.RGBLuminanceSource = RGBLuminanceSource;\n    exports1.RSS14Reader = RSS14Reader;\n    exports1.RSSExpandedReader = RSSExpandedReader;\n    exports1.ReaderException = ReaderException;\n    exports1.ReedSolomonDecoder = ReedSolomonDecoder;\n    exports1.ReedSolomonEncoder = ReedSolomonEncoder;\n    exports1.ReedSolomonException = ReedSolomonException;\n    exports1.Result = Result;\n    exports1.ResultMetadataType = ResultMetadataType$1;\n    exports1.ResultPoint = ResultPoint;\n    exports1.StringUtils = StringUtils;\n    exports1.UnsupportedOperationException = UnsupportedOperationException;\n    exports1.VideoInputDevice = VideoInputDevice;\n    exports1.WhiteRectangleDetector = WhiteRectangleDetector;\n    exports1.WriterException = WriterException;\n    exports1.ZXingArrays = Arrays;\n    exports1.ZXingCharset = Charset;\n    exports1.ZXingInteger = Integer;\n    exports1.ZXingStandardCharsets = StandardCharsets;\n    exports1.ZXingStringBuilder = StringBuilder;\n    exports1.ZXingStringEncoding = StringEncoding;\n    exports1.ZXingSystem = System;\n    exports1.createAbstractExpandedDecoder = createDecoder;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL3RoaXJkX3BhcnR5L3p4aW5nLWpzLnVtZC5qcyIsIm1hcHBpbmdzIjoiQUFBQyxVQUFVQSxPQUFNLEVBQUVDLE9BQU87SUFDdEIsS0FBaUQsR0FBY0EsUUFBUUMsV0FDdkUsQ0FDcUc7QUFDekcsR0FBRSxJQUFJLEVBQUcsU0FBVUEsUUFBTztJQUFJO0lBRTFCLFNBQVNPLGtCQUFrQkMsR0FBRztRQUMxQixPQUFPQSxRQUFRLFFBQVFBLFFBQVFDO0lBQ25DO0lBRUE7Ozs7Ozs7Ozs7Ozs7O0tBY0MsR0FDRCwyQkFBMkIsR0FFM0IsSUFBSUMsZ0JBQWdCQyxPQUFPQyxjQUFjLElBQ3BDO1FBQUVDLFdBQVcsRUFBRTtJQUFDLGNBQWFDLFNBQVMsU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO1FBQUlELEVBQUVGLFNBQVMsR0FBR0c7SUFBRyxLQUMxRSxTQUFVRCxDQUFDLEVBQUVDLENBQUM7UUFBSSxJQUFLLElBQUlDLEtBQUtELEVBQUcsSUFBSUEsRUFBRUUsY0FBYyxDQUFDRCxJQUFJRixDQUFDLENBQUNFLEVBQUUsR0FBR0QsQ0FBQyxDQUFDQyxFQUFFO0lBQUU7SUFFN0UsU0FBU0UsVUFBVUosQ0FBQyxFQUFFQyxDQUFDO1FBQ25CTixjQUFjSyxHQUFHQztRQUNqQixTQUFTSTtZQUFPLElBQUksQ0FBQ0MsV0FBVyxHQUFHTjtRQUFHO1FBQ3RDQSxFQUFFTyxTQUFTLEdBQUdOLE1BQU0sT0FBT0wsT0FBT1ksTUFBTSxDQUFDUCxLQUFNSSxDQUFBQSxHQUFHRSxTQUFTLEdBQUdOLEVBQUVNLFNBQVMsRUFBRSxJQUFJRixJQUFHO0lBQ3RGO0lBRUEsU0FBU0ksU0FBU0MsTUFBTSxFQUFFSCxTQUFTO1FBQy9CLElBQUlWLGlCQUFpQkQsT0FBT0MsY0FBYztRQUMxQ0EsaUJBQWlCQSxlQUFlYSxRQUFRSCxhQUFjRyxPQUFPWixTQUFTLEdBQUdTO0lBQzdFO0lBRUEsU0FBU0ksU0FBU0QsTUFBTSxFQUFFRSxFQUFF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R0FBRyxFQUFFLElBQUksQ0FBQ04sR0FBRyxHQUFHL3VCLE1BQU1ndkIsR0FBRyxHQUFHLElBQUksQ0FBQ0EsR0FBRyxHQUFHaHZCLE1BQU1tdkIsR0FBRyxHQUFHLElBQUksQ0FBQ0YsR0FBRyxHQUFHanZCLE1BQU1zdkIsR0FBRyxFQUFFLElBQUksQ0FBQ1AsR0FBRyxHQUFHL3VCLE1BQU1pdkIsR0FBRyxHQUFHLElBQUksQ0FBQ0QsR0FBRyxHQUFHaHZCLE1BQU1vdkIsR0FBRyxHQUFHLElBQUksQ0FBQ0gsR0FBRyxHQUFHanZCLE1BQU11dkIsR0FBRyxFQUFFLElBQUksQ0FBQ0wsR0FBRyxHQUFHbHZCLE1BQU0rdUIsR0FBRyxHQUFHLElBQUksQ0FBQ0ksR0FBRyxHQUFHbnZCLE1BQU1rdkIsR0FBRyxHQUFHLElBQUksQ0FBQ0UsR0FBRyxHQUFHcHZCLE1BQU1xdkIsR0FBRyxFQUFFLElBQUksQ0FBQ0gsR0FBRyxHQUFHbHZCLE1BQU1ndkIsR0FBRyxHQUFHLElBQUksQ0FBQ0csR0FBRyxHQUFHbnZCLE1BQU1tdkIsR0FBRyxHQUFHLElBQUksQ0FBQ0MsR0FBRyxHQUFHcHZCLE1BQU1zdkIsR0FBRyxFQUFFLElBQUksQ0FBQ0osR0FBRyxHQUFHbHZCLE1BQU1pdkIsR0FBRyxHQUFHLElBQUksQ0FBQ0UsR0FBRyxHQUFHbnZCLE1BQU1vdkIsR0FBRyxHQUFHLElBQUksQ0FBQ0EsR0FBRyxHQUFHcHZCLE1BQU11dkIsR0FBRyxFQUFFLElBQUksQ0FBQ0YsR0FBRyxHQUFHcnZCLE1BQU0rdUIsR0FBRyxHQUFHLElBQUksQ0FBQ08sR0FBRyxHQUFHdHZCLE1BQU1rdkIsR0FBRyxHQUFHLElBQUksQ0FBQ0ssR0FBRyxHQUFHdnZCLE1BQU1xdkIsR0FBRyxFQUFFLElBQUksQ0FBQ0EsR0FBRyxHQUFHcnZCLE1BQU1ndkIsR0FBRyxHQUFHLElBQUksQ0FBQ00sR0FBRyxHQUFHdHZCLE1BQU1tdkIsR0FBRyxHQUFHLElBQUksQ0FBQ0ksR0FBRyxHQUFHdnZCLE1BQU1zdkIsR0FBRyxFQUFFLElBQUksQ0FB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V0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDbENJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ2xDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUNsQ0ksV0FBV0os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QztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFBQztZQUFPO1NBQUU7UUFDVjtZQUFDO1lBQU87U0FBRTtRQUNWO1lBQUM7WUFBTztTQUFFO1FBQ1Y7WUFB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O1lBQUs7WUFBSztTQUFJO1FBQ3RDO1lBQUM7WUFBSztZQUFLO1lBQUk7WUFBSztZQUFJO1lBQUk7WUFBSztTQUFHO1FBQ3BDO1lBQUM7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFLO1lBQUk7WUFBSTtTQUFJO1FBQ3JDO1lBQUM7WUFBSztZQUFLO1lBQUs7WUFBSztZQUFHO1lBQUk7WUFBSTtTQUFJO1FBQ3BDO1lBQUM7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFJO1lBQUk7WUFBSTtTQUFHO1FBQ25DO1lBQUM7WUFBSztZQUFJO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSTtTQUFJO1FBQ3BDO1lBQUM7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFLO1lBQUs7WUFBSztTQUFJO1FBQ3ZDO1lBQUM7WUFBSTtZQUFJO1lBQUk7WUFBSztZQUFJO1lBQUs7WUFBSztTQUFJO1FBQ3BDO1lBQUM7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFLO1lBQUs7WUFBSztTQUFJO1FBQ3ZDO1lBQUM7WUFBSTtZQUFJO1lBQUs7WUFBSTtZQUFJO1lBQUk7WUFBSTtTQUFJO1FBQ2xDO1lBQUM7WUFBSztZQUFLO1lBQUs7WUFBSztZQUFLO1lBQUs7WUFBSztTQUFJO1FBQ3hDO1lBQUM7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFLO1lBQUs7WUFBSztTQUFJO1FBQ3ZDO1lBQUM7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFJO1lBQUk7WUFBSztTQUFJO1FBQ3JDO1lBQUM7WUFBSztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUk7WUFBSTtTQUFFO1FBQ2xDO1lBQUM7WUFBRztZQUFJO1lBQUk7WUFBSztZQUFJO1lBQUs7WUFBSztTQUFHO1FBQ2xDO1lBQUM7WUFBSztZQUFLO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSztTQUFJO1FBQ3BDO1lBQUM7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUs7WUFBSztTQUFJO1FBQ25DO1lBQUM7WUFBSztZQUFJO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSztTQUFJO1FBQ3JDO1lBQUM7WUFBSztZ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QUFRLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJVixTQUFTLElBQUksSUFBSU8sSUFBSSxHQUFHO2dCQUMzRCxJQUFJRyxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJVixTQUFTLElBQUksSUFBSU8sSUFBSSxHQUFHO2dCQUM1RCxJQUFJRyxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJVixTQUFTLElBQUksSUFBSU8sSUFBSSxHQUFHO2dCQUM1RCxJQUFJRyxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJVixTQUFTLElBQUksSUFBSU8sSUFBSSxHQUFHO2dCQUM1RCxJQUFJRyxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJVixTQUFTLElBQUksSUFBSU8sSUFBSSxHQUFHO2dCQUM1RCxJQUFJRyxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJVixTQUFTLElBQUksSUFBSU8sSUFBSSxHQUFHO2dCQUM1RCxJQUFJRyxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJVixTQUFTLElBQUksSUFBSU8sSUFBSSxHQUFHO2dCQUM1RCxJQUFJRyxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJVixTQUFTLElBQUksSUFBSU8sSUFBSSxHQUFHO2dCQUM1RCxJQUFJRyxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJVixTQUFTLElBQUksSUFBSU8sSUFBSSxHQUFHO2dCQUM1RCxJQUFJRyxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJVixTQUFTLElBQUksSUFBSU8sSUFBSSxHQUFHO2dCQUM1RCxJQUFJRyxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJVixTQUFTLElBQUksSUFBSU8sSUFBSSxHQUFHO2dCQUM1RCxJQUFJRyxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJVixTQUFTLElBQUksSUFBSU8sSUFBSSxHQUFHO2dCQUM1RCxJQUFJRyxR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UUFDL1EsSUFBSUMsVUFBVSxJQUFJcnhELFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1NBQUcsR0FBRyxJQUFJbXhELFdBQVcsSUFBSSxJQUFJSyxNQUFNLEdBQUcsS0FBSyxJQUFJQSxNQUFNLEdBQUcsTUFBTSxJQUFJTCxXQUFXLElBQUksSUFBSUssTUFBTSxHQUFHLEtBQUssSUFBSUEsTUFBTSxHQUFHLE1BQU0sSUFBSUwsV0FBVyxJQUFJLElBQUlLLE1BQU0sSUFBSSxLQUFLLElBQUlBLE1BQU0sR0FBRyxNQUFNLElBQUlMLFdBQVcsSUFBSSxJQUFJSyxNQUFNLEdBQUcsS0FBSyxJQUFJQSxNQUFNLElBQUk7UUFDaFIsSUFBSUMsVUFBVSxJQUFJcnhELFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1NBQUcsR0FBRyxJQUFJbXhELFdBQVcsSUFBSSxJQUFJSyxNQUFNLEdBQUcsTUFBTSxJQUFJQSxNQUFNLEdBQUcsT0FBTyxJQUFJTCxXQUFXLElBQUksSUFBSUssTUFBTSxJQUFJLEtBQUssSUFBSUEsTUFBTSxHQUFHLE1BQU0sSUFBSUwsV0FBVyxJQUFJLElBQUlLLE1BQU0sR0FBRyxLQUFLLElBQUlBLE1BQU0sSUFBSSxNQUFNLElBQUlMLFdBQVcsSUFBSSxJQUFJSyxNQUFNLEdBQUcsS0FBSyxJQUFJQSxNQUFNLElBQUk7UUFDblIsSUFBSUMsVUFBVSxJQUFJcnhELFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1NBQUcsR0FBRyxJQUFJbXhELFdBQVcsSUFBSSxJQUFJSyxNQUFNLEdBQUcsTUFBTSxJQUFJQSxNQUFNLEdBQUcsT0FBTyxJQUFJTCxXQUFXLElBQUksSUFBSUssTUFBTSxHQUFHLEtBQUssSUFBSUEsTUFBTSxHQUFHLE1BQU0sSUFBSUwsV0FBVyxJQUFJLElBQUlLLE1BQU0sSUFBSSxLQUFLLElBQUlBLE1BQU0sR0FBRyxNQUFNLElBQUlMLFdBQVcsSUFBSSxJQUFJSyxNQUFNLEdBQUcsS0FBSyxJQUFJQSxNQUFNLElBQUk7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QUlMLFdBQVcsSUFBSSxJQUFJSyxNQUFNLEdBQUcsS0FBSyxJQUFJQSxNQUFNLElBQUk7UUFDcFMsSUFBSUMsVUFBVSxJQUFJcnhELFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUk7WUFBSztZQUFLO1NBQUksR0FBRyxJQUFJbXhELFdBQVcsSUFBSSxJQUFJSyxNQUFNLElBQUksTUFBTSxJQUFJQSxNQUFNLEdBQUcsT0FBTyxJQUFJTCxXQUFXLElBQUksSUFBSUssTUFBTSxJQUFJLEtBQUssSUFBSUEsTUFBTSxJQUFJLE1BQU0sSUFBSUwsV0FBVyxJQUFJLElBQUlLLE1BQU0sSUFBSSxLQUFLLElBQUlBLE1BQU0sSUFBSSxNQUFNLElBQUlMLFdBQVcsSUFBSSxJQUFJSyxNQUFNLElBQUksS0FBSyxJQUFJQSxNQUFNLElBQUk7UUFDdFMsSUFBSUMsVUFBVSxJQUFJcnhELFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUk7WUFBSztZQUFLO1NBQUksR0FBRyxJQUFJbXhELFdBQVcsSUFBSSxJQUFJSyxNQUFNLEdBQUcsTUFBTSxJQUFJQSxNQUFNLElBQUksT0FBTyxJQUFJTCxXQUFXLElBQUksSUFBSUssTUFBTSxJQUFJLEtBQUssSUFBSUEsTUFBTSxJQUFJLE1BQU0sSUFBSUwsV0FBVyxJQUFJLElBQUlLLE1BQU0sSUFBSSxLQUFLLElBQUlBLE1BQU0sSUFBSSxNQUFNLElBQUlMLFdBQVcsSUFBSSxJQUFJSyxNQUFNLElBQUksS0FBSyxJQUFJQSxNQUFNLElBQUk7UUFDdFMsSUFBSUMsVUFBVSxJQUFJcnhELFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUk7WUFBSztZQUFLO1NBQUksR0FBRyxJQUFJbXhELFdBQVcsSUFBSSxJQUFJSyxNQUFNLElBQUksTUFBTSxJQUFJQSxNQUFNLEdBQUcsT0FBTyxJQUFJTCxXQUFXLElBQUksSUFBSUssTUFBTSxJQUFJLEtBQUssSUFBSUEsTUFBTSxHQUFHLE1BQU0sSUFBSUwsV0FBVyxJQUFJ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UztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQ25HO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUNuRztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFBUztRQUFTO1FBQVM7UUFDbkc7UUFBUztRQUFTO0tBQ3JCO0lBQ0Q7O0tBRUMsR0FDRGsvRCxhQUFhVSxjQUFjLEdBQUd4L0QsV0FBV0osSUFBSSxDQUFDO1FBQzFDO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFDM0c7UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQzVHO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQ3ZHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFDNUc7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQzVHO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUM3RztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQzFHO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFDekc7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDdkc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDNUc7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBSztRQUFNO1FBQzNHO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQUs7UUFDekc7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUN6RztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQ3pHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFDMUc7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUN6RztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFLO1FBQ3pHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQzFHO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBSztRQUFNO1FBQU07UUFDNUc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDNUc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQU07UUFBSztRQUFLO1FBQUs7UUFDeEc7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUMxRztRQUFLO1FBQU07UUFBSztRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQ3pHO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQUs7UUFDMUc7UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQU07UUFBSztRQUMzRztRQUFLO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQU07UUFBTTtRQUN2RztRQUFNO1FBQU07UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQzFHO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFDM0c7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUM3RztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQ3pHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQ3pHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQ3hHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFDNUc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDNUc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDNUc7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDekc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFDekc7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUN4RztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFJO1FBQUk7UUFBTTtRQUFJO1FBQU07UUFDNUc7UUFBTTtRQUFNO1FBQU07UUFBSTtRQUFJO1FBQUk7UUFBTTtRQUFJO1FBQU07UUFBSTtRQUFNO1FBQUk7UUFBSTtRQUFJO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQ3hHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSTtRQUFJO1FBQU07UUFBSTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUk7UUFBTTtRQUFJO1FBQU07UUFBSTtRQUFNO1FBQU07UUFBSTtRQUMxRztRQUFNO1FBQUk7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFJO1FBQU07UUFBSTtRQUFNO1FBQUk7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSTtRQUFJO1FBQU07UUFDNUc7UUFBTTtRQUFNO1FBQUk7UUFBTTtRQUFJO1FBQU07UUFBTTtRQUFNO1FBQUk7UUFBTTtRQUFJO1FBQU07UUFBSTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFJO1FBQUs7UUFDM0c7UUFBSztRQUFLO1FBQUk7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUN4RztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQzFHO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDekc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUMzRztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUN6RztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQzFHO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQzNHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBSztRQUFNO1FBQU07UUFDNUc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUM3RztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUM1RztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQzVHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFNO1FBQzFHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFLO1FBQ3hHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQzVHO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQ3hHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQzVHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQzVHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDNUc7UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUN4RztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFDN0c7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQzNHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFDekc7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUMzRztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQzFHO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUMzRztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFNO1FBQ3hHO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDM0c7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUN6RztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQ3pHO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFDNUc7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUMzRztRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQ3hHO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFDeEc7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQU07UUFBTTtRQUM1RztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFDN0c7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFDeEc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQU07UUFDMUc7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQzVHO1FBQU07UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFJO1FBQUk7UUFBTTtRQUFJO1FBQU07UUFBSTtRQUFNO1FBQUk7UUFBSTtRQUFJO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUN6RztRQUFNO1FBQUk7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSTtRQUFJO1FBQU07UUFBSTtRQUFNO1FBQUk7UUFBTTtRQUFNO1FBQUk7UUFBSTtRQUFJO1FBQU07UUFBSTtRQUM1RztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUk7UUFBTTtRQUFJO1FBQU07UUFBSTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUk7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUk7UUFDOUc7UUFBTTtRQUFHO1FBQU07UUFBTTtRQUFNO1FBQUk7UUFBTTtRQUFJO1FBQU07UUFBSTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSztRQUM3RztRQUFJO1FBQUs7UUFBSTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFDekc7UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQzVHO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFLO1FBQU07UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFDMUc7UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDdkc7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBSztRQUN2RztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQzVHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQ3ZHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQ3ZHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQzNHO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFNO1FBQzFHO1FBQU07UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFDNUc7UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBSztRQUMzRztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQzVHO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztRQUMxRztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQzFHO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQU07UUFDMUc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQU07UUFDeEc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFLO1FBQU07UUFBTTtRQUM1RztRQUFLO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQ3pHO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBSztRQUM1RztRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQzVHO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFJO1FBQUk7UUFBSTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSTtRQUM1RztRQUFJO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUk7UUFBSTtRQUFJO1FBQU07UUFBSTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSTtRQUFNO1FBQUk7UUFDMUc7UUFBSTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUk7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBRztRQUFNO1FBQUc7UUFBTTtRQUFHO1FBQU07UUFBSztRQUFLO1FBQ3pHO1FBQUs7UUFBSztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFJO1FBQUs7UUFBSTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQzNHO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUM1RztRQUFLO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQzFHO1FBQU07UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUM3RztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQ3pHO1FBQUs7UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDekc7UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDMUc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDNUc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFDMUc7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDM0c7UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDekc7UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDeEc7UUFBSztRQUFNO1FBQU07UUFBSztRQUFLO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUN6RztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQ3pHO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUk7UUFBTTtRQUFJO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQ3ZHO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSTtRQUFLO1FBQUk7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFJO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFDekc7UUFBSztRQUFLO1FBQUs7UUFBRztRQUFHO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFLO1FBQUk7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQU07UUFDeEc7UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUMzRztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQUs7UUFBSztRQUFLO1FBQ3pHO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztRQUMxRztRQUFNO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUN4RztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUM1RztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUMzRztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUMxRztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFJO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBRztRQUFLO1FBQUc7UUFDMUc7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQU07UUFBSTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFDdkc7UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQU07UUFDeEc7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUMzRztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUM1RztRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtRQUN2RztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FB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O1lBQUcsQ0FBQztZQUFHLENBQUM7WUFBRyxDQUFDO1lBQUcsQ0FBQztTQUFFO1FBQzNDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUk7WUFBSSxDQUFDO1lBQUcsQ0FBQztZQUFHLENBQUM7WUFBRyxDQUFDO1NBQUU7UUFDM0NJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJLENBQUM7WUFBRyxDQUFDO1lBQUcsQ0FBQztZQUFHLENBQUM7U0FBRTtRQUMzQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFJO1lBQUksQ0FBQztZQUFHLENBQUM7WUFBRyxDQUFDO1lBQUcsQ0FBQztTQUFFO1FBQzNDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUk7WUFBSSxDQUFDO1lBQUcsQ0FBQztZQUFHLENBQUM7WUFBRyxDQUFDO1NBQUU7UUFDM0NJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJLENBQUM7WUFBRyxDQUFDO1lBQUcsQ0FBQztZQUFHLENBQUM7U0FBRTtRQUMzQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFJO1lBQUksQ0FBQztZQUFHLENBQUM7WUFBRyxDQUFDO1lBQUcsQ0FBQztTQUFFO1FBQzNDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUk7WUFBSSxDQUFDO1lBQUcsQ0FBQztZQUFHLENBQUM7WUFBRyxDQUFDO1NBQUU7UUFDM0NJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUksQ0FBQztZQUFHLENBQUM7WUFBRyxDQUFDO1NBQUU7UUFDM0NJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUksQ0FBQztZQUFHLENBQUM7WUFBRyxDQUFDO1NBQUU7UUFDM0NJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUksQ0FBQztZQUFHLENBQUM7WUFBRyxDQUFDO1NBQUU7UUFDM0NJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUksQ0FBQztZQUFHLENBQUM7WUFBRyxDQUFDO1NBQUU7UUFDM0NJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUksQ0FBQztZQUFHLENBQUM7WUFBRyxDQUFDO1NBQUU7UUFDM0NJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUksQ0FBQztZQUFHLENBQUM7WUFBRyxDQUFDO1NBQUU7UUFDM0NJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUksQ0FBQztZQUFHLENBQUM7WUFBRyxDQUFDO1NBQUU7UUFDM0NJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUk7WUFBSSxDQUFDO1lBQUcsQ0FBQztTQUFFO1FBQzNDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUk7WUFBSTtZQUFJO1lBQUksQ0FBQztZQUFHLENBQUM7U0FBRTtRQUMzQ0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFJO1lBQUk7WUFBSTtZQUFLLENBQUM7WUFBRyxDQUFDO1NBQUU7UUFDNUNJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUk7WUFBSyxDQUFDO1lBQUcsQ0FBQztTQUFFO1FBQzVDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUk7WUFBSTtZQUFJO1lBQUssQ0FBQztZQUFHLENBQUM7U0FBRTtRQUM1Q0ksV0FBV0osSUFBSSxDQUFDO1lBQUM7WUFBRztZQUFJO1lBQUk7WUFBSTtZQUFLLENBQUM7WUFBRyxDQUFDO1NBQUU7UUFDNUNJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUk7WUFBSyxDQUFDO1lBQUcsQ0FBQztTQUFFO1FBQzVDSSxXQUFXSixJQUFJLENBQUM7WUFBQztZQUFHO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSyxDQUFDO1NBQUU7UUFDNUNJLFdBQVdKLElBQUksQ0FBQztZQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUk7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a0JBQWtCLEdBQUdBO0lBQzdCM3VGLFNBQVFxbkQsV0FBVyxHQUFHQTtJQUN0QnJuRCxTQUFRc2hELGlCQUFpQixHQUFHQTtJQUM1QnRoRCxTQUFRby9FLGVBQWUsR0FBR0E7SUFDMUJwL0UsU0FBUTJ2QixrQkFBa0IsR0FBR0E7SUFDN0IzdkIsU0FBUW1nRixrQkFBa0IsR0FBR0E7SUFDN0JuZ0YsU0FBUXl2QixvQkFBb0IsR0FBR0E7SUFDL0J6dkIsU0FBUWtwQixNQUFNLEdBQUdBO0lBQ2pCbHBCLFNBQVF3cUIsa0JBQWtCLEdBQUdDO0lBQzdCenFCLFNBQVF5MkIsV0FBVyxHQUFHQTtJQUN0QnoyQixTQUFRZ1MsV0FBVyxHQUFHQTtJQUN0QmhTLFNBQVE4UCw2QkFBNkIsR0FBR0E7SUFDeEM5UCxTQUFRa2UsZ0JBQWdCLEdBQUdBO0lBQzNCbGUsU0FBUTgzQixzQkFBc0IsR0FBR0E7SUFDakM5M0IsU0FBUXdqRixlQUFlLEdBQUdBO0lBQzFCeGpGLFNBQVFrNEYsV0FBVyxHQUFHNXlGO0lBQ3RCdEYsU0FBUW00RixZQUFZLEdBQUdwSjtJQUN2Qi91RixTQUFRbzRGLFlBQVksR0FBRzl2RjtJQUN2QnRJLFNBQVFxNEYscUJBQXFCLEdBQUdwSjtJQUNoQ2p2RixTQUFRczRGLGtCQUFrQixHQUFHbGpGO0lBQzdCcFYsU0FBUXU0RixtQkFBbUIsR0FBR3hvRjtJQUM5Qi9QLFNBQVF3NEYsV0FBVyxHQUFHL3pGO0lBQ3RCekUsU0FBUXk0Riw2QkFBNkIsR0FBR2w1QztJQUV4QzUrQyxPQUFPeUIsY0FBYyxDQUFDcEMsVUFBUyxjQUFjO1FBQUVxQyxPQUFPO0lBQUs7QUFFL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb3Bvcy8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvdGhpcmRfcGFydHkvenhpbmctanMudW1kLmpzPzMzYTAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5aWGluZyA9IHt9KSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgICBmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG5cbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXG4gICAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhQcm90byh0YXJnZXQsIHByb3RvdHlwZSkge1xuICAgICAgICB2YXIgc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2Y7XG4gICAgICAgIHNldFByb3RvdHlwZU9mID8gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90b3R5cGUpIDogKHRhcmdldC5fX3Byb3RvX18gPSBwcm90b3R5cGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeFN0YWNrKHRhcmdldCwgZm4pIHtcbiAgICAgICAgaWYgKGZuID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGZuID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlO1xuICAgICAgICBjYXB0dXJlU3RhY2tUcmFjZSAmJiBjYXB0dXJlU3RhY2tUcmFjZSh0YXJnZXQsIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgQ3VzdG9tRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQ3VzdG9tRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsICduYW1lJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBfbmV3VGFyZ2V0Lm5hbWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZml4UHJvdG8oX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGZpeFN0YWNrKF90aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIEN1c3RvbUVycm9yO1xuICAgIH0pKEVycm9yKTtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBFeGNlcHRpb24gZXh0ZW5kcyBDdXN0b21FcnJvciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgRXhjZXB0aW9uIHRvIGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5XG4gICAgICAgICAqIHdpdGggc29tZSBtZXNzYWdlIGFuZCBwcm90b3R5cGUgZGVmaW5pdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRLaW5kKCkge1xuICAgICAgICAgICAgY29uc3QgZXggPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIGV4LmtpbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSXQncyB0eXBlZCBhcyBzdHJpbmcgc28gaXQgY2FuIGJlIGV4dGVuZGVkIGFuZCBvdmVycmlkZW4uXG4gICAgICovXG4gICAgRXhjZXB0aW9uLmtpbmQgPSAnRXhjZXB0aW9uJztcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBBcmd1bWVudEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIEFyZ3VtZW50RXhjZXB0aW9uLmtpbmQgPSAnQXJndW1lbnRFeGNlcHRpb24nO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbi5raW5kID0gJ0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbic7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIGNsYXNzIEJpbmFyeUJpdG1hcCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJpbmFyaXplcikge1xuICAgICAgICAgICAgdGhpcy5iaW5hcml6ZXIgPSBiaW5hcml6ZXI7XG4gICAgICAgICAgICBpZiAoYmluYXJpemVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQmluYXJpemVyIG11c3QgYmUgbm9uLW51bGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHdpZHRoIG9mIHRoZSBiaXRtYXAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyaXplci5nZXRXaWR0aCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBoZWlnaHQgb2YgdGhlIGJpdG1hcC5cbiAgICAgICAgICovXG4gICAgICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyaXplci5nZXRIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgb25lIHJvdyBvZiBsdW1pbmFuY2UgZGF0YSB0byAxIGJpdCBkYXRhLiBNYXkgYWN0dWFsbHkgZG8gdGhlIGNvbnZlcnNpb24sIG9yIHJldHVyblxuICAgICAgICAgKiBjYWNoZWQgZGF0YS4gQ2FsbGVycyBzaG91bGQgYXNzdW1lIHRoaXMgbWV0aG9kIGlzIGV4cGVuc2l2ZSBhbmQgY2FsbCBpdCBhcyBzZWxkb20gYXMgcG9zc2libGUuXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvciBkZWNvZGluZyAxRCBiYXJjb2RlcyBhbmQgbWF5IGNob29zZSB0byBhcHBseSBzaGFycGVuaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geSBUaGUgcm93IHRvIGZldGNoLCB3aGljaCBtdXN0IGJlIGluIFswLCBiaXRtYXAgaGVpZ2h0KVxuICAgICAgICAgKiBAcGFyYW0gcm93IEFuIG9wdGlvbmFsIHByZWFsbG9jYXRlZCBhcnJheS4gSWYgbnVsbCBvciB0b28gc21hbGwsIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgICAgICogICAgICAgICAgICBJZiB1c2VkLCB0aGUgQmluYXJpemVyIHdpbGwgY2FsbCBCaXRBcnJheS5jbGVhcigpLiBBbHdheXMgdXNlIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGFycmF5IG9mIGJpdHMgZm9yIHRoaXMgcm93ICh0cnVlIG1lYW5zIGJsYWNrKS5cbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiByb3cgY2FuJ3QgYmUgYmluYXJpemVkXG4gICAgICAgICAqL1xuICAgICAgICBnZXRCbGFja1Jvdyh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJpemVyLmdldEJsYWNrUm93KHksIHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGEgMkQgYXJyYXkgb2YgbHVtaW5hbmNlIGRhdGEgdG8gMSBiaXQuIEFzIGFib3ZlLCBhc3N1bWUgdGhpcyBtZXRob2QgaXMgZXhwZW5zaXZlXG4gICAgICAgICAqIGFuZCBkbyBub3QgY2FsbCBpdCByZXBlYXRlZGx5LiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZGVjb2RpbmcgMkQgYmFyY29kZXMgYW5kIG1heSBvclxuICAgICAgICAgKiBtYXkgbm90IGFwcGx5IHNoYXJwZW5pbmcuIFRoZXJlZm9yZSwgYSByb3cgZnJvbSB0aGlzIG1hdHJpeCBtYXkgbm90IGJlIGlkZW50aWNhbCB0byBvbmVcbiAgICAgICAgICogZmV0Y2hlZCB1c2luZyBnZXRCbGFja1JvdygpLCBzbyBkb24ndCBtaXggYW5kIG1hdGNoIGJldHdlZW4gdGhlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBUaGUgMkQgYXJyYXkgb2YgYml0cyBmb3IgdGhlIGltYWdlICh0cnVlIG1lYW5zIGJsYWNrKS5cbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBpbWFnZSBjYW4ndCBiZSBiaW5hcml6ZWQgdG8gbWFrZSBhIG1hdHJpeFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmxhY2tNYXRyaXgoKSB7XG4gICAgICAgICAgICAvLyBUaGUgbWF0cml4IGlzIGNyZWF0ZWQgb24gZGVtYW5kIHRoZSBmaXJzdCB0aW1lIGl0IGlzIHJlcXVlc3RlZCwgdGhlbiBjYWNoZWQuIFRoZXJlIGFyZSB0d29cbiAgICAgICAgICAgIC8vIHJlYXNvbnMgZm9yIHRoaXM6XG4gICAgICAgICAgICAvLyAxLiBUaGlzIHdvcmsgd2lsbCBuZXZlciBiZSBkb25lIGlmIHRoZSBjYWxsZXIgb25seSBpbnN0YWxscyAxRCBSZWFkZXIgb2JqZWN0cywgb3IgaWYgYVxuICAgICAgICAgICAgLy8gICAgMUQgUmVhZGVyIGZpbmRzIGEgYmFyY29kZSBiZWZvcmUgdGhlIDJEIFJlYWRlcnMgcnVuLlxuICAgICAgICAgICAgLy8gMi4gVGhpcyB3b3JrIHdpbGwgb25seSBiZSBkb25lIG9uY2UgZXZlbiBpZiB0aGUgY2FsbGVyIGluc3RhbGxzIG11bHRpcGxlIDJEIFJlYWRlcnMuXG4gICAgICAgICAgICBpZiAodGhpcy5tYXRyaXggPT09IG51bGwgfHwgdGhpcy5tYXRyaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0cml4ID0gdGhpcy5iaW5hcml6ZXIuZ2V0QmxhY2tNYXRyaXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBXaGV0aGVyIHRoaXMgYml0bWFwIGNhbiBiZSBjcm9wcGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNDcm9wU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJpemVyLmdldEx1bWluYW5jZVNvdXJjZSgpLmlzQ3JvcFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIGNyb3BwZWQgaW1hZ2UgZGF0YS4gSW1wbGVtZW50YXRpb25zIG1heSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZVxuICAgICAgICAgKiBvcmlnaW5hbCBkYXRhIHJhdGhlciB0aGFuIGEgY29weS4gT25seSBjYWxsYWJsZSBpZiBpc0Nyb3BTdXBwb3J0ZWQoKSBpcyB0cnVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBjb29yZGluYXRlLCB3aGljaCBtdXN0IGJlIGluIFswLGdldFdpZHRoKCkpXG4gICAgICAgICAqIEBwYXJhbSB0b3AgVGhlIHRvcCBjb29yZGluYXRlLCB3aGljaCBtdXN0IGJlIGluIFswLGdldEhlaWdodCgpKVxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgdG8gY3JvcC5cbiAgICAgICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUgdG8gY3JvcC5cbiAgICAgICAgICogQHJldHVybiBBIGNyb3BwZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGNyb3AobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NvdXJjZSA9IHRoaXMuYmluYXJpemVyLmdldEx1bWluYW5jZVNvdXJjZSgpLmNyb3AobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5Qml0bWFwKHRoaXMuYmluYXJpemVyLmNyZWF0ZUJpbmFyaXplcihuZXdTb3VyY2UpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBXaGV0aGVyIHRoaXMgYml0bWFwIHN1cHBvcnRzIGNvdW50ZXItY2xvY2t3aXNlIHJvdGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNSb3RhdGVTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcml6ZXIuZ2V0THVtaW5hbmNlU291cmNlKCkuaXNSb3RhdGVTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCByb3RhdGVkIGltYWdlIGRhdGEgYnkgOTAgZGVncmVlcyBjb3VudGVyY2xvY2t3aXNlLlxuICAgICAgICAgKiBPbmx5IGNhbGxhYmxlIGlmIHtAbGluayAjaXNSb3RhdGVTdXBwb3J0ZWQoKX0gaXMgdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBBIHJvdGF0ZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTb3VyY2UgPSB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUJpdG1hcCh0aGlzLmJpbmFyaXplci5jcmVhdGVCaW5hcml6ZXIobmV3U291cmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggcm90YXRlZCBpbWFnZSBkYXRhIGJ5IDQ1IGRlZ3JlZXMgY291bnRlcmNsb2Nrd2lzZS5cbiAgICAgICAgICogT25seSBjYWxsYWJsZSBpZiB7QGxpbmsgI2lzUm90YXRlU3VwcG9ydGVkKCl9IGlzIHRydWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gQSByb3RhdGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlNDUoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTb3VyY2UgPSB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlNDUoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5Qml0bWFwKHRoaXMuYmluYXJpemVyLmNyZWF0ZUJpbmFyaXplcihuZXdTb3VyY2UpKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCbGFja01hdHJpeCgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSAvKjogTm90Rm91bmRFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBDaGVja3N1bUV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgICAgIHN0YXRpYyBnZXRDaGVja3N1bUluc3RhbmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja3N1bUV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIENoZWNrc3VtRXhjZXB0aW9uLmtpbmQgPSAnQ2hlY2tzdW1FeGNlcHRpb24nO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGlzIGNsYXNzIGhpZXJhcmNoeSBwcm92aWRlcyBhIHNldCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgbHVtaW5hbmNlIGRhdGEgdG8gMSBiaXQgZGF0YS5cbiAgICAgKiBJdCBhbGxvd3MgdGhlIGFsZ29yaXRobSB0byB2YXJ5IHBvbHltb3JwaGljYWxseSwgZm9yIGV4YW1wbGUgYWxsb3dpbmcgYSB2ZXJ5IGV4cGVuc2l2ZVxuICAgICAqIHRocmVzaG9sZGluZyB0ZWNobmlxdWUgZm9yIHNlcnZlcnMgYW5kIGEgZmFzdCBvbmUgZm9yIG1vYmlsZS4gSXQgYWxzbyBwZXJtaXRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAqIHRvIHZhcnksIGUuZy4gYSBKTkkgdmVyc2lvbiBmb3IgQW5kcm9pZCBhbmQgYSBKYXZhIGZhbGxiYWNrIHZlcnNpb24gZm9yIG90aGVyIHBsYXRmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICovXG4gICAgY2xhc3MgQmluYXJpemVyIHtcbiAgICAgICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRMdW1pbmFuY2VTb3VyY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBTeXN0ZW0ge1xuICAgICAgICAvLyBwdWJsaWMgc3RhdGljIHZvaWQgYXJyYXljb3B5KE9iamVjdCBzcmMsIGludCBzcmNQb3MsIE9iamVjdCBkZXN0LCBpbnQgZGVzdFBvcywgaW50IGxlbmd0aClcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2VzIGEgY29weSBvZiBhIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFycmF5Y29weShzcmMsIHNyY1BvcywgZGVzdCwgZGVzdFBvcywgbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgdXNlIHNwbGl0IG9yIHNldD9cbiAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY3VycmVudFRpbWVNaWxsaXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICB9XG4gICAgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5raW5kID0gJ0luZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24nO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiBleHRlbmRzIEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24ge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmRleCA9IHVuZGVmaW5lZCwgbWVzc2FnZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5raW5kID0gJ0FycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbic7XG5cbiAgICBjbGFzcyBBcnJheXMge1xuICAgICAgICAvKipcbiAgICAgICAgICogQXNzaWducyB0aGUgc3BlY2lmaWVkIGludCB2YWx1ZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCBhcnJheVxuICAgICAgICAgKiBvZiBpbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYSB0aGUgYXJyYXkgdG8gYmUgZmlsbGVkXG4gICAgICAgICAqIEBwYXJhbSB2YWwgdGhlIHZhbHVlIHRvIGJlIHN0b3JlZCBpbiBhbGwgZWxlbWVudHMgb2YgdGhlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZmlsbChhLCB2YWwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIGFbaV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2lnbnMgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWRcbiAgICAgICAgICogcmFuZ2Ugb2YgdGhlIHNwZWNpZmllZCBhcnJheSBvZiBpbnRzLiAgVGhlIHJhbmdlIHRvIGJlIGZpbGxlZFxuICAgICAgICAgKiBleHRlbmRzIGZyb20gaW5kZXgge0Bjb2RlIGZyb21JbmRleH0sIGluY2x1c2l2ZSwgdG8gaW5kZXhcbiAgICAgICAgICoge0Bjb2RlIHRvSW5kZXh9LCBleGNsdXNpdmUuICAoSWYge0Bjb2RlIGZyb21JbmRleD09dG9JbmRleH0sIHRoZVxuICAgICAgICAgKiByYW5nZSB0byBiZSBmaWxsZWQgaXMgZW1wdHkuKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYSB0aGUgYXJyYXkgdG8gYmUgZmlsbGVkXG4gICAgICAgICAqIEBwYXJhbSBmcm9tSW5kZXggdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IChpbmNsdXNpdmUpIHRvIGJlXG4gICAgICAgICAqICAgICAgICBmaWxsZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB0b0luZGV4IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBlbGVtZW50IChleGNsdXNpdmUpIHRvIGJlXG4gICAgICAgICAqICAgICAgICBmaWxsZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB2YWwgdGhlIHZhbHVlIHRvIGJlIHN0b3JlZCBpbiBhbGwgZWxlbWVudHMgb2YgdGhlIGFycmF5XG4gICAgICAgICAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIHtAY29kZSBmcm9tSW5kZXggPiB0b0luZGV4fVxuICAgICAgICAgKiBAdGhyb3dzIEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiBpZiB7QGNvZGUgZnJvbUluZGV4IDwgMH0gb3JcbiAgICAgICAgICogICAgICAgICB7QGNvZGUgdG9JbmRleCA+IGEubGVuZ3RofVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZpbGxXaXRoaW4oYSwgZnJvbUluZGV4LCB0b0luZGV4LCB2YWwpIHtcbiAgICAgICAgICAgIEFycmF5cy5yYW5nZUNoZWNrKGEubGVuZ3RoLCBmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZyb21JbmRleDsgaSA8IHRvSW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICBhW2ldID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgdGhhdCB7QGNvZGUgZnJvbUluZGV4fSBhbmQge0Bjb2RlIHRvSW5kZXh9IGFyZSBpblxuICAgICAgICAgKiB0aGUgcmFuZ2UgYW5kIHRocm93cyBhbiBleGNlcHRpb24gaWYgdGhleSBhcmVuJ3QuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcmFuZ2VDaGVjayhhcnJheUxlbmd0aCwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgICAgICBpZiAoZnJvbUluZGV4ID4gdG9JbmRleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ2Zyb21JbmRleCgnICsgZnJvbUluZGV4ICsgJykgPiB0b0luZGV4KCcgKyB0b0luZGV4ICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbihmcm9tSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvSW5kZXggPiBhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24odG9JbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFzTGlzdCguLi5hcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY3JlYXRlKHJvd3MsIGNvbHMsIHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgYXJyID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogcm93cyB9KTtcbiAgICAgICAgICAgIHJldHVybiBhcnIubWFwKHggPT4gQXJyYXkuZnJvbSh7IGxlbmd0aDogY29scyB9KS5maWxsKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNyZWF0ZUludDMyQXJyYXkocm93cywgY29scywgdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBhcnIgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiByb3dzIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFyci5tYXAoeCA9PiBJbnQzMkFycmF5LmZyb20oeyBsZW5ndGg6IGNvbHMgfSkuZmlsbCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlcXVhbHMoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmaXJzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlY29uZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3QubGVuZ3RoICE9PSBzZWNvbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGZpcnN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0W2ldICE9PSBzZWNvbmRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBoYXNoQ29kZShhKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDE7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IDMxICogcmVzdWx0ICsgZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZpbGxVaW50OEFycmF5KGEsIHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFbaV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY29weU9mKG9yaWdpbmFsLCBuZXdMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5zbGljZSgwLCBuZXdMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjb3B5T2ZVaW50OEFycmF5KG9yaWdpbmFsLCBuZXdMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggPD0gbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICAgICAgICAgICAgICAgIG5ld0FycmF5LnNldChvcmlnaW5hbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLnNsaWNlKDAsIG5ld0xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNvcHlPZlJhbmdlKG9yaWdpbmFsLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gdG8gLSBmcm9tO1xuICAgICAgICAgICAgY29uc3QgY29weSA9IG5ldyBJbnQzMkFycmF5KG5ld0xlbmd0aCk7XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KG9yaWdpbmFsLCBmcm9tLCBjb3B5LCAwLCBuZXdMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBvZiB0aGUgZWxlbWVudCBpbiBhIHNvcnRlZCBhcnJheSBvciAoLW4tMSkgd2hlcmUgbiBpcyB0aGUgaW5zZXJ0aW9uIHBvaW50XG4gICAgICAgICogZm9yIHRoZSBuZXcgZWxlbWVudC5cbiAgICAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAgICAqICAgICBhciAtIEEgc29ydGVkIGFycmF5XG4gICAgICAgICogICAgIGVsIC0gQW4gZWxlbWVudCB0byBzZWFyY2ggZm9yXG4gICAgICAgICogICAgIGNvbXBhcmF0b3IgLSBBIGNvbXBhcmF0b3IgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiB0YWtlcyB0d28gYXJndW1lbnRzOiAoYSwgYikgYW5kIHJldHVybnM6XG4gICAgICAgICogICAgICAgIGEgbmVnYXRpdmUgbnVtYmVyICBpZiBhIGlzIGxlc3MgdGhhbiBiO1xuICAgICAgICAqICAgICAgICAwIGlmIGEgaXMgZXF1YWwgdG8gYjtcbiAgICAgICAgKiAgICAgICAgYSBwb3NpdGl2ZSBudW1iZXIgb2YgYSBpcyBncmVhdGVyIHRoYW4gYi5cbiAgICAgICAgKiBUaGUgYXJyYXkgbWF5IGNvbnRhaW4gZHVwbGljYXRlIGVsZW1lbnRzLiBJZiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBlcXVhbCBlbGVtZW50cyBpbiB0aGUgYXJyYXksXG4gICAgICAgICogdGhlIHJldHVybmVkIHZhbHVlIGNhbiBiZSB0aGUgaW5kZXggb2YgYW55IG9uZSBvZiB0aGUgZXF1YWwgZWxlbWVudHMuXG4gICAgICAgICpcbiAgICAgICAgKiBodHRwOi8vanNmaWRkbGUubmV0L2FyeXpob3YvcGtmc3Q1NTAvXG4gICAgICAgICovXG4gICAgICAgIHN0YXRpYyBiaW5hcnlTZWFyY2goYXIsIGVsLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY29tcGFyYXRvciA9IEFycmF5cy5udW1iZXJDb21wYXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG0gPSAwO1xuICAgICAgICAgICAgbGV0IG4gPSBhci5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKG0gPD0gbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGsgPSAobiArIG0pID4+IDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY21wID0gY29tcGFyYXRvcihlbCwgYXJba10pO1xuICAgICAgICAgICAgICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG0gPSBrICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBuID0gayAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLW0gLSAxO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBudW1iZXJDb21wYXJhdG9yKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbnlmaWxsIGZvciBKYXZhJ3MgSW50ZWdlciBjbGFzcy5cbiAgICAgKi9cbiAgICBjbGFzcyBJbnRlZ2VyIHtcbiAgICAgICAgc3RhdGljIG51bWJlck9mVHJhaWxpbmdaZXJvcyhpKSB7XG4gICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgIGlmIChpID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgICAgIGxldCBuID0gMzE7XG4gICAgICAgICAgICB5ID0gaSA8PCAxNjtcbiAgICAgICAgICAgIGlmICh5ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbiAtPSAxNjtcbiAgICAgICAgICAgICAgICBpID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHkgPSBpIDw8IDg7XG4gICAgICAgICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG4gLT0gODtcbiAgICAgICAgICAgICAgICBpID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHkgPSBpIDw8IDQ7XG4gICAgICAgICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG4gLT0gNDtcbiAgICAgICAgICAgICAgICBpID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHkgPSBpIDw8IDI7XG4gICAgICAgICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG4gLT0gMjtcbiAgICAgICAgICAgICAgICBpID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuIC0gKChpIDw8IDEpID4+PiAzMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG51bWJlck9mTGVhZGluZ1plcm9zKGkpIHtcbiAgICAgICAgICAgIC8vIEhELCBGaWd1cmUgNS02XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuID0gMTtcbiAgICAgICAgICAgIGlmIChpID4+PiAxNiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG4gKz0gMTY7XG4gICAgICAgICAgICAgICAgaSA8PD0gMTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+Pj4gMjQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBuICs9IDg7XG4gICAgICAgICAgICAgICAgaSA8PD0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4+PiAyOCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG4gKz0gNDtcbiAgICAgICAgICAgICAgICBpIDw8PSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj4+IDMwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbiArPSAyO1xuICAgICAgICAgICAgICAgIGkgPDw9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuIC09IGkgPj4+IDMxO1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHRvSGV4U3RyaW5nKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgdG9CaW5hcnlTdHJpbmcoaW50TnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHBhcnNlSW50KFN0cmluZyhpbnROdW1iZXIpLCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIG9uZS1iaXRzIGluIHRoZSB0d28ncyBjb21wbGVtZW50IGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGludCB2YWx1ZS4gVGhpcyBmdW5jdGlvbiBpcyBzb21ldGltZXMgcmVmZXJyZWQgdG8gYXMgdGhlIHBvcHVsYXRpb24gY291bnQuXG4gICAgICAgIC8vIFJldHVybnM6XG4gICAgICAgIC8vIHRoZSBudW1iZXIgb2Ygb25lLWJpdHMgaW4gdGhlIHR3bydzIGNvbXBsZW1lbnQgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzcGVjaWZpZWQgaW50IHZhbHVlLlxuICAgICAgICBzdGF0aWMgYml0Q291bnQoaSkge1xuICAgICAgICAgICAgLy8gSEQsIEZpZ3VyZSA1LTJcbiAgICAgICAgICAgIGkgPSBpIC0gKChpID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICAgICAgICAgICAgaSA9IChpICYgMHgzMzMzMzMzMykgKyAoKGkgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gICAgICAgICAgICBpID0gKGkgKyAoaSA+Pj4gNCkpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgICAgIGkgPSBpICsgKGkgPj4+IDgpO1xuICAgICAgICAgICAgaSA9IGkgKyAoaSA+Pj4gMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGkgJiAweDNmO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyB0cnVuY0RpdmlzaW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC50cnVuYyhkaXZpZGVuZCAvIGRpdmlzb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBBIHN0cmluZyB0byBhbiBpbnRlZ2VyLlxuICAgICAgICAgKiBAcGFyYW0gcyBBIHN0cmluZyB0byBjb252ZXJ0IGludG8gYSBudW1iZXIuXG4gICAgICAgICAqIEBwYXJhbSByYWRpeCBBIHZhbHVlIGJldHdlZW4gMiBhbmQgMzYgdGhhdCBzcGVjaWZpZXMgdGhlIGJhc2Ugb2YgdGhlIG51bWJlciBpbiBudW1TdHJpbmcuIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IHN1cHBsaWVkLCBzdHJpbmdzIHdpdGggYSBwcmVmaXggb2YgJzB4JyBhcmUgY29uc2lkZXJlZCBoZXhhZGVjaW1hbC4gQWxsIG90aGVyIHN0cmluZ3MgYXJlIGNvbnNpZGVyZWQgZGVjaW1hbC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBwYXJzZUludChudW0sIHJhZGl4ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLCByYWRpeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSW50ZWdlci5NSU5fVkFMVUVfMzJfQklUUyA9IC0yMTQ3NDgzNjQ4O1xuICAgIEludGVnZXIuTUFYX1ZBTFVFID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbiAgICAvKipcbiAgICAgKiA8cD5BIHNpbXBsZSwgZmFzdCBhcnJheSBvZiBiaXRzLCByZXByZXNlbnRlZCBjb21wYWN0bHkgYnkgYW4gYXJyYXkgb2YgaW50cyBpbnRlcm5hbGx5LjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgQml0QXJyYXkgLyppbXBsZW1lbnRzIENsb25lYWJsZSovIHtcbiAgICAgICAgLy8gRm9yIHRlc3Rpbmcgb25seVxuICAgICAgICBjb25zdHJ1Y3RvcihzaXplIC8qaW50Ki8sIGJpdHMpIHtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuYml0cyA9IG5ldyBJbnQzMkFycmF5KDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBiaXRzIHx8IG51bGwgPT09IGJpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaXRzID0gQml0QXJyYXkubWFrZUFycmF5KHNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U2l6ZUluQnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigodGhpcy5zaXplICsgNykgLyA4KTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVDYXBhY2l0eShzaXplIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChzaXplID4gdGhpcy5iaXRzLmxlbmd0aCAqIDMyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Qml0cyA9IEJpdEFycmF5Lm1ha2VBcnJheShzaXplKTtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHRoaXMuYml0cywgMCwgbmV3Qml0cywgMCwgdGhpcy5iaXRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5iaXRzID0gbmV3Qml0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGkgYml0IHRvIGdldFxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWZmIGJpdCBpIGlzIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0KGkgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmJpdHNbTWF0aC5mbG9vcihpIC8gMzIpXSAmICgxIDw8IChpICYgMHgxRikpKSAhPT0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBiaXQgaS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGkgYml0IHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0KGkgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy5iaXRzW01hdGguZmxvb3IoaSAvIDMyKV0gfD0gMSA8PCAoaSAmIDB4MUYpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGlwcyBiaXQgaS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGkgYml0IHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZmxpcChpIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuYml0c1tNYXRoLmZsb29yKGkgLyAzMildIF49IDEgPDwgKGkgJiAweDFGKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGZyb20gZmlyc3QgYml0IHRvIGNoZWNrXG4gICAgICAgICAqIEByZXR1cm4gaW5kZXggb2YgZmlyc3QgYml0IHRoYXQgaXMgc2V0LCBzdGFydGluZyBmcm9tIHRoZSBnaXZlbiBpbmRleCwgb3Igc2l6ZSBpZiBub25lIGFyZSBzZXRcbiAgICAgICAgICogIGF0IG9yIGJleW9uZCB0aGlzIGdpdmVuIGluZGV4XG4gICAgICAgICAqIEBzZWUgI2dldE5leHRVbnNldChpbnQpXG4gICAgICAgICAqL1xuICAgICAgICBnZXROZXh0U2V0KGZyb20gLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tID49IHNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBsZXQgYml0c09mZnNldCA9IE1hdGguZmxvb3IoZnJvbSAvIDMyKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qml0cyA9IGJpdHNbYml0c09mZnNldF07XG4gICAgICAgICAgICAvLyBtYXNrIG9mZiBsZXNzZXIgYml0cyBmaXJzdFxuICAgICAgICAgICAgY3VycmVudEJpdHMgJj0gfigoMSA8PCAoZnJvbSAmIDB4MUYpKSAtIDEpO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYml0cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudEJpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoKytiaXRzT2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRCaXRzID0gYml0c1tiaXRzT2Zmc2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChiaXRzT2Zmc2V0ICogMzIpICsgSW50ZWdlci5udW1iZXJPZlRyYWlsaW5nWmVyb3MoY3VycmVudEJpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA+IHNpemUgPyBzaXplIDogcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gZnJvbSBpbmRleCB0byBzdGFydCBsb29raW5nIGZvciB1bnNldCBiaXRcbiAgICAgICAgICogQHJldHVybiBpbmRleCBvZiBuZXh0IHVuc2V0IGJpdCwgb3Ige0Bjb2RlIHNpemV9IGlmIG5vbmUgYXJlIHVuc2V0IHVudGlsIHRoZSBlbmRcbiAgICAgICAgICogQHNlZSAjZ2V0TmV4dFNldChpbnQpXG4gICAgICAgICAqL1xuICAgICAgICBnZXROZXh0VW5zZXQoZnJvbSAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb20gPj0gc2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgICAgIGxldCBiaXRzT2Zmc2V0ID0gTWF0aC5mbG9vcihmcm9tIC8gMzIpO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRCaXRzID0gfmJpdHNbYml0c09mZnNldF07XG4gICAgICAgICAgICAvLyBtYXNrIG9mZiBsZXNzZXIgYml0cyBmaXJzdFxuICAgICAgICAgICAgY3VycmVudEJpdHMgJj0gfigoMSA8PCAoZnJvbSAmIDB4MUYpKSAtIDEpO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYml0cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudEJpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoKytiaXRzT2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRCaXRzID0gfmJpdHNbYml0c09mZnNldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoYml0c09mZnNldCAqIDMyKSArIEludGVnZXIubnVtYmVyT2ZUcmFpbGluZ1plcm9zKGN1cnJlbnRCaXRzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPiBzaXplID8gc2l6ZSA6IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhIGJsb2NrIG9mIDMyIGJpdHMsIHN0YXJ0aW5nIGF0IGJpdCBpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaSBmaXJzdCBiaXQgdG8gc2V0XG4gICAgICAgICAqIEBwYXJhbSBuZXdCaXRzIHRoZSBuZXcgdmFsdWUgb2YgdGhlIG5leHQgMzIgYml0cy4gTm90ZSBhZ2FpbiB0aGF0IHRoZSBsZWFzdC1zaWduaWZpY2FudCBiaXRcbiAgICAgICAgICogY29ycmVzcG9uZHMgdG8gYml0IGksIHRoZSBuZXh0LWxlYXN0LXNpZ25pZmljYW50IHRvIGkrMSwgYW5kIHNvIG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QnVsayhpIC8qaW50Ki8sIG5ld0JpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy5iaXRzW01hdGguZmxvb3IoaSAvIDMyKV0gPSBuZXdCaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGEgcmFuZ2Ugb2YgYml0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0YXJ0IHN0YXJ0IG9mIHJhbmdlLCBpbmNsdXNpdmUuXG4gICAgICAgICAqIEBwYXJhbSBlbmQgZW5kIG9mIHJhbmdlLCBleGNsdXNpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNldFJhbmdlKHN0YXJ0IC8qaW50Ki8sIGVuZCAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoZW5kIDwgc3RhcnQgfHwgc3RhcnQgPCAwIHx8IGVuZCA+IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kLS07IC8vIHdpbGwgYmUgZWFzaWVyIHRvIHRyZWF0IHRoaXMgYXMgdGhlIGxhc3QgYWN0dWFsbHkgc2V0IGJpdCAtLSBpbmNsdXNpdmVcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0SW50ID0gTWF0aC5mbG9vcihzdGFydCAvIDMyKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RJbnQgPSBNYXRoLmZsb29yKGVuZCAvIDMyKTtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZmlyc3RJbnQ7IGkgPD0gbGFzdEludDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RCaXQgPSBpID4gZmlyc3RJbnQgPyAwIDogc3RhcnQgJiAweDFGO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RCaXQgPSBpIDwgbGFzdEludCA/IDMxIDogZW5kICYgMHgxRjtcbiAgICAgICAgICAgICAgICAvLyBPbmVzIGZyb20gZmlyc3RCaXQgdG8gbGFzdEJpdCwgaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgY29uc3QgbWFzayA9ICgyIDw8IGxhc3RCaXQpIC0gKDEgPDwgZmlyc3RCaXQpO1xuICAgICAgICAgICAgICAgIGJpdHNbaV0gfD0gbWFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIGFsbCBiaXRzIChzZXRzIHRvIGZhbHNlKS5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyKCkge1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5iaXRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYml0c1tpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudCBtZXRob2QgdG8gY2hlY2sgaWYgYSByYW5nZSBvZiBiaXRzIGlzIHNldCwgb3Igbm90IHNldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0YXJ0IHN0YXJ0IG9mIHJhbmdlLCBpbmNsdXNpdmUuXG4gICAgICAgICAqIEBwYXJhbSBlbmQgZW5kIG9mIHJhbmdlLCBleGNsdXNpdmVcbiAgICAgICAgICogQHBhcmFtIHZhbHVlIGlmIHRydWUsIGNoZWNrcyB0aGF0IGJpdHMgaW4gcmFuZ2UgYXJlIHNldCwgb3RoZXJ3aXNlIGNoZWNrcyB0aGF0IHRoZXkgYXJlIG5vdCBzZXRcbiAgICAgICAgICogXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgYWxsIGJpdHMgYXJlIHNldCBvciBub3Qgc2V0IGluIHJhbmdlLCBhY2NvcmRpbmcgdG8gdmFsdWUgYXJndW1lbnRcbiAgICAgICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgZW5kIGlzIGxlc3MgdGhhbiBzdGFydCBvciB0aGUgcmFuZ2UgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIGlzUmFuZ2Uoc3RhcnQgLyppbnQqLywgZW5kIC8qaW50Ki8sIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZW5kIDwgc3RhcnQgfHwgc3RhcnQgPCAwIHx8IGVuZCA+IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGVtcHR5IHJhbmdlIG1hdGNoZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZC0tOyAvLyB3aWxsIGJlIGVhc2llciB0byB0cmVhdCB0aGlzIGFzIHRoZSBsYXN0IGFjdHVhbGx5IHNldCBiaXQgLS0gaW5jbHVzaXZlXG4gICAgICAgICAgICBjb25zdCBmaXJzdEludCA9IE1hdGguZmxvb3Ioc3RhcnQgLyAzMik7XG4gICAgICAgICAgICBjb25zdCBsYXN0SW50ID0gTWF0aC5mbG9vcihlbmQgLyAzMik7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZpcnN0SW50OyBpIDw9IGxhc3RJbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Qml0ID0gaSA+IGZpcnN0SW50ID8gMCA6IHN0YXJ0ICYgMHgxRjtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Qml0ID0gaSA8IGxhc3RJbnQgPyAzMSA6IGVuZCAmIDB4MUY7XG4gICAgICAgICAgICAgICAgLy8gT25lcyBmcm9tIGZpcnN0Qml0IHRvIGxhc3RCaXQsIGluY2x1c2l2ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hc2sgPSAoMiA8PCBsYXN0Qml0KSAtICgxIDw8IGZpcnN0Qml0KSAmIDB4RkZGRkZGRkY7XG4gICAgICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6ICYgMHhGRkZGRkZGRiBhZGRlZCB0byBkaXNjYXJkIGFueXRoaW5nIGFmdGVyIDMyIGJpdHMsIGFzIEVTIGhhcyA1MyBiaXRzXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGlmIHdlJ3JlIGxvb2tpbmcgZm9yIDFzIGFuZCB0aGUgbWFza2VkIGJpdHNbaV0gaXNuJ3QgYWxsIDFzIChpczogdGhhdCxcbiAgICAgICAgICAgICAgICAvLyBlcXVhbHMgdGhlIG1hc2ssIG9yIHdlJ3JlIGxvb2tpbmcgZm9yIDBzIGFuZCB0aGUgbWFza2VkIHBvcnRpb24gaXMgbm90IGFsbCAwc1xuICAgICAgICAgICAgICAgIGlmICgoYml0c1tpXSAmIG1hc2spICE9PSAodmFsdWUgPyBtYXNrIDogMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGFwcGVuZEJpdChiaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5zaXplICsgMSk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaXRzW01hdGguZmxvb3IodGhpcy5zaXplIC8gMzIpXSB8PSAxIDw8ICh0aGlzLnNpemUgJiAweDFGKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmRzIHRoZSBsZWFzdC1zaWduaWZpY2FudCBiaXRzLCBmcm9tIHZhbHVlLCBpbiBvcmRlciBmcm9tIG1vc3Qtc2lnbmlmaWNhbnQgdG9cbiAgICAgICAgICogbGVhc3Qtc2lnbmlmaWNhbnQuIEZvciBleGFtcGxlLCBhcHBlbmRpbmcgNiBiaXRzIGZyb20gMHgwMDAwMDFFIHdpbGwgYXBwZW5kIHRoZSBiaXRzXG4gICAgICAgICAqIDAsIDEsIDEsIDEsIDEsIDAgaW4gdGhhdCBvcmRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZhbHVlIHtAY29kZSBpbnR9IGNvbnRhaW5pbmcgYml0cyB0byBhcHBlbmRcbiAgICAgICAgICogQHBhcmFtIG51bUJpdHMgYml0cyBmcm9tIHZhbHVlIHRvIGFwcGVuZFxuICAgICAgICAgKi9cbiAgICAgICAgYXBwZW5kQml0cyh2YWx1ZSAvKmludCovLCBudW1CaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChudW1CaXRzIDwgMCB8fCBudW1CaXRzID4gMzIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdOdW0gYml0cyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMzInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5zaXplICsgbnVtQml0cyk7XG4gICAgICAgICAgICAvLyBjb25zdCBhcHBlbmRCaXQgPSB0aGlzLmFwcGVuZEJpdDtcbiAgICAgICAgICAgIGZvciAobGV0IG51bUJpdHNMZWZ0ID0gbnVtQml0czsgbnVtQml0c0xlZnQgPiAwOyBudW1CaXRzTGVmdC0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRCaXQoKCh2YWx1ZSA+PiAobnVtQml0c0xlZnQgLSAxKSkgJiAweDAxKSA9PT0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kQml0QXJyYXkob3RoZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyU2l6ZSA9IG90aGVyLnNpemU7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuc2l6ZSArIG90aGVyU2l6ZSk7XG4gICAgICAgICAgICAvLyBjb25zdCBhcHBlbmRCaXQgPSB0aGlzLmFwcGVuZEJpdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3RoZXJTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEJpdChvdGhlci5nZXQoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHhvcihvdGhlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2l6ZSAhPT0gb3RoZXIuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1NpemVzIGRvblxcJ3QgbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gYml0cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBsYXN0IGludCBjb3VsZCBiZSBpbmNvbXBsZXRlIChpLmUuIG5vdCBoYXZlIDMyIGJpdHMgaW5cbiAgICAgICAgICAgICAgICAvLyBpdCkgYnV0IHRoZXJlIGlzIG5vIHByb2JsZW0gc2luY2UgMCBYT1IgMCA9PSAwLlxuICAgICAgICAgICAgICAgIGJpdHNbaV0gXj0gb3RoZXIuYml0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJpdE9mZnNldCBmaXJzdCBiaXQgdG8gc3RhcnQgd3JpdGluZ1xuICAgICAgICAgKiBAcGFyYW0gYXJyYXkgYXJyYXkgdG8gd3JpdGUgaW50by4gQnl0ZXMgYXJlIHdyaXR0ZW4gbW9zdC1zaWduaWZpY2FudCBieXRlIGZpcnN0LiBUaGlzIGlzIHRoZSBvcHBvc2l0ZVxuICAgICAgICAgKiAgb2YgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uLCB3aGljaCBpcyBleHBvc2VkIGJ5IHtAbGluayAjZ2V0Qml0QXJyYXkoKX1cbiAgICAgICAgICogQHBhcmFtIG9mZnNldCBwb3NpdGlvbiBpbiBhcnJheSB0byBzdGFydCB3cml0aW5nXG4gICAgICAgICAqIEBwYXJhbSBudW1CeXRlcyBob3cgbWFueSBieXRlcyB0byB3cml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdG9CeXRlcyhiaXRPZmZzZXQgLyppbnQqLywgYXJyYXksIG9mZnNldCAvKmludCovLCBudW1CeXRlcyAvKmludCovKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJ5dGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdGhlQnl0ZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGJpdE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZUJ5dGUgfD0gMSA8PCAoNyAtIGopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJpdE9mZnNldCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBpXSA9IC8qKGJ5dGUpKi8gdGhlQnl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB1bmRlcmx5aW5nIGFycmF5IG9mIGludHMuIFRoZSBmaXJzdCBlbGVtZW50IGhvbGRzIHRoZSBmaXJzdCAzMiBiaXRzLCBhbmQgdGhlIGxlYXN0XG4gICAgICAgICAqICAgICAgICAgc2lnbmlmaWNhbnQgYml0IGlzIGJpdCAwLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Qml0QXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXZlcnNlcyBhbGwgYml0cyBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICByZXZlcnNlKCkge1xuICAgICAgICAgICAgY29uc3QgbmV3Qml0cyA9IG5ldyBJbnQzMkFycmF5KHRoaXMuYml0cy5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gcmV2ZXJzZSBhbGwgaW50J3MgZmlyc3RcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IE1hdGguZmxvb3IoKHRoaXMuc2l6ZSAtIDEpIC8gMzIpO1xuICAgICAgICAgICAgY29uc3Qgb2xkQml0c0xlbiA9IGxlbiArIDE7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbGRCaXRzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeCA9IGJpdHNbaV07XG4gICAgICAgICAgICAgICAgeCA9ICgoeCA+PiAxKSAmIDB4NTU1NTU1NTUpIHwgKCh4ICYgMHg1NTU1NTU1NSkgPDwgMSk7XG4gICAgICAgICAgICAgICAgeCA9ICgoeCA+PiAyKSAmIDB4MzMzMzMzMzMpIHwgKCh4ICYgMHgzMzMzMzMzMykgPDwgMik7XG4gICAgICAgICAgICAgICAgeCA9ICgoeCA+PiA0KSAmIDB4MGYwZjBmMGYpIHwgKCh4ICYgMHgwZjBmMGYwZikgPDwgNCk7XG4gICAgICAgICAgICAgICAgeCA9ICgoeCA+PiA4KSAmIDB4MDBmZjAwZmYpIHwgKCh4ICYgMHgwMGZmMDBmZikgPDwgOCk7XG4gICAgICAgICAgICAgICAgeCA9ICgoeCA+PiAxNikgJiAweDAwMDBmZmZmKSB8ICgoeCAmIDB4MDAwMGZmZmYpIDw8IDE2KTtcbiAgICAgICAgICAgICAgICBuZXdCaXRzW2xlbiAtIGldID0gLyooaW50KSovIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3cgY29ycmVjdCB0aGUgaW50J3MgaWYgdGhlIGJpdCBzaXplIGlzbid0IGEgbXVsdGlwbGUgb2YgMzJcbiAgICAgICAgICAgIGlmICh0aGlzLnNpemUgIT09IG9sZEJpdHNMZW4gKiAzMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRPZmZzZXQgPSBvbGRCaXRzTGVuICogMzIgLSB0aGlzLnNpemU7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRJbnQgPSBuZXdCaXRzWzBdID4+PiBsZWZ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb2xkQml0c0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJbnQgPSBuZXdCaXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SW50IHw9IG5leHRJbnQgPDwgKDMyIC0gbGVmdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0JpdHNbaSAtIDFdID0gY3VycmVudEludDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEludCA9IG5leHRJbnQgPj4+IGxlZnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld0JpdHNbb2xkQml0c0xlbiAtIDFdID0gY3VycmVudEludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYml0cyA9IG5ld0JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG1ha2VBcnJheShzaXplIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShNYXRoLmZsb29yKChzaXplICsgMzEpIC8gMzIpKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgQml0QXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gb3RoZXIuc2l6ZSAmJiBBcnJheXMuZXF1YWxzKHRoaXMuYml0cywgb3RoZXIuYml0cyk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAzMSAqIHRoaXMuc2l6ZSArIEFycmF5cy5oYXNoQ29kZSh0aGlzLmJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgc2l6ZSA9IHRoaXMuc2l6ZTsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgoaSAmIDB4MDcpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmdldChpKSA/ICdYJyA6ICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBjbG9uZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQml0QXJyYXkodGhpcy5zaXplLCB0aGlzLmJpdHMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXG4gICAgLyoqXG4gICAgICogRW5jYXBzdWxhdGVzIGEgdHlwZSBvZiBoaW50IHRoYXQgYSBjYWxsZXIgbWF5IHBhc3MgdG8gYSBiYXJjb2RlIHJlYWRlciB0byBoZWxwIGl0XG4gICAgICogbW9yZSBxdWlja2x5IG9yIGFjY3VyYXRlbHkgZGVjb2RlIGl0LiBJdCBpcyB1cCB0byBpbXBsZW1lbnRhdGlvbnMgdG8gZGVjaWRlIHdoYXQsXG4gICAgICogaWYgYW55dGhpbmcsIHRvIGRvIHdpdGggdGhlIGluZm9ybWF0aW9uIHRoYXQgaXMgc3VwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQHNlZSBSZWFkZXIjZGVjb2RlKEJpbmFyeUJpdG1hcCxqYXZhLnV0aWwuTWFwKVxuICAgICAqL1xuICAgIHZhciBEZWNvZGVIaW50VHlwZTtcbiAgICAoZnVuY3Rpb24gKERlY29kZUhpbnRUeXBlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnNwZWNpZmllZCwgYXBwbGljYXRpb24tc3BlY2lmaWMgaGludC4gTWFwcyB0byBhbiB1bnNwZWNpZmllZCB7QGxpbmsgT2JqZWN0fS5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiT1RIRVJcIl0gPSAwXSA9IFwiT1RIRVJcIjsgLyooT2JqZWN0LmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbWFnZSBpcyBhIHB1cmUgbW9ub2Nocm9tZSBpbWFnZSBvZiBhIGJhcmNvZGUuIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bztcbiAgICAgICAgICogdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJQVVJFX0JBUkNPREVcIl0gPSAxXSA9IFwiUFVSRV9CQVJDT0RFXCI7IC8qKFZvaWQuY2xhc3MpKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltYWdlIGlzIGtub3duIHRvIGJlIG9mIG9uZSBvZiBhIGZldyBwb3NzaWJsZSBmb3JtYXRzLlxuICAgICAgICAgKiBNYXBzIHRvIGEge0BsaW5rIExpc3R9IG9mIHtAbGluayBCYXJjb2RlRm9ybWF0fXMuXG4gICAgICAgICAqL1xuICAgICAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIlBPU1NJQkxFX0ZPUk1BVFNcIl0gPSAyXSA9IFwiUE9TU0lCTEVfRk9STUFUU1wiOyAvKihMaXN0LmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVuZCBtb3JlIHRpbWUgdG8gdHJ5IHRvIGZpbmQgYSBiYXJjb2RlOyBvcHRpbWl6ZSBmb3IgYWNjdXJhY3ksIG5vdCBzcGVlZC5cbiAgICAgICAgICogRG9lc24ndCBtYXR0ZXIgd2hhdCBpdCBtYXBzIHRvOyB1c2Uge0BsaW5rIEJvb2xlYW4jVFJVRX0uXG4gICAgICAgICAqL1xuICAgICAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIlRSWV9IQVJERVJcIl0gPSAzXSA9IFwiVFJZX0hBUkRFUlwiOyAvKihWb2lkLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hhdCBjaGFyYWN0ZXIgZW5jb2RpbmcgdG8gdXNlIHdoZW4gZGVjb2RpbmcsIHdoZXJlIGFwcGxpY2FibGUgKHR5cGUgU3RyaW5nKVxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJDSEFSQUNURVJfU0VUXCJdID0gNF0gPSBcIkNIQVJBQ1RFUl9TRVRcIjsgLyooU3RyaW5nLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd2VkIGxlbmd0aHMgb2YgZW5jb2RlZCBkYXRhIC0tIHJlamVjdCBhbnl0aGluZyBlbHNlLiBNYXBzIHRvIGFuIHtAY29kZSBJbnQzMkFycmF5fS5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiQUxMT1dFRF9MRU5HVEhTXCJdID0gNV0gPSBcIkFMTE9XRURfTEVOR1RIU1wiOyAvKihJbnQzMkFycmF5LmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3N1bWUgQ29kZSAzOSBjb2RlcyBlbXBsb3kgYSBjaGVjayBkaWdpdC4gRG9lc24ndCBtYXR0ZXIgd2hhdCBpdCBtYXBzIHRvO1xuICAgICAgICAgKiB1c2Uge0BsaW5rIEJvb2xlYW4jVFJVRX0uXG4gICAgICAgICAqL1xuICAgICAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIkFTU1VNRV9DT0RFXzM5X0NIRUNLX0RJR0lUXCJdID0gNl0gPSBcIkFTU1VNRV9DT0RFXzM5X0NIRUNLX0RJR0lUXCI7IC8qKFZvaWQuY2xhc3MpKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc3VtZSB0aGUgYmFyY29kZSBpcyBiZWluZyBwcm9jZXNzZWQgYXMgYSBHUzEgYmFyY29kZSwgYW5kIG1vZGlmeSBiZWhhdmlvciBhcyBuZWVkZWQuXG4gICAgICAgICAqIEZvciBleGFtcGxlIHRoaXMgYWZmZWN0cyBGTkMxIGhhbmRsaW5nIGZvciBDb2RlIDEyOCAoYWthIEdTMS0xMjgpLiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87XG4gICAgICAgICAqIHVzZSB7QGxpbmsgQm9vbGVhbiNUUlVFfS5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiQVNTVU1FX0dTMVwiXSA9IDddID0gXCJBU1NVTUVfR1MxXCI7IC8qKFZvaWQuY2xhc3MpKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHJldHVybiB0aGUgc3RhcnQgYW5kIGVuZCBkaWdpdHMgaW4gYSBDb2RhYmFyIGJhcmNvZGUgaW5zdGVhZCBvZiBzdHJpcHBpbmcgdGhlbS4gVGhleVxuICAgICAgICAgKiBhcmUgYWxwaGEsIHdoZXJlYXMgdGhlIHJlc3QgYXJlIG51bWVyaWMuIEJ5IGRlZmF1bHQsIHRoZXkgYXJlIHN0cmlwcGVkLCBidXQgdGhpcyBjYXVzZXMgdGhlbVxuICAgICAgICAgKiB0byBub3QgYmUuIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bzsgdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJSRVRVUk5fQ09EQUJBUl9TVEFSVF9FTkRcIl0gPSA4XSA9IFwiUkVUVVJOX0NPREFCQVJfU1RBUlRfRU5EXCI7IC8qKFZvaWQuY2xhc3MpKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYWxsZXIgbmVlZHMgdG8gYmUgbm90aWZpZWQgdmlhIGNhbGxiYWNrIHdoZW4gYSBwb3NzaWJsZSB7QGxpbmsgUmVzdWx0UG9pbnR9XG4gICAgICAgICAqIGlzIGZvdW5kLiBNYXBzIHRvIGEge0BsaW5rIFJlc3VsdFBvaW50Q2FsbGJhY2t9LlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDS1wiXSA9IDldID0gXCJORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDS1wiOyAvKihSZXN1bHRQb2ludENhbGxiYWNrLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd2VkIGV4dGVuc2lvbiBsZW5ndGhzIGZvciBFQU4gb3IgVVBDIGJhcmNvZGVzLiBPdGhlciBmb3JtYXRzIHdpbGwgaWdub3JlIHRoaXMuXG4gICAgICAgICAqIE1hcHMgdG8gYW4ge0Bjb2RlIEludDMyQXJyYXl9IG9mIHRoZSBhbGxvd2VkIGV4dGVuc2lvbiBsZW5ndGhzLCBmb3IgZXhhbXBsZSBbMl0sIFs1XSwgb3IgWzIsIDVdLlxuICAgICAgICAgKiBJZiBpdCBpcyBvcHRpb25hbCB0byBoYXZlIGFuIGV4dGVuc2lvbiwgZG8gbm90IHNldCB0aGlzIGhpbnQuIElmIHRoaXMgaXMgc2V0LFxuICAgICAgICAgKiBhbmQgYSBVUEMgb3IgRUFOIGJhcmNvZGUgaXMgZm91bmQgYnV0IGFuIGV4dGVuc2lvbiBpcyBub3QsIHRoZW4gbm8gcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgICAgICogYXQgYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJBTExPV0VEX0VBTl9FWFRFTlNJT05TXCJdID0gMTBdID0gXCJBTExPV0VEX0VBTl9FWFRFTlNJT05TXCI7IC8qKEludDMyQXJyYXkuY2xhc3MpKi9cbiAgICAgICAgLy8gRW5kIG9mIGVudW1lcmF0aW9uIHZhbHVlcy5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGEgdHlwZSB0aGUgaGludCBpcyBleHBlY3RpbmcuXG4gICAgICAgICAqIEFtb25nIHRoZSBwb3NzaWJsZSB2YWx1ZXMgdGhlIHtAbGluayBWb2lkfSBzdGFuZHMgb3V0IGFzIGJlaW5nIHVzZWQgZm9yXG4gICAgICAgICAqIGhpbnRzIHRoYXQgZG8gbm90IGV4cGVjdCBhIHZhbHVlIHRvIGJlIHN1cHBsaWVkIChmbGFnIGhpbnRzKS4gU3VjaCBoaW50c1xuICAgICAgICAgKiB3aWxsIHBvc3NpYmx5IGhhdmUgdGhlaXIgdmFsdWUgaWdub3JlZCwgb3IgcmVwbGFjZWQgYnkgYVxuICAgICAgICAgKiB7QGxpbmsgQm9vbGVhbiNUUlVFfS4gSGludCBzdXBwbGllcnMgc2hvdWxkIHByb2JhYmx5IHVzZVxuICAgICAgICAgKiB7QGxpbmsgQm9vbGVhbiNUUlVFfSBhcyBkaXJlY3RlZCBieSB0aGUgYWN0dWFsIGhpbnQgZG9jdW1lbnRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIC8vIHByaXZhdGUgdmFsdWVUeXBlOiBDbGFzczw/PlxuICAgICAgICAvLyBEZWNvZGVIaW50VHlwZSh2YWx1ZVR5cGU6IENsYXNzPD8+KSB7XG4gICAgICAgIC8vICAgdGhpcy52YWx1ZVR5cGUgPSB2YWx1ZVR5cGVcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBwdWJsaWMgZ2V0VmFsdWVUeXBlKCk6IENsYXNzPD8+IHtcbiAgICAgICAgLy8gICByZXR1cm4gdmFsdWVUeXBlXG4gICAgICAgIC8vIH1cbiAgICB9KShEZWNvZGVIaW50VHlwZSB8fCAoRGVjb2RlSGludFR5cGUgPSB7fSkpO1xuICAgIHZhciBEZWNvZGVIaW50VHlwZSQxID0gRGVjb2RlSGludFR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgRm9ybWF0RXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICAgICAgc3RhdGljIGdldEZvcm1hdEluc3RhbmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBGb3JtYXRFeGNlcHRpb24ua2luZCA9ICdGb3JtYXRFeGNlcHRpb24nO1xuXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkhhc2hNYXA7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgdmFyIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnM7XG4gICAgKGZ1bmN0aW9uIChDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzKSB7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwNDM3XCJdID0gMF0gPSBcIkNwNDM3XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMVwiXSA9IDFdID0gXCJJU084ODU5XzFcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8yXCJdID0gMl0gPSBcIklTTzg4NTlfMlwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzNcIl0gPSAzXSA9IFwiSVNPODg1OV8zXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfNFwiXSA9IDRdID0gXCJJU084ODU5XzRcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV81XCJdID0gNV0gPSBcIklTTzg4NTlfNVwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzZcIl0gPSA2XSA9IFwiSVNPODg1OV82XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfN1wiXSA9IDddID0gXCJJU084ODU5XzdcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV84XCJdID0gOF0gPSBcIklTTzg4NTlfOFwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzlcIl0gPSA5XSA9IFwiSVNPODg1OV85XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMTBcIl0gPSAxMF0gPSBcIklTTzg4NTlfMTBcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xMVwiXSA9IDExXSA9IFwiSVNPODg1OV8xMVwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzEzXCJdID0gMTJdID0gXCJJU084ODU5XzEzXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMTRcIl0gPSAxM10gPSBcIklTTzg4NTlfMTRcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xNVwiXSA9IDE0XSA9IFwiSVNPODg1OV8xNVwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzE2XCJdID0gMTVdID0gXCJJU084ODU5XzE2XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIlNKSVNcIl0gPSAxNl0gPSBcIlNKSVNcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQ3AxMjUwXCJdID0gMTddID0gXCJDcDEyNTBcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQ3AxMjUxXCJdID0gMThdID0gXCJDcDEyNTFcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQ3AxMjUyXCJdID0gMTldID0gXCJDcDEyNTJcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQ3AxMjU2XCJdID0gMjBdID0gXCJDcDEyNTZcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiVW5pY29kZUJpZ1VubWFya2VkXCJdID0gMjFdID0gXCJVbmljb2RlQmlnVW5tYXJrZWRcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiVVRGOFwiXSA9IDIyXSA9IFwiVVRGOFwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJBU0NJSVwiXSA9IDIzXSA9IFwiQVNDSUlcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQmlnNVwiXSA9IDI0XSA9IFwiQmlnNVwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJHQjE4MDMwXCJdID0gMjVdID0gXCJHQjE4MDMwXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkVVQ19LUlwiXSA9IDI2XSA9IFwiRVVDX0tSXCI7XG4gICAgfSkoQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycyB8fCAoQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycyA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogRW5jYXBzdWxhdGVzIGEgQ2hhcmFjdGVyIFNldCBFQ0ksIGFjY29yZGluZyB0byBcIkV4dGVuZGVkIENoYW5uZWwgSW50ZXJwcmV0YXRpb25zXCIgNS4zLjEuMVxuICAgICAqIG9mIElTTyAxODAwNC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgQ2hhcmFjdGVyU2V0RUNJIHtcbiAgICAgICAgY29uc3RydWN0b3IodmFsdWVJZGVudGlmaWVyLCB2YWx1ZXNQYXJhbSwgbmFtZSwgLi4ub3RoZXJFbmNvZGluZ05hbWVzKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlSWRlbnRpZmllciA9IHZhbHVlSWRlbnRpZmllcjtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlc1BhcmFtID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gSW50MzJBcnJheS5mcm9tKFt2YWx1ZXNQYXJhbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXNQYXJhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3RoZXJFbmNvZGluZ05hbWVzID0gb3RoZXJFbmNvZGluZ05hbWVzO1xuICAgICAgICAgICAgQ2hhcmFjdGVyU2V0RUNJLlZBTFVFX0lERU5USUZJRVJfVE9fRUNJLnNldCh2YWx1ZUlkZW50aWZpZXIsIHRoaXMpO1xuICAgICAgICAgICAgQ2hhcmFjdGVyU2V0RUNJLk5BTUVfVE9fRUNJLnNldChuYW1lLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7IGkgIT09IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBDaGFyYWN0ZXJTZXRFQ0kuVkFMVUVTX1RPX0VDSS5zZXQodiwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG90aGVyTmFtZSBvZiBvdGhlckVuY29kaW5nTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBDaGFyYWN0ZXJTZXRFQ0kuTkFNRV9UT19FQ0kuc2V0KG90aGVyTmFtZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hhcmFjdGVyU2V0RUNJKHZhbHVlOiBudW1iZXIgLyppbnQqLykge1xuICAgICAgICAvLyAgIHRoaXMobmV3IEludDMyQXJyYXkge3ZhbHVlfSlcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBDaGFyYWN0ZXJTZXRFQ0kodmFsdWU6IG51bWJlciAvKmludCovLCBTdHJpbmcuLi4gb3RoZXJFbmNvZGluZ05hbWVzKSB7XG4gICAgICAgIC8vICAgdGhpcy52YWx1ZXMgPSBuZXcgSW50MzJBcnJheSB7dmFsdWV9XG4gICAgICAgIC8vICAgdGhpcy5vdGhlckVuY29kaW5nTmFtZXMgPSBvdGhlckVuY29kaW5nTmFtZXNcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBDaGFyYWN0ZXJTZXRFQ0kodmFsdWVzOiBJbnQzMkFycmF5LCBTdHJpbmcuLi4gb3RoZXJFbmNvZGluZ05hbWVzKSB7XG4gICAgICAgIC8vICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXNcbiAgICAgICAgLy8gICB0aGlzLm90aGVyRW5jb2RpbmdOYW1lcyA9IG90aGVyRW5jb2RpbmdOYW1lc1xuICAgICAgICAvLyB9XG4gICAgICAgIGdldFZhbHVlSWRlbnRpZmllcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlSWRlbnRpZmllcjtcbiAgICAgICAgfVxuICAgICAgICBnZXROYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1swXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHZhbHVlIGNoYXJhY3RlciBzZXQgRUNJIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4ge0Bjb2RlIENoYXJhY3RlclNldEVDSX0gcmVwcmVzZW50aW5nIEVDSSBvZiBnaXZlbiB2YWx1ZSwgb3IgbnVsbCBpZiBpdCBpcyBsZWdhbCBidXRcbiAgICAgICAgICogICB1bnN1cHBvcnRlZFxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBFQ0kgdmFsdWUgaXMgaW52YWxpZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldENoYXJhY3RlclNldEVDSUJ5VmFsdWUodmFsdWUgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSA5MDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCdpbmNvcmVjdCB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhcmFjdGVyU2V0ID0gQ2hhcmFjdGVyU2V0RUNJLlZBTFVFU19UT19FQ0kuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNoYXJhY3RlclNldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oJ2luY29yZWN0IHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhcmFjdGVyU2V0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZSBjaGFyYWN0ZXIgc2V0IEVDSSBlbmNvZGluZyBuYW1lXG4gICAgICAgICAqIEByZXR1cm4gQ2hhcmFjdGVyU2V0RUNJIHJlcHJlc2VudGluZyBFQ0kgZm9yIGNoYXJhY3RlciBlbmNvZGluZywgb3IgbnVsbCBpZiBpdCBpcyBsZWdhbFxuICAgICAgICAgKiAgIGJ1dCB1bnN1cHBvcnRlZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldENoYXJhY3RlclNldEVDSUJ5TmFtZShuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJTZXQgPSBDaGFyYWN0ZXJTZXRFQ0kuTkFNRV9UT19FQ0kuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY2hhcmFjdGVyU2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbignaW5jb3JlY3QgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFyYWN0ZXJTZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBDaGFyYWN0ZXJTZXRFQ0kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZSgpID09PSBvdGhlci5nZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2hhcmFjdGVyU2V0RUNJLlZBTFVFX0lERU5USUZJRVJfVE9fRUNJID0gbmV3IE1hcCgpO1xuICAgIENoYXJhY3RlclNldEVDSS5WQUxVRVNfVE9fRUNJID0gbmV3IE1hcCgpO1xuICAgIENoYXJhY3RlclNldEVDSS5OQU1FX1RPX0VDSSA9IG5ldyBNYXAoKTtcbiAgICAvLyBFbnVtIG5hbWUgaXMgYSBKYXZhIGVuY29kaW5nIHZhbGlkIGZvciBqYXZhLmxhbmcgYW5kIGphdmEuaW9cbiAgICAvLyBUWVBFU0NSSVBUUE9SVDogY2hhbmdlZCB0aGUgbWFpbiBsYWJlbCBmb3IgSVNPIGFzIHRoZSBUZXh0RW5jb2RlciBkaWQgbm90IHJlY29nbml6ZWQgdGhlbSBpbiB0aGUgZm9ybSBmcm9tIGphdmFcbiAgICAvLyAoZWcgSVNPODg1OV8xIG11c3QgYmUgSVNPODg1OTEgb3IgSVNPODg1OS0xIG9yIElTTy04ODU5LTEpXG4gICAgLy8gbGF0ZXIgb246IHdlbGwsIGV4Y2VwdCAxNiB3aWNoIGRvZXMgbm90IHdvcmsgd2l0aCBJU084ODU5MTYgc28gdXNlZCBJU08tODg1OS0xIGZvcm0gZm9yIGRlZmF1bHRcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3A0MzcgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3A0MzcsIEludDMyQXJyYXkuZnJvbShbMCwgMl0pLCAnQ3A0MzcnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMSwgSW50MzJBcnJheS5mcm9tKFsxLCAzXSksICdJU08tODg1OS0xJywgJ0lTTzg4NTkxJywgJ0lTTzg4NTlfMScpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzIgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8yLCA0LCAnSVNPLTg4NTktMicsICdJU084ODU5MicsICdJU084ODU5XzInKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8zID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMywgNSwgJ0lTTy04ODU5LTMnLCAnSVNPODg1OTMnLCAnSVNPODg1OV8zJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzQsIDYsICdJU08tODg1OS00JywgJ0lTTzg4NTk0JywgJ0lTTzg4NTlfNCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzUgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV81LCA3LCAnSVNPLTg4NTktNScsICdJU084ODU5NScsICdJU084ODU5XzUnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV82ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfNiwgOCwgJ0lTTy04ODU5LTYnLCAnSVNPODg1OTYnLCAnSVNPODg1OV82Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzcsIDksICdJU08tODg1OS03JywgJ0lTTzg4NTk3JywgJ0lTTzg4NTlfNycpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzggPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV84LCAxMCwgJ0lTTy04ODU5LTgnLCAnSVNPODg1OTgnLCAnSVNPODg1OV84Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfOSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzksIDExLCAnSVNPLTg4NTktOScsICdJU084ODU5OScsICdJU084ODU5XzknKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xMCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzEwLCAxMiwgJ0lTTy04ODU5LTEwJywgJ0lTTzg4NTkxMCcsICdJU084ODU5XzEwJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTEgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xMSwgMTMsICdJU08tODg1OS0xMScsICdJU084ODU5MTEnLCAnSVNPODg1OV8xMScpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzEzID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTMsIDE1LCAnSVNPLTg4NTktMTMnLCAnSVNPODg1OTEzJywgJ0lTTzg4NTlfMTMnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xNCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzE0LCAxNiwgJ0lTTy04ODU5LTE0JywgJ0lTTzg4NTkxNCcsICdJU084ODU5XzE0Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTUgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xNSwgMTcsICdJU08tODg1OS0xNScsICdJU084ODU5MTUnLCAnSVNPODg1OV8xNScpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzE2ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTYsIDE4LCAnSVNPLTg4NTktMTYnLCAnSVNPODg1OTE2JywgJ0lTTzg4NTlfMTYnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuU0pJUyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5TSklTLCAyMCwgJ1NKSVMnLCAnU2hpZnRfSklTJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkNwMTI1MCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5DcDEyNTAsIDIxLCAnQ3AxMjUwJywgJ3dpbmRvd3MtMTI1MCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5DcDEyNTEgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3AxMjUxLCAyMiwgJ0NwMTI1MScsICd3aW5kb3dzLTEyNTEnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3AxMjUyID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwMTI1MiwgMjMsICdDcDEyNTInLCAnd2luZG93cy0xMjUyJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkNwMTI1NiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5DcDEyNTYsIDI0LCAnQ3AxMjU2JywgJ3dpbmRvd3MtMTI1NicpO1xuICAgIENoYXJhY3RlclNldEVDSS5Vbmljb2RlQmlnVW5tYXJrZWQgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuVW5pY29kZUJpZ1VubWFya2VkLCAyNSwgJ1VuaWNvZGVCaWdVbm1hcmtlZCcsICdVVEYtMTZCRScsICdVbmljb2RlQmlnJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLlVURjggPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuVVRGOCwgMjYsICdVVEY4JywgJ1VURi04Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkFTQ0lJID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkFTQ0lJLCBJbnQzMkFycmF5LmZyb20oWzI3LCAxNzBdKSwgJ0FTQ0lJJywgJ1VTLUFTQ0lJJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkJpZzUgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQmlnNSwgMjgsICdCaWc1Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkdCMTgwMzAgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuR0IxODAzMCwgMjksICdHQjE4MDMwJywgJ0dCMjMxMicsICdFVUNfQ04nLCAnR0JLJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkVVQ19LUiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5FVUNfS1IsIDMwLCAnRVVDX0tSJywgJ0VVQy1LUicpO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICB9XG4gICAgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24ua2luZCA9ICdVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbic7XG5cbiAgICAvKipcbiAgICAgKiBSZXNwb25zaWJsZSBmb3IgZW4vZGVjb2Rpbmcgc3RyaW5ncy5cbiAgICAgKi9cbiAgICBjbGFzcyBTdHJpbmdFbmNvZGluZyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIHNvbWUgVWludDhBcnJheSB0byBhIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlKGJ5dGVzLCBlbmNvZGluZykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RpbmdOYW1lID0gdGhpcy5lbmNvZGluZ05hbWUoZW5jb2RpbmcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VzdG9tRGVjb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbURlY29kZXIoYnl0ZXMsIGVuY29kaW5nTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbmNyZWFzZXMgYnJvd3NlciBzdXBwb3J0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5zaG91bGREZWNvZGVPbkZhbGxiYWNrKGVuY29kaW5nTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGYWxsYmFjayhieXRlcywgZW5jb2RpbmdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmdOYW1lKS5kZWNvZGUoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGRlY29kaW5nIG1ldGhvZCBzaG91bGQgdXNlIHRoZSBmYWxsYmFjayBmb3IgZGVjb2RpbmdcbiAgICAgICAgICogb25jZSBOb2RlIFRleHREZWNvZGVyIGRvZXNuJ3Qgc3VwcG9ydCBhbGwgZW5jb2RpbmcgZm9ybWF0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVuY29kaW5nTmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHNob3VsZERlY29kZU9uRmFsbGJhY2soZW5jb2RpbmdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gIVN0cmluZ0VuY29kaW5nLmlzQnJvd3NlcigpICYmIGVuY29kaW5nTmFtZSA9PT0gJ0lTTy04ODU5LTEnO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHNvbWUgc3RyaW5nIGludG8gYSBVaW50OEFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kZShzLCBlbmNvZGluZykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RpbmdOYW1lID0gdGhpcy5lbmNvZGluZ05hbWUoZW5jb2RpbmcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VzdG9tRW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbUVuY29kZXIocywgZW5jb2RpbmdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluY3JlYXNlcyBicm93c2VyIHN1cHBvcnQuXG4gICAgICAgICAgICBpZiAodHlwZW9mIFRleHRFbmNvZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZUZhbGxiYWNrKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGV4dEVuY29kZXIgb25seSBlbmNvZGVzIHRvIFVURjggYnkgZGVmYXVsdCBhcyBzcGVjaWZpZWQgYnkgZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpc0Jyb3dzZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwod2luZG93KSA9PT0gJ1tvYmplY3QgV2luZG93XScpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgdmFsdWUgZnJvbSBzb21lIGVuY29kaW5nIGNoYXJhY3RlciBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZW5jb2RpbmdOYW1lKGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gZW5jb2RpbmdcbiAgICAgICAgICAgICAgICA6IGVuY29kaW5nLmdldE5hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBjaGFyYWN0ZXIgc2V0IGZyb20gc29tZSBlbmNvZGluZyBjaGFyYWN0ZXIgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kaW5nQ2hhcmFjdGVyU2V0KGVuY29kaW5nKSB7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcgaW5zdGFuY2VvZiBDaGFyYWN0ZXJTZXRFQ0kpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2Rpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2hhcmFjdGVyU2V0RUNJLmdldENoYXJhY3RlclNldEVDSUJ5TmFtZShlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJ1bnMgYSBmYWxsYmFjayBmb3IgdGhlIG5hdGl2ZSBkZWNvZGluZyBmdW5jaW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUZhbGxiYWNrKGJ5dGVzLCBlbmNvZGluZykge1xuICAgICAgICAgICAgY29uc3QgY2hhcmFjdGVyU2V0ID0gdGhpcy5lbmNvZGluZ0NoYXJhY3RlclNldChlbmNvZGluZyk7XG4gICAgICAgICAgICBpZiAoU3RyaW5nRW5jb2RpbmcuaXNEZWNvZGVGYWxsYmFja1N1cHBvcnRlZChjaGFyYWN0ZXJTZXQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGggPSBieXRlc1tpXS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gJyUnICsgaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJTZXQuZXF1YWxzKENoYXJhY3RlclNldEVDSS5Vbmljb2RlQmlnVW5tYXJrZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ5dGVzLmJ1ZmZlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKGBFbmNvZGluZyAke3RoaXMuZW5jb2RpbmdOYW1lKGVuY29kaW5nKX0gbm90IHN1cHBvcnRlZCBieSBmYWxsYmFjay5gKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNEZWNvZGVGYWxsYmFja1N1cHBvcnRlZChjaGFyYWN0ZXJTZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFyYWN0ZXJTZXQuZXF1YWxzKENoYXJhY3RlclNldEVDSS5VVEY4KSB8fFxuICAgICAgICAgICAgICAgIGNoYXJhY3RlclNldC5lcXVhbHMoQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMSkgfHxcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJTZXQuZXF1YWxzKENoYXJhY3RlclNldEVDSS5BU0NJSSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJ1bnMgYSBmYWxsYmFjayBmb3IgdGhlIG5hdGl2ZSBlbmNvZGluZyBmdW5jaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzE5Mjg0NS80MzY3NjgzXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZW5jb2RlRmFsbGJhY2socykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFVSSXN0cmluZyA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHMpKSk7XG4gICAgICAgICAgICBjb25zdCBjaGFyTGlzdCA9IGVuY29kZWRVUklzdHJpbmcuc3BsaXQoJycpO1xuICAgICAgICAgICAgY29uc3QgdWludEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdWludEFycmF5LnB1c2goY2hhckxpc3RbaV0uY2hhckNvZGVBdCgwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodWludEFycmF5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IChDKSAyMDEwIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENvbW1vbiBzdHJpbmctcmVsYXRlZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgQWxleCBEdXByZVxuICAgICAqL1xuICAgIGNsYXNzIFN0cmluZ1V0aWxzIHtcbiAgICAgICAgLy8gU0hJRlRfSklTLmVxdWFsc0lnbm9yZUNhc2UoUExBVEZPUk1fREVGQVVMVF9FTkNPRElORykgfHxcbiAgICAgICAgLy8gRVVDX0pQLmVxdWFsc0lnbm9yZUNhc2UoUExBVEZPUk1fREVGQVVMVF9FTkNPRElORyk7XG4gICAgICAgIHN0YXRpYyBjYXN0QXNOb25VdGY4Q2hhcihjb2RlLCBlbmNvZGluZyA9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElTTyA4ODU5LTEgaXMgdGhlIEphdmEgZGVmYXVsdCBhcyBVVEYtOCBpcyBKYXZhU2NyaXB0c1xuICAgICAgICAgICAgLy8geW91IGNhbiBzZWUgdGhpcyBtZXRob2QgYXMgYSBKYXZhIHZlcnNpb24gb2YgU3RyaW5nLmZyb21DaGFyQ29kZVxuICAgICAgICAgICAgY29uc3QgZSA9IGVuY29kaW5nID8gZW5jb2RpbmcuZ2V0TmFtZSgpIDogdGhpcy5JU084ODU5MTtcbiAgICAgICAgICAgIC8vIHVzZSBwYXNzZWQgZm9ybWF0IChmcm9tQ2hhckNvZGUgd2lsbCByZXR1cm4gVVRGOCBlbmNvZGluZylcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdFbmNvZGluZy5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoW2NvZGVdKSwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBieXRlcyBieXRlcyBlbmNvZGluZyBhIHN0cmluZywgd2hvc2UgZW5jb2Rpbmcgc2hvdWxkIGJlIGd1ZXNzZWRcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIGRlY29kZSBoaW50cyBpZiBhcHBsaWNhYmxlXG4gICAgICAgICAqIEByZXR1cm4gbmFtZSBvZiBndWVzc2VkIGVuY29kaW5nOyBhdCB0aGUgbW9tZW50IHdpbGwgb25seSBndWVzcyBvbmUgb2Y6XG4gICAgICAgICAqICB7QGxpbmsgI1NISUZUX0pJU30sIHtAbGluayAjVVRGOH0sIHtAbGluayAjSVNPODg1OTF9LCBvciB0aGUgcGxhdGZvcm1cbiAgICAgICAgICogIGRlZmF1bHQgZW5jb2RpbmcgaWYgbm9uZSBvZiB0aGVzZSBjYW4gcG9zc2libHkgYmUgY29ycmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGd1ZXNzRW5jb2RpbmcoYnl0ZXMsIGhpbnRzKSB7XG4gICAgICAgICAgICBpZiAoaGludHMgIT09IG51bGwgJiYgaGludHMgIT09IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQgIT09IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLkNIQVJBQ1RFUl9TRVQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLkNIQVJBQ1RFUl9TRVQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb3Igbm93LCBtZXJlbHkgdHJpZXMgdG8gZGlzdGluZ3Vpc2ggSVNPLTg4NTktMSwgVVRGLTggYW5kIFNoaWZ0X0pJUyxcbiAgICAgICAgICAgIC8vIHdoaWNoIHNob3VsZCBiZSBieSBmYXIgdGhlIG1vc3QgY29tbW9uIGVuY29kaW5ncy5cbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjYW5CZUlTTzg4NTkxID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBjYW5CZVNoaWZ0SklTID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBjYW5CZVVURjggPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHV0ZjhCeXRlc0xlZnQgPSAwO1xuICAgICAgICAgICAgLy8gaW50IHV0ZjhMb3dDaGFycyA9IDBcbiAgICAgICAgICAgIGxldCB1dGYyQnl0ZXNDaGFycyA9IDA7XG4gICAgICAgICAgICBsZXQgdXRmM0J5dGVzQ2hhcnMgPSAwO1xuICAgICAgICAgICAgbGV0IHV0ZjRCeXRlc0NoYXJzID0gMDtcbiAgICAgICAgICAgIGxldCBzamlzQnl0ZXNMZWZ0ID0gMDtcbiAgICAgICAgICAgIC8vIGludCBzamlzTG93Q2hhcnMgPSAwXG4gICAgICAgICAgICBsZXQgc2ppc0thdGFrYW5hQ2hhcnMgPSAwO1xuICAgICAgICAgICAgLy8gaW50IHNqaXNEb3VibGVCeXRlc0NoYXJzID0gMFxuICAgICAgICAgICAgbGV0IHNqaXNDdXJLYXRha2FuYVdvcmRMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGV0IHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGV0IHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGV0IHNqaXNNYXhEb3VibGVCeXRlc1dvcmRMZW5ndGggPSAwO1xuICAgICAgICAgICAgLy8gaW50IGlzb0xvd0NoYXJzID0gMFxuICAgICAgICAgICAgLy8gaW50IGlzb0hpZ2hDaGFycyA9IDBcbiAgICAgICAgICAgIGxldCBpc29IaWdoT3RoZXIgPSAwO1xuICAgICAgICAgICAgY29uc3QgdXRmOGJvbSA9IGJ5dGVzLmxlbmd0aCA+IDMgJiZcbiAgICAgICAgICAgICAgICBieXRlc1swXSA9PT0gLyooYnl0ZSkgKi8gMHhFRiAmJlxuICAgICAgICAgICAgICAgIGJ5dGVzWzFdID09PSAvKihieXRlKSAqLyAweEJCICYmXG4gICAgICAgICAgICAgICAgYnl0ZXNbMl0gPT09IC8qKGJ5dGUpICovIDB4QkY7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aCAmJiAoY2FuQmVJU084ODU5MSB8fCBjYW5CZVNoaWZ0SklTIHx8IGNhbkJlVVRGOCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYnl0ZXNbaV0gJiAweEZGO1xuICAgICAgICAgICAgICAgIC8vIFVURi04IHN0dWZmXG4gICAgICAgICAgICAgICAgaWYgKGNhbkJlVVRGOCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXRmOEJ5dGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDgwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmOEJ5dGVzTGVmdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh2YWx1ZSAmIDB4ODApICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHg0MCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHgyMCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmMkJ5dGVzQ2hhcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4MTApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGYzQnl0ZXNDaGFycysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmOEJ5dGVzTGVmdCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4MDgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmNEJ5dGVzQ2hhcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB1dGY4TG93Q2hhcnMrK1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElTTy04ODU5LTEgc3R1ZmZcbiAgICAgICAgICAgICAgICBpZiAoY2FuQmVJU084ODU5MSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAweDdGICYmIHZhbHVlIDwgMHhBMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVJU084ODU5MSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMHg5Rikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHhDMCB8fCB2YWx1ZSA9PT0gMHhENyB8fCB2YWx1ZSA9PT0gMHhGNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzb0hpZ2hPdGhlcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzb0hpZ2hDaGFycysrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzb0xvd0NoYXJzKytcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaGlmdF9KSVMgc3R1ZmZcbiAgICAgICAgICAgICAgICBpZiAoY2FuQmVTaGlmdEpJUykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2ppc0J5dGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4NDAgfHwgdmFsdWUgPT09IDB4N0YgfHwgdmFsdWUgPiAweEZDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVTaGlmdEpJUyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ppc0J5dGVzTGVmdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAweDgwIHx8IHZhbHVlID09PSAweEEwIHx8IHZhbHVlID4gMHhFRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVTaGlmdEpJUyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMHhBMCAmJiB2YWx1ZSA8IDB4RTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNLYXRha2FuYUNoYXJzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNDdXJLYXRha2FuYVdvcmRMZW5ndGgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID4gc2ppc01heEthdGFrYW5hV29yZExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPSBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMHg3Rikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ppc0J5dGVzTGVmdCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2ppc0RvdWJsZUJ5dGVzQ2hhcnMrK1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCA+IHNqaXNNYXhEb3VibGVCeXRlc1dvcmRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNqaXNMb3dDaGFycysrXG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbkJlVVRGOCAmJiB1dGY4Qnl0ZXNMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbkJlU2hpZnRKSVMgJiYgc2ppc0J5dGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICBjYW5CZVNoaWZ0SklTID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFYXN5IC0tIGlmIHRoZXJlIGlzIEJPTSBvciBhdCBsZWFzdCAxIHZhbGlkIG5vdC1zaW5nbGUgYnl0ZSBjaGFyYWN0ZXIgKGFuZCBubyBldmlkZW5jZSBpdCBjYW4ndCBiZSBVVEYtOCksIGRvbmVcbiAgICAgICAgICAgIGlmIChjYW5CZVVURjggJiYgKHV0Zjhib20gfHwgdXRmMkJ5dGVzQ2hhcnMgKyB1dGYzQnl0ZXNDaGFycyArIHV0ZjRCeXRlc0NoYXJzID4gMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuVVRGODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVhc3kgLS0gaWYgYXNzdW1pbmcgU2hpZnRfSklTIG9yIGF0IGxlYXN0IDMgdmFsaWQgY29uc2VjdXRpdmUgbm90LWFzY2lpIGNoYXJhY3RlcnMgKGFuZCBubyBldmlkZW5jZSBpdCBjYW4ndCBiZSksIGRvbmVcbiAgICAgICAgICAgIGlmIChjYW5CZVNoaWZ0SklTICYmIChTdHJpbmdVdGlscy5BU1NVTUVfU0hJRlRfSklTIHx8IHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPj0gMyB8fCBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoID49IDMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLlNISUZUX0pJUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERpc3Rpbmd1aXNoaW5nIFNoaWZ0X0pJUyBhbmQgSVNPLTg4NTktMSBjYW4gYmUgYSBsaXR0bGUgdG91Z2ggZm9yIHNob3J0IHdvcmRzLiBUaGUgY3J1ZGUgaGV1cmlzdGljIGlzOlxuICAgICAgICAgICAgLy8gLSBJZiB3ZSBzYXdcbiAgICAgICAgICAgIC8vICAgLSBvbmx5IHR3byBjb25zZWN1dGl2ZSBrYXRha2FuYSBjaGFycyBpbiB0aGUgd2hvbGUgdGV4dCwgb3JcbiAgICAgICAgICAgIC8vICAgLSBhdCBsZWFzdCAxMCUgb2YgYnl0ZXMgdGhhdCBjb3VsZCBiZSBcInVwcGVyXCIgbm90LWFscGhhbnVtZXJpYyBMYXRpbjEsXG4gICAgICAgICAgICAvLyAtIHRoZW4gd2UgY29uY2x1ZGUgU2hpZnRfSklTLCBlbHNlIElTTy04ODU5LTFcbiAgICAgICAgICAgIGlmIChjYW5CZUlTTzg4NTkxICYmIGNhbkJlU2hpZnRKSVMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPT09IDIgJiYgc2ppc0thdGFrYW5hQ2hhcnMgPT09IDIpIHx8IGlzb0hpZ2hPdGhlciAqIDEwID49IGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IFN0cmluZ1V0aWxzLlNISUZUX0pJUyA6IFN0cmluZ1V0aWxzLklTTzg4NTkxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0cnkgaW4gb3JkZXIgSVNPLTg4NTktMSwgU2hpZnQgSklTLCBVVEYtOCBhbmQgZmFsbCBiYWNrIHRvIGRlZmF1bHQgcGxhdGZvcm0gZW5jb2RpbmdcbiAgICAgICAgICAgIGlmIChjYW5CZUlTTzg4NTkxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLklTTzg4NTkxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbkJlU2hpZnRKSVMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuU0hJRlRfSklTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbkJlVVRGOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmdVdGlscy5VVEY4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSB0YWtlIGEgd2lsZCBndWVzcyB3aXRoIHBsYXRmb3JtIGVuY29kaW5nXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuUExBVEZPUk1fREVGQVVMVF9FTkNPRElORztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTM0Mzk3MTEvNDM2NzY4M1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYXBwZW5kIFRoZSBuZXcgc3RyaW5nIHRvIGFwcGVuZC5cbiAgICAgICAgICogQHBhcmFtIGFyZ3MgQXJndW1ldHMgdmFsdWVzIHRvIGJlIGZvcm1hdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZvcm1hdChhcHBlbmQsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGxldCBpID0gLTE7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhleHAsIHAwLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgICAgIGlmIChleHAgPT09ICclJScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJSc7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbKytpXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGV4cCA9IHAyID8gcGFyc2VJbnQocDIuc3Vic3RyKDEpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IHAzID8gcGFyc2VJbnQocDMuc3Vic3RyKDEpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgdmFsO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocDQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcmdzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gYXJnc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoYXJnc1tpXSkudG9GaXhlZChleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcmdzW2ldKS50b1ByZWNpc2lvbihleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcmdzW2ldKS50b0V4cG9uZW50aWFsKGV4cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUludChhcmdzW2ldKS50b1N0cmluZyhiYXNlID8gYmFzZSA6IDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQocGFyc2VJbnQoYXJnc1tpXSwgYmFzZSA/IGJhc2UgOiAxMCkudG9QcmVjaXNpb24oZXhwKSkudG9GaXhlZCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KHZhbCkgOiAoK3ZhbCkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChwMSk7IC8qIHBhZGRpbmcgc2l6ZSAqL1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IHAxICYmIChwMVswXSArICcnKSA9PT0gJzAnID8gJzAnIDogJyAnOyAvKiBpc251bGw/ICovXG4gICAgICAgICAgICAgICAgd2hpbGUgKHZhbC5sZW5ndGggPCBzaXplKVxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwMCAhPT0gdW5kZWZpbmVkID8gdmFsICsgY2ggOiBjaCArIHZhbDsgLyogaXNtaW51cz8gKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gLyUoLSk/KDA/WzAtOV0rKT8oWy5dWzAtOV0rKT8oWyNdWzAtOV0rKT8oW3NjZnBleGQlXSkvZztcbiAgICAgICAgICAgIHJldHVybiBhcHBlbmQucmVwbGFjZShyZWdleCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldEJ5dGVzKHN0ciwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdFbmNvZGluZy5lbmNvZGUoc3RyLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNoYXJjb2RlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb3IgYXQgaW5kZXggemVyby5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRDaGFyQ29kZShzdHIsIGluZGV4ID0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBjaGFyIGZvciBnaXZlbiBjaGFyY29kZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldENoYXJBdChjaGFyQ29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN0cmluZ1V0aWxzLlNISUZUX0pJUyA9IENoYXJhY3RlclNldEVDSS5TSklTLmdldE5hbWUoKTsgLy8gXCJTSklTXCJcbiAgICBTdHJpbmdVdGlscy5HQjIzMTIgPSAnR0IyMzEyJztcbiAgICBTdHJpbmdVdGlscy5JU084ODU5MSA9IENoYXJhY3RlclNldEVDSS5JU084ODU5XzEuZ2V0TmFtZSgpOyAvLyBcIklTTzg4NTlfMVwiXG4gICAgU3RyaW5nVXRpbHMuRVVDX0pQID0gJ0VVQ19KUCc7XG4gICAgU3RyaW5nVXRpbHMuVVRGOCA9IENoYXJhY3RlclNldEVDSS5VVEY4LmdldE5hbWUoKTsgLy8gXCJVVEY4XCJcbiAgICBTdHJpbmdVdGlscy5QTEFURk9STV9ERUZBVUxUX0VOQ09ESU5HID0gU3RyaW5nVXRpbHMuVVRGODsgLy8gXCJVVEY4XCIvL0NoYXJzZXQuZGVmYXVsdENoYXJzZXQoKS5uYW1lKClcbiAgICBTdHJpbmdVdGlscy5BU1NVTUVfU0hJRlRfSklTID0gZmFsc2U7XG5cbiAgICBjbGFzcyBTdHJpbmdCdWlsZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IodmFsdWUgPSAnJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVuYWJsZURlY29kaW5nKGVuY29kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmQocykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgKz0gcy50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5lbmNvZGluZykge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBwYXNzZWQgZm9ybWF0IChmcm9tQ2hhckNvZGUgd2lsbCByZXR1cm4gVVRGOCBlbmNvZGluZylcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlICs9IFN0cmluZ1V0aWxzLmNhc3RBc05vblV0ZjhDaGFyKHMsIHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdGx5IGNvbnZlcnRzIGZyb20gVVRGLTgsIGJ1dCBub3Qgb3RoZXIgZW5jb2RpbmdzXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kQ2hhcnMoc3RyLCBvZmZzZXQsIGxlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgb2Zmc2V0IDwgb2Zmc2V0ICsgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChzdHJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNoYXJBdChuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5jaGFyQXQobik7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlQ2hhckF0KG4pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnN1YnN0cigwLCBuKSArIHRoaXMudmFsdWUuc3Vic3RyaW5nKG4gKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRDaGFyQXQobiwgYykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc3Vic3RyKDAsIG4pICsgYyArIHRoaXMudmFsdWUuc3Vic3RyKG4gKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzdHJpbmcoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbm90ZSBoZWxwZXIgbWV0aG9kIGZvciBSU1MgRXhwYW5kZWRcbiAgICAgICAgICovXG4gICAgICAgIHNldExlbmd0aFRvWmVybygpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChuLCBjKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5zdWJzdHIoMCwgbikgKyBjICsgdGhpcy52YWx1ZS5zdWJzdHIobiArIGMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+UmVwcmVzZW50cyBhIDJEIG1hdHJpeCBvZiBiaXRzLiBJbiBmdW5jdGlvbiBhcmd1bWVudHMgYmVsb3csIGFuZCB0aHJvdWdob3V0IHRoZSBjb21tb25cbiAgICAgKiBtb2R1bGUsIHggaXMgdGhlIGNvbHVtbiBwb3NpdGlvbiwgYW5kIHkgaXMgdGhlIHJvdyBwb3NpdGlvbi4gVGhlIG9yZGVyaW5nIGlzIGFsd2F5cyB4LCB5LlxuICAgICAqIFRoZSBvcmlnaW4gaXMgYXQgdGhlIHRvcC1sZWZ0LjwvcD5cbiAgICAgKlxuICAgICAqIDxwPkludGVybmFsbHkgdGhlIGJpdHMgYXJlIHJlcHJlc2VudGVkIGluIGEgMS1EIGFycmF5IG9mIDMyLWJpdCBpbnRzLiBIb3dldmVyLCBlYWNoIHJvdyBiZWdpbnNcbiAgICAgKiB3aXRoIGEgbmV3IGludC4gVGhpcyBpcyBkb25lIGludGVudGlvbmFsbHkgc28gdGhhdCB3ZSBjYW4gY29weSBvdXQgYSByb3cgaW50byBhIEJpdEFycmF5IHZlcnlcbiAgICAgKiBlZmZpY2llbnRseS48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGUgb3JkZXJpbmcgb2YgYml0cyBpcyByb3ctbWFqb3IuIFdpdGhpbiBlYWNoIGludCwgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgYXJlIHVzZWQgZmlyc3QsXG4gICAgICogbWVhbmluZyB0aGV5IHJlcHJlc2VudCBsb3dlciB4IHZhbHVlcy4gVGhpcyBpcyBjb21wYXRpYmxlIHdpdGggQml0QXJyYXkncyBpbXBsZW1lbnRhdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICovXG4gICAgY2xhc3MgQml0TWF0cml4IC8qaW1wbGVtZW50cyBDbG9uZWFibGUqLyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGVtcHR5IHNxdWFyZSB7QGxpbmsgQml0TWF0cml4fS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRpbWVuc2lvbiBoZWlnaHQgYW5kIHdpZHRoXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IoZGltZW5zaW9uOiBudW1iZXIgLyppbnQqLykge1xuICAgICAgICAvLyAgIHRoaXMoZGltZW5zaW9uLCBkaW1lbnNpb24pXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gZW1wdHkge0BsaW5rIEJpdE1hdHJpeH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB3aWR0aCBiaXQgbWF0cml4IHdpZHRoXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgYml0IG1hdHJpeCBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3Rvcih3aWR0aDogbnVtYmVyIC8qaW50Ki8sIGhlaWdodDogbnVtYmVyIC8qaW50Ki8pIHtcbiAgICAgICAgLy8gICBpZiAod2lkdGggPCAxIHx8IGhlaWdodCA8IDEpIHtcbiAgICAgICAgLy8gICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJCb3RoIGRpbWVuc2lvbnMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiKVxuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICAgICAgLy8gICB0aGlzLmhlaWdodCA9IGhlaWdodFxuICAgICAgICAvLyAgIHRoaXMucm93U2l6ZSA9ICh3aWR0aCArIDMxKSAvIDMyXG4gICAgICAgIC8vICAgYml0cyA9IG5ldyBpbnRbcm93U2l6ZSAqIGhlaWdodF07XG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3RydWN0b3Iod2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIHJvd1NpemUgLyppbnQqLywgYml0cykge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnJvd1NpemUgPSByb3dTaXplO1xuICAgICAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGhlaWdodCB8fCBudWxsID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMSB8fCBoZWlnaHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQm90aCBkaW1lbnNpb25zIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHJvd1NpemUgfHwgbnVsbCA9PT0gcm93U2l6ZSkge1xuICAgICAgICAgICAgICAgIHJvd1NpemUgPSBNYXRoLmZsb29yKCh3aWR0aCArIDMxKSAvIDMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucm93U2l6ZSA9IHJvd1NpemU7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBiaXRzIHx8IG51bGwgPT09IGJpdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpdHMgPSBuZXcgSW50MzJBcnJheSh0aGlzLnJvd1NpemUgKiB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVycHJldHMgYSAyRCBhcnJheSBvZiBib29sZWFucyBhcyBhIHtAbGluayBCaXRNYXRyaXh9LCB3aGVyZSBcInRydWVcIiBtZWFucyBhbiBcIm9uXCIgYml0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZnVuY3Rpb24gcGFyc2VcbiAgICAgICAgICogQHBhcmFtIGltYWdlIGJpdHMgb2YgdGhlIGltYWdlLCBhcyBhIHJvdy1tYWpvciAyRCBhcnJheS4gRWxlbWVudHMgYXJlIGFycmF5cyByZXByZXNlbnRpbmcgcm93c1xuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBCaXRNYXRyaXh9IHJlcHJlc2VudGF0aW9uIG9mIGltYWdlXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcGFyc2VGcm9tQm9vbGVhbkFycmF5KGltYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBuZXcgQml0TWF0cml4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlSSA9IGltYWdlW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VJW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRzLnNldChqLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZnVuY3Rpb24gcGFyc2VcbiAgICAgICAgICogQHBhcmFtIHN0cmluZ1JlcHJlc2VudGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSBzZXRTdHJpbmdcbiAgICAgICAgICogQHBhcmFtIHVuc2V0U3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcGFyc2VGcm9tU3RyaW5nKHN0cmluZ1JlcHJlc2VudGF0aW9uLCBzZXRTdHJpbmcsIHVuc2V0U3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoc3RyaW5nUmVwcmVzZW50YXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdzdHJpbmdSZXByZXNlbnRhdGlvbiBjYW5ub3QgYmUgbnVsbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYml0cyA9IG5ldyBBcnJheShzdHJpbmdSZXByZXNlbnRhdGlvbi5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGJpdHNQb3MgPSAwO1xuICAgICAgICAgICAgbGV0IHJvd1N0YXJ0UG9zID0gMDtcbiAgICAgICAgICAgIGxldCByb3dMZW5ndGggPSAtMTtcbiAgICAgICAgICAgIGxldCBuUm93cyA9IDA7XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBzdHJpbmdSZXByZXNlbnRhdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nUmVwcmVzZW50YXRpb24uY2hhckF0KHBvcykgPT09ICdcXG4nIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1JlcHJlc2VudGF0aW9uLmNoYXJBdChwb3MpID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYml0c1BvcyA+IHJvd1N0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93TGVuZ3RoID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0xlbmd0aCA9IGJpdHNQb3MgLSByb3dTdGFydFBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJpdHNQb3MgLSByb3dTdGFydFBvcyAhPT0gcm93TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigncm93IGxlbmd0aHMgZG8gbm90IG1hdGNoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dTdGFydFBvcyA9IGJpdHNQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBuUm93cysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJpbmdSZXByZXNlbnRhdGlvbi5zdWJzdHJpbmcocG9zLCBwb3MgKyBzZXRTdHJpbmcubGVuZ3RoKSA9PT0gc2V0U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBzZXRTdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBiaXRzW2JpdHNQb3NdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYml0c1BvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJpbmdSZXByZXNlbnRhdGlvbi5zdWJzdHJpbmcocG9zLCBwb3MgKyB1bnNldFN0cmluZy5sZW5ndGgpID09PSB1bnNldFN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gdW5zZXRTdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBiaXRzW2JpdHNQb3NdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJpdHNQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ2lsbGVnYWwgY2hhcmFjdGVyIGVuY291bnRlcmVkOiAnICsgc3RyaW5nUmVwcmVzZW50YXRpb24uc3Vic3RyaW5nKHBvcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vIEVPTCBhdCBlbmQ/XG4gICAgICAgICAgICBpZiAoYml0c1BvcyA+IHJvd1N0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0xlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93TGVuZ3RoID0gYml0c1BvcyAtIHJvd1N0YXJ0UG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiaXRzUG9zIC0gcm93U3RhcnRQb3MgIT09IHJvd0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdyb3cgbGVuZ3RocyBkbyBub3QgbWF0Y2gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgblJvd3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBCaXRNYXRyaXgocm93TGVuZ3RoLCBuUm93cyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpdHNQb3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChiaXRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoTWF0aC5mbG9vcihpICUgcm93TGVuZ3RoKSwgTWF0aC5mbG9vcihpIC8gcm93TGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+R2V0cyB0aGUgcmVxdWVzdGVkIGJpdCwgd2hlcmUgdHJ1ZSBtZWFucyBibGFjay48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB4IFRoZSBob3Jpem9udGFsIGNvbXBvbmVudCAoaS5lLiB3aGljaCBjb2x1bW4pXG4gICAgICAgICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggcm93KVxuICAgICAgICAgKiBAcmV0dXJuIHZhbHVlIG9mIGdpdmVuIGJpdCBpbiBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIGdldCh4IC8qaW50Ki8sIHkgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHRoaXMucm93U2l6ZSArIE1hdGguZmxvb3IoeCAvIDMyKTtcbiAgICAgICAgICAgIHJldHVybiAoKHRoaXMuYml0c1tvZmZzZXRdID4+PiAoeCAmIDB4MWYpKSAmIDEpICE9PSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5TZXRzIHRoZSBnaXZlbiBiaXQgdG8gdHJ1ZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB4IFRoZSBob3Jpem9udGFsIGNvbXBvbmVudCAoaS5lLiB3aGljaCBjb2x1bW4pXG4gICAgICAgICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggcm93KVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0KHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgTWF0aC5mbG9vcih4IC8gMzIpO1xuICAgICAgICAgICAgdGhpcy5iaXRzW29mZnNldF0gfD0gKDEgPDwgKHggJiAweDFmKSkgJiAweEZGRkZGRkZGO1xuICAgICAgICB9XG4gICAgICAgIHVuc2V0KHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgTWF0aC5mbG9vcih4IC8gMzIpO1xuICAgICAgICAgICAgdGhpcy5iaXRzW29mZnNldF0gJj0gfigoMSA8PCAoeCAmIDB4MWYpKSAmIDB4RkZGRkZGRkYpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5GbGlwcyB0aGUgZ2l2ZW4gYml0LjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHggVGhlIGhvcml6b250YWwgY29tcG9uZW50IChpLmUuIHdoaWNoIGNvbHVtbilcbiAgICAgICAgICogQHBhcmFtIHkgVGhlIHZlcnRpY2FsIGNvbXBvbmVudCAoaS5lLiB3aGljaCByb3cpXG4gICAgICAgICAqL1xuICAgICAgICBmbGlwKHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgTWF0aC5mbG9vcih4IC8gMzIpO1xuICAgICAgICAgICAgdGhpcy5iaXRzW29mZnNldF0gXj0gKCgxIDw8ICh4ICYgMHgxZikpICYgMHhGRkZGRkZGRik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4Y2x1c2l2ZS1vciAoWE9SKTogRmxpcCB0aGUgYml0IGluIHRoaXMge0Bjb2RlIEJpdE1hdHJpeH0gaWYgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgICogbWFzayBiaXQgaXMgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbWFzayBYT1IgbWFza1xuICAgICAgICAgKi9cbiAgICAgICAgeG9yKG1hc2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoICE9PSBtYXNrLmdldFdpZHRoKCkgfHwgdGhpcy5oZWlnaHQgIT09IG1hc2suZ2V0SGVpZ2h0KClcbiAgICAgICAgICAgICAgICB8fCB0aGlzLnJvd1NpemUgIT09IG1hc2suZ2V0Um93U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignaW5wdXQgbWF0cml4IGRpbWVuc2lvbnMgZG8gbm90IG1hdGNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3dBcnJheSA9IG5ldyBCaXRBcnJheShNYXRoLmZsb29yKHRoaXMud2lkdGggLyAzMikgKyAxKTtcbiAgICAgICAgICAgIGNvbnN0IHJvd1NpemUgPSB0aGlzLnJvd1NpemU7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDAsIGhlaWdodCA9IHRoaXMuaGVpZ2h0OyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogcm93U2l6ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSBtYXNrLmdldFJvdyh5LCByb3dBcnJheSkuZ2V0Qml0QXJyYXkoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJvd1NpemU7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBiaXRzW29mZnNldCArIHhdIF49IHJvd1t4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwgYml0cyAoc2V0cyB0byBmYWxzZSkuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcigpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBjb25zdCBtYXggPSBiaXRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBiaXRzW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+U2V0cyBhIHNxdWFyZSByZWdpb24gb2YgdGhlIGJpdCBtYXRyaXggdG8gdHJ1ZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBob3Jpem9udGFsIHBvc2l0aW9uIHRvIGJlZ2luIGF0IChpbmNsdXNpdmUpXG4gICAgICAgICAqIEBwYXJhbSB0b3AgVGhlIHZlcnRpY2FsIHBvc2l0aW9uIHRvIGJlZ2luIGF0IChpbmNsdXNpdmUpXG4gICAgICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHJlZ2lvblxuICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHJlZ2lvblxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UmVnaW9uKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAodG9wIDwgMCB8fCBsZWZ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0xlZnQgYW5kIHRvcCBtdXN0IGJlIG5vbm5lZ2F0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMSB8fCB3aWR0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdIZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgYXQgbGVhc3QgMScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAoYm90dG9tID4gdGhpcy5oZWlnaHQgfHwgcmlnaHQgPiB0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVGhlIHJlZ2lvbiBtdXN0IGZpdCBpbnNpZGUgdGhlIG1hdHJpeCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm93U2l6ZSA9IHRoaXMucm93U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gdG9wOyB5IDwgYm90dG9tOyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogcm93U2l6ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gbGVmdDsgeCA8IHJpZ2h0OyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYml0c1tvZmZzZXQgKyBNYXRoLmZsb29yKHggLyAzMildIHw9ICgoMSA8PCAoeCAmIDB4MWYpKSAmIDB4RkZGRkZGRkYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQSBmYXN0IG1ldGhvZCB0byByZXRyaWV2ZSBvbmUgcm93IG9mIGRhdGEgZnJvbSB0aGUgbWF0cml4IGFzIGEgQml0QXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB5IFRoZSByb3cgdG8gcmV0cmlldmVcbiAgICAgICAgICogQHBhcmFtIHJvdyBBbiBvcHRpb25hbCBjYWxsZXItYWxsb2NhdGVkIEJpdEFycmF5LCB3aWxsIGJlIGFsbG9jYXRlZCBpZiBudWxsIG9yIHRvbyBzbWFsbFxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQml0QXJyYXkgLSB0aGlzIHJlZmVyZW5jZSBzaG91bGQgYWx3YXlzIGJlIHVzZWQgZXZlbiB3aGVuIHBhc3NpbmdcbiAgICAgICAgICogICAgICAgICB5b3VyIG93biByb3dcbiAgICAgICAgICovXG4gICAgICAgIGdldFJvdyh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICAgICAgaWYgKHJvdyA9PT0gbnVsbCB8fCByb3cgPT09IHVuZGVmaW5lZCB8fCByb3cuZ2V0U2l6ZSgpIDwgdGhpcy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHJvdyA9IG5ldyBCaXRBcnJheSh0aGlzLndpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdy5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm93U2l6ZSA9IHRoaXMucm93U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogcm93U2l6ZTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgcm93U2l6ZTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgcm93LnNldEJ1bGsoeCAqIDMyLCBiaXRzW29mZnNldCArIHhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB5IHJvdyB0byBzZXRcbiAgICAgICAgICogQHBhcmFtIHJvdyB7QGxpbmsgQml0QXJyYXl9IHRvIGNvcHkgZnJvbVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0Um93KHkgLyppbnQqLywgcm93KSB7XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHJvdy5nZXRCaXRBcnJheSgpLCAwLCB0aGlzLmJpdHMsIHkgKiB0aGlzLnJvd1NpemUsIHRoaXMucm93U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGlmaWVzIHRoaXMge0Bjb2RlIEJpdE1hdHJpeH0gdG8gcmVwcmVzZW50IHRoZSBzYW1lIGJ1dCByb3RhdGVkIDE4MCBkZWdyZWVzXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGUxODAoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBsZXQgdG9wUm93ID0gbmV3IEJpdEFycmF5KHdpZHRoKTtcbiAgICAgICAgICAgIGxldCBib3R0b21Sb3cgPSBuZXcgQml0QXJyYXkod2lkdGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IE1hdGguZmxvb3IoKGhlaWdodCArIDEpIC8gMik7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRvcFJvdyA9IHRoaXMuZ2V0Um93KGksIHRvcFJvdyk7XG4gICAgICAgICAgICAgICAgYm90dG9tUm93ID0gdGhpcy5nZXRSb3coaGVpZ2h0IC0gMSAtIGksIGJvdHRvbVJvdyk7XG4gICAgICAgICAgICAgICAgdG9wUm93LnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICBib3R0b21Sb3cucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Um93KGksIGJvdHRvbVJvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSb3coaGVpZ2h0IC0gMSAtIGksIHRvcFJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZnVsIGluIGRldGVjdGluZyB0aGUgZW5jbG9zaW5nIHJlY3RhbmdsZSBvZiBhICdwdXJlJyBiYXJjb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtAY29kZSBsZWZ0LHRvcCx3aWR0aCxoZWlnaHR9IGVuY2xvc2luZyByZWN0YW5nbGUgb2YgYWxsIDEgYml0cywgb3IgbnVsbCBpZiBpdCBpcyBhbGwgd2hpdGVcbiAgICAgICAgICovXG4gICAgICAgIGdldEVuY2xvc2luZ1JlY3RhbmdsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgcm93U2l6ZSA9IHRoaXMucm93U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHdpZHRoO1xuICAgICAgICAgICAgbGV0IHRvcCA9IGhlaWdodDtcbiAgICAgICAgICAgIGxldCByaWdodCA9IC0xO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHgzMiA9IDA7IHgzMiA8IHJvd1NpemU7IHgzMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoZUJpdHMgPSBiaXRzW3kgKiByb3dTaXplICsgeDMyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoZUJpdHMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5IDwgdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5ID4gYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4MzIgKiAzMiA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKCh0aGVCaXRzIDw8ICgzMSAtIGJpdCkpICYgMHhGRkZGRkZGRikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoeDMyICogMzIgKyBiaXQpIDwgbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0geDMyICogMzIgKyBiaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHgzMiAqIDMyICsgMzEgPiByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXQgPSAzMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKHRoZUJpdHMgPj4+IGJpdCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoeDMyICogMzIgKyBiaXQpID4gcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB4MzIgKiAzMiArIGJpdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmlnaHQgPCBsZWZ0IHx8IGJvdHRvbSA8IHRvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbbGVmdCwgdG9wLCByaWdodCAtIGxlZnQgKyAxLCBib3R0b20gLSB0b3AgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZnVsIGluIGRldGVjdGluZyBhIGNvcm5lciBvZiBhICdwdXJlJyBiYXJjb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtAY29kZSB4LHl9IGNvb3JkaW5hdGUgb2YgdG9wLWxlZnQtbW9zdCAxIGJpdCwgb3IgbnVsbCBpZiBpdCBpcyBhbGwgd2hpdGVcbiAgICAgICAgICovXG4gICAgICAgIGdldFRvcExlZnRPbkJpdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvd1NpemUgPSB0aGlzLnJvd1NpemU7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgbGV0IGJpdHNPZmZzZXQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHNPZmZzZXQgPCBiaXRzLmxlbmd0aCAmJiBiaXRzW2JpdHNPZmZzZXRdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYml0c09mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpdHNPZmZzZXQgPT09IGJpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB5ID0gYml0c09mZnNldCAvIHJvd1NpemU7XG4gICAgICAgICAgICBsZXQgeCA9IChiaXRzT2Zmc2V0ICUgcm93U2l6ZSkgKiAzMjtcbiAgICAgICAgICAgIGNvbnN0IHRoZUJpdHMgPSBiaXRzW2JpdHNPZmZzZXRdO1xuICAgICAgICAgICAgbGV0IGJpdCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoKCh0aGVCaXRzIDw8ICgzMSAtIGJpdCkpICYgMHhGRkZGRkZGRikgPT09IDApIHtcbiAgICAgICAgICAgICAgICBiaXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggKz0gYml0O1xuICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbeCwgeV0pO1xuICAgICAgICB9XG4gICAgICAgIGdldEJvdHRvbVJpZ2h0T25CaXQoKSB7XG4gICAgICAgICAgICBjb25zdCByb3dTaXplID0gdGhpcy5yb3dTaXplO1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgICAgIGxldCBiaXRzT2Zmc2V0ID0gYml0cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHNPZmZzZXQgPj0gMCAmJiBiaXRzW2JpdHNPZmZzZXRdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYml0c09mZnNldC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpdHNPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihiaXRzT2Zmc2V0IC8gcm93U2l6ZSk7XG4gICAgICAgICAgICBsZXQgeCA9IE1hdGguZmxvb3IoYml0c09mZnNldCAlIHJvd1NpemUpICogMzI7XG4gICAgICAgICAgICBjb25zdCB0aGVCaXRzID0gYml0c1tiaXRzT2Zmc2V0XTtcbiAgICAgICAgICAgIGxldCBiaXQgPSAzMTtcbiAgICAgICAgICAgIHdoaWxlICgodGhlQml0cyA+Pj4gYml0KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJpdC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCArPSBiaXQ7XG4gICAgICAgICAgICByZXR1cm4gSW50MzJBcnJheS5mcm9tKFt4LCB5XSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHdpZHRoIG9mIHRoZSBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGhlaWdodCBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJvdyBzaXplIG9mIHRoZSBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIGdldFJvd1NpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dTaXplO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBCaXRNYXRyaXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IG90aGVyLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBvdGhlci5oZWlnaHQgJiYgdGhpcy5yb3dTaXplID09PSBvdGhlci5yb3dTaXplICYmXG4gICAgICAgICAgICAgICAgQXJyYXlzLmVxdWFscyh0aGlzLmJpdHMsIG90aGVyLmJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgaGFzaENvZGUoKSB7XG4gICAgICAgICAgICBsZXQgaGFzaCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgdGhpcy53aWR0aDtcbiAgICAgICAgICAgIGhhc2ggPSAzMSAqIGhhc2ggKyB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGhhc2ggPSAzMSAqIGhhc2ggKyB0aGlzLnJvd1NpemU7XG4gICAgICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgQXJyYXlzLmhhc2hDb2RlKHRoaXMuYml0cyk7XG4gICAgICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gdXNpbmcgXCJYXCIgZm9yIHNldCBhbmQgXCIgXCIgZm9yIHVuc2V0IGJpdHNcbiAgICAgICAgICovXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgLy8gcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIC8vICAgcmV0dXJuIHRvU3RyaW5nKFwiOiBcIlgsIFwiICBcIilcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHNldFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHNldCBiaXRcbiAgICAgICAgICogQHBhcmFtIHVuc2V0U3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIHVuc2V0IGJpdFxuICAgICAgICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBlbnRpcmUgbWF0cml4IHV0aWxpemluZyBnaXZlbiBzdHJpbmdzXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgdG9TdHJpbmcoc2V0U3RyaW5nOiBzdHJpbmcgPSBcIlggXCIsIHVuc2V0U3RyaW5nOiBzdHJpbmcgPSBcIiAgXCIpOiBzdHJpbmcge1xuICAgICAgICAvLyAgIHJldHVybiB0aGlzLmJ1aWxkVG9TdHJpbmcoc2V0U3RyaW5nLCB1bnNldFN0cmluZywgXCJcXG5cIilcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHNldFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHNldCBiaXRcbiAgICAgICAgICogQHBhcmFtIHVuc2V0U3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIHVuc2V0IGJpdFxuICAgICAgICAgKiBAcGFyYW0gbGluZVNlcGFyYXRvciBuZXdsaW5lIGNoYXJhY3RlciBpbiBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZW50aXJlIG1hdHJpeCB1dGlsaXppbmcgZ2l2ZW4gc3RyaW5ncyBhbmQgbGluZSBzZXBhcmF0b3JcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgY2FsbCB7QGxpbmsgI3RvU3RyaW5nKFN0cmluZyxTdHJpbmcpfSBvbmx5LCB3aGljaCB1c2VzIFxcbiBsaW5lIHNlcGFyYXRvciBhbHdheXNcbiAgICAgICAgICovXG4gICAgICAgIC8vIEBEZXByZWNhdGVkXG4gICAgICAgIHRvU3RyaW5nKHNldFN0cmluZyA9ICdYICcsIHVuc2V0U3RyaW5nID0gJyAgJywgbGluZVNlcGFyYXRvciA9ICdcXG4nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFRvU3RyaW5nKHNldFN0cmluZywgdW5zZXRTdHJpbmcsIGxpbmVTZXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkVG9TdHJpbmcoc2V0U3RyaW5nLCB1bnNldFN0cmluZywgbGluZVNlcGFyYXRvcikge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAvLyByZXN1bHQuYXBwZW5kKGxpbmVTZXBhcmF0b3IpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDAsIGhlaWdodCA9IHRoaXMuaGVpZ2h0OyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMCwgd2lkdGggPSB0aGlzLndpZHRoOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMuZ2V0KHgsIHkpID8gc2V0U3RyaW5nIDogdW5zZXRTdHJpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGxpbmVTZXBhcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgY2xvbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpdE1hdHJpeCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5yb3dTaXplLCB0aGlzLmJpdHMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgTm90Rm91bmRFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgICAgICBzdGF0aWMgZ2V0Tm90Rm91bmRJbnN0YW5jZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBOb3RGb3VuZEV4Y2VwdGlvbi5raW5kID0gJ05vdEZvdW5kRXhjZXB0aW9uJztcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBCaW5hcml6ZXIgaW1wbGVtZW50YXRpb24gdXNlcyB0aGUgb2xkIFpYaW5nIGdsb2JhbCBoaXN0b2dyYW0gYXBwcm9hY2guIEl0IGlzIHN1aXRhYmxlXG4gICAgICogZm9yIGxvdy1lbmQgbW9iaWxlIGRldmljZXMgd2hpY2ggZG9uJ3QgaGF2ZSBlbm91Z2ggQ1BVIG9yIG1lbW9yeSB0byB1c2UgYSBsb2NhbCB0aHJlc2hvbGRpbmdcbiAgICAgKiBhbGdvcml0aG0uIEhvd2V2ZXIsIGJlY2F1c2UgaXQgcGlja3MgYSBnbG9iYWwgYmxhY2sgcG9pbnQsIGl0IGNhbm5vdCBoYW5kbGUgZGlmZmljdWx0IHNoYWRvd3NcbiAgICAgKiBhbmQgZ3JhZGllbnRzLlxuICAgICAqXG4gICAgICogRmFzdGVyIG1vYmlsZSBkZXZpY2VzIGFuZCBhbGwgZGVza3RvcCBhcHBsaWNhdGlvbnMgc2hvdWxkIHByb2JhYmx5IHVzZSBIeWJyaWRCaW5hcml6ZXIgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIgZXh0ZW5kcyBCaW5hcml6ZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgICAgIHN1cGVyKHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLmx1bWluYW5jZXMgPSBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuRU1QVFk7XG4gICAgICAgICAgICB0aGlzLmJ1Y2tldHMgPSBuZXcgSW50MzJBcnJheShHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX0JVQ0tFVFMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGxpZXMgc2ltcGxlIHNoYXJwZW5pbmcgdG8gdGhlIHJvdyBkYXRhIHRvIGltcHJvdmUgcGVyZm9ybWFuY2Ugb2YgdGhlIDFEIFJlYWRlcnMuXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0QmxhY2tSb3coeSAvKmludCovLCByb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZ2V0THVtaW5hbmNlU291cmNlKCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHNvdXJjZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgaWYgKHJvdyA9PT0gdW5kZWZpbmVkIHx8IHJvdyA9PT0gbnVsbCB8fCByb3cuZ2V0U2l6ZSgpIDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICByb3cgPSBuZXcgQml0QXJyYXkod2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm93LmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluaXRBcnJheXMod2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxMdW1pbmFuY2VzID0gc291cmNlLmdldFJvdyh5LCB0aGlzLmx1bWluYW5jZXMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxCdWNrZXRzID0gdGhpcy5idWNrZXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxCdWNrZXRzWyhsb2NhbEx1bWluYW5jZXNbeF0gJiAweGZmKSA+PiBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX1NISUZUXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmxhY2tQb2ludCA9IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5lc3RpbWF0ZUJsYWNrUG9pbnQobG9jYWxCdWNrZXRzKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHZlcnkgc21hbGwgaW1hZ2VzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgobG9jYWxMdW1pbmFuY2VzW3hdICYgMHhmZikgPCBibGFja1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuc2V0KHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSBsb2NhbEx1bWluYW5jZXNbMF0gJiAweGZmO1xuICAgICAgICAgICAgICAgIGxldCBjZW50ZXIgPSBsb2NhbEx1bWluYW5jZXNbMV0gJiAweGZmO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAxOyB4IDwgd2lkdGggLSAxOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBsb2NhbEx1bWluYW5jZXNbeCArIDFdICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBzaW1wbGUgLTEgNCAtMSBib3ggZmlsdGVyIHdpdGggYSB3ZWlnaHQgb2YgMi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoY2VudGVyICogNCkgLSBsZWZ0IC0gcmlnaHQpIC8gMiA8IGJsYWNrUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5zZXQoeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGNlbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCBzaGFycGVuIHRoZSBkYXRhLCBhcyB0aGlzIGNhbGwgaXMgaW50ZW5kZWQgdG8gb25seSBiZSB1c2VkIGJ5IDJEIFJlYWRlcnMuXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0QmxhY2tNYXRyaXgoKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldEx1bWluYW5jZVNvdXJjZSgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBzb3VyY2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHNvdXJjZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBCaXRNYXRyaXgod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAvLyBRdWlja2x5IGNhbGN1bGF0ZXMgdGhlIGhpc3RvZ3JhbSBieSBzYW1wbGluZyBmb3VyIHJvd3MgZnJvbSB0aGUgaW1hZ2UuIFRoaXMgcHJvdmVkIHRvIGJlXG4gICAgICAgICAgICAvLyBtb3JlIHJvYnVzdCBvbiB0aGUgYmxhY2tib3ggdGVzdHMgdGhhbiBzYW1wbGluZyBhIGRpYWdvbmFsIGFzIHdlIHVzZWQgdG8gZG8uXG4gICAgICAgICAgICB0aGlzLmluaXRBcnJheXMod2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxCdWNrZXRzID0gdGhpcy5idWNrZXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDE7IHkgPCA1OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKChoZWlnaHQgKiB5KSAvIDUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsTHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRSb3cocm93LCB0aGlzLmx1bWluYW5jZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5mbG9vcigod2lkdGggKiA0KSAvIDUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSBNYXRoLmZsb29yKHdpZHRoIC8gNSk7IHggPCByaWdodDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0gbG9jYWxMdW1pbmFuY2VzW3hdICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxCdWNrZXRzW3BpeGVsID4+IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfU0hJRlRdKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmxhY2tQb2ludCA9IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5lc3RpbWF0ZUJsYWNrUG9pbnQobG9jYWxCdWNrZXRzKTtcbiAgICAgICAgICAgIC8vIFdlIGRlbGF5IHJlYWRpbmcgdGhlIGVudGlyZSBpbWFnZSBsdW1pbmFuY2UgdW50aWwgdGhlIGJsYWNrIHBvaW50IGVzdGltYXRpb24gc3VjY2VlZHMuXG4gICAgICAgICAgICAvLyBBbHRob3VnaCB3ZSBlbmQgdXAgcmVhZGluZyBmb3VyIHJvd3MgdHdpY2UsIGl0IGlzIGNvbnNpc3RlbnQgd2l0aCBvdXIgbW90dG8gb2ZcbiAgICAgICAgICAgIC8vIFwiZmFpbCBxdWlja2x5XCIgd2hpY2ggaXMgbmVjZXNzYXJ5IGZvciBjb250aW51b3VzIHNjYW5uaW5nLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxMdW1pbmFuY2VzID0gc291cmNlLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiB3aWR0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGl4ZWwgPSBsb2NhbEx1bWluYW5jZXNbb2Zmc2V0ICsgeF0gJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWwgPCBibGFja1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGNyZWF0ZUJpbmFyaXplcihzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdEFycmF5cyhsdW1pbmFuY2VTaXplIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmx1bWluYW5jZXMubGVuZ3RoIDwgbHVtaW5hbmNlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubHVtaW5hbmNlcyA9IG5ldyBVaW50OENsYW1wZWRBcnJheShsdW1pbmFuY2VTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ1Y2tldHMgPSB0aGlzLmJ1Y2tldHM7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQlVDS0VUUzsgeCsrKSB7XG4gICAgICAgICAgICAgICAgYnVja2V0c1t4XSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVzdGltYXRlQmxhY2tQb2ludChidWNrZXRzKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSB0YWxsZXN0IHBlYWsgaW4gdGhlIGhpc3RvZ3JhbS5cbiAgICAgICAgICAgIGNvbnN0IG51bUJ1Y2tldHMgPSBidWNrZXRzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBtYXhCdWNrZXRDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgZmlyc3RQZWFrID0gMDtcbiAgICAgICAgICAgIGxldCBmaXJzdFBlYWtTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbnVtQnVja2V0czsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1Y2tldHNbeF0gPiBmaXJzdFBlYWtTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UGVhayA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UGVha1NpemUgPSBidWNrZXRzW3hdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYnVja2V0c1t4XSA+IG1heEJ1Y2tldENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1heEJ1Y2tldENvdW50ID0gYnVja2V0c1t4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBzZWNvbmQtdGFsbGVzdCBwZWFrIHdoaWNoIGlzIHNvbWV3aGF0IGZhciBmcm9tIHRoZSB0YWxsZXN0IHBlYWsuXG4gICAgICAgICAgICBsZXQgc2Vjb25kUGVhayA9IDA7XG4gICAgICAgICAgICBsZXQgc2Vjb25kUGVha1Njb3JlID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbnVtQnVja2V0czsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VUb0JpZ2dlc3QgPSB4IC0gZmlyc3RQZWFrO1xuICAgICAgICAgICAgICAgIC8vIEVuY291cmFnZSBtb3JlIGRpc3RhbnQgc2Vjb25kIHBlYWtzIGJ5IG11bHRpcGx5aW5nIGJ5IHNxdWFyZSBvZiBkaXN0YW5jZS5cbiAgICAgICAgICAgICAgICBjb25zdCBzY29yZSA9IGJ1Y2tldHNbeF0gKiBkaXN0YW5jZVRvQmlnZ2VzdCAqIGRpc3RhbmNlVG9CaWdnZXN0O1xuICAgICAgICAgICAgICAgIGlmIChzY29yZSA+IHNlY29uZFBlYWtTY29yZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWNvbmRQZWFrID0geDtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUGVha1Njb3JlID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGZpcnN0UGVhayBjb3JyZXNwb25kcyB0byB0aGUgYmxhY2sgcGVhay5cbiAgICAgICAgICAgIGlmIChmaXJzdFBlYWsgPiBzZWNvbmRQZWFrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcCA9IGZpcnN0UGVhaztcbiAgICAgICAgICAgICAgICBmaXJzdFBlYWsgPSBzZWNvbmRQZWFrO1xuICAgICAgICAgICAgICAgIHNlY29uZFBlYWsgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgdG9vIGxpdHRsZSBjb250cmFzdCBpbiB0aGUgaW1hZ2UgdG8gcGljayBhIG1lYW5pbmdmdWwgYmxhY2sgcG9pbnQsIHRocm93IHJhdGhlclxuICAgICAgICAgICAgLy8gdGhhbiB3YXN0ZSB0aW1lIHRyeWluZyB0byBkZWNvZGUgdGhlIGltYWdlLCBhbmQgcmlzayBmYWxzZSBwb3NpdGl2ZXMuXG4gICAgICAgICAgICBpZiAoc2Vjb25kUGVhayAtIGZpcnN0UGVhayA8PSBudW1CdWNrZXRzIC8gMTYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmQgYSB2YWxsZXkgYmV0d2VlbiB0aGVtIHRoYXQgaXMgbG93IGFuZCBjbG9zZXIgdG8gdGhlIHdoaXRlIHBlYWsuXG4gICAgICAgICAgICBsZXQgYmVzdFZhbGxleSA9IHNlY29uZFBlYWsgLSAxO1xuICAgICAgICAgICAgbGV0IGJlc3RWYWxsZXlTY29yZSA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IHNlY29uZFBlYWsgLSAxOyB4ID4gZmlyc3RQZWFrOyB4LS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tRmlyc3QgPSB4IC0gZmlyc3RQZWFrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlID0gZnJvbUZpcnN0ICogZnJvbUZpcnN0ICogKHNlY29uZFBlYWsgLSB4KSAqIChtYXhCdWNrZXRDb3VudCAtIGJ1Y2tldHNbeF0pO1xuICAgICAgICAgICAgICAgIGlmIChzY29yZSA+IGJlc3RWYWxsZXlTY29yZSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0VmFsbGV5ID0geDtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFZhbGxleVNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJlc3RWYWxsZXkgPDwgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9TSElGVDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX0JJVFMgPSA1O1xuICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfU0hJRlQgPSA4IC0gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CSVRTO1xuICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQlVDS0VUUyA9IDEgPDwgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CSVRTO1xuICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5FTVBUWSA9IFVpbnQ4Q2xhbXBlZEFycmF5LmZyb20oWzBdKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBjbGFzcyBpbXBsZW1lbnRzIGEgbG9jYWwgdGhyZXNob2xkaW5nIGFsZ29yaXRobSwgd2hpY2ggd2hpbGUgc2xvd2VyIHRoYW4gdGhlXG4gICAgICogR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLCBpcyBmYWlybHkgZWZmaWNpZW50IGZvciB3aGF0IGl0IGRvZXMuIEl0IGlzIGRlc2lnbmVkIGZvclxuICAgICAqIGhpZ2ggZnJlcXVlbmN5IGltYWdlcyBvZiBiYXJjb2RlcyB3aXRoIGJsYWNrIGRhdGEgb24gd2hpdGUgYmFja2dyb3VuZHMuIEZvciB0aGlzIGFwcGxpY2F0aW9uLFxuICAgICAqIGl0IGRvZXMgYSBtdWNoIGJldHRlciBqb2IgdGhhbiBhIGdsb2JhbCBibGFja3BvaW50IHdpdGggc2V2ZXJlIHNoYWRvd3MgYW5kIGdyYWRpZW50cy5cbiAgICAgKiBIb3dldmVyIGl0IHRlbmRzIHRvIHByb2R1Y2UgYXJ0aWZhY3RzIG9uIGxvd2VyIGZyZXF1ZW5jeSBpbWFnZXMgYW5kIGlzIHRoZXJlZm9yZSBub3RcbiAgICAgKiBhIGdvb2QgZ2VuZXJhbCBwdXJwb3NlIGJpbmFyaXplciBmb3IgdXNlcyBvdXRzaWRlIFpYaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBjbGFzcyBleHRlbmRzIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplciwgdXNpbmcgdGhlIG9sZGVyIGhpc3RvZ3JhbSBhcHByb2FjaCBmb3IgMUQgcmVhZGVycyxcbiAgICAgKiBhbmQgdGhlIG5ld2VyIGxvY2FsIGFwcHJvYWNoIGZvciAyRCByZWFkZXJzLiAxRCBkZWNvZGluZyB1c2luZyBhIHBlci1yb3cgaGlzdG9ncmFtIGlzIGFscmVhZHlcbiAgICAgKiBpbmhlcmVudGx5IGxvY2FsLCBhbmQgb25seSBmYWlscyBmb3IgaG9yaXpvbnRhbCBncmFkaWVudHMuIFdlIGNhbiByZXZpc2l0IHRoYXQgcHJvYmxlbSBsYXRlcixcbiAgICAgKiBidXQgZm9yIG5vdyBpdCB3YXMgbm90IGEgd2luIHRvIHVzZSBsb2NhbCBibG9ja3MgZm9yIDFELlxuICAgICAqXG4gICAgICogVGhpcyBCaW5hcml6ZXIgaXMgdGhlIGRlZmF1bHQgZm9yIHRoZSB1bml0IHRlc3RzIGFuZCB0aGUgcmVjb21tZW5kZWQgY2xhc3MgZm9yIGxpYnJhcnkgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIEh5YnJpZEJpbmFyaXplciBleHRlbmRzIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICAgICAgc3VwZXIoc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgZmluYWwgQml0TWF0cml4IG9uY2UgZm9yIGFsbCByZXF1ZXN0cy4gVGhpcyBjb3VsZCBiZSBjYWxsZWQgb25jZSBmcm9tIHRoZVxuICAgICAgICAgKiBjb25zdHJ1Y3RvciBpbnN0ZWFkLCBidXQgdGhlcmUgYXJlIHNvbWUgYWR2YW50YWdlcyB0byBkb2luZyBpdCBsYXppbHksIHN1Y2ggYXMgbWFraW5nXG4gICAgICAgICAqIHByb2ZpbGluZyBlYXNpZXIsIGFuZCBub3QgZG9pbmcgaGVhdnkgbGlmdGluZyB3aGVuIGNhbGxlcnMgZG9uJ3QgZXhwZWN0IGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBnZXRCbGFja01hdHJpeCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hdHJpeCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdHJpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZ2V0THVtaW5hbmNlU291cmNlKCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHNvdXJjZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gc291cmNlLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgaWYgKHdpZHRoID49IEh5YnJpZEJpbmFyaXplci5NSU5JTVVNX0RJTUVOU0lPTiAmJiBoZWlnaHQgPj0gSHlicmlkQmluYXJpemVyLk1JTklNVU1fRElNRU5TSU9OKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgICAgICBsZXQgc3ViV2lkdGggPSB3aWR0aCA+PiBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUjtcbiAgICAgICAgICAgICAgICBpZiAoKHdpZHRoICYgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfTUFTSykgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViV2lkdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHN1YkhlaWdodCA9IGhlaWdodCA+PiBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUjtcbiAgICAgICAgICAgICAgICBpZiAoKGhlaWdodCAmIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX01BU0spICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YkhlaWdodCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBibGFja1BvaW50cyA9IEh5YnJpZEJpbmFyaXplci5jYWxjdWxhdGVCbGFja1BvaW50cyhsdW1pbmFuY2VzLCBzdWJXaWR0aCwgc3ViSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgQml0TWF0cml4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIEh5YnJpZEJpbmFyaXplci5jYWxjdWxhdGVUaHJlc2hvbGRGb3JCbG9jayhsdW1pbmFuY2VzLCBzdWJXaWR0aCwgc3ViSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBibGFja1BvaW50cywgbmV3TWF0cml4KTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeCA9IG5ld01hdHJpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBpcyB0b28gc21hbGwsIGZhbGwgYmFjayB0byB0aGUgZ2xvYmFsIGhpc3RvZ3JhbSBhcHByb2FjaC5cbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeCA9IHN1cGVyLmdldEJsYWNrTWF0cml4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBjcmVhdGVCaW5hcml6ZXIoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEh5YnJpZEJpbmFyaXplcihzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgZWFjaCBibG9jayBpbiB0aGUgaW1hZ2UsIGNhbGN1bGF0ZSB0aGUgYXZlcmFnZSBibGFjayBwb2ludCB1c2luZyBhIDV4NSBncmlkXG4gICAgICAgICAqIG9mIHRoZSBibG9ja3MgYXJvdW5kIGl0LiBBbHNvIGhhbmRsZXMgdGhlIGNvcm5lciBjYXNlcyAoZnJhY3Rpb25hbCBibG9ja3MgYXJlIGNvbXB1dGVkIGJhc2VkXG4gICAgICAgICAqIG9uIHRoZSBsYXN0IHBpeGVscyBpbiB0aGUgcm93L2NvbHVtbiB3aGljaCBhcmUgYWxzbyB1c2VkIGluIHRoZSBwcmV2aW91cyBibG9jaykuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlVGhyZXNob2xkRm9yQmxvY2sobHVtaW5hbmNlcywgc3ViV2lkdGggLyppbnQqLywgc3ViSGVpZ2h0IC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBibGFja1BvaW50cywgbWF0cml4KSB7XG4gICAgICAgICAgICBjb25zdCBtYXhZT2Zmc2V0ID0gaGVpZ2h0IC0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7XG4gICAgICAgICAgICBjb25zdCBtYXhYT2Zmc2V0ID0gd2lkdGggLSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc3ViSGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeW9mZnNldCA9IHkgPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICAgICAgaWYgKHlvZmZzZXQgPiBtYXhZT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHlvZmZzZXQgPSBtYXhZT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSBIeWJyaWRCaW5hcml6ZXIuY2FwKHksIDIsIHN1YkhlaWdodCAtIDMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc3ViV2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeG9mZnNldCA9IHggPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4b2Zmc2V0ID4gbWF4WE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeG9mZnNldCA9IG1heFhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IEh5YnJpZEJpbmFyaXplci5jYXAoeCwgMiwgc3ViV2lkdGggLSAzKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHogPSAtMjsgeiA8PSAyOyB6KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsYWNrUm93ID0gYmxhY2tQb2ludHNbdG9wICsgel07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gYmxhY2tSb3dbbGVmdCAtIDJdICsgYmxhY2tSb3dbbGVmdCAtIDFdICsgYmxhY2tSb3dbbGVmdF0gKyBibGFja1Jvd1tsZWZ0ICsgMV0gKyBibGFja1Jvd1tsZWZ0ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZlcmFnZSA9IHN1bSAvIDI1O1xuICAgICAgICAgICAgICAgICAgICBIeWJyaWRCaW5hcml6ZXIudGhyZXNob2xkQmxvY2sobHVtaW5hbmNlcywgeG9mZnNldCwgeW9mZnNldCwgYXZlcmFnZSwgd2lkdGgsIG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjYXAodmFsdWUgLyppbnQqLywgbWluIC8qaW50Ki8sIG1heCAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIGEgc2luZ2xlIHRocmVzaG9sZCB0byBhIGJsb2NrIG9mIHBpeGVscy5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyB0aHJlc2hvbGRCbG9jayhsdW1pbmFuY2VzLCB4b2Zmc2V0IC8qaW50Ki8sIHlvZmZzZXQgLyppbnQqLywgdGhyZXNob2xkIC8qaW50Ki8sIHN0cmlkZSAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwLCBvZmZzZXQgPSB5b2Zmc2V0ICogc3RyaWRlICsgeG9mZnNldDsgeSA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB5KyssIG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyaXNvbiBuZWVkcyB0byBiZSA8PSBzbyB0aGF0IGJsYWNrID09IDAgcGl4ZWxzIGFyZSBibGFjayBldmVuIGlmIHRoZSB0aHJlc2hvbGQgaXMgMC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChsdW1pbmFuY2VzW29mZnNldCArIHhdICYgMHhGRikgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KHhvZmZzZXQgKyB4LCB5b2Zmc2V0ICsgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgYSBzaW5nbGUgYmxhY2sgcG9pbnQgZm9yIGVhY2ggYmxvY2sgb2YgcGl4ZWxzIGFuZCBzYXZlcyBpdCBhd2F5LlxuICAgICAgICAgKiBTZWUgdGhlIGZvbGxvd2luZyB0aHJlYWQgZm9yIGEgZGlzY3Vzc2lvbiBvZiB0aGlzIGFsZ29yaXRobTpcbiAgICAgICAgICogIGh0dHA6Ly9ncm91cHMuZ29vZ2xlLmNvbS9ncm91cC96eGluZy9icm93c2VfdGhyZWFkL3RocmVhZC9kMDZlZmEyYzM1YTdkZGMwXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlQmxhY2tQb2ludHMobHVtaW5hbmNlcywgc3ViV2lkdGggLyppbnQqLywgc3ViSGVpZ2h0IC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBtYXhZT2Zmc2V0ID0gaGVpZ2h0IC0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7XG4gICAgICAgICAgICBjb25zdCBtYXhYT2Zmc2V0ID0gd2lkdGggLSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp3aGl0ZXNwYWNlXG4gICAgICAgICAgICBjb25zdCBibGFja1BvaW50cyA9IG5ldyBBcnJheShzdWJIZWlnaHQpOyAvLyBzdWJXaWR0aFxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzdWJIZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGJsYWNrUG9pbnRzW3ldID0gbmV3IEludDMyQXJyYXkoc3ViV2lkdGgpO1xuICAgICAgICAgICAgICAgIGxldCB5b2Zmc2V0ID0geSA8PCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUjtcbiAgICAgICAgICAgICAgICBpZiAoeW9mZnNldCA+IG1heFlPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgeW9mZnNldCA9IG1heFlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc3ViV2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeG9mZnNldCA9IHggPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4b2Zmc2V0ID4gbWF4WE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeG9mZnNldCA9IG1heFhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtaW4gPSAweEZGO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeXkgPSAwLCBvZmZzZXQgPSB5b2Zmc2V0ICogd2lkdGggKyB4b2Zmc2V0OyB5eSA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB5eSsrLCBvZmZzZXQgKz0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHh4ID0gMDsgeHggPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0gbHVtaW5hbmNlc1tvZmZzZXQgKyB4eF0gJiAweEZGO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGlsbCBsb29raW5nIGZvciBnb29kIGNvbnRyYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpeGVsIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWwgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBtaW4vbWF4IHRlc3RzIG9uY2UgZHluYW1pYyByYW5nZSBpcyBtZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXggLSBtaW4gPiBIeWJyaWRCaW5hcml6ZXIuTUlOX0RZTkFNSUNfUkFOR0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5pc2ggdGhlIHJlc3Qgb2YgdGhlIHJvd3MgcXVpY2tseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoeXkrKywgb2Zmc2V0ICs9IHdpZHRoOyB5eSA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB5eSsrLCBvZmZzZXQgKz0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeHggPSAwOyB4eCA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB4eCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gbHVtaW5hbmNlc1tvZmZzZXQgKyB4eF0gJiAweEZGO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGVzdGltYXRlIGlzIHRoZSBhdmVyYWdlIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIGJsb2NrLlxuICAgICAgICAgICAgICAgICAgICBsZXQgYXZlcmFnZSA9IHN1bSA+PiAoSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVIgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heCAtIG1pbiA8PSBIeWJyaWRCaW5hcml6ZXIuTUlOX0RZTkFNSUNfUkFOR0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHZhcmlhdGlvbiB3aXRoaW4gdGhlIGJsb2NrIGlzIGxvdywgYXNzdW1lIHRoaXMgaXMgYSBibG9jayB3aXRoIG9ubHkgbGlnaHQgb3Igb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGFyayBwaXhlbHMuIEluIHRoYXQgY2FzZSB3ZSBkbyBub3Qgd2FudCB0byB1c2UgdGhlIGF2ZXJhZ2UsIGFzIGl0IHdvdWxkIGRpdmlkZSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb3cgY29udHJhc3QgYXJlYSBpbnRvIGJsYWNrIGFuZCB3aGl0ZSBwaXhlbHMsIGVzc2VudGlhbGx5IGNyZWF0aW5nIGRhdGEgb3V0IG9mIG5vaXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGFzc3VtcHRpb24gaXMgdGhhdCB0aGUgYmxvY2sgaXMgbGlnaHQvYmFja2dyb3VuZC4gU2luY2Ugbm8gZXN0aW1hdGUgZm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbGV2ZWwgb2YgZGFyayBwaXhlbHMgZXhpc3RzIGxvY2FsbHksIHVzZSBoYWxmIHRoZSBtaW4gZm9yIHRoZSBibG9jay5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2UgPSBtaW4gLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHkgPiAwICYmIHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29ycmVjdCB0aGUgXCJ3aGl0ZSBiYWNrZ3JvdW5kXCIgYXNzdW1wdGlvbiBmb3IgYmxvY2tzIHRoYXQgaGF2ZSBuZWlnaGJvcnMgYnkgY29tcGFyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBpeGVscyBpbiB0aGlzIGJsb2NrIHRvIHRoZSBwcmV2aW91c2x5IGNhbGN1bGF0ZWQgYmxhY2sgcG9pbnRzLiBUaGlzIGlzIGJhc2VkIG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZhY3QgdGhhdCBkYXJrIGJhcmNvZGUgc3ltYm9sb2d5IGlzIGFsd2F5cyBzdXJyb3VuZGVkIGJ5IHNvbWUgYW1vdW50IG9mIGxpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFja2dyb3VuZCBmb3Igd2hpY2ggcmVhc29uYWJsZSBibGFjayBwb2ludCBlc3RpbWF0ZXMgd2VyZSBtYWRlLiBUaGUgYnAgZXN0aW1hdGVkIGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGJvdW5kYXJpZXMgaXMgdXNlZCBmb3IgdGhlIGludGVyaW9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSAobWluIDwgYnApIGlzIGFyYml0cmFyeSBidXQgd29ya3MgYmV0dGVyIHRoYW4gb3RoZXIgaGV1cmlzdGljcyB0aGF0IHdlcmUgdHJpZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZlcmFnZU5laWdoYm9yQmxhY2tQb2ludCA9IChibGFja1BvaW50c1t5IC0gMV1beF0gKyAoMiAqIGJsYWNrUG9pbnRzW3ldW3ggLSAxXSkgKyBibGFja1BvaW50c1t5IC0gMV1beCAtIDFdKSAvIDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA8IGF2ZXJhZ2VOZWlnaGJvckJsYWNrUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZlcmFnZSA9IGF2ZXJhZ2VOZWlnaGJvckJsYWNrUG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJsYWNrUG9pbnRzW3ldW3hdID0gYXZlcmFnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmxhY2tQb2ludHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBjbGFzcyB1c2VzIDV4NSBibG9ja3MgdG8gY29tcHV0ZSBsb2NhbCBsdW1pbmFuY2UsIHdoZXJlIGVhY2ggYmxvY2sgaXMgOHg4IHBpeGVscy5cbiAgICAvLyBTbyB0aGlzIGlzIHRoZSBzbWFsbGVzdCBkaW1lbnNpb24gaW4gZWFjaCBheGlzIHdlIGNhbiBhY2NlcHQuXG4gICAgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVIgPSAzO1xuICAgIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFID0gMSA8PCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUjsgLy8gLi4uMDEwMC4uLjAwXG4gICAgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfTUFTSyA9IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFIC0gMTsgLy8gLi4uMDAxMS4uLjExXG4gICAgSHlicmlkQmluYXJpemVyLk1JTklNVU1fRElNRU5TSU9OID0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkUgKiA1O1xuICAgIEh5YnJpZEJpbmFyaXplci5NSU5fRFlOQU1JQ19SQU5HRSA9IDI0O1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xuICAgIC8qKlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgY2xhc3MgaGllcmFyY2h5IGlzIHRvIGFic3RyYWN0IGRpZmZlcmVudCBiaXRtYXAgaW1wbGVtZW50YXRpb25zIGFjcm9zc1xuICAgICAqIHBsYXRmb3JtcyBpbnRvIGEgc3RhbmRhcmQgaW50ZXJmYWNlIGZvciByZXF1ZXN0aW5nIGdyZXlzY2FsZSBsdW1pbmFuY2UgdmFsdWVzLiBUaGUgaW50ZXJmYWNlXG4gICAgICogb25seSBwcm92aWRlcyBpbW11dGFibGUgbWV0aG9kczsgdGhlcmVmb3JlIGNyb3AgYW5kIHJvdGF0aW9uIGNyZWF0ZSBjb3BpZXMuIFRoaXMgaXMgdG8gZW5zdXJlXG4gICAgICogdGhhdCBvbmUgUmVhZGVyIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwgbHVtaW5hbmNlIHNvdXJjZSBhbmQgbGVhdmUgaXQgaW4gYW4gdW5rbm93biBzdGF0ZVxuICAgICAqIGZvciBvdGhlciBSZWFkZXJzIGluIHRoZSBjaGFpbi5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICovXG4gICAgY2xhc3MgTHVtaW5hbmNlU291cmNlIHtcbiAgICAgICAgY29uc3RydWN0b3Iod2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSB3aWR0aCBvZiB0aGUgYml0bWFwLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBUaGUgaGVpZ2h0IG9mIHRoZSBiaXRtYXAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gV2hldGhlciB0aGlzIHN1YmNsYXNzIHN1cHBvcnRzIGNyb3BwaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNDcm9wU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIGNyb3BwZWQgaW1hZ2UgZGF0YS4gSW1wbGVtZW50YXRpb25zIG1heSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZVxuICAgICAgICAgKiBvcmlnaW5hbCBkYXRhIHJhdGhlciB0aGFuIGEgY29weS4gT25seSBjYWxsYWJsZSBpZiBpc0Nyb3BTdXBwb3J0ZWQoKSBpcyB0cnVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBjb29yZGluYXRlLCB3aGljaCBtdXN0IGJlIGluIFswLGdldFdpZHRoKCkpXG4gICAgICAgICAqIEBwYXJhbSB0b3AgVGhlIHRvcCBjb29yZGluYXRlLCB3aGljaCBtdXN0IGJlIGluIFswLGdldEhlaWdodCgpKVxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgdG8gY3JvcC5cbiAgICAgICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUgdG8gY3JvcC5cbiAgICAgICAgICogQHJldHVybiBBIGNyb3BwZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGNyb3AobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbignVGhpcyBsdW1pbmFuY2Ugc291cmNlIGRvZXMgbm90IHN1cHBvcnQgY3JvcHBpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gV2hldGhlciB0aGlzIHN1YmNsYXNzIHN1cHBvcnRzIGNvdW50ZXItY2xvY2t3aXNlIHJvdGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNSb3RhdGVTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggcm90YXRlZCBpbWFnZSBkYXRhIGJ5IDkwIGRlZ3JlZXMgY291bnRlcmNsb2Nrd2lzZS5cbiAgICAgICAgICogT25seSBjYWxsYWJsZSBpZiB7QGxpbmsgI2lzUm90YXRlU3VwcG9ydGVkKCl9IGlzIHRydWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gQSByb3RhdGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKCdUaGlzIGx1bWluYW5jZSBzb3VyY2UgZG9lcyBub3Qgc3VwcG9ydCByb3RhdGlvbiBieSA5MCBkZWdyZWVzLicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHJvdGF0ZWQgaW1hZ2UgZGF0YSBieSA0NSBkZWdyZWVzIGNvdW50ZXJjbG9ja3dpc2UuXG4gICAgICAgICAqIE9ubHkgY2FsbGFibGUgaWYge0BsaW5rICNpc1JvdGF0ZVN1cHBvcnRlZCgpfSBpcyB0cnVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIEEgcm90YXRlZCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKCdUaGlzIGx1bWluYW5jZSBzb3VyY2UgZG9lcyBub3Qgc3VwcG9ydCByb3RhdGlvbiBieSA0NSBkZWdyZWVzLicpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkodGhpcy53aWR0aCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVJvdyA9IHRoaXMuZ2V0Um93KHksIHJvdyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbHVtaW5hbmNlID0gc291cmNlUm93W3hdICYgMHhGRjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsdW1pbmFuY2UgPCAweDQwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJyMnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGx1bWluYW5jZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnKyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobHVtaW5hbmNlIDwgMHhDMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICcuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXG4gICAgLyoqXG4gICAgICogQSB3cmFwcGVyIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBMdW1pbmFuY2VTb3VyY2V9IHdoaWNoIGludmVydHMgdGhlIGx1bWluYW5jZXMgaXQgcmV0dXJucyAtLSBibGFjayBiZWNvbWVzXG4gICAgICogd2hpdGUgYW5kIHZpY2UgdmVyc2EsIGFuZCBlYWNoIHZhbHVlIGJlY29tZXMgKDI1NS12YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEludmVydGVkTHVtaW5hbmNlU291cmNlIGV4dGVuZHMgTHVtaW5hbmNlU291cmNlIHtcbiAgICAgICAgY29uc3RydWN0b3IoZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHN1cGVyKGRlbGVnYXRlLmdldFdpZHRoKCksIGRlbGVnYXRlLmdldEhlaWdodCgpKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGdldFJvdyh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlUm93ID0gdGhpcy5kZWxlZ2F0ZS5nZXRSb3coeSwgcm93KTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc291cmNlUm93W2ldID0gLyooYnl0ZSkqLyAoMjU1IC0gKHNvdXJjZVJvd1tpXSAmIDB4RkYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VSb3c7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBnZXRNYXRyaXgoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSB0aGlzLmRlbGVnYXRlLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5nZXRXaWR0aCgpICogdGhpcy5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGludmVydGVkTWF0cml4ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWRNYXRyaXhbaV0gPSAvKihieXRlKSovICgyNTUgLSAobWF0cml4W2ldICYgMHhGRikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGludmVydGVkTWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgaXNDcm9wU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuaXNDcm9wU3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBjcm9wKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMuZGVsZWdhdGUuY3JvcChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGlzUm90YXRlU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuaXNSb3RhdGVTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBvcmlnaW5hbCBkZWxlZ2F0ZSB7QGxpbmsgTHVtaW5hbmNlU291cmNlfSBzaW5jZSBpbnZlcnQgdW5kb2VzIGl0c2VsZlxuICAgICAgICAgKi9cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBpbnZlcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMuZGVsZWdhdGUucm90YXRlQ291bnRlckNsb2Nrd2lzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHJvdGF0ZUNvdW50ZXJDbG9ja3dpc2U0NSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UodGhpcy5kZWxlZ2F0ZS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlNDUoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBNb3ZpbmcgdG8gQHp4aW5nL2Jyb3dzZXJcbiAgICAgKi9cbiAgICBjbGFzcyBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZSBleHRlbmRzIEx1bWluYW5jZVNvdXJjZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNhbnZhcykge1xuICAgICAgICAgICAgc3VwZXIoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICAgICAgdGhpcy50ZW1wQ2FudmFzRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLm1ha2VCdWZmZXJGcm9tQ2FudmFzSW1hZ2VEYXRhKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG1ha2VCdWZmZXJGcm9tQ2FudmFzSW1hZ2VEYXRhKGNhbnZhcykge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY2FudmFzLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UudG9HcmF5c2NhbGVCdWZmZXIoaW1hZ2VEYXRhLmRhdGEsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHRvR3JheXNjYWxlQnVmZmVyKGltYWdlQnVmZmVyLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBncmF5c2NhbGVCdWZmZXIgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwLCBsZW5ndGggPSBpbWFnZUJ1ZmZlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gNCwgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdyYXk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxwaGEgPSBpbWFnZUJ1ZmZlcltpICsgM107XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbG9yIG9mIGZ1bGx5LXRyYW5zcGFyZW50IHBpeGVscyBpcyBpcnJlbGV2YW50LiBUaGV5IGFyZSBvZnRlbiwgdGVjaG5pY2FsbHksIGZ1bGx5LXRyYW5zcGFyZW50XG4gICAgICAgICAgICAgICAgLy8gYmxhY2sgKDAgYWxwaGEsIGFuZCB0aGVuIDAgUkdCKS4gVGhleSBhcmUgb2Z0ZW4gdXNlZCwgb2YgY291cnNlIGFzIHRoZSBcIndoaXRlXCIgYXJlYSBpbiBhXG4gICAgICAgICAgICAgICAgLy8gYmFyY29kZSBpbWFnZS4gRm9yY2UgYW55IHN1Y2ggcGl4ZWwgdG8gYmUgd2hpdGU6XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXkgPSAweEZGO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxSID0gaW1hZ2VCdWZmZXJbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsRyA9IGltYWdlQnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxCID0gaW1hZ2VCdWZmZXJbaSArIDJdO1xuICAgICAgICAgICAgICAgICAgICAvLyAuMjk5UiArIDAuNTg3RyArIDAuMTE0QiAoWVVWL1lJUSBmb3IgUEFMIGFuZCBOVFNDKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gKDMwNipSKSA+PiAxMCBpcyBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIFIqMC4yOTksIGFuZCBzbyBvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gMHgyMDAgPj4gMTAgaXMgMC41LCBpdCBpbXBsZW1lbnRzIHJvdW5kaW5nLlxuICAgICAgICAgICAgICAgICAgICBncmF5ID0gKDMwNiAqIHBpeGVsUiArXG4gICAgICAgICAgICAgICAgICAgICAgICA2MDEgKiBwaXhlbEcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgMTE3ICogcGl4ZWxCICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDB4MjAwKSA+PiAxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JheXNjYWxlQnVmZmVyW2pdID0gZ3JheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBncmF5c2NhbGVCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Um93KHkgLyppbnQqLywgcm93KSB7XG4gICAgICAgICAgICBpZiAoeSA8IDAgfHwgeSA+PSB0aGlzLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUmVxdWVzdGVkIHJvdyBpcyBvdXRzaWRlIHRoZSBpbWFnZTogJyArIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHkgKiB3aWR0aDtcbiAgICAgICAgICAgIGlmIChyb3cgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByb3cgPSB0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgc3RhcnQgKyB3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocm93Lmxlbmd0aCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZSB1bmRlcmx5aW5nIHJhc3RlciBvZiBpbWFnZSBjb25zaXN0cyBvZiBieXRlcyB3aXRoIHRoZSBsdW1pbmFuY2UgdmFsdWVzXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY2FuIGF2b2lkIHNldC9zbGljZT9cbiAgICAgICAgICAgICAgICByb3cuc2V0KHRoaXMuYnVmZmVyLnNsaWNlKHN0YXJ0LCBzdGFydCArIHdpZHRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG4gICAgICAgIGdldE1hdHJpeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBpc0Nyb3BTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjcm9wKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICBzdXBlci5jcm9wKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyBhbHdheXMgdHJ1ZSwgc2luY2UgdGhlIGltYWdlIGlzIGEgZ3JheS1zY2FsZSBpbWFnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICBpc1JvdGF0ZVN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UoKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZSgtOTApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGUoLTQ1KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGdldFRlbXBDYW52YXNFbGVtZW50KCkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IHRoaXMudGVtcENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wQ2FudmFzRWxlbWVudCA9IHRoaXMuY2FudmFzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgdGVtcENhbnZhc0VsZW1lbnQud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgICAgICB0ZW1wQ2FudmFzRWxlbWVudC5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wQ2FudmFzRWxlbWVudCA9IHRlbXBDYW52YXNFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVtcENhbnZhc0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcm90YXRlKGFuZ2xlKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wQ2FudmFzRWxlbWVudCA9IHRoaXMuZ2V0VGVtcENhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBDb250ZXh0ID0gdGVtcENhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IGFuZ2xlICogSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UuREVHUkVFX1RPX1JBRElBTlM7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgYW5kIHNldCBuZXcgZGltZW5zaW9ucyBmb3IgdGVtcCBjYW52YXNcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGguY2VpbChNYXRoLmFicyhNYXRoLmNvcyhhbmdsZVJhZGlhbnMpKSAqIHdpZHRoICsgTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGVSYWRpYW5zKSkgKiBoZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGguYWJzKE1hdGguc2luKGFuZ2xlUmFkaWFucykpICogd2lkdGggKyBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZVJhZGlhbnMpKSAqIGhlaWdodCk7XG4gICAgICAgICAgICB0ZW1wQ2FudmFzRWxlbWVudC53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICAgICAgdGVtcENhbnZhc0VsZW1lbnQuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgLy8gRHJhdyBhdCBjZW50ZXIgb2YgdGVtcCBjYW52YXMgdG8gcHJldmVudCBjbGlwcGluZyBvZiBpbWFnZSBkYXRhXG4gICAgICAgICAgICB0ZW1wQ29udGV4dC50cmFuc2xhdGUobmV3V2lkdGggLyAyLCBuZXdIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIHRlbXBDb250ZXh0LnJvdGF0ZShhbmdsZVJhZGlhbnMpO1xuICAgICAgICAgICAgdGVtcENvbnRleHQuZHJhd0ltYWdlKHRoaXMuY2FudmFzLCB3aWR0aCAvIC0yLCBoZWlnaHQgLyAtMik7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLm1ha2VCdWZmZXJGcm9tQ2FudmFzSW1hZ2VEYXRhKHRlbXBDYW52YXNFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGludmVydCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UuREVHUkVFX1RPX1JBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICpcbiAgICAgKiBWaWRlbyBpbnB1dCBkZXZpY2UgbWV0YWRhdGEgY29udGFpbmluZyB0aGUgaWQgYW5kIGxhYmVsIG9mIHRoZSBkZXZpY2UgaWYgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGNsYXNzIFZpZGVvSW5wdXREZXZpY2Uge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBWaWRlb0lucHV0RGV2aWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGV2aWNlSWQgdGhlIHZpZGVvIGlucHV0IGRldmljZSBpZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgdGhlIGxhYmVsIG9mIHRoZSBkZXZpY2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihkZXZpY2VJZCwgbGFiZWwsIGdyb3VwSWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgICAgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgICAgICAgICAgdGhpcy5raW5kID0gJ3ZpZGVvaW5wdXQnO1xuICAgICAgICAgICAgdGhpcy5ncm91cElkID0gZ3JvdXBJZCB8fCB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgICAgICAgICAgIGdyb3VwSWQ6IHRoaXMuZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICBkZXZpY2VJZDogdGhpcy5kZXZpY2VJZCxcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5sYWJlbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX19hd2FpdGVyID0gKChnbG9iYWxUaGlzIHx8IGdsb2JhbCB8fCBzZWxmIHx8IHdpbmRvdyB8fCB1bmRlZmluZWQpICYmIChnbG9iYWxUaGlzIHx8IGdsb2JhbCB8fCBzZWxmIHx8IHdpbmRvdyB8fCB1bmRlZmluZWQpLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICpcbiAgICAgKiBCYXNlIGNsYXNzIGZvciBicm93c2VyIGNvZGUgcmVhZGVyLlxuICAgICAqL1xuICAgIGNsYXNzIEJyb3dzZXJDb2RlUmVhZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlckNvZGVSZWFkZXIuXG4gICAgICAgICAqIEBwYXJhbSB7UmVhZGVyfSByZWFkZXIgVGhlIHJlYWRlciBpbnN0YW5jZSB0byBkZWNvZGUgdGhlIGJhcmNvZGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lQmV0d2VlblNjYW5zTWlsbGlzPTUwMF0gdGhlIHRpbWUgZGVsYXkgYmV0d2VlbiBzdWJzZXF1ZW50IHN1Y2Nlc3NmdWwgZGVjb2RlIHRyaWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IocmVhZGVyLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwLCBfaGludHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyO1xuICAgICAgICAgICAgdGhpcy50aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gdGltZUJldHdlZW5TY2Fuc01pbGxpcztcbiAgICAgICAgICAgIHRoaXMuX2hpbnRzID0gX2hpbnRzO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIHdpbGwgYnJlYWsgdGhlIGxvb3AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgd2lsbCBicmVhayB0aGUgbG9vcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fc3RvcEFzeW5jRGVjb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlbGF5IHRpbWUgYmV0d2VlbiBkZWNvZGUgYXR0ZW1wdHMgbWFkZSBieSB0aGUgc2Nhbm5lci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbmF2aWdhdG9yIGlzIHByZXNlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgaGFzTmF2aWdhdG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBtZWRpYURldmljZXMgdW5kZXIgbmF2aWdhdG9yIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBpc01lZGlhRGV2aWNlc1N1cG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzTmF2aWdhdG9yICYmICEhbmF2aWdhdG9yLm1lZGlhRGV2aWNlcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZW51bWVyYXRlRGV2aWNlcyB1bmRlciBuYXZpZ2F0b3IgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGNhbkVudW1lcmF0ZURldmljZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEodGhpcy5pc01lZGlhRGV2aWNlc1N1cG9ydGVkICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFRpbWUgYmV0d2VlbiB0d28gZGVjb2RpbmcgdHJpZXMgaW4gbWlsbGkgc2Vjb25kcy4gKi9cbiAgICAgICAgZ2V0IHRpbWVCZXR3ZWVuRGVjb2RpbmdBdHRlbXB0cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZSB0aGUgdGltZSBzcGFuIHRoZSBkZWNvZGVyIHdhaXRzIGJldHdlZW4gdHdvIGRlY29kaW5nIHRyaWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzIFRpbWUgYmV0d2VlbiB0d28gZGVjb2RpbmcgdHJpZXMgaW4gbWlsbGkgc2Vjb25kcy5cbiAgICAgICAgICovXG4gICAgICAgIHNldCB0aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHMobWlsbGlzKSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHMgPSBtaWxsaXMgPCAwID8gMCA6IG1pbGxpcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgaGludHMuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQgaGludHMoaGludHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpbnRzID0gaGludHMgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgaGludHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgaGludHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGludHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGFsbCB0aGUgYXZhaWxhYmxlIHZpZGVvIGlucHV0IGRldmljZXMuXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0VmlkZW9JbnB1dERldmljZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNOYXZpZ2F0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGVudW1lcmF0ZSBkZXZpY2VzLCBuYXZpZ2F0b3IgaXMgbm90IHByZXNlbnQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYW5FbnVtZXJhdGVEZXZpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBlbnVtZXJhdGUgZGV2aWNlcywgbWV0aG9kIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZXMgPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWRlb0RldmljZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRldmljZSBvZiBkZXZpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvJyA/ICd2aWRlb2lucHV0JyA6IGRldmljZS5raW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2VJZCA9IGRldmljZS5kZXZpY2VJZCB8fCBkZXZpY2UuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZGV2aWNlLmxhYmVsIHx8IGBWaWRlbyBkZXZpY2UgJHt2aWRlb0RldmljZXMubGVuZ3RoICsgMX1gO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBncm91cElkID0gZGV2aWNlLmdyb3VwSWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZGVvRGV2aWNlID0geyBkZXZpY2VJZCwgbGFiZWwsIGtpbmQsIGdyb3VwSWQgfTtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9EZXZpY2VzLnB1c2godmlkZW9EZXZpY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW9EZXZpY2VzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9idGFpbiB0aGUgbGlzdCBvZiBhdmFpbGFibGUgZGV2aWNlcyB3aXRoIHR5cGUgJ3ZpZGVvaW5wdXQnLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWaWRlb0lucHV0RGV2aWNlW10+fSBhbiBhcnJheSBvZiBhdmFpbGFibGUgdmlkZW8gaW5wdXQgZGV2aWNlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGBsaXN0VmlkZW9JbnB1dERldmljZXNgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRWaWRlb0lucHV0RGV2aWNlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlcyA9IHlpZWxkIHRoaXMubGlzdFZpZGVvSW5wdXREZXZpY2VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZXMubWFwKGQgPT4gbmV3IFZpZGVvSW5wdXREZXZpY2UoZC5kZXZpY2VJZCwgZC5sYWJlbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExldCdzIHlvdSBmaW5kIGEgZGV2aWNlIHVzaW5nIGl0J3MgSWQuXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kRGV2aWNlQnlJZChkZXZpY2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2VzID0geWllbGQgdGhpcy5saXN0VmlkZW9JbnB1dERldmljZXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRldmljZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXZpY2VzLmZpbmQoeCA9PiB4LmRldmljZUlkID09PSBkZXZpY2VJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyB0aGUgYmFyY29kZSBmcm9tIHRoZSBkZXZpY2Ugc3BlY2lmaWVkIGJ5IGRldmljZUlkIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRldmljZUlkIHRoZSBpZCBvZiBvbmUgb2YgdGhlIGRldmljZXMgb2J0YWluZWQgYWZ0ZXIgY2FsbGluZyBnZXRWaWRlb0lucHV0RGV2aWNlcy4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gdGhpcyBjYXNlIGl0IHdpbGwgZGVjb2RlIGZyb20gb25lIG9mIHRoZSBhdmFpbGFibGUgZGV2aWNlcywgcHJlZmZlcmluZyB0aGUgbWFpbiBjYW1lcmEgKGVudmlyb25tZW50IGZhY2luZykgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgKiBAcGFyYW0gdmlkZW8gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMgVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZGVjb2RlT25jZUZyb21WaWRlb0RldmljZWAgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21JbnB1dFZpZGVvRGV2aWNlKGRldmljZUlkLCB2aWRlb1NvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVPbmNlRnJvbVZpZGVvRGV2aWNlKGRldmljZUlkLCB2aWRlb1NvdXJjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gb25lIGF0dGVtcHQsIHRyaWVzIHRvIGRlY29kZSB0aGUgYmFyY29kZSBmcm9tIHRoZSBkZXZpY2Ugc3BlY2lmaWVkIGJ5IGRldmljZUlkIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRldmljZUlkIHRoZSBpZCBvZiBvbmUgb2YgdGhlIGRldmljZXMgb2J0YWluZWQgYWZ0ZXIgY2FsbGluZyBnZXRWaWRlb0lucHV0RGV2aWNlcy4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gdGhpcyBjYXNlIGl0IHdpbGwgZGVjb2RlIGZyb20gb25lIG9mIHRoZSBhdmFpbGFibGUgZGV2aWNlcywgcHJlZmZlcmluZyB0aGUgbWFpbiBjYW1lcmEgKGVudmlyb25tZW50IGZhY2luZykgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgKiBAcGFyYW0gdmlkZW8gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMgVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVPbmNlRnJvbVZpZGVvRGV2aWNlKGRldmljZUlkLCB2aWRlb1NvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgbGV0IHZpZGVvQ29uc3RyYWludHM7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXZpY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzID0geyBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzID0geyBkZXZpY2VJZDogeyBleGFjdDogZGV2aWNlSWQgfSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHsgdmlkZW86IHZpZGVvQ29uc3RyYWludHMgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVPbmNlRnJvbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzLCB2aWRlb1NvdXJjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gb25lIGF0dGVtcHQsIHRyaWVzIHRvIGRlY29kZSB0aGUgYmFyY29kZSBmcm9tIGEgc3RyZWFtIG9idGFpbmVkIGZyb20gdGhlIGdpdmVuIGNvbnN0cmFpbnRzIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvbnN0cmFpbnRzIHRoZSBtZWRpYSBzdHJlYW0gY29uc3RyYWludHMgdG8gZ2V0IHMgdmFsaWQgbWVkaWEgc3RyZWFtIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB2aWRlbyB0aGUgdmlkZW8gZWxlbWVudCBpbiBwYWdlIHdoZXJlIHRvIHNob3cgdGhlIHZpZGVvIHdoaWxlIGRlY29kaW5nLiBDYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgZGlyZWN0bHkgYW4gSFRNTFZpZGVvRWxlbWVudC4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSBubyB2aWRlbyB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgZGVjb2RpbmcgcmVzdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZU9uY2VGcm9tQ29uc3RyYWludHMoY29uc3RyYWludHMsIHZpZGVvU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVPbmNlRnJvbVN0cmVhbShzdHJlYW0sIHZpZGVvU291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbiBvbmUgYXR0ZW1wdCwgdHJpZXMgdG8gZGVjb2RlIHRoZSBiYXJjb2RlIGZyb20gYSBzdHJlYW0gb2J0YWluZWQgZnJvbSB0aGUgZ2l2ZW4gY29uc3RyYWludHMgd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBbY29uc3RyYWludHNdIHRoZSBtZWRpYSBzdHJlYW0gY29uc3RyYWludHMgdG8gZ2V0IHMgdmFsaWQgbWVkaWEgc3RyZWFtIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxWaWRlb0VsZW1lbnR9IFt2aWRlb10gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVPbmNlRnJvbVN0cmVhbShzdHJlYW0sIHZpZGVvU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWRlbyA9IHlpZWxkIHRoaXMuYXR0YWNoU3RyZWFtVG9WaWRlbyhzdHJlYW0sIHZpZGVvU291cmNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLmRlY29kZU9uY2UodmlkZW8pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGludW91c2x5IGRlY29kZXMgdGhlIGJhcmNvZGUgZnJvbSB0aGUgZGV2aWNlIHNwZWNpZmllZCBieSBkZXZpY2Ugd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBbZGV2aWNlSWRdIHRoZSBpZCBvZiBvbmUgb2YgdGhlIGRldmljZXMgb2J0YWluZWQgYWZ0ZXIgY2FsbGluZyBnZXRWaWRlb0lucHV0RGV2aWNlcy4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gdGhpcyBjYXNlIGl0IHdpbGwgZGVjb2RlIGZyb20gb25lIG9mIHRoZSBhdmFpbGFibGUgZGV2aWNlcywgcHJlZmZlcmluZyB0aGUgbWFpbiBjYW1lcmEgKGVudmlyb25tZW50IGZhY2luZykgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MVmlkZW9FbGVtZW50fG51bGx9IFt2aWRlb10gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGRlY29kZUZyb21WaWRlb0RldmljZWAgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21JbnB1dFZpZGVvRGV2aWNlQ29udGludW91c2x5KGRldmljZUlkLCB2aWRlb1NvdXJjZSwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVGcm9tVmlkZW9EZXZpY2UoZGV2aWNlSWQsIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250aW51b3VzbHkgdHJpZXMgdG8gZGVjb2RlIHRoZSBiYXJjb2RlIGZyb20gdGhlIGRldmljZSBzcGVjaWZpZWQgYnkgZGV2aWNlIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gW2RldmljZUlkXSB0aGUgaWQgb2Ygb25lIG9mIHRoZSBkZXZpY2VzIG9idGFpbmVkIGFmdGVyIGNhbGxpbmcgZ2V0VmlkZW9JbnB1dERldmljZXMuIENhbiBiZSB1bmRlZmluZWQsIGluIHRoaXMgY2FzZSBpdCB3aWxsIGRlY29kZSBmcm9tIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGRldmljZXMsIHByZWZmZXJpbmcgdGhlIG1haW4gY2FtZXJhIChlbnZpcm9ubWVudCBmYWNpbmcpIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTFZpZGVvRWxlbWVudHxudWxsfSBbdmlkZW9dIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21WaWRlb0RldmljZShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZGVvQ29uc3RyYWludHM7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXZpY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzID0geyBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzID0geyBkZXZpY2VJZDogeyBleGFjdDogZGV2aWNlSWQgfSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHsgdmlkZW86IHZpZGVvQ29uc3RyYWludHMgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVGcm9tQ29uc3RyYWludHMoY29uc3RyYWludHMsIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250aW51b3VzbHkgdHJpZXMgdG8gZGVjb2RlIHRoZSBiYXJjb2RlIGZyb20gYSBzdHJlYW0gb2J0YWluZWQgZnJvbSB0aGUgZ2l2ZW4gY29uc3RyYWludHMgd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBbY29uc3RyYWludHNdIHRoZSBtZWRpYSBzdHJlYW0gY29uc3RyYWludHMgdG8gZ2V0IHMgdmFsaWQgbWVkaWEgc3RyZWFtIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxWaWRlb0VsZW1lbnR9IFt2aWRlb10gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tQ29uc3RyYWludHMoY29uc3RyYWludHMsIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVGcm9tU3RyZWFtKHN0cmVhbSwgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIG9uZSBhdHRlbXB0LCB0cmllcyB0byBkZWNvZGUgdGhlIGJhcmNvZGUgZnJvbSBhIHN0cmVhbSBvYnRhaW5lZCBmcm9tIHRoZSBnaXZlbiBjb25zdHJhaW50cyB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IFtjb25zdHJhaW50c10gdGhlIG1lZGlhIHN0cmVhbSBjb25zdHJhaW50cyB0byBnZXQgcyB2YWxpZCBtZWRpYSBzdHJlYW0gdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTFZpZGVvRWxlbWVudH0gW3ZpZGVvXSB0aGUgdmlkZW8gZWxlbWVudCBpbiBwYWdlIHdoZXJlIHRvIHNob3cgdGhlIHZpZGVvIHdoaWxlIGRlY29kaW5nLiBDYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgZGlyZWN0bHkgYW4gSFRNTFZpZGVvRWxlbWVudC4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSBubyB2aWRlbyB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ+fSBUaGUgZGVjb2RpbmcgcmVzdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21TdHJlYW0oc3RyZWFtLCB2aWRlb1NvdXJjZSwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlkZW8gPSB5aWVsZCB0aGlzLmF0dGFjaFN0cmVhbVRvVmlkZW8oc3RyZWFtLCB2aWRlb1NvdXJjZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlQ29udGludW91c2x5KHZpZGVvLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcmVha3MgdGhlIGRlY29kaW5nIGxvb3AuXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wQXN5bmNEZWNvZGUoKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wQXN5bmNEZWNvZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcmVha3MgdGhlIGRlY29kaW5nIGxvb3AuXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wQ29udGludW91c0RlY29kZSgpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgbmV3IHN0cmVhbSBhbmQgcmVxdWVzdCBhIG5ldyBkZWNvZGluZy13aXRoLWRlbGF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3RyZWFtIFRoZSBzdHJlYW0gdG8gYmUgc2hvd24gaW4gdGhlIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSBkZWNvZGVGbiBBIGNhbGxiYWNrIGZvciB0aGUgZGVjb2RlIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIGF0dGFjaFN0cmVhbVRvVmlkZW8oc3RyZWFtLCB2aWRlb1NvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWRlb0VsZW1lbnQgPSB0aGlzLnByZXBhcmVWaWRlb0VsZW1lbnQodmlkZW9Tb3VyY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVmlkZW9Tb3VyY2UodmlkZW9FbGVtZW50LCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50ID0gdmlkZW9FbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGxheVZpZGVvT25Mb2FkQXN5bmModmlkZW9FbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW9FbGVtZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2aWRlb0VsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHBsYXlWaWRlb09uTG9hZEFzeW5jKHZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHRoaXMucGxheVZpZGVvT25Mb2FkKHZpZGVvRWxlbWVudCwgKCkgPT4gcmVzb2x2ZSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRzIGxpc3RlbmVycyBhbmQgY2FsbGJhY2tzIHRvIHRoZSB2aWRlb0VsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja0ZuXG4gICAgICAgICAqL1xuICAgICAgICBwbGF5VmlkZW9PbkxvYWQoZWxlbWVudCwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgdGhpcy52aWRlb0VuZGVkTGlzdGVuZXIgPSAoKSA9PiB0aGlzLnN0b3BTdHJlYW1zKCk7XG4gICAgICAgICAgICB0aGlzLnZpZGVvQ2FuUGxheUxpc3RlbmVyID0gKCkgPT4gdGhpcy50cnlQbGF5VmlkZW8oZWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy52aWRlb0VuZGVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgdGhpcy52aWRlb0NhblBsYXlMaXN0ZW5lcik7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIC8vIGlmIGNhbnBsYXkgd2FzIGFscmVhZHkgZmlyZWQsIHdlIHdvbid0IGtub3cgd2hlbiB0byBwbGF5LCBzbyBqdXN0IGdpdmUgaXQgYSB0cnlcbiAgICAgICAgICAgIHRoaXMudHJ5UGxheVZpZGVvKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZpZGVvIGVsZW1lbnQgaXMgY3VycmVudGx5IHBsYXlpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBpc1ZpZGVvUGxheWluZyh2aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvLmN1cnJlbnRUaW1lID4gMCAmJiAhdmlkZW8ucGF1c2VkICYmICF2aWRlby5lbmRlZCAmJiB2aWRlby5yZWFkeVN0YXRlID4gMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSnVzdCB0cmllcyB0byBwbGF5IHRoZSB2aWRlbyBhbmQgbG9ncyBhbnkgZXJyb3JzLlxuICAgICAgICAgKiBUaGUgcGxheSBjYWxsIGlzIG9ubHkgbWFkZSBpcyB0aGUgdmlkZW8gaXMgbm90IGFscmVhZHkgcGxheWluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRyeVBsYXlWaWRlbyh2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXlpbmcodmlkZW9FbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RyeWluZyB0byBwbGF5IHZpZGVvIHRoYXQgaXMgYWxyZWFkeSBwbGF5aW5nLicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHZpZGVvRWxlbWVudC5wbGF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0l0IHdhcyBub3QgcG9zc2libGUgdG8gcGxheSB0aGUgdmlkZW8uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlYXJjaGVzIGFuZCB2YWxpZGF0ZXMgYSBtZWRpYSBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TWVkaWFFbGVtZW50KG1lZGlhRWxlbWVudElkLCB0eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBtZWRpYUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtZWRpYUVsZW1lbnRJZCk7XG4gICAgICAgICAgICBpZiAoIW1lZGlhRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihgZWxlbWVudCB3aXRoIGlkICcke21lZGlhRWxlbWVudElkfScgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVkaWFFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihgZWxlbWVudCB3aXRoIGlkICcke21lZGlhRWxlbWVudElkfScgbXVzdCBiZSBhbiAke3R5cGV9IGVsZW1lbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZWRpYUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgdGhlIGJhcmNvZGUgZnJvbSBhbiBpbWFnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsoc3RyaW5nfEhUTUxJbWFnZUVsZW1lbnQpfSBbc291cmNlXSBUaGUgaW1hZ2UgZWxlbWVudCB0aGF0IGNhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciB0aGUgZWxlbWVudCBpdHNlbGYuIENhbiBiZSB1bmRlZmluZWQgaW4gd2hpY2ggY2FzZSB0aGUgZGVjb2Rpbmcgd2lsbCBiZSBkb25lIGZyb20gdGhlIGltYWdlVXJsIHBhcmFtZXRlci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt1cmxdXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3VsdD59IFRoZSBkZWNvZGluZyByZXN1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbUltYWdlKHNvdXJjZSwgdXJsKSB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZSAmJiAhdXJsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdlaXRoZXIgaW1hZ2VFbGVtZW50IHdpdGggYSBzcmMgc2V0IG9yIGFuIHVybCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXJsICYmICFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGcm9tSW1hZ2VVcmwodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZyb21JbWFnZUVsZW1lbnQoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyB0aGUgYmFyY29kZSBmcm9tIGEgdmlkZW8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xIVE1MSW1hZ2VFbGVtZW50KX0gW3NvdXJjZV0gVGhlIGltYWdlIGVsZW1lbnQgdGhhdCBjYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgdGhlIGVsZW1lbnQgaXRzZWxmLiBDYW4gYmUgdW5kZWZpbmVkIGluIHdoaWNoIGNhc2UgdGhlIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBmcm9tIHRoZSBpbWFnZVVybCBwYXJhbWV0ZXIuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXJsXVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ+fSBUaGUgZGVjb2RpbmcgcmVzdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21WaWRlbyhzb3VyY2UsIHVybCkge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UgJiYgIXVybCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbignRWl0aGVyIGFuIGVsZW1lbnQgd2l0aCBhIHNyYyBzZXQgb3IgYW4gVVJMIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cmwgJiYgIXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZyb21WaWRlb1VybCh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRnJvbVZpZGVvRWxlbWVudChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGNvbnRpbnVvdXNseSB0aGUgYmFyY29kZSBmcm9tIGEgdmlkZW8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xIVE1MSW1hZ2VFbGVtZW50KX0gW3NvdXJjZV0gVGhlIGltYWdlIGVsZW1lbnQgdGhhdCBjYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgdGhlIGVsZW1lbnQgaXRzZWxmLiBDYW4gYmUgdW5kZWZpbmVkIGluIHdoaWNoIGNhc2UgdGhlIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBmcm9tIHRoZSBpbWFnZVVybCBwYXJhbWV0ZXIuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXJsXVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ+fSBUaGUgZGVjb2RpbmcgcmVzdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbVZpZGVvQ29udGludW91c2x5KHNvdXJjZSwgdXJsLCBjYWxsYmFja0ZuKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBzb3VyY2UgJiYgdW5kZWZpbmVkID09PSB1cmwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oJ0VpdGhlciBhbiBlbGVtZW50IHdpdGggYSBzcmMgc2V0IG9yIGFuIFVSTCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXJsICYmICFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGcm9tVmlkZW9VcmxDb250aW51b3VzbHkodXJsLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZyb21WaWRlb0VsZW1lbnRDb250aW51b3VzbHkoc291cmNlLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBzb21ldGhpbmcgZnJvbSBhbiBpbWFnZSBIVE1MIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tSW1hZ2VFbGVtZW50KHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oJ0FuIGltYWdlIGVsZW1lbnQgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnByZXBhcmVJbWFnZUVsZW1lbnQoc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbWFnZUxvYWRlZChlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHRhc2sgPSB0aGlzLmRlY29kZU9uY2UoZWxlbWVudCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFzayA9IHRoaXMuX2RlY29kZU9uTG9hZEltYWdlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgc29tZXRoaW5nIGZyb20gYW4gaW1hZ2UgSFRNTCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbVZpZGVvRWxlbWVudChzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9kZWNvZGVGcm9tVmlkZW9FbGVtZW50U2V0dXAoc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVPbkxvYWRWaWRlbyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBzb21ldGhpbmcgZnJvbSBhbiBpbWFnZSBIVE1MIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tVmlkZW9FbGVtZW50Q29udGludW91c2x5KHNvdXJjZSwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2RlY29kZUZyb21WaWRlb0VsZW1lbnRTZXR1cChzb3VyY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZU9uTG9hZFZpZGVvQ29udGludW91c2x5KGVsZW1lbnQsIGNhbGxiYWNrRm4pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHVwIHRoZSB2aWRlbyBzb3VyY2Ugc28gaXQgY2FuIGJlIGRlY29kZWQgd2hlbiBsb2FkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzb3VyY2UgVGhlIHZpZGVvIHNvdXJjZSBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgX2RlY29kZUZyb21WaWRlb0VsZW1lbnRTZXR1cChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdBIHZpZGVvIGVsZW1lbnQgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnByZXBhcmVWaWRlb0VsZW1lbnQoc291cmNlKTtcbiAgICAgICAgICAgIC8vIGRlZmluZXMgdGhlIHZpZGVvIGVsZW1lbnQgYmVmb3JlIHN0YXJ0cyBkZWNvZGluZ1xuICAgICAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gaW1hZ2UgZnJvbSBhIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21JbWFnZVVybCh1cmwpIHtcbiAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdBbiBVUkwgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnByZXBhcmVJbWFnZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZVRhc2sgPSB0aGlzLl9kZWNvZGVPbkxvYWRJbWFnZShlbGVtZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3JjID0gdXJsO1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gaW1hZ2UgZnJvbSBhIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21WaWRlb1VybCh1cmwpIHtcbiAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdBbiBVUkwgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZXMgYSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMucHJlcGFyZVZpZGVvRWxlbWVudCgpO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlVGFzayA9IHRoaXMuZGVjb2RlRnJvbVZpZGVvRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3JjID0gdXJsO1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gaW1hZ2UgZnJvbSBhIFVSTC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbVZpZGVvVXJsQ29udGludW91c2x5KHVybCwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oJ0FuIFVSTCBtdXN0IGJlIHByb3ZpZGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgLy8gY3JlYXRlcyBhIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wcmVwYXJlVmlkZW9FbGVtZW50KCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVUYXNrID0gdGhpcy5kZWNvZGVGcm9tVmlkZW9FbGVtZW50Q29udGludW91c2x5KGVsZW1lbnQsIGNhbGxiYWNrRm4pO1xuICAgICAgICAgICAgZWxlbWVudC5zcmMgPSB1cmw7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlVGFzaztcbiAgICAgICAgfVxuICAgICAgICBfZGVjb2RlT25Mb2FkSW1hZ2UoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlTG9hZGVkTGlzdGVuZXIgPSAoKSA9PiB0aGlzLmRlY29kZU9uY2UoZWxlbWVudCwgZmFsc2UsIHRydWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLmltYWdlTG9hZGVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX2RlY29kZU9uTG9hZFZpZGVvKHZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAvLyBwbGF5cyB0aGUgdmlkZW9cbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBsYXlWaWRlb09uTG9hZEFzeW5jKHZpZGVvRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnRzIGRlY29kaW5nIGFmdGVyIHBsYXllZCB0aGUgdmlkZW9cbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVPbmNlKHZpZGVvRWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfZGVjb2RlT25Mb2FkVmlkZW9Db250aW51b3VzbHkodmlkZW9FbGVtZW50LCBjYWxsYmFja0ZuKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIC8vIHBsYXlzIHRoZSB2aWRlb1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGxheVZpZGVvT25Mb2FkQXN5bmModmlkZW9FbGVtZW50KTtcbiAgICAgICAgICAgICAgICAvLyBzdGFydHMgZGVjb2RpbmcgYWZ0ZXIgcGxheWVkIHRoZSB2aWRlb1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQ29udGludW91c2x5KHZpZGVvRWxlbWVudCwgY2FsbGJhY2tGbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpc0ltYWdlTG9hZGVkKGltZykge1xuICAgICAgICAgICAgLy8gRHVyaW5nIHRoZSBvbmxvYWQgZXZlbnQsIElFIGNvcnJlY3RseSBpZGVudGlmaWVzIGFueSBpbWFnZXMgdGhhdFxuICAgICAgICAgICAgLy8gd2VyZW7igJl0IGRvd25sb2FkZWQgYXMgbm90IGNvbXBsZXRlLiBPdGhlcnMgc2hvdWxkIHRvby4gR2Vja28tYmFzZWRcbiAgICAgICAgICAgIC8vIGJyb3dzZXJzIGFjdCBsaWtlIE5TNCBpbiB0aGF0IHRoZXkgcmVwb3J0IHRoaXMgaW5jb3JyZWN0bHkuXG4gICAgICAgICAgICBpZiAoIWltZy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZXkgZG8gaGF2ZSB0d28gdmVyeSB1c2VmdWwgcHJvcGVydGllczogbmF0dXJhbFdpZHRoIGFuZFxuICAgICAgICAgICAgLy8gbmF0dXJhbEhlaWdodC4gVGhlc2UgZ2l2ZSB0aGUgdHJ1ZSBzaXplIG9mIHRoZSBpbWFnZS4gSWYgaXQgZmFpbGVkXG4gICAgICAgICAgICAvLyB0byBsb2FkLCBlaXRoZXIgb2YgdGhlc2Ugc2hvdWxkIGJlIHplcm8uXG4gICAgICAgICAgICBpZiAoaW1nLm5hdHVyYWxXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIG90aGVyIHdheSBvZiBjaGVja2luZzogYXNzdW1lIGl04oCZcyBvay5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHByZXBhcmVJbWFnZUVsZW1lbnQoaW1hZ2VTb3VyY2UpIHtcbiAgICAgICAgICAgIGxldCBpbWFnZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGltYWdlU291cmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudC53aWR0aCA9IDIwMDtcbiAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQuaGVpZ2h0ID0gMjAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbWFnZVNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQgPSB0aGlzLmdldE1lZGlhRWxlbWVudChpbWFnZVNvdXJjZSwgJ2ltZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltYWdlU291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudCA9IGltYWdlU291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGltYWdlRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhIEhUTUxWaWRlb0VsZW1lbnQgZm9yIHNjYW5uaW5nIG9yIGNyZWF0ZXMgYSBuZXcgb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdmlkZW9Tb3VyY2UgVGhlIEhUTUxWaWRlb0VsZW1lbnQgdG8gYmUgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJlcGFyZVZpZGVvRWxlbWVudCh2aWRlb1NvdXJjZSkge1xuICAgICAgICAgICAgbGV0IHZpZGVvRWxlbWVudDtcbiAgICAgICAgICAgIGlmICghdmlkZW9Tb3VyY2UgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LndpZHRoID0gMjAwO1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5oZWlnaHQgPSAyMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZpZGVvU291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudCA9IHRoaXMuZ2V0TWVkaWFFbGVtZW50KHZpZGVvU291cmNlLCAndmlkZW8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWRlb1NvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQgPSB2aWRlb1NvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5lZWRlZCBmb3IgaU9TIDExXG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICd0cnVlJyk7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCdtdXRlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICd0cnVlJyk7XG4gICAgICAgICAgICByZXR1cm4gdmlkZW9FbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmllcyB0byBkZWNvZGUgZnJvbSB0aGUgdmlkZW8gaW5wdXQgdW50aWwgaXQgZmluZHMgc29tZSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZU9uY2UoZWxlbWVudCwgcmV0cnlJZk5vdEZvdW5kID0gdHJ1ZSwgcmV0cnlJZkNoZWNrc3VtT3JGb3JtYXRFcnJvciA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BBc3luY0RlY29kZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbG9vcCA9IChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RvcEFzeW5jRGVjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgTm90Rm91bmRFeGNlcHRpb24oJ1ZpZGVvIHN0cmVhbSBoYXMgZW5kZWQgYmVmb3JlIGFueSBjb2RlIGNvdWxkIGJlIGRldGVjdGVkLicpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcEFzeW5jRGVjb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZGVjb2RlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlmTm90Rm91bmQgPSByZXRyeUlmTm90Rm91bmQgJiYgZSBpbnN0YW5jZW9mIE5vdEZvdW5kRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0NoZWNrc3VtT3JGb3JtYXRFcnJvciA9IGUgaW5zdGFuY2VvZiBDaGVja3N1bUV4Y2VwdGlvbiB8fCBlIGluc3RhbmNlb2YgRm9ybWF0RXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZkNoZWNrc3VtT3JGb3JtYXQgPSBpc0NoZWNrc3VtT3JGb3JtYXRFcnJvciAmJiByZXRyeUlmQ2hlY2tzdW1PckZvcm1hdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWZOb3RGb3VuZCB8fCBpZkNoZWNrc3VtT3JGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeWluZyBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQobG9vcCwgdGhpcy5fdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGxvb3AocmVzb2x2ZSwgcmVqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRpbnVvdXNseSBkZWNvZGVzIGZyb20gdmlkZW8gaW5wdXQuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVDb250aW51b3VzbHkoZWxlbWVudCwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgdGhpcy5fc3RvcENvbnRpbnVvdXNEZWNvZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGxvb3AgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZGVjb2RlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0ZuKHJlc3VsdCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcCwgdGhpcy50aW1lQmV0d2VlblNjYW5zTWlsbGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tGbihudWxsLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDaGVja3N1bU9yRm9ybWF0RXJyb3IgPSBlIGluc3RhbmNlb2YgQ2hlY2tzdW1FeGNlcHRpb24gfHwgZSBpbnN0YW5jZW9mIEZvcm1hdEV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNOb3RGb3VuZCA9IGUgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hlY2tzdW1PckZvcm1hdEVycm9yIHx8IGlzTm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeWluZyBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wLCB0aGlzLl90aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxvb3AoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgQmluYXJ5Qml0bWFwIGZvciB5YSEgKGFuZCBkZWNvZGVzIGl0KVxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGdldCBiaW5hcnkgYml0bWFwIGZvciBkZWNvZGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IGJpbmFyeUJpdG1hcCA9IHRoaXMuY3JlYXRlQmluYXJ5Qml0bWFwKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlQml0bWFwKGJpbmFyeUJpdG1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBtZWRpYSBlbGVtZW50IGlzIGluZGVlZCBhIHtAbGluayBIdG1sVmlkZW9FbGVtZW50fS5cbiAgICAgICAgICovXG4gICAgICAgIF9pc0hUTUxWaWRlb0VsZW1lbnQobWVkaWFFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwb3RlbnRpYWxWaWRlbyA9IG1lZGlhRWxlbWVudDtcbiAgICAgICAgICAgIHJldHVybiBwb3RlbnRpYWxWaWRlby52aWRlb1dpZHRoICE9PSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVyd3JpdGluZyB0aGlzIGFsbG93cyB5b3UgdG8gbWFuaXB1bGF0ZSB0aGUgbmV4dCBmcmFtZSBpbiBhbnl3YXlcbiAgICAgICAgICogeW91IHdhbnQgYmVmb3JlIGRlY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIGRyYXdGcmFtZU9uQ2FudmFzKFxuICAgICAgICAgICAgc3JjRWxlbWVudCwgZGltZW5zaW9ucywgY2FudmFzRWxlbWVudENvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICghZGltZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN4OiAwLFxuICAgICAgICAgICAgICAgICAgICBzeTogMCxcbiAgICAgICAgICAgICAgICAgICAgc1dpZHRoOiBzcmNFbGVtZW50LnZpZGVvV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHNIZWlnaHQ6IHNyY0VsZW1lbnQudmlkZW9IZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgICAgICAgICAgICBkeTogMCxcbiAgICAgICAgICAgICAgICAgICAgZFdpZHRoOiBzcmNFbGVtZW50LnZpZGVvV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGRIZWlnaHQ6IHNyY0VsZW1lbnQudmlkZW9IZWlnaHR9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYW52YXNFbGVtZW50Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNhbnZhc0VsZW1lbnRDb250ZXh0ID0gdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbnZhc0VsZW1lbnRDb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICBzcmNFbGVtZW50LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuc3gsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5zeSxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnNXaWR0aCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnNIZWlnaHQsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5keCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmR5LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuZFdpZHRoLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXdyaXRpbmcgdGhpcyBhbGxvd3MgeW91IHRvIG1hbmlwdWxhdGUgdGhlIHNuYXBzaG90IGltYWdlIGluIGFueXdheVxuICAgICAgICAgKiAgeW91IHdhbnQgYmVmb3JlIGRlY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIGRyYXdJbWFnZU9uQ2FudmFzKFxuICAgICAgICAgICAgc3JjRWxlbWVudCxcbiAgICAgICAgICAgIGRpbWVuc2lvbnMsXG4gICAgICAgICAgICBjYW52YXNFbGVtZW50Q29udGV4dCA9IHRoaXMuY2FwdHVyZUNhbnZhc0NvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICghZGltZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN4OiAwLFxuICAgICAgICAgICAgICAgICAgICBzeTogMCxcbiAgICAgICAgICAgICAgICAgICAgc1dpZHRoOiBzcmNFbGVtZW50Lm5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgc0hlaWdodDogc3JjRWxlbWVudC5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgICAgICAgICAgZHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIGRXaWR0aDogc3JjRWxlbWVudC5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGRIZWlnaHQ6IHNyY0VsZW1lbnQubmF0dXJhbEhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNhbnZhc0VsZW1lbnRDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FudmFzRWxlbWVudENvbnRleHQgPSB0aGlzLmNhcHR1cmVDYW52YXNDb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FudmFzRWxlbWVudENvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgIHNyY0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5zeCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnN5LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuc1dpZHRoLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuc0hlaWdodCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmR4LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuZHksXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5kV2lkdGgsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5kSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGJpbmFyeUJpdG1hcCBiYXNlZCBpbiBzb21lIGltYWdlIHNvdXJjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1lZGlhRWxlbWVudCBIVE1MIGVsZW1lbnQgY29udGFpbmluZyBkcmF3YWJsZSBpbWFnZSBzb3VyY2UuXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVCaW5hcnlCaXRtYXAobWVkaWFFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLmdldENhcHR1cmVDYW52YXNDb250ZXh0KG1lZGlhRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNIVE1MVmlkZW9FbGVtZW50KG1lZGlhRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdGcmFtZU9uQ2FudmFzKG1lZGlhRWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0ltYWdlT25DYW52YXMobWVkaWFFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuZ2V0Q2FwdHVyZUNhbnZhcyhtZWRpYUVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgbHVtaW5hbmNlU291cmNlID0gbmV3IEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlKGNhbnZhcyk7XG4gICAgICAgICAgICBjb25zdCBoeWJyaWRCaW5hcml6ZXIgPSBuZXcgSHlicmlkQmluYXJpemVyKGx1bWluYW5jZVNvdXJjZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5Qml0bWFwKGh5YnJpZEJpbmFyaXplcik7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRDYXB0dXJlQ2FudmFzQ29udGV4dChtZWRpYUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLmdldENhcHR1cmVDYW52YXMobWVkaWFFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBlbGVtLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dCA9IGN0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhcHR1cmVDYW52YXNDb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGdldENhcHR1cmVDYW52YXMobWVkaWFFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FwdHVyZUNhbnZhcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLmNyZWF0ZUNhcHR1cmVDYW52YXMobWVkaWFFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmVDYW52YXMgPSBlbGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FwdHVyZUNhbnZhcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbCB0aGUgZW5jYXBzdWxhdGVkIHJlYWRlcnMgZGVjb2RlXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVCaXRtYXAoYmluYXJ5Qml0bWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkZXIuZGVjb2RlKGJpbmFyeUJpdG1hcCwgdGhpcy5faGludHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDwn5aMIFByZXBhcmVzIHRoZSBjYW52YXMgZm9yIGNhcHR1cmUgYW5kIHNjYW4gZnJhbWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlQ2FwdHVyZUNhbnZhcyhtZWRpYUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveUNhcHR1cmVDYW52YXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGxldCB3aWR0aDtcbiAgICAgICAgICAgIGxldCBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lZGlhRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVkaWFFbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IG1lZGlhRWxlbWVudC52aWRlb1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBtZWRpYUVsZW1lbnQudmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lZGlhRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBtZWRpYUVsZW1lbnQubmF0dXJhbFdpZHRoIHx8IG1lZGlhRWxlbWVudC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gbWVkaWFFbGVtZW50Lm5hdHVyYWxIZWlnaHQgfHwgbWVkaWFFbGVtZW50LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW52YXNFbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgY2FudmFzRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgY2FudmFzRWxlbWVudC53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY2FudmFzRWxlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcHMgdGhlIGNvbnRpbnVvdXMgc2NhbiBhbmQgY2xlYW5zIHRoZSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wU3RyZWFtcygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wQXN5bmNEZWNvZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wQXN5bmNEZWNvZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wQ29udGludW91c0RlY29kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BDb250aW51b3VzRGVjb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUgY29kZSByZWFkZXIgdG8gdGhlIGluaXRpYWwgc3RhdGUuIENhbmNlbHMgYW55IG9uZ29pbmcgYmFyY29kZSBzY2FubmluZyBmcm9tIHZpZGVvIG9yIGNhbWVyYS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIHN0b3BzIHRoZSBjYW1lcmEsIHByZXZpZXcgYW5kIHNjYW4g8J+UtFxuICAgICAgICAgICAgdGhpcy5zdG9wU3RyZWFtcygpO1xuICAgICAgICAgICAgLy8gY2xlYW4gYW5kIGZvcmdldCBhYm91dCBIVE1MIGVsZW1lbnRzXG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95VmlkZW9FbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95SW1hZ2VFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95Q2FwdHVyZUNhbnZhcygpO1xuICAgICAgICB9XG4gICAgICAgIF9kZXN0cm95VmlkZW9FbGVtZW50KCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZpcnN0IGdpdmVzIGZyZWVkb24gdG8gdGhlIGVsZW1lbnQg8J+VilxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnZpZGVvRW5kZWRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMudmlkZW9FbmRlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy52aWRlb1BsYXlpbmdFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLnZpZGVvUGxheWluZ0V2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnZpZGVvQ2FuUGxheUxpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgdGhpcy52aWRlb0NhblBsYXlMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGVuIGZvcmdldHMgYWJvdXQgdGhhdCBlbGVtZW50IPCfmKJcbiAgICAgICAgICAgIHRoaXMuY2xlYW5WaWRlb1NvdXJjZSh0aGlzLnZpZGVvRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBfZGVzdHJveUltYWdlRWxlbWVudCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaXJzdCBnaXZlcyBmcmVlZG9uIHRvIHRoZSBlbGVtZW50IPCflYpcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IHRoaXMuaW1hZ2VMb2FkZWRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLmltYWdlTG9hZGVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlbiBmb3JnZXQgYWJvdXQgdGhhdCBlbGVtZW50IPCfmKJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50LnNyYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYW5zIGNhbnZhcyByZWZlcmVuY2VzIPCfloxcbiAgICAgICAgICovXG4gICAgICAgIF9kZXN0cm95Q2FwdHVyZUNhbnZhcygpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gZm9yZ2V0IGFib3V0IHRoYXQgZWxlbWVudCDwn5iiXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVDYW52YXNDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHdoYXQgdGhlIHZpZGVvRWxlbWVudCBzcmMgd2lsbCBiZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZpZGVvRWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gc3RyZWFtXG4gICAgICAgICAqL1xuICAgICAgICBhZGRWaWRlb1NvdXJjZSh2aWRlb0VsZW1lbnQsIHN0cmVhbSkge1xuICAgICAgICAgICAgLy8gT2xkZXIgYnJvd3NlcnMgbWF5IG5vdCBoYXZlIGBzcmNPYmplY3RgXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEBub3RlIFRocm93cyBFeGNlcHRpb24gaWYgaW50ZXJydXB0ZWQgYnkgYSBuZXcgbG9hZGVkIHJlcXVlc3RcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIEBub3RlIEF2b2lkIHVzaW5nIHRoaXMgaW4gbmV3IGJyb3dzZXJzLCBhcyBpdCBpcyBnb2luZyBhd2F5LlxuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuYmluZHMgYSBIVE1MIHZpZGVvIHNyYyBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZpZGVvRWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYW5WaWRlb1NvdXJjZSh2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNyYyA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIHRoZSByZXN1bHQgb2YgZGVjb2RpbmcgYSBiYXJjb2RlIHdpdGhpbiBhbiBpbWFnZS48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIFJlc3VsdCB7XG4gICAgICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIHRleHQ6IHN0cmluZyxcbiAgICAgICAgLy8gICAgICAgICAgICAgICBVaW50OEFycmF5IHJhd0J5dGVzLFxuICAgICAgICAvLyAgICAgICAgICAgICAgIFJlc3VsdFBvY29uc3QgcmVzdWx0UG9pbnRzOiBJbnQzMkFycmF5LFxuICAgICAgICAvLyAgICAgICAgICAgICAgIEJhcmNvZGVGb3JtYXQgZm9ybWF0KSB7XG4gICAgICAgIC8vICAgdGhpcyh0ZXh0LCByYXdCeXRlcywgcmVzdWx0UG9pbnRzLCBmb3JtYXQsIFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3Rvcih0ZXh0OiBzdHJpbmcsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgVWludDhBcnJheSByYXdCeXRlcyxcbiAgICAgICAgLy8gICAgICAgICAgICAgICBSZXN1bHRQb2NvbnN0IHJlc3VsdFBvaW50czogSW50MzJBcnJheSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICBCYXJjb2RlRm9ybWF0IGZvcm1hdCxcbiAgICAgICAgLy8gICAgICAgICAgICAgICBsb25nIHRpbWVzdGFtcCkge1xuICAgICAgICAvLyAgIHRoaXModGV4dCwgcmF3Qnl0ZXMsIHJhd0J5dGVzID09IG51bGwgPyAwIDogOCAqIHJhd0J5dGVzLmxlbmd0aCxcbiAgICAgICAgLy8gICAgICAgIHJlc3VsdFBvaW50cywgZm9ybWF0LCB0aW1lc3RhbXApXG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3RydWN0b3IodGV4dCwgcmF3Qnl0ZXMsIG51bUJpdHMgPSByYXdCeXRlcyA9PSBudWxsID8gMCA6IDggKiByYXdCeXRlcy5sZW5ndGgsIHJlc3VsdFBvaW50cywgZm9ybWF0LCB0aW1lc3RhbXAgPSBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIHRoaXMucmF3Qnl0ZXMgPSByYXdCeXRlcztcbiAgICAgICAgICAgIHRoaXMubnVtQml0cyA9IG51bUJpdHM7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50cyA9IHJlc3VsdFBvaW50cztcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgdGhpcy5yYXdCeXRlcyA9IHJhd0J5dGVzO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gbnVtQml0cyB8fCBudWxsID09PSBudW1CaXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5udW1CaXRzID0gKHJhd0J5dGVzID09PSBudWxsIHx8IHJhd0J5dGVzID09PSB1bmRlZmluZWQpID8gMCA6IDggKiByYXdCeXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm51bUJpdHMgPSBudW1CaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMgPSByZXN1bHRQb2ludHM7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0TWV0YWRhdGEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdGltZXN0YW1wIHx8IG51bGwgPT09IHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiByYXcgdGV4dCBlbmNvZGVkIGJ5IHRoZSBiYXJjb2RlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiByYXcgYnl0ZXMgZW5jb2RlZCBieSB0aGUgYmFyY29kZSwgaWYgYXBwbGljYWJsZSwgb3RoZXJ3aXNlIHtAY29kZSBudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYXdCeXRlcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBob3cgbWFueSBiaXRzIG9mIHtAbGluayAjZ2V0UmF3Qnl0ZXMoKX0gYXJlIHZhbGlkOyB0eXBpY2FsbHkgOCB0aW1lcyBpdHMgbGVuZ3RoXG4gICAgICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TnVtQml0cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bUJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gcG9pbnRzIHJlbGF0ZWQgdG8gdGhlIGJhcmNvZGUgaW4gdGhlIGltYWdlLiBUaGVzZSBhcmUgdHlwaWNhbGx5IHBvaW50c1xuICAgICAgICAgKiAgICAgICAgIGlkZW50aWZ5aW5nIGZpbmRlciBwYXR0ZXJucyBvciB0aGUgY29ybmVycyBvZiB0aGUgYmFyY29kZS4gVGhlIGV4YWN0IG1lYW5pbmcgaXNcbiAgICAgICAgICogICAgICAgICBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiBiYXJjb2RlIHRoYXQgd2FzIGRlY29kZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSZXN1bHRQb2ludHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRQb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIEJhcmNvZGVGb3JtYXR9IHJlcHJlc2VudGluZyB0aGUgZm9ybWF0IG9mIHRoZSBiYXJjb2RlIHRoYXQgd2FzIGRlY29kZWRcbiAgICAgICAgICovXG4gICAgICAgIGdldEJhcmNvZGVGb3JtYXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIE1hcH0gbWFwcGluZyB7QGxpbmsgUmVzdWx0TWV0YWRhdGFUeXBlfSBrZXlzIHRvIHZhbHVlcy4gTWF5IGJlXG4gICAgICAgICAqICAge0Bjb2RlIG51bGx9LiBUaGlzIGNvbnRhaW5zIG9wdGlvbmFsIG1ldGFkYXRhIGFib3V0IHdoYXQgd2FzIGRldGVjdGVkIGFib3V0IHRoZSBiYXJjb2RlLFxuICAgICAgICAgKiAgIGxpa2Ugb3JpZW50YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSZXN1bHRNZXRhZGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdE1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHB1dE1ldGFkYXRhKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bHRNZXRhZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0TWV0YWRhdGEgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc3VsdE1ldGFkYXRhLnNldCh0eXBlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHV0QWxsTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdE1ldGFkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0TWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0TWV0YWRhdGEgPSBuZXcgTWFwKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkUmVzdWx0UG9pbnRzKG5ld1BvaW50cykge1xuICAgICAgICAgICAgY29uc3Qgb2xkUG9pbnRzID0gdGhpcy5yZXN1bHRQb2ludHM7XG4gICAgICAgICAgICBpZiAob2xkUG9pbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMgPSBuZXdQb2ludHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdQb2ludHMgIT09IG51bGwgJiYgbmV3UG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxQb2ludHMgPSBuZXcgQXJyYXkob2xkUG9pbnRzLmxlbmd0aCArIG5ld1BvaW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkob2xkUG9pbnRzLCAwLCBhbGxQb2ludHMsIDAsIG9sZFBvaW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkobmV3UG9pbnRzLCAwLCBhbGxQb2ludHMsIG9sZFBvaW50cy5sZW5ndGgsIG5ld1BvaW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gYWxsUG9pbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldFRpbWVzdGFtcCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogRGlyZWN0IHBvcnQgdG8gVHlwZVNjcmlwdCBvZiBaWGluZyBieSBBZHJpYW4gVG/ImWPEg1xuICAgICAqL1xuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbiAgICAvKipcbiAgICAgKiBFbnVtZXJhdGVzIGJhcmNvZGUgZm9ybWF0cyBrbm93biB0byB0aGlzIHBhY2thZ2UuIFBsZWFzZSBrZWVwIGFscGhhYmV0aXplZC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgdmFyIEJhcmNvZGVGb3JtYXQ7XG4gICAgKGZ1bmN0aW9uIChCYXJjb2RlRm9ybWF0KSB7XG4gICAgICAgIC8qKiBBenRlYyAyRCBiYXJjb2RlIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQVpURUNcIl0gPSAwXSA9IFwiQVpURUNcIjtcbiAgICAgICAgLyoqIENPREFCQVIgMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJDT0RBQkFSXCJdID0gMV0gPSBcIkNPREFCQVJcIjtcbiAgICAgICAgLyoqIENvZGUgMzkgMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJDT0RFXzM5XCJdID0gMl0gPSBcIkNPREVfMzlcIjtcbiAgICAgICAgLyoqIENvZGUgOTMgMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJDT0RFXzkzXCJdID0gM10gPSBcIkNPREVfOTNcIjtcbiAgICAgICAgLyoqIENvZGUgMTI4IDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQ09ERV8xMjhcIl0gPSA0XSA9IFwiQ09ERV8xMjhcIjtcbiAgICAgICAgLyoqIERhdGEgTWF0cml4IDJEIGJhcmNvZGUgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJEQVRBX01BVFJJWFwiXSA9IDVdID0gXCJEQVRBX01BVFJJWFwiO1xuICAgICAgICAvKiogRUFOLTggMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJFQU5fOFwiXSA9IDZdID0gXCJFQU5fOFwiO1xuICAgICAgICAvKiogRUFOLTEzIDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiRUFOXzEzXCJdID0gN10gPSBcIkVBTl8xM1wiO1xuICAgICAgICAvKiogSVRGIChJbnRlcmxlYXZlZCBUd28gb2YgRml2ZSkgMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJJVEZcIl0gPSA4XSA9IFwiSVRGXCI7XG4gICAgICAgIC8qKiBNYXhpQ29kZSAyRCBiYXJjb2RlIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiTUFYSUNPREVcIl0gPSA5XSA9IFwiTUFYSUNPREVcIjtcbiAgICAgICAgLyoqIFBERjQxNyBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIlBERl80MTdcIl0gPSAxMF0gPSBcIlBERl80MTdcIjtcbiAgICAgICAgLyoqIFFSIENvZGUgMkQgYmFyY29kZSBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIlFSX0NPREVcIl0gPSAxMV0gPSBcIlFSX0NPREVcIjtcbiAgICAgICAgLyoqIFJTUyAxNCAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJSU1NfMTRcIl0gPSAxMl0gPSBcIlJTU18xNFwiO1xuICAgICAgICAvKiogUlNTIEVYUEFOREVEICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIlJTU19FWFBBTkRFRFwiXSA9IDEzXSA9IFwiUlNTX0VYUEFOREVEXCI7XG4gICAgICAgIC8qKiBVUEMtQSAxRCBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIlVQQ19BXCJdID0gMTRdID0gXCJVUENfQVwiO1xuICAgICAgICAvKiogVVBDLUUgMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJVUENfRVwiXSA9IDE1XSA9IFwiVVBDX0VcIjtcbiAgICAgICAgLyoqIFVQQy9FQU4gZXh0ZW5zaW9uIGZvcm1hdC4gTm90IGEgc3RhbmQtYWxvbmUgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJVUENfRUFOX0VYVEVOU0lPTlwiXSA9IDE2XSA9IFwiVVBDX0VBTl9FWFRFTlNJT05cIjtcbiAgICB9KShCYXJjb2RlRm9ybWF0IHx8IChCYXJjb2RlRm9ybWF0ID0ge30pKTtcbiAgICB2YXIgQmFyY29kZUZvcm1hdCQxID0gQmFyY29kZUZvcm1hdDtcblxuICAgIC8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBzb21lIHR5cGUgb2YgbWV0YWRhdGEgYWJvdXQgdGhlIHJlc3VsdCBvZiB0aGUgZGVjb2RpbmcgdGhhdCB0aGUgZGVjb2RlclxuICAgICAqIHdpc2hlcyB0byBjb21tdW5pY2F0ZSBiYWNrIHRvIHRoZSBjYWxsZXIuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIHZhciBSZXN1bHRNZXRhZGF0YVR5cGU7XG4gICAgKGZ1bmN0aW9uIChSZXN1bHRNZXRhZGF0YVR5cGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuc3BlY2lmaWVkLCBhcHBsaWNhdGlvbi1zcGVjaWZpYyBtZXRhZGF0YS4gTWFwcyB0byBhbiB1bnNwZWNpZmllZCB7QGxpbmsgT2JqZWN0fS5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJPVEhFUlwiXSA9IDBdID0gXCJPVEhFUlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVub3RlcyB0aGUgbGlrZWx5IGFwcHJveGltYXRlIG9yaWVudGF0aW9uIG9mIHRoZSBiYXJjb2RlIGluIHRoZSBpbWFnZS4gVGhpcyB2YWx1ZVxuICAgICAgICAgKiBpcyBnaXZlbiBhcyBkZWdyZWVzIHJvdGF0ZWQgY2xvY2t3aXNlIGZyb20gdGhlIG5vcm1hbCwgdXByaWdodCBvcmllbnRhdGlvbi5cbiAgICAgICAgICogRm9yIGV4YW1wbGUgYSAxRCBiYXJjb2RlIHdoaWNoIHdhcyBmb3VuZCBieSByZWFkaW5nIHRvcC10by1ib3R0b20gd291bGQgYmVcbiAgICAgICAgICogc2FpZCB0byBoYXZlIG9yaWVudGF0aW9uIFwiOTBcIi4gVGhpcyBrZXkgbWFwcyB0byBhbiB7QGxpbmsgSW50ZWdlcn0gd2hvc2VcbiAgICAgICAgICogdmFsdWUgaXMgaW4gdGhlIHJhbmdlIFswLDM2MCkuXG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiT1JJRU5UQVRJT05cIl0gPSAxXSA9IFwiT1JJRU5UQVRJT05cIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPjJEIGJhcmNvZGUgZm9ybWF0cyB0eXBpY2FsbHkgZW5jb2RlIHRleHQsIGJ1dCBhbGxvdyBmb3IgYSBzb3J0IG9mICdieXRlIG1vZGUnXG4gICAgICAgICAqIHdoaWNoIGlzIHNvbWV0aW1lcyB1c2VkIHRvIGVuY29kZSBiaW5hcnkgZGF0YS4gV2hpbGUge0BsaW5rIFJlc3VsdH0gbWFrZXMgYXZhaWxhYmxlXG4gICAgICAgICAqIHRoZSBjb21wbGV0ZSByYXcgYnl0ZXMgaW4gdGhlIGJhcmNvZGUgZm9yIHRoZXNlIGZvcm1hdHMsIGl0IGRvZXMgbm90IG9mZmVyIHRoZSBieXRlc1xuICAgICAgICAgKiBmcm9tIHRoZSBieXRlIHNlZ21lbnRzIGFsb25lLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+VGhpcyBtYXBzIHRvIGEge0BsaW5rIGphdmEudXRpbC5MaXN0fSBvZiBieXRlIGFycmF5cyBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICAgICAgICAgKiByYXcgYnl0ZXMgaW4gdGhlIGJ5dGUgc2VnbWVudHMgaW4gdGhlIGJhcmNvZGUsIGluIG9yZGVyLjwvcD5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJCWVRFX1NFR01FTlRTXCJdID0gMl0gPSBcIkJZVEVfU0VHTUVOVFNcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVycm9yIGNvcnJlY3Rpb24gbGV2ZWwgdXNlZCwgaWYgYXBwbGljYWJsZS4gVGhlIHZhbHVlIHR5cGUgZGVwZW5kcyBvbiB0aGVcbiAgICAgICAgICogZm9ybWF0LCBidXQgaXMgdHlwaWNhbGx5IGEgU3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIkVSUk9SX0NPUlJFQ1RJT05fTEVWRUxcIl0gPSAzXSA9IFwiRVJST1JfQ09SUkVDVElPTl9MRVZFTFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIHNvbWUgcGVyaW9kaWNhbHMsIGluZGljYXRlcyB0aGUgaXNzdWUgbnVtYmVyIGFzIGFuIHtAbGluayBJbnRlZ2VyfS5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJJU1NVRV9OVU1CRVJcIl0gPSA0XSA9IFwiSVNTVUVfTlVNQkVSXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3Igc29tZSBwcm9kdWN0cywgaW5kaWNhdGVzIHRoZSBzdWdnZXN0ZWQgcmV0YWlsIHByaWNlIGluIHRoZSBiYXJjb2RlIGFzIGFcbiAgICAgICAgICogZm9ybWF0dGVkIHtAbGluayBTdHJpbmd9LlxuICAgICAgICAgKi9cbiAgICAgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIlNVR0dFU1RFRF9QUklDRVwiXSA9IDVdID0gXCJTVUdHRVNURURfUFJJQ0VcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBzb21lIHByb2R1Y3RzLCB0aGUgcG9zc2libGUgY291bnRyeSBvZiBtYW51ZmFjdHVyZSBhcyBhIHtAbGluayBTdHJpbmd9IGRlbm90aW5nIHRoZVxuICAgICAgICAgKiBJU08gY291bnRyeSBjb2RlLiBTb21lIG1hcCB0byBtdWx0aXBsZSBwb3NzaWJsZSBjb3VudHJpZXMsIGxpa2UgXCJVUy9DQVwiLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIlBPU1NJQkxFX0NPVU5UUllcIl0gPSA2XSA9IFwiUE9TU0lCTEVfQ09VTlRSWVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIHNvbWUgcHJvZHVjdHMsIHRoZSBleHRlbnNpb24gdGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIlVQQ19FQU5fRVhURU5TSU9OXCJdID0gN10gPSBcIlVQQ19FQU5fRVhURU5TSU9OXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQREY0MTctc3BlY2lmaWMgbWV0YWRhdGFcbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJQREY0MTdfRVhUUkFfTUVUQURBVEFcIl0gPSA4XSA9IFwiUERGNDE3X0VYVFJBX01FVEFEQVRBXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgY29kZSBmb3JtYXQgc3VwcG9ydHMgc3RydWN0dXJlZCBhcHBlbmQgYW5kIHRoZSBjdXJyZW50IHNjYW5uZWQgY29kZSBpcyBwYXJ0IG9mIG9uZSB0aGVuIHRoZVxuICAgICAgICAgKiBzZXF1ZW5jZSBudW1iZXIgaXMgZ2l2ZW4gd2l0aCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJTVFJVQ1RVUkVEX0FQUEVORF9TRVFVRU5DRVwiXSA9IDldID0gXCJTVFJVQ1RVUkVEX0FQUEVORF9TRVFVRU5DRVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGNvZGUgZm9ybWF0IHN1cHBvcnRzIHN0cnVjdHVyZWQgYXBwZW5kIGFuZCB0aGUgY3VycmVudCBzY2FubmVkIGNvZGUgaXMgcGFydCBvZiBvbmUgdGhlbiB0aGVcbiAgICAgICAgICogcGFyaXR5IGlzIGdpdmVuIHdpdGggaXQuXG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiU1RSVUNUVVJFRF9BUFBFTkRfUEFSSVRZXCJdID0gMTBdID0gXCJTVFJVQ1RVUkVEX0FQUEVORF9QQVJJVFlcIjtcbiAgICB9KShSZXN1bHRNZXRhZGF0YVR5cGUgfHwgKFJlc3VsdE1ldGFkYXRhVHlwZSA9IHt9KSk7XG4gICAgdmFyIFJlc3VsdE1ldGFkYXRhVHlwZSQxID0gUmVzdWx0TWV0YWRhdGFUeXBlO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbiB7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTGlzdDsqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyB0aGUgcmVzdWx0IG9mIGRlY29kaW5nIGEgbWF0cml4IG9mIGJpdHMuIFRoaXMgdHlwaWNhbGx5XG4gICAgICogYXBwbGllcyB0byAyRCBiYXJjb2RlIGZvcm1hdHMuIEZvciBub3cgaXQgY29udGFpbnMgdGhlIHJhdyBieXRlcyBvYnRhaW5lZCxcbiAgICAgKiBhcyB3ZWxsIGFzIGEgU3RyaW5nIGludGVycHJldGF0aW9uIG9mIHRob3NlIGJ5dGVzLCBpZiBhcHBsaWNhYmxlLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGVjb2RlclJlc3VsdCB7XG4gICAgICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3RvcihyYXdCeXRlczogVWludDhBcnJheSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGV4dDogc3RyaW5nLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBMaXN0PFVpbnQ4QXJyYXk+IGJ5dGVTZWdtZW50cyxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgU3RyaW5nIGVjTGV2ZWwpIHtcbiAgICAgICAgLy8gICB0aGlzKHJhd0J5dGVzLCB0ZXh0LCBieXRlU2VnbWVudHMsIGVjTGV2ZWwsIC0xLCAtMSlcbiAgICAgICAgLy8gfVxuICAgICAgICBjb25zdHJ1Y3RvcihyYXdCeXRlcywgdGV4dCwgYnl0ZVNlZ21lbnRzLCBlY0xldmVsLCBzdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXIgPSAtMSwgc3RydWN0dXJlZEFwcGVuZFBhcml0eSA9IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJhd0J5dGVzID0gcmF3Qnl0ZXM7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgdGhpcy5ieXRlU2VnbWVudHMgPSBieXRlU2VnbWVudHM7XG4gICAgICAgICAgICB0aGlzLmVjTGV2ZWwgPSBlY0xldmVsO1xuICAgICAgICAgICAgdGhpcy5zdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXIgPSBzdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICB0aGlzLnN0cnVjdHVyZWRBcHBlbmRQYXJpdHkgPSBzdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5O1xuICAgICAgICAgICAgdGhpcy5udW1CaXRzID0gKHJhd0J5dGVzID09PSB1bmRlZmluZWQgfHwgcmF3Qnl0ZXMgPT09IG51bGwpID8gMCA6IDggKiByYXdCeXRlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gcmF3IGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LCBvciB7QGNvZGUgbnVsbH0gaWYgbm90IGFwcGxpY2FibGVcbiAgICAgICAgICovXG4gICAgICAgIGdldFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3Qnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gaG93IG1hbnkgYml0cyBvZiB7QGxpbmsgI2dldFJhd0J5dGVzKCl9IGFyZSB2YWxpZDsgdHlwaWNhbGx5IDggdGltZXMgaXRzIGxlbmd0aFxuICAgICAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgICAgICovXG4gICAgICAgIGdldE51bUJpdHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW1CaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gbnVtQml0cyBvdmVycmlkZXMgdGhlIG51bWJlciBvZiBiaXRzIHRoYXQgYXJlIHZhbGlkIGluIHtAbGluayAjZ2V0UmF3Qnl0ZXMoKX1cbiAgICAgICAgICogQHNpbmNlIDMuMy4wXG4gICAgICAgICAqL1xuICAgICAgICBzZXROdW1CaXRzKG51bUJpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy5udW1CaXRzID0gbnVtQml0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXN1bHRcbiAgICAgICAgICovXG4gICAgICAgIGdldFRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGxpc3Qgb2YgYnl0ZSBzZWdtZW50cyBpbiB0aGUgcmVzdWx0LCBvciB7QGNvZGUgbnVsbH0gaWYgbm90IGFwcGxpY2FibGVcbiAgICAgICAgICovXG4gICAgICAgIGdldEJ5dGVTZWdtZW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVTZWdtZW50cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBuYW1lIG9mIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwgdXNlZCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFQ0xldmVsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNMZXZlbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBudW1iZXIgb2YgZXJyb3JzIGNvcnJlY3RlZCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFcnJvcnNDb3JyZWN0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcnNDb3JyZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RXJyb3JzQ29ycmVjdGVkKGVycm9yc0NvcnJlY3RlZCAvKkludGVnZXIqLykge1xuICAgICAgICAgICAgdGhpcy5lcnJvcnNDb3JyZWN0ZWQgPSBlcnJvcnNDb3JyZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGVyYXN1cmVzIGNvcnJlY3RlZCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFcmFzdXJlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVyYXN1cmVzO1xuICAgICAgICB9XG4gICAgICAgIHNldEVyYXN1cmVzKGVyYXN1cmVzIC8qSW50ZWdlciovKSB7XG4gICAgICAgICAgICB0aGlzLmVyYXN1cmVzID0gZXJhc3VyZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gYXJiaXRyYXJ5IGFkZGl0aW9uYWwgbWV0YWRhdGFcbiAgICAgICAgICovXG4gICAgICAgIGdldE90aGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3RoZXI7XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3RoZXIob3RoZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBoYXNTdHJ1Y3R1cmVkQXBwZW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RydWN0dXJlZEFwcGVuZFBhcml0eSA+PSAwICYmIHRoaXMuc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyID49IDA7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U3RydWN0dXJlZEFwcGVuZFBhcml0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cnVjdHVyZWRBcHBlbmRQYXJpdHk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5UaGlzIGNsYXNzIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3IgcGVyZm9ybWluZyBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucyBvdmVyXG4gICAgICogdGhlIEdhbG9pcyBGaWVsZHMuIE9wZXJhdGlvbnMgdXNlIGEgZ2l2ZW4gcHJpbWl0aXZlIHBvbHlub21pYWwgaW4gY2FsY3VsYXRpb25zLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRocm91Z2hvdXQgdGhpcyBwYWNrYWdlLCBlbGVtZW50cyBvZiB0aGUgR0YgYXJlIHJlcHJlc2VudGVkIGFzIGFuIHtAY29kZSBpbnR9XG4gICAgICogZm9yIGNvbnZlbmllbmNlIGFuZCBzcGVlZCAoYnV0IGF0IHRoZSBjb3N0IG9mIG1lbW9yeSkuXG4gICAgICogPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcbiAgICAgKi9cbiAgICBjbGFzcyBBYnN0cmFjdEdlbmVyaWNHRiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIDIgdG8gdGhlIHBvd2VyIG9mIGEgaW4gR0Yoc2l6ZSlcbiAgICAgICAgICovXG4gICAgICAgIGV4cChhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVthXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBiYXNlIDIgbG9nIG9mIGEgaW4gR0Yoc2l6ZSlcbiAgICAgICAgICovXG4gICAgICAgIGxvZyhhIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9nVGFibGVbYV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgYm90aCBhZGRpdGlvbiBhbmQgc3VidHJhY3Rpb24gLS0gdGhleSBhcmUgdGhlIHNhbWUgaW4gR0Yoc2l6ZSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gc3VtL2RpZmZlcmVuY2Ugb2YgYSBhbmQgYlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFkZE9yU3VidHJhY3QoYSAvKmludCovLCBiIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiBhIF4gYjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+UmVwcmVzZW50cyBhIHBvbHlub21pYWwgd2hvc2UgY29lZmZpY2llbnRzIGFyZSBlbGVtZW50cyBvZiBhIEdGLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBpbW11dGFibGUuPC9wPlxuICAgICAqXG4gICAgICogPHA+TXVjaCBjcmVkaXQgaXMgZHVlIHRvIFdpbGxpYW0gUnVja2xpZGdlIHNpbmNlIHBvcnRpb25zIG9mIHRoaXMgY29kZSBhcmUgYW4gaW5kaXJlY3RcbiAgICAgKiBwb3J0IG9mIGhpcyBDKysgUmVlZC1Tb2xvbW9uIGltcGxlbWVudGF0aW9uLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgR2VuZXJpY0dGUG9seSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gZmllbGQgdGhlIHtAbGluayBHZW5lcmljR0Z9IGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGUgZmllbGQgdG8gdXNlXG4gICAgICAgICAqIHRvIHBlcmZvcm0gY29tcHV0YXRpb25zXG4gICAgICAgICAqIEBwYXJhbSBjb2VmZmljaWVudHMgY29lZmZpY2llbnRzIGFzIGludHMgcmVwcmVzZW50aW5nIGVsZW1lbnRzIG9mIEdGKHNpemUpLCBhcnJhbmdlZFxuICAgICAgICAgKiBmcm9tIG1vc3Qgc2lnbmlmaWNhbnQgKGhpZ2hlc3QtcG93ZXIgdGVybSkgY29lZmZpY2llbnQgdG8gbGVhc3Qgc2lnbmlmaWNhbnRcbiAgICAgICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgYXJndW1lbnQgaXMgbnVsbCBvciBlbXB0eSxcbiAgICAgICAgICogb3IgaWYgbGVhZGluZyBjb2VmZmljaWVudCBpcyAwIGFuZCB0aGlzIGlzIG5vdCBhXG4gICAgICAgICAqIGNvbnN0YW50IHBvbHlub21pYWwgKHRoYXQgaXMsIGl0IGlzIG5vdCB0aGUgbW9ub21pYWwgXCIwXCIpXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihmaWVsZCwgY29lZmZpY2llbnRzKSB7XG4gICAgICAgICAgICBpZiAoY29lZmZpY2llbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgICAgIGNvbnN0IGNvZWZmaWNpZW50c0xlbmd0aCA9IGNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY29lZmZpY2llbnRzTGVuZ3RoID4gMSAmJiBjb2VmZmljaWVudHNbMF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHRlcm0gbXVzdCBiZSBub24temVybyBmb3IgYW55dGhpbmcgZXhjZXB0IHRoZSBjb25zdGFudCBwb2x5bm9taWFsIFwiMFwiXG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0Tm9uWmVybyA9IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGZpcnN0Tm9uWmVybyA8IGNvZWZmaWNpZW50c0xlbmd0aCAmJiBjb2VmZmljaWVudHNbZmlyc3ROb25aZXJvXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9uWmVybyA9PT0gY29lZmZpY2llbnRzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gSW50MzJBcnJheS5mcm9tKFswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KGNvZWZmaWNpZW50c0xlbmd0aCAtIGZpcnN0Tm9uWmVybyk7XG4gICAgICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoY29lZmZpY2llbnRzLCBmaXJzdE5vblplcm8sIHRoaXMuY29lZmZpY2llbnRzLCAwLCB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldENvZWZmaWNpZW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBkZWdyZWUgb2YgdGhpcyBwb2x5bm9taWFsXG4gICAgICAgICAqL1xuICAgICAgICBnZXREZWdyZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmZiB0aGlzIHBvbHlub21pYWwgaXMgdGhlIG1vbm9taWFsIFwiMFwiXG4gICAgICAgICAqL1xuICAgICAgICBpc1plcm8oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHNbMF0gPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gY29lZmZpY2llbnQgb2YgeF5kZWdyZWUgdGVybSBpbiB0aGlzIHBvbHlub21pYWxcbiAgICAgICAgICovXG4gICAgICAgIGdldENvZWZmaWNpZW50KGRlZ3JlZSAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHNbdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoIC0gMSAtIGRlZ3JlZV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gZXZhbHVhdGlvbiBvZiB0aGlzIHBvbHlub21pYWwgYXQgYSBnaXZlbiBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgZXZhbHVhdGVBdChhIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIHheMCBjb2VmZmljaWVudFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvZWZmaWNpZW50KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBKdXN0IHRoZSBzdW0gb2YgdGhlIGNvZWZmaWNpZW50c1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGNvZWZmaWNpZW50cy5sZW5ndGg7IGkgIT09IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZWZmaWNpZW50ID0gY29lZmZpY2llbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBYnN0cmFjdEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KHJlc3VsdCwgY29lZmZpY2llbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gY29lZmZpY2llbnRzWzBdO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEFic3RyYWN0R2VuZXJpY0dGLmFkZE9yU3VidHJhY3QoZmllbGQubXVsdGlwbHkoYSwgcmVzdWx0KSwgY29lZmZpY2llbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgYWRkT3JTdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdHZW5lcmljR0ZQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIEdlbmVyaWNHRiBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzbWFsbGVyQ29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBsZXQgbGFyZ2VyQ29lZmZpY2llbnRzID0gb3RoZXIuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgaWYgKHNtYWxsZXJDb2VmZmljaWVudHMubGVuZ3RoID4gbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBzbWFsbGVyQ29lZmZpY2llbnRzO1xuICAgICAgICAgICAgICAgIHNtYWxsZXJDb2VmZmljaWVudHMgPSBsYXJnZXJDb2VmZmljaWVudHM7XG4gICAgICAgICAgICAgICAgbGFyZ2VyQ29lZmZpY2llbnRzID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdW1EaWZmID0gbmV3IEludDMyQXJyYXkobGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGhEaWZmID0gbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCAtIHNtYWxsZXJDb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gQ29weSBoaWdoLW9yZGVyIHRlcm1zIG9ubHkgZm91bmQgaW4gaGlnaGVyLWRlZ3JlZSBwb2x5bm9taWFsJ3MgY29lZmZpY2llbnRzXG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGxhcmdlckNvZWZmaWNpZW50cywgMCwgc3VtRGlmZiwgMCwgbGVuZ3RoRGlmZik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoRGlmZjsgaSA8IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bURpZmZbaV0gPSBBYnN0cmFjdEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KHNtYWxsZXJDb2VmZmljaWVudHNbaSAtIGxlbmd0aERpZmZdLCBsYXJnZXJDb2VmZmljaWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljR0ZQb2x5KHRoaXMuZmllbGQsIHN1bURpZmYpO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5KG90aGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0dlbmVyaWNHRlBvbHlzIGRvIG5vdCBoYXZlIHNhbWUgR2VuZXJpY0dGIGZpZWxkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1plcm8oKSB8fCBvdGhlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFDb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIGNvbnN0IGFMZW5ndGggPSBhQ29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJDb2VmZmljaWVudHMgPSBvdGhlci5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBjb25zdCBiTGVuZ3RoID0gYkNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0ID0gbmV3IEludDMyQXJyYXkoYUxlbmd0aCArIGJMZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYUNvZWZmID0gYUNvZWZmaWNpZW50c1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0W2kgKyBqXSA9IEFic3RyYWN0R2VuZXJpY0dGLmFkZE9yU3VidHJhY3QocHJvZHVjdFtpICsgal0sIGZpZWxkLm11bHRpcGx5KGFDb2VmZiwgYkNvZWZmaWNpZW50c1tqXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0dGUG9seShmaWVsZCwgcHJvZHVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHlTY2FsYXIoc2NhbGFyIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChzY2FsYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NhbGFyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgICAgICAgICAgY29uc3QgY29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb2R1Y3RbaV0gPSBmaWVsZC5tdWx0aXBseShjb2VmZmljaWVudHNbaV0sIHNjYWxhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIHByb2R1Y3QpO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5QnlNb25vbWlhbChkZWdyZWUgLyppbnQqLywgY29lZmZpY2llbnQgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBjb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KHNpemUgKyBkZWdyZWUpO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9kdWN0W2ldID0gZmllbGQubXVsdGlwbHkoY29lZmZpY2llbnRzW2ldLCBjb2VmZmljaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIHByb2R1Y3QpO1xuICAgICAgICB9XG4gICAgICAgIGRpdmlkZShvdGhlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdHZW5lcmljR0ZQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIEdlbmVyaWNHRiBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRGl2aWRlIGJ5IDAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGxldCBxdW90aWVudCA9IGZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgIGxldCByZW1haW5kZXIgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgZGVub21pbmF0b3JMZWFkaW5nVGVybSA9IG90aGVyLmdldENvZWZmaWNpZW50KG90aGVyLmdldERlZ3JlZSgpKTtcbiAgICAgICAgICAgIGNvbnN0IGludmVyc2VEZW5vbWluYXRvckxlYWRpbmdUZXJtID0gZmllbGQuaW52ZXJzZShkZW5vbWluYXRvckxlYWRpbmdUZXJtKTtcbiAgICAgICAgICAgIHdoaWxlIChyZW1haW5kZXIuZ2V0RGVncmVlKCkgPj0gb3RoZXIuZ2V0RGVncmVlKCkgJiYgIXJlbWFpbmRlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZ3JlZURpZmZlcmVuY2UgPSByZW1haW5kZXIuZ2V0RGVncmVlKCkgLSBvdGhlci5nZXREZWdyZWUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IGZpZWxkLm11bHRpcGx5KHJlbWFpbmRlci5nZXRDb2VmZmljaWVudChyZW1haW5kZXIuZ2V0RGVncmVlKCkpLCBpbnZlcnNlRGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVybSA9IG90aGVyLm11bHRpcGx5QnlNb25vbWlhbChkZWdyZWVEaWZmZXJlbmNlLCBzY2FsZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlcmF0aW9uUXVvdGllbnQgPSBmaWVsZC5idWlsZE1vbm9taWFsKGRlZ3JlZURpZmZlcmVuY2UsIHNjYWxlKTtcbiAgICAgICAgICAgICAgICBxdW90aWVudCA9IHF1b3RpZW50LmFkZE9yU3VidHJhY3QoaXRlcmF0aW9uUXVvdGllbnQpO1xuICAgICAgICAgICAgICAgIHJlbWFpbmRlciA9IHJlbWFpbmRlci5hZGRPclN1YnRyYWN0KHRlcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtxdW90aWVudCwgcmVtYWluZGVyXTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgZGVncmVlID0gdGhpcy5nZXREZWdyZWUoKTsgZGVncmVlID49IDA7IGRlZ3JlZS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZWZmaWNpZW50ID0gdGhpcy5nZXRDb2VmZmljaWVudChkZWdyZWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAtICc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmZmljaWVudCA9IC1jb2VmZmljaWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICsgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlID09PSAwIHx8IGNvZWZmaWNpZW50ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHBoYVBvd2VyID0gdGhpcy5maWVsZC5sb2coY29lZmZpY2llbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhUG93ZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxwaGFQb3dlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnYSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2FeJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYWxwaGFQb3dlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICd4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAneF4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBkZWdyZWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIEFyaXRobWV0aWNFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cbiAgICBBcml0aG1ldGljRXhjZXB0aW9uLmtpbmQgPSAnQXJpdGhtZXRpY0V4Y2VwdGlvbic7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgY29udGFpbnMgdXRpbGl0eSBtZXRob2RzIGZvciBwZXJmb3JtaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRpb25zIG92ZXJcbiAgICAgKiB0aGUgR2Fsb2lzIEZpZWxkcy4gT3BlcmF0aW9ucyB1c2UgYSBnaXZlbiBwcmltaXRpdmUgcG9seW5vbWlhbCBpbiBjYWxjdWxhdGlvbnMuPC9wPlxuICAgICAqXG4gICAgICogPHA+VGhyb3VnaG91dCB0aGlzIHBhY2thZ2UsIGVsZW1lbnRzIG9mIHRoZSBHRiBhcmUgcmVwcmVzZW50ZWQgYXMgYW4ge0Bjb2RlIGludH1cbiAgICAgKiBmb3IgY29udmVuaWVuY2UgYW5kIHNwZWVkIChidXQgYXQgdGhlIGNvc3Qgb2YgbWVtb3J5KS5cbiAgICAgKiA8L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgRGF2aWQgT2xpdmllclxuICAgICAqL1xuICAgIGNsYXNzIEdlbmVyaWNHRiBleHRlbmRzIEFic3RyYWN0R2VuZXJpY0dGIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHJlcHJlc2VudGF0aW9uIG9mIEdGKHNpemUpIHVzaW5nIHRoZSBnaXZlbiBwcmltaXRpdmUgcG9seW5vbWlhbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHByaW1pdGl2ZSBpcnJlZHVjaWJsZSBwb2x5bm9taWFsIHdob3NlIGNvZWZmaWNpZW50cyBhcmUgcmVwcmVzZW50ZWQgYnlcbiAgICAgICAgICogIHRoZSBiaXRzIG9mIGFuIGludCwgd2hlcmUgdGhlIGxlYXN0LXNpZ25pZmljYW50IGJpdCByZXByZXNlbnRzIHRoZSBjb25zdGFudFxuICAgICAgICAgKiAgY29lZmZpY2llbnRcbiAgICAgICAgICogQHBhcmFtIHNpemUgdGhlIHNpemUgb2YgdGhlIGZpZWxkXG4gICAgICAgICAqIEBwYXJhbSBiIHRoZSBmYWN0b3IgYiBpbiB0aGUgZ2VuZXJhdG9yIHBvbHlub21pYWwgY2FuIGJlIDAtIG9yIDEtYmFzZWRcbiAgICAgICAgICogIChnKHgpID0gKHgrYV5iKSh4K2FeKGIrMSkpLi4uKHgrYV4oYisydC0xKSkpLlxuICAgICAgICAgKiAgSW4gbW9zdCBjYXNlcyBpdCBzaG91bGQgYmUgMSwgYnV0IGZvciBRUiBjb2RlIGl0IGlzIDAuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihwcmltaXRpdmUgLyppbnQqLywgc2l6ZSAvKmludCovLCBnZW5lcmF0b3JCYXNlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLnByaW1pdGl2ZSA9IHByaW1pdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRvckJhc2UgPSBnZW5lcmF0b3JCYXNlO1xuICAgICAgICAgICAgY29uc3QgZXhwVGFibGUgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgICAgICAgIGxldCB4ID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZXhwVGFibGVbaV0gPSB4O1xuICAgICAgICAgICAgICAgIHggKj0gMjsgLy8gd2UncmUgYXNzdW1pbmcgdGhlIGdlbmVyYXRvciBhbHBoYSBpcyAyXG4gICAgICAgICAgICAgICAgaWYgKHggPj0gc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB4IF49IHByaW1pdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgeCAmPSBzaXplIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV4cFRhYmxlID0gZXhwVGFibGU7XG4gICAgICAgICAgICBjb25zdCBsb2dUYWJsZSA9IG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9nVGFibGVbZXhwVGFibGVbaV1dID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nVGFibGUgPSBsb2dUYWJsZTtcbiAgICAgICAgICAgIC8vIGxvZ1RhYmxlWzBdID09IDAgYnV0IHRoaXMgc2hvdWxkIG5ldmVyIGJlIHVzZWRcbiAgICAgICAgICAgIHRoaXMuemVybyA9IG5ldyBHZW5lcmljR0ZQb2x5KHRoaXMsIEludDMyQXJyYXkuZnJvbShbMF0pKTtcbiAgICAgICAgICAgIHRoaXMub25lID0gbmV3IEdlbmVyaWNHRlBvbHkodGhpcywgSW50MzJBcnJheS5mcm9tKFsxXSkpO1xuICAgICAgICB9XG4gICAgICAgIGdldFplcm8oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xuICAgICAgICB9XG4gICAgICAgIGdldE9uZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0aGUgbW9ub21pYWwgcmVwcmVzZW50aW5nIGNvZWZmaWNpZW50ICogeF5kZWdyZWVcbiAgICAgICAgICovXG4gICAgICAgIGJ1aWxkTW9ub21pYWwoZGVncmVlIC8qaW50Ki8sIGNvZWZmaWNpZW50IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChkZWdyZWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KGRlZ3JlZSArIDEpO1xuICAgICAgICAgICAgY29lZmZpY2llbnRzWzBdID0gY29lZmZpY2llbnQ7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNHRlBvbHkodGhpcywgY29lZmZpY2llbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIG9mIGFcbiAgICAgICAgICovXG4gICAgICAgIGludmVyc2UoYSAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcml0aG1ldGljRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVt0aGlzLnNpemUgLSB0aGlzLmxvZ1RhYmxlW2FdIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gcHJvZHVjdCBvZiBhIGFuZCBiIGluIEdGKHNpemUpXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShhIC8qaW50Ki8sIGIgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKGEgPT09IDAgfHwgYiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbKHRoaXMubG9nVGFibGVbYV0gKyB0aGlzLmxvZ1RhYmxlW2JdKSAlICh0aGlzLnNpemUgLSAxKV07XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0R2VuZXJhdG9yQmFzZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvckJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAoJ0dGKDB4JyArIEludGVnZXIudG9IZXhTdHJpbmcodGhpcy5wcmltaXRpdmUpICsgJywnICsgdGhpcy5zaXplICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBlcXVhbHMobykge1xuICAgICAgICAgICAgcmV0dXJuIG8gPT09IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgR2VuZXJpY0dGLkFaVEVDX0RBVEFfMTIgPSBuZXcgR2VuZXJpY0dGKDB4MTA2OSwgNDA5NiwgMSk7IC8vIHheMTIgKyB4XjYgKyB4XjUgKyB4XjMgKyAxXG4gICAgR2VuZXJpY0dGLkFaVEVDX0RBVEFfMTAgPSBuZXcgR2VuZXJpY0dGKDB4NDA5LCAxMDI0LCAxKTsgLy8geF4xMCArIHheMyArIDFcbiAgICBHZW5lcmljR0YuQVpURUNfREFUQV82ID0gbmV3IEdlbmVyaWNHRigweDQzLCA2NCwgMSk7IC8vIHheNiArIHggKyAxXG4gICAgR2VuZXJpY0dGLkFaVEVDX1BBUkFNID0gbmV3IEdlbmVyaWNHRigweDEzLCAxNiwgMSk7IC8vIHheNCArIHggKyAxXG4gICAgR2VuZXJpY0dGLlFSX0NPREVfRklFTERfMjU2ID0gbmV3IEdlbmVyaWNHRigweDAxMWQsIDI1NiwgMCk7IC8vIHheOCArIHheNCArIHheMyArIHheMiArIDFcbiAgICBHZW5lcmljR0YuREFUQV9NQVRSSVhfRklFTERfMjU2ID0gbmV3IEdlbmVyaWNHRigweDAxMmQsIDI1NiwgMSk7IC8vIHheOCArIHheNSArIHheMyArIHheMiArIDFcbiAgICBHZW5lcmljR0YuQVpURUNfREFUQV84ID0gR2VuZXJpY0dGLkRBVEFfTUFUUklYX0ZJRUxEXzI1NjtcbiAgICBHZW5lcmljR0YuTUFYSUNPREVfRklFTERfNjQgPSBHZW5lcmljR0YuQVpURUNfREFUQV82O1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFJlZWRTb2xvbW9uRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICB9XG4gICAgUmVlZFNvbG9tb25FeGNlcHRpb24ua2luZCA9ICdSZWVkU29sb21vbkV4Y2VwdGlvbic7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgSWxsZWdhbFN0YXRlRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICB9XG4gICAgSWxsZWdhbFN0YXRlRXhjZXB0aW9uLmtpbmQgPSAnSWxsZWdhbFN0YXRlRXhjZXB0aW9uJztcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+SW1wbGVtZW50cyBSZWVkLVNvbG9tb24gZGVjb2RpbmcsIGFzIHRoZSBuYW1lIGltcGxpZXMuPC9wPlxuICAgICAqXG4gICAgICogPHA+VGhlIGFsZ29yaXRobSB3aWxsIG5vdCBiZSBleHBsYWluZWQgaGVyZSwgYnV0IHRoZSBmb2xsb3dpbmcgcmVmZXJlbmNlcyB3ZXJlIGhlbHBmdWxcbiAgICAgKiBpbiBjcmVhdGluZyB0aGlzIGltcGxlbWVudGF0aW9uOjwvcD5cbiAgICAgKlxuICAgICAqIDx1bD5cbiAgICAgKiA8bGk+QnJ1Y2UgTWFnZ3MuXG4gICAgICogPGEgaHJlZj1cImh0dHA6Ly93d3cuY3MuY211LmVkdS9hZnMvY3MuY211LmVkdS9wcm9qZWN0L3BzY2ljby1ndXliL3JlYWx3b3JsZC93d3cvcnNfZGVjb2RlLnBzXCI+XG4gICAgICogXCJEZWNvZGluZyBSZWVkLVNvbG9tb24gQ29kZXNcIjwvYT4gKHNlZSBkaXNjdXNzaW9uIG9mIEZvcm5leSdzIEZvcm11bGEpPC9saT5cbiAgICAgKiA8bGk+Si5JLiBIYWxsLiA8YSBocmVmPVwid3d3Lm10aC5tc3UuZWR1L35qaGFsbC9jbGFzc2VzL2NvZGVub3Rlcy9HUlMucGRmXCI+XG4gICAgICogXCJDaGFwdGVyIDUuIEdlbmVyYWxpemVkIFJlZWQtU29sb21vbiBDb2Rlc1wiPC9hPlxuICAgICAqIChzZWUgZGlzY3Vzc2lvbiBvZiBFdWNsaWRlYW4gYWxnb3JpdGhtKTwvbGk+XG4gICAgICogPC91bD5cbiAgICAgKlxuICAgICAqIDxwPk11Y2ggY3JlZGl0IGlzIGR1ZSB0byBXaWxsaWFtIFJ1Y2tsaWRnZSBzaW5jZSBwb3J0aW9ucyBvZiB0aGlzIGNvZGUgYXJlIGFuIGluZGlyZWN0XG4gICAgICogcG9ydCBvZiBoaXMgQysrIFJlZWQtU29sb21vbiBpbXBsZW1lbnRhdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgV2lsbGlhbSBSdWNrbGlkZ2VcbiAgICAgKiBAYXV0aG9yIHNhbmZvcmRzcXVpcmVzXG4gICAgICovXG4gICAgY2xhc3MgUmVlZFNvbG9tb25EZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoZmllbGQpIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGVjb2RlcyBnaXZlbiBzZXQgb2YgcmVjZWl2ZWQgY29kZXdvcmRzLCB3aGljaCBpbmNsdWRlIGJvdGggZGF0YSBhbmQgZXJyb3ItY29ycmVjdGlvblxuICAgICAgICAgKiBjb2Rld29yZHMuIFJlYWxseSwgdGhpcyBtZWFucyBpdCB1c2VzIFJlZWQtU29sb21vbiB0byBkZXRlY3QgYW5kIGNvcnJlY3QgZXJyb3JzLCBpbi1wbGFjZSxcbiAgICAgICAgICogaW4gdGhlIGlucHV0LjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJlY2VpdmVkIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzXG4gICAgICAgICAqIEBwYXJhbSB0d29TIG51bWJlciBvZiBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyBhdmFpbGFibGVcbiAgICAgICAgICogQHRocm93cyBSZWVkU29sb21vbkV4Y2VwdGlvbiBpZiBkZWNvZGluZyBmYWlscyBmb3IgYW55IHJlYXNvblxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlKHJlY2VpdmVkLCB0d29TIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGNvbnN0IHBvbHkgPSBuZXcgR2VuZXJpY0dGUG9seShmaWVsZCwgcmVjZWl2ZWQpO1xuICAgICAgICAgICAgY29uc3Qgc3luZHJvbWVDb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheSh0d29TKTtcbiAgICAgICAgICAgIGxldCBub0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHdvUzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZhbFJlc3VsdCA9IHBvbHkuZXZhbHVhdGVBdChmaWVsZC5leHAoaSArIGZpZWxkLmdldEdlbmVyYXRvckJhc2UoKSkpO1xuICAgICAgICAgICAgICAgIHN5bmRyb21lQ29lZmZpY2llbnRzW3N5bmRyb21lQ29lZmZpY2llbnRzLmxlbmd0aCAtIDEgLSBpXSA9IGV2YWxSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGV2YWxSZXN1bHQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9FcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3luZHJvbWUgPSBuZXcgR2VuZXJpY0dGUG9seShmaWVsZCwgc3luZHJvbWVDb2VmZmljaWVudHMpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWFPbWVnYSA9IHRoaXMucnVuRXVjbGlkZWFuQWxnb3JpdGhtKGZpZWxkLmJ1aWxkTW9ub21pYWwodHdvUywgMSksIHN5bmRyb21lLCB0d29TKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hID0gc2lnbWFPbWVnYVswXTtcbiAgICAgICAgICAgIGNvbnN0IG9tZWdhID0gc2lnbWFPbWVnYVsxXTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTG9jYXRpb25zID0gdGhpcy5maW5kRXJyb3JMb2NhdGlvbnMoc2lnbWEpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNYWduaXR1ZGVzID0gdGhpcy5maW5kRXJyb3JNYWduaXR1ZGVzKG9tZWdhLCBlcnJvckxvY2F0aW9ucyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9yTG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSByZWNlaXZlZC5sZW5ndGggLSAxIC0gZmllbGQubG9nKGVycm9yTG9jYXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkV4Y2VwdGlvbignQmFkIGVycm9yIGxvY2F0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkW3Bvc2l0aW9uXSA9IEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KHJlY2VpdmVkW3Bvc2l0aW9uXSwgZXJyb3JNYWduaXR1ZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBydW5FdWNsaWRlYW5BbGdvcml0aG0oYSwgYiwgUiAvKmludCovKSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgYSdzIGRlZ3JlZSBpcyA+PSBiJ3NcbiAgICAgICAgICAgIGlmIChhLmdldERlZ3JlZSgpIDwgYi5nZXREZWdyZWUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBhO1xuICAgICAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgICAgIGIgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgbGV0IHJMYXN0ID0gYTtcbiAgICAgICAgICAgIGxldCByID0gYjtcbiAgICAgICAgICAgIGxldCB0TGFzdCA9IGZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgIGxldCB0ID0gZmllbGQuZ2V0T25lKCk7XG4gICAgICAgICAgICAvLyBSdW4gRXVjbGlkZWFuIGFsZ29yaXRobSB1bnRpbCByJ3MgZGVncmVlIGlzIGxlc3MgdGhhbiBSLzJcbiAgICAgICAgICAgIHdoaWxlIChyLmdldERlZ3JlZSgpID49IChSIC8gMiB8IDApKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJMYXN0TGFzdCA9IHJMYXN0O1xuICAgICAgICAgICAgICAgIGxldCB0TGFzdExhc3QgPSB0TGFzdDtcbiAgICAgICAgICAgICAgICByTGFzdCA9IHI7XG4gICAgICAgICAgICAgICAgdExhc3QgPSB0O1xuICAgICAgICAgICAgICAgIC8vIERpdmlkZSByTGFzdExhc3QgYnkgckxhc3QsIHdpdGggcXVvdGllbnQgaW4gcSBhbmQgcmVtYWluZGVyIGluIHJcbiAgICAgICAgICAgICAgICBpZiAockxhc3QuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT29wcywgRXVjbGlkZWFuIGFsZ29yaXRobSBhbHJlYWR5IHRlcm1pbmF0ZWQ/XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkV4Y2VwdGlvbigncl97aS0xfSB3YXMgemVybycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByID0gckxhc3RMYXN0O1xuICAgICAgICAgICAgICAgIGxldCBxID0gZmllbGQuZ2V0WmVybygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0gPSByTGFzdC5nZXRDb2VmZmljaWVudChyTGFzdC5nZXREZWdyZWUoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGx0SW52ZXJzZSA9IGZpZWxkLmludmVyc2UoZGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIuZ2V0RGVncmVlKCkgPj0gckxhc3QuZ2V0RGVncmVlKCkgJiYgIXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVncmVlRGlmZiA9IHIuZ2V0RGVncmVlKCkgLSByTGFzdC5nZXREZWdyZWUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBmaWVsZC5tdWx0aXBseShyLmdldENvZWZmaWNpZW50KHIuZ2V0RGVncmVlKCkpLCBkbHRJbnZlcnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEuYWRkT3JTdWJ0cmFjdChmaWVsZC5idWlsZE1vbm9taWFsKGRlZ3JlZURpZmYsIHNjYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByLmFkZE9yU3VidHJhY3Qockxhc3QubXVsdGlwbHlCeU1vbm9taWFsKGRlZ3JlZURpZmYsIHNjYWxlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSBxLm11bHRpcGx5KHRMYXN0KS5hZGRPclN1YnRyYWN0KHRMYXN0TGFzdCk7XG4gICAgICAgICAgICAgICAgaWYgKHIuZ2V0RGVncmVlKCkgPj0gckxhc3QuZ2V0RGVncmVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbignRGl2aXNpb24gYWxnb3JpdGhtIGZhaWxlZCB0byByZWR1Y2UgcG9seW5vbWlhbD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaWdtYVRpbGRlQXRaZXJvID0gdC5nZXRDb2VmZmljaWVudCgwKTtcbiAgICAgICAgICAgIGlmIChzaWdtYVRpbGRlQXRaZXJvID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZWRTb2xvbW9uRXhjZXB0aW9uKCdzaWdtYVRpbGRlKDApIHdhcyB6ZXJvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnZlcnNlID0gZmllbGQuaW52ZXJzZShzaWdtYVRpbGRlQXRaZXJvKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hID0gdC5tdWx0aXBseVNjYWxhcihpbnZlcnNlKTtcbiAgICAgICAgICAgIGNvbnN0IG9tZWdhID0gci5tdWx0aXBseVNjYWxhcihpbnZlcnNlKTtcbiAgICAgICAgICAgIHJldHVybiBbc2lnbWEsIG9tZWdhXTtcbiAgICAgICAgfVxuICAgICAgICBmaW5kRXJyb3JMb2NhdGlvbnMoZXJyb3JMb2NhdG9yKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgZGlyZWN0IGFwcGxpY2F0aW9uIG9mIENoaWVuJ3Mgc2VhcmNoXG4gICAgICAgICAgICBjb25zdCBudW1FcnJvcnMgPSBlcnJvckxvY2F0b3IuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICBpZiAobnVtRXJyb3JzID09PSAxKSB7IC8vIHNob3J0Y3V0XG4gICAgICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbZXJyb3JMb2NhdG9yLmdldENvZWZmaWNpZW50KDEpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgSW50MzJBcnJheShudW1FcnJvcnMpO1xuICAgICAgICAgICAgbGV0IGUgPSAwO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBmaWVsZC5nZXRTaXplKCkgJiYgZSA8IG51bUVycm9yczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTG9jYXRvci5ldmFsdWF0ZUF0KGkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtlXSA9IGZpZWxkLmludmVyc2UoaSk7XG4gICAgICAgICAgICAgICAgICAgIGUrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSAhPT0gbnVtRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZWRTb2xvbW9uRXhjZXB0aW9uKCdFcnJvciBsb2NhdG9yIGRlZ3JlZSBkb2VzIG5vdCBtYXRjaCBudW1iZXIgb2Ygcm9vdHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZmluZEVycm9yTWFnbml0dWRlcyhlcnJvckV2YWx1YXRvciwgZXJyb3JMb2NhdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZGlyZWN0bHkgYXBwbHlpbmcgRm9ybmV5J3MgRm9ybXVsYVxuICAgICAgICAgICAgY29uc3QgcyA9IGVycm9yTG9jYXRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KHMpO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4aUludmVyc2UgPSBmaWVsZC5pbnZlcnNlKGVycm9yTG9jYXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVub21pbmF0b3IgPSAxO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZW5vbWluYXRvciA9IGZpZWxkLm11bHRpcGx5KGRlbm9taW5hdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgR2VuZXJpY0dGLmFkZE9yU3VidHJhY3QoMSwgZmllbGQubXVsdGlwbHkoZXJyb3JMb2NhdGlvbnNbal0sIHhpSW52ZXJzZSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWJvdmUgc2hvdWxkIHdvcmsgYnV0IGZhaWxzIG9uIHNvbWUgQXBwbGUgYW5kIExpbnV4IEpES3MgZHVlIHRvIGEgSG90c3BvdCBidWcuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCZWxvdyBpcyBhIGZ1bm55LWxvb2tpbmcgd29ya2Fyb3VuZCBmcm9tIFN0ZXZlbiBQYXJrZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm0gPSBmaWVsZC5tdWx0aXBseShlcnJvckxvY2F0aW9uc1tqXSwgeGlJbnZlcnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1QbHVzMSA9ICh0ZXJtICYgMHgxKSA9PT0gMCA/IHRlcm0gfCAxIDogdGVybSAmIH4xO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVub21pbmF0b3IgPSBmaWVsZC5tdWx0aXBseShkZW5vbWluYXRvciwgdGVybVBsdXMxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBmaWVsZC5tdWx0aXBseShlcnJvckV2YWx1YXRvci5ldmFsdWF0ZUF0KHhpSW52ZXJzZSksIGZpZWxkLmludmVyc2UoZGVub21pbmF0b3IpKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQuZ2V0R2VuZXJhdG9yQmFzZSgpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGZpZWxkLm11bHRpcGx5KHJlc3VsdFtpXSwgeGlJbnZlcnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMCBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkFycmF5cztcbiAgICB2YXIgVGFibGU7XG4gICAgKGZ1bmN0aW9uIChUYWJsZSkge1xuICAgICAgICBUYWJsZVtUYWJsZVtcIlVQUEVSXCJdID0gMF0gPSBcIlVQUEVSXCI7XG4gICAgICAgIFRhYmxlW1RhYmxlW1wiTE9XRVJcIl0gPSAxXSA9IFwiTE9XRVJcIjtcbiAgICAgICAgVGFibGVbVGFibGVbXCJNSVhFRFwiXSA9IDJdID0gXCJNSVhFRFwiO1xuICAgICAgICBUYWJsZVtUYWJsZVtcIkRJR0lUXCJdID0gM10gPSBcIkRJR0lUXCI7XG4gICAgICAgIFRhYmxlW1RhYmxlW1wiUFVOQ1RcIl0gPSA0XSA9IFwiUFVOQ1RcIjtcbiAgICAgICAgVGFibGVbVGFibGVbXCJCSU5BUllcIl0gPSA1XSA9IFwiQklOQVJZXCI7XG4gICAgfSkoVGFibGUgfHwgKFRhYmxlID0ge30pKTtcbiAgICAvKipcbiAgICAgKiA8cD5UaGUgbWFpbiBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIEF6dGVjIENvZGUgZGVjb2RpbmcgLS0gYXMgb3Bwb3NlZCB0byBsb2NhdGluZyBhbmQgZXh0cmFjdGluZ1xuICAgICAqIHRoZSBBenRlYyBDb2RlIGZyb20gYW4gaW1hZ2UuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBEYXZpZCBPbGl2aWVyXG4gICAgICovXG4gICAgY2xhc3MgRGVjb2RlciB7XG4gICAgICAgIGRlY29kZShkZXRlY3RvclJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5kZGF0YSA9IGRldGVjdG9yUmVzdWx0O1xuICAgICAgICAgICAgbGV0IG1hdHJpeCA9IGRldGVjdG9yUmVzdWx0LmdldEJpdHMoKTtcbiAgICAgICAgICAgIGxldCByYXdiaXRzID0gdGhpcy5leHRyYWN0Qml0cyhtYXRyaXgpO1xuICAgICAgICAgICAgbGV0IGNvcnJlY3RlZEJpdHMgPSB0aGlzLmNvcnJlY3RCaXRzKHJhd2JpdHMpO1xuICAgICAgICAgICAgbGV0IHJhd0J5dGVzID0gRGVjb2Rlci5jb252ZXJ0Qm9vbEFycmF5VG9CeXRlQXJyYXkoY29ycmVjdGVkQml0cyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gRGVjb2Rlci5nZXRFbmNvZGVkRGF0YShjb3JyZWN0ZWRCaXRzKTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVyUmVzdWx0ID0gbmV3IERlY29kZXJSZXN1bHQocmF3Qnl0ZXMsIHJlc3VsdCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICBkZWNvZGVyUmVzdWx0LnNldE51bUJpdHMoY29ycmVjdGVkQml0cy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgdGVzdGluZyB0aGUgaGlnaC1sZXZlbCBlbmNvZGVyXG4gICAgICAgIHN0YXRpYyBoaWdoTGV2ZWxEZWNvZGUoY29ycmVjdGVkQml0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2RlZERhdGEoY29ycmVjdGVkQml0cyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHN0cmluZyBlbmNvZGVkIGluIHRoZSBhenRlYyBjb2RlIGJpdHNcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgZGVjb2RlZCBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRFbmNvZGVkRGF0YShjb3JyZWN0ZWRCaXRzKSB7XG4gICAgICAgICAgICBsZXQgZW5kSW5kZXggPSBjb3JyZWN0ZWRCaXRzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBsYXRjaFRhYmxlID0gVGFibGUuVVBQRVI7IC8vIHRhYmxlIG1vc3QgcmVjZW50bHkgbGF0Y2hlZCB0b1xuICAgICAgICAgICAgbGV0IHNoaWZ0VGFibGUgPSBUYWJsZS5VUFBFUjsgLy8gdGFibGUgdG8gdXNlIGZvciB0aGUgbmV4dCByZWFkXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hpZnRUYWJsZSA9PT0gVGFibGUuQklOQVJZKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRJbmRleCAtIGluZGV4IDwgNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IERlY29kZXIucmVhZENvZGUoY29ycmVjdGVkQml0cywgaW5kZXgsIDUpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggLSBpbmRleCA8IDExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBEZWNvZGVyLnJlYWRDb2RlKGNvcnJlY3RlZEJpdHMsIGluZGV4LCAxMSkgKyAzMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDExO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNoYXJDb3VudCA9IDA7IGNoYXJDb3VudCA8IGxlbmd0aDsgY2hhckNvdW50KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRJbmRleCAtIGluZGV4IDwgOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZW5kSW5kZXg7IC8vIEZvcmNlIG91dGVyIGxvb3AgdG8gZXhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IERlY29kZXIucmVhZENvZGUoY29ycmVjdGVkQml0cywgaW5kZXgsIDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IC8qKGNoYXIpKi8gU3RyaW5nVXRpbHMuY2FzdEFzTm9uVXRmOENoYXIoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArPSA4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEdvIGJhY2sgdG8gd2hhdGV2ZXIgbW9kZSB3ZSBoYWQgYmVlbiBpblxuICAgICAgICAgICAgICAgICAgICBzaGlmdFRhYmxlID0gbGF0Y2hUYWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gc2hpZnRUYWJsZSA9PT0gVGFibGUuRElHSVQgPyA0IDogNTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluZGV4IC0gaW5kZXggPCBzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IERlY29kZXIucmVhZENvZGUoY29ycmVjdGVkQml0cywgaW5kZXgsIHNpemUpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RyID0gRGVjb2Rlci5nZXRDaGFyYWN0ZXIoc2hpZnRUYWJsZSwgY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIuc3RhcnRzV2l0aCgnQ1RSTF8nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFibGUgY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSVNPL0lFQyAyNDc3ODoyMDA4IHByZXNjcmliZXMgZW5kaW5nIGEgc2hpZnQgc2VxdWVuY2UgaW4gdGhlIG1vZGUgZnJvbSB3aGljaCBpdCB3YXMgaW52b2tlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYXQncyBpbmNsdWRpbmcgd2hlbiB0aGF0IG1vZGUgaXMgYSBzaGlmdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE91ciB0ZXN0IGNhc2UgZGx1c2JzLnBuZyBmb3IgaXNzdWUgIzY0MiBleGVyY2lzZXMgdGhhdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdGNoVGFibGUgPSBzaGlmdFRhYmxlOyAvLyBMYXRjaCB0aGUgY3VycmVudCBtb2RlLCBzbyBhcyB0byByZXR1cm4gdG8gVXBwZXIgYWZ0ZXIgVS9TIEIvU1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRUYWJsZSA9IERlY29kZXIuZ2V0VGFibGUoc3RyLmNoYXJBdCg1KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLmNoYXJBdCg2KSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0Y2hUYWJsZSA9IHNoaWZ0VGFibGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR28gYmFjayB0byB3aGF0ZXZlciBtb2RlIHdlIGhhZCBiZWVuIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFRhYmxlID0gbGF0Y2hUYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldHMgdGhlIHRhYmxlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNoYXIgcGFzc2VkXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0VGFibGUodCkge1xuICAgICAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUYWJsZS5MT1dFUjtcbiAgICAgICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLlBVTkNUO1xuICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGFibGUuTUlYRUQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUYWJsZS5ESUdJVDtcbiAgICAgICAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLkJJTkFSWTtcbiAgICAgICAgICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGFibGUuVVBQRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGNoYXJhY3RlciAob3Igc3RyaW5nKSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwYXNzZWQgY29kZSBpbiB0aGUgZ2l2ZW4gdGFibGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRhYmxlIHRoZSB0YWJsZSB1c2VkXG4gICAgICAgICAqIEBwYXJhbSBjb2RlIHRoZSBjb2RlIG9mIHRoZSBjaGFyYWN0ZXJcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRDaGFyYWN0ZXIodGFibGUsIGNvZGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGFibGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRhYmxlLlVQUEVSOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5VUFBFUl9UQUJMRVtjb2RlXTtcbiAgICAgICAgICAgICAgICBjYXNlIFRhYmxlLkxPV0VSOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5MT1dFUl9UQUJMRVtjb2RlXTtcbiAgICAgICAgICAgICAgICBjYXNlIFRhYmxlLk1JWEVEOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5NSVhFRF9UQUJMRVtjb2RlXTtcbiAgICAgICAgICAgICAgICBjYXNlIFRhYmxlLlBVTkNUOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5QVU5DVF9UQUJMRVtjb2RlXTtcbiAgICAgICAgICAgICAgICBjYXNlIFRhYmxlLkRJR0lUOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5ESUdJVF9UQUJMRVtjb2RlXTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgbm90IHJlYWNoIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oJ0JhZCB0YWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5QZXJmb3JtcyBSUyBlcnJvciBjb3JyZWN0aW9uIG9uIGFuIGFycmF5IG9mIGJpdHMuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBjb3JyZWN0ZWQgYXJyYXlcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIGlucHV0IGNvbnRhaW5zIHRvbyBtYW55IGVycm9yc1xuICAgICAgICAgKi9cbiAgICAgICAgY29ycmVjdEJpdHMocmF3Yml0cykge1xuICAgICAgICAgICAgbGV0IGdmO1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkU2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRkYXRhLmdldE5iTGF5ZXJzKCkgPD0gMikge1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkU2l6ZSA9IDY7XG4gICAgICAgICAgICAgICAgZ2YgPSBHZW5lcmljR0YuQVpURUNfREFUQV82O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5kZGF0YS5nZXROYkxheWVycygpIDw9IDgpIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZFNpemUgPSA4O1xuICAgICAgICAgICAgICAgIGdmID0gR2VuZXJpY0dGLkFaVEVDX0RBVEFfODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZGRhdGEuZ2V0TmJMYXllcnMoKSA8PSAyMikge1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkU2l6ZSA9IDEwO1xuICAgICAgICAgICAgICAgIGdmID0gR2VuZXJpY0dGLkFaVEVDX0RBVEFfMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZFNpemUgPSAxMjtcbiAgICAgICAgICAgICAgICBnZiA9IEdlbmVyaWNHRi5BWlRFQ19EQVRBXzEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG51bURhdGFDb2Rld29yZHMgPSB0aGlzLmRkYXRhLmdldE5iRGF0YWJsb2NrcygpO1xuICAgICAgICAgICAgbGV0IG51bUNvZGV3b3JkcyA9IHJhd2JpdHMubGVuZ3RoIC8gY29kZXdvcmRTaXplO1xuICAgICAgICAgICAgaWYgKG51bUNvZGV3b3JkcyA8IG51bURhdGFDb2Rld29yZHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcmF3Yml0cy5sZW5ndGggJSBjb2Rld29yZFNpemU7XG4gICAgICAgICAgICBsZXQgZGF0YVdvcmRzID0gbmV3IEludDMyQXJyYXkobnVtQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29kZXdvcmRzOyBpKyssIG9mZnNldCArPSBjb2Rld29yZFNpemUpIHtcbiAgICAgICAgICAgICAgICBkYXRhV29yZHNbaV0gPSBEZWNvZGVyLnJlYWRDb2RlKHJhd2JpdHMsIG9mZnNldCwgY29kZXdvcmRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJzRGVjb2RlciA9IG5ldyBSZWVkU29sb21vbkRlY29kZXIoZ2YpO1xuICAgICAgICAgICAgICAgIHJzRGVjb2Rlci5kZWNvZGUoZGF0YVdvcmRzLCBudW1Db2Rld29yZHMgLSBudW1EYXRhQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IHBlcmZvcm0gdGhlIHVuc3R1ZmZpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgICAgLy8gRmlyc3QsIGNvdW50IGhvdyBtYW55IGJpdHMgYXJlIGdvaW5nIHRvIGJlIHRocm93biBvdXQgYXMgc3R1ZmZpbmdcbiAgICAgICAgICAgIGxldCBtYXNrID0gKDEgPDwgY29kZXdvcmRTaXplKSAtIDE7XG4gICAgICAgICAgICBsZXQgc3R1ZmZlZEJpdHMgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVdvcmQgPSBkYXRhV29yZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFXb3JkID09PSAwIHx8IGRhdGFXb3JkID09PSBtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVdvcmQgPT09IDEgfHwgZGF0YVdvcmQgPT09IG1hc2sgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0dWZmZWRCaXRzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93LCBhY3R1YWxseSB1bnBhY2sgdGhlIGJpdHMgYW5kIHJlbW92ZSB0aGUgc3R1ZmZpbmdcbiAgICAgICAgICAgIGxldCBjb3JyZWN0ZWRCaXRzID0gbmV3IEFycmF5KG51bURhdGFDb2Rld29yZHMgKiBjb2Rld29yZFNpemUgLSBzdHVmZmVkQml0cyk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVdvcmQgPSBkYXRhV29yZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFXb3JkID09PSAxIHx8IGRhdGFXb3JkID09PSBtYXNrIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGNvZGV3b3JkU2l6ZS0xIGJpdHMgYXJlIGFsbCB6ZXJvcyBvciBhbGwgb25lc1xuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0ZWRCaXRzLmZpbGwoZGF0YVdvcmQgPiAxLCBpbmRleCwgaW5kZXggKyBjb2Rld29yZFNpemUgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXlzLmZpbGwoY29ycmVjdGVkQml0cywgaW5kZXgsIGluZGV4ICsgY29kZXdvcmRTaXplIC0gMSwgZGF0YVdvcmQgPiAxKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gY29kZXdvcmRTaXplIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGJpdCA9IGNvZGV3b3JkU2l6ZSAtIDE7IGJpdCA+PSAwOyAtLWJpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVjdGVkQml0c1tpbmRleCsrXSA9IChkYXRhV29yZCAmICgxIDw8IGJpdCkpICE9PSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3RlZEJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGFycmF5IG9mIGJpdHMgZnJvbSBhbiBBenRlYyBDb2RlIG1hdHJpeFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBhcnJheSBvZiBiaXRzXG4gICAgICAgICAqL1xuICAgICAgICBleHRyYWN0Qml0cyhtYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCBjb21wYWN0ID0gdGhpcy5kZGF0YS5pc0NvbXBhY3QoKTtcbiAgICAgICAgICAgIGxldCBsYXllcnMgPSB0aGlzLmRkYXRhLmdldE5iTGF5ZXJzKCk7XG4gICAgICAgICAgICBsZXQgYmFzZU1hdHJpeFNpemUgPSAoY29tcGFjdCA/IDExIDogMTQpICsgbGF5ZXJzICogNDsgLy8gbm90IGluY2x1ZGluZyBhbGlnbm1lbnQgbGluZXNcbiAgICAgICAgICAgIGxldCBhbGlnbm1lbnRNYXAgPSBuZXcgSW50MzJBcnJheShiYXNlTWF0cml4U2l6ZSk7XG4gICAgICAgICAgICBsZXQgcmF3Yml0cyA9IG5ldyBBcnJheSh0aGlzLnRvdGFsQml0c0luTGF5ZXIobGF5ZXJzLCBjb21wYWN0KSk7XG4gICAgICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxpZ25tZW50TWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudE1hcFtpXSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdHJpeFNpemUgPSBiYXNlTWF0cml4U2l6ZSArIDEgKyAyICogSW50ZWdlci50cnVuY0RpdmlzaW9uKChJbnRlZ2VyLnRydW5jRGl2aXNpb24oYmFzZU1hdHJpeFNpemUsIDIpIC0gMSksIDE1KTtcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ0NlbnRlciA9IGJhc2VNYXRyaXhTaXplIC8gMjtcbiAgICAgICAgICAgICAgICBsZXQgY2VudGVyID0gSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ0NlbnRlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdPZmZzZXQgPSBpICsgSW50ZWdlci50cnVuY0RpdmlzaW9uKGksIDE1KTtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50TWFwW29yaWdDZW50ZXIgLSBpIC0gMV0gPSBjZW50ZXIgLSBuZXdPZmZzZXQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRNYXBbb3JpZ0NlbnRlciArIGldID0gY2VudGVyICsgbmV3T2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcm93T2Zmc2V0ID0gMDsgaSA8IGxheWVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvd1NpemUgPSAobGF5ZXJzIC0gaSkgKiA0ICsgKGNvbXBhY3QgPyA5IDogMTIpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSB0b3AtbGVmdCBtb3N0IHBvaW50IG9mIHRoaXMgbGF5ZXIgaXMgPGxvdywgbG93PiAobm90IGluY2x1ZGluZyBhbGlnbm1lbnQgbGluZXMpXG4gICAgICAgICAgICAgICAgbGV0IGxvdyA9IGkgKiAyO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBib3R0b20tcmlnaHQgbW9zdCBwb2ludCBvZiB0aGlzIGxheWVyIGlzIDxoaWdoLCBoaWdoPiAobm90IGluY2x1ZGluZyBhbGlnbm1lbnQgbGluZXMpXG4gICAgICAgICAgICAgICAgbGV0IGhpZ2ggPSBiYXNlTWF0cml4U2l6ZSAtIDEgLSBsb3c7XG4gICAgICAgICAgICAgICAgLy8gV2UgcHVsbCBiaXRzIGZyb20gdGhlIHR3byAyIHggcm93U2l6ZSBjb2x1bW5zIGFuZCB0d28gcm93U2l6ZSB4IDIgcm93c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93U2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2x1bW5PZmZzZXQgPSBqICogMjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCAyOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlZnQgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdiaXRzW3Jvd09mZnNldCArIGNvbHVtbk9mZnNldCArIGtdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguZ2V0KGFsaWdubWVudE1hcFtsb3cgKyBrXSwgYWxpZ25tZW50TWFwW2xvdyArIGpdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvdHRvbSByb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd2JpdHNbcm93T2Zmc2V0ICsgMiAqIHJvd1NpemUgKyBjb2x1bW5PZmZzZXQgKyBrXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LmdldChhbGlnbm1lbnRNYXBbbG93ICsgal0sIGFsaWdubWVudE1hcFtoaWdoIC0ga10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmlnaHQgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdiaXRzW3Jvd09mZnNldCArIDQgKiByb3dTaXplICsgY29sdW1uT2Zmc2V0ICsga10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5nZXQoYWxpZ25tZW50TWFwW2hpZ2ggLSBrXSwgYWxpZ25tZW50TWFwW2hpZ2ggLSBqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0b3Agcm93XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdiaXRzW3Jvd09mZnNldCArIDYgKiByb3dTaXplICsgY29sdW1uT2Zmc2V0ICsga10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5nZXQoYWxpZ25tZW50TWFwW2hpZ2ggLSBqXSwgYWxpZ25tZW50TWFwW2xvdyArIGtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gcm93U2l6ZSAqIDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmF3Yml0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZHMgYSBjb2RlIG9mIGdpdmVuIGxlbmd0aCBhbmQgYXQgZ2l2ZW4gaW5kZXggaW4gYW4gYXJyYXkgb2YgYml0c1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHJlYWRDb2RlKHJhd2JpdHMsIHN0YXJ0SW5kZXgsIGxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJlcyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IHN0YXJ0SW5kZXggKyBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlcyA8PD0gMTtcbiAgICAgICAgICAgICAgICBpZiAocmF3Yml0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXMgfD0gMHgwMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkcyBhIGNvZGUgb2YgbGVuZ3RoIDggaW4gYW4gYXJyYXkgb2YgYml0cywgcGFkZGluZyB3aXRoIHplcm9zXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcmVhZEJ5dGUocmF3Yml0cywgc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgbGV0IG4gPSByYXdiaXRzLmxlbmd0aCAtIHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBpZiAobiA+PSA4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIucmVhZENvZGUocmF3Yml0cywgc3RhcnRJbmRleCwgOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5yZWFkQ29kZShyYXdiaXRzLCBzdGFydEluZGV4LCBuKSA8PCAoOCAtIG4pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYWNrcyBhIGJpdCBhcnJheSBpbnRvIGJ5dGVzLCBtb3N0IHNpZ25pZmljYW50IGJpdCBmaXJzdFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNvbnZlcnRCb29sQXJyYXlUb0J5dGVBcnJheShib29sQXJyKSB7XG4gICAgICAgICAgICBsZXQgYnl0ZUFyciA9IG5ldyBVaW50OEFycmF5KChib29sQXJyLmxlbmd0aCArIDcpIC8gOCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBieXRlQXJyW2ldID0gRGVjb2Rlci5yZWFkQnl0ZShib29sQXJyLCA4ICogaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnl0ZUFycjtcbiAgICAgICAgfVxuICAgICAgICB0b3RhbEJpdHNJbkxheWVyKGxheWVycywgY29tcGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuICgoY29tcGFjdCA/IDg4IDogMTEyKSArIDE2ICogbGF5ZXJzKSAqIGxheWVycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBEZWNvZGVyLlVQUEVSX1RBQkxFID0gW1xuICAgICAgICAnQ1RSTF9QUycsICcgJywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLFxuICAgICAgICAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdDVFJMX0xMJywgJ0NUUkxfTUwnLCAnQ1RSTF9ETCcsICdDVFJMX0JTJ1xuICAgIF07XG4gICAgRGVjb2Rlci5MT1dFUl9UQUJMRSA9IFtcbiAgICAgICAgJ0NUUkxfUFMnLCAnICcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJyxcbiAgICAgICAgJ3EnLCAncicsICdzJywgJ3QnLCAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnQ1RSTF9VUycsICdDVFJMX01MJywgJ0NUUkxfREwnLCAnQ1RSTF9CUydcbiAgICBdO1xuICAgIERlY29kZXIuTUlYRURfVEFCTEUgPSBbXG4gICAgICAgIC8vIE1vZHVsZSBwYXJzZSBmYWlsZWQ6IE9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGUgKDUwOjI5KVxuICAgICAgICAvLyBzbyBudW1iZXIgc3RyaW5nIHdlcmUgc2NhcGVkXG4gICAgICAgICdDVFJMX1BTJywgJyAnLCAnXFxcXDEnLCAnXFxcXDInLCAnXFxcXDMnLCAnXFxcXDQnLCAnXFxcXDUnLCAnXFxcXDYnLCAnXFxcXDcnLCAnXFxiJywgJ1xcdCcsICdcXG4nLFxuICAgICAgICAnXFxcXDEzJywgJ1xcZicsICdcXHInLCAnXFxcXDMzJywgJ1xcXFwzNCcsICdcXFxcMzUnLCAnXFxcXDM2JywgJ1xcXFwzNycsICdAJywgJ1xcXFwnLCAnXicsICdfJyxcbiAgICAgICAgJ2AnLCAnfCcsICd+JywgJ1xcXFwxNzcnLCAnQ1RSTF9MTCcsICdDVFJMX1VMJywgJ0NUUkxfUEwnLCAnQ1RSTF9CUydcbiAgICBdO1xuICAgIERlY29kZXIuUFVOQ1RfVEFCTEUgPSBbXG4gICAgICAgICcnLCAnXFxyJywgJ1xcclxcbicsICcuICcsICcsICcsICc6ICcsICchJywgJ1wiJywgJyMnLCAnJCcsICclJywgJyYnLCAnXFwnJywgJygnLCAnKScsXG4gICAgICAgICcqJywgJysnLCAnLCcsICctJywgJy4nLCAnLycsICc6JywgJzsnLCAnPCcsICc9JywgJz4nLCAnPycsICdbJywgJ10nLCAneycsICd9JywgJ0NUUkxfVUwnXG4gICAgXTtcbiAgICBEZWNvZGVyLkRJR0lUX1RBQkxFID0gW1xuICAgICAgICAnQ1RSTF9QUycsICcgJywgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnLCcsICcuJywgJ0NUUkxfVUwnLCAnQ1RSTF9VUydcbiAgICBdO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMiBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5kZXRlY3RvciB7Ki9cbiAgICAvKipcbiAgICAgKiBHZW5lcmFsIG1hdGgtcmVsYXRlZCBhbmQgbnVtZXJpYyB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBNYXRoVXRpbHMge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5kcyB1cCBiZWluZyBhIGJpdCBmYXN0ZXIgdGhhbiB7QGxpbmsgTWF0aCNyb3VuZChmbG9hdCl9LiBUaGlzIG1lcmVseSByb3VuZHMgaXRzXG4gICAgICAgICAqIGFyZ3VtZW50IHRvIHRoZSBuZWFyZXN0IGludCwgd2hlcmUgeC41IHJvdW5kcyB1cCB0byB4KzEuIFNlbWFudGljcyBvZiB0aGlzIHNob3J0Y3V0XG4gICAgICAgICAqIGRpZmZlciBzbGlnaHRseSBmcm9tIHtAbGluayBNYXRoI3JvdW5kKGZsb2F0KX0gaW4gdGhhdCBoYWxmIHJvdW5kcyBkb3duIGZvciBuZWdhdGl2ZVxuICAgICAgICAgKiB2YWx1ZXMuIC0yLjUgcm91bmRzIHRvIC0zLCBub3QgLTIuIEZvciBwdXJwb3NlcyBoZXJlIGl0IG1ha2VzIG5vIGRpZmZlcmVuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkIHJlYWwgdmFsdWUgdG8gcm91bmRcbiAgICAgICAgICogQHJldHVybiBuZWFyZXN0IHtAY29kZSBpbnR9XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcm91bmQoZCAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGlmIChOYU4gPT09IGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBpZiAoZCA8PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUilcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICBpZiAoZCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICByZXR1cm4gLyooaW50KSAqLyAoZCArIChkIDwgMC4wID8gLTAuNSA6IDAuNSkpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogbWF5YmUgcmVtb3ZlIHJvdW5kIG1ldGhvZCBhbmQgY2FsbCBkaXJlY3RseSBNYXRoLnJvdW5kLCBpdCBsb29rcyBsaWtlIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IganNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBhWCBwb2ludCBBIHggY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gYVkgcG9pbnQgQSB5IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIGJYIHBvaW50IEIgeCBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSBiWSBwb2ludCBCIHkgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcmV0dXJuIEV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cyBBIGFuZCBCXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGlzdGFuY2UoYVggLypmbG9hdHxpbnQqLywgYVkgLypmbG9hdHxpbnQqLywgYlggLypmbG9hdHxpbnQqLywgYlkgLypmbG9hdHxpbnQqLykge1xuICAgICAgICAgICAgY29uc3QgeERpZmYgPSBhWCAtIGJYO1xuICAgICAgICAgICAgY29uc3QgeURpZmYgPSBhWSAtIGJZO1xuICAgICAgICAgICAgcmV0dXJuIC8qKGZsb2F0KSAqLyBNYXRoLnNxcnQoeERpZmYgKiB4RGlmZiArIHlEaWZmICogeURpZmYpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYVggcG9pbnQgQSB4IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIGFZIHBvaW50IEEgeSBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSBiWCBwb2ludCBCIHggY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gYlkgcG9pbnQgQiB5IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHJldHVybiBFdWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgQSBhbmQgQlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIHN0YXRpYyBkaXN0YW5jZShhWDogbnVtYmVyIC8qaW50Ki8sIGFZOiBudW1iZXIgLyppbnQqLywgYlg6IG51bWJlciAvKmludCovLCBiWTogbnVtYmVyIC8qaW50Ki8pOiBmbG9hdCB7XG4gICAgICAgIC8vICAgY29uc3QgeERpZmYgPSBhWCAtIGJYXG4gICAgICAgIC8vICAgY29uc3QgeURpZmYgPSBhWSAtIGJZXG4gICAgICAgIC8vICAgcmV0dXJuIChmbG9hdCkgTWF0aC5zcXJ0KHhEaWZmICogeERpZmYgKyB5RGlmZiAqIHlEaWZmKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGFycmF5IHZhbHVlcyB0byBzdW1cbiAgICAgICAgICogQHJldHVybiBzdW0gb2YgdmFsdWVzIGluIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgc3VtKGFycmF5KSB7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSAhPT0gbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgY291bnQgKz0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbnlmaWxsIGZvciBKYXZhJ3MgRmxvYXQgY2xhc3MuXG4gICAgICovXG4gICAgY2xhc3MgRmxvYXQge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2luY1RTIGhhcyBubyBkaWZmZXJlbmNlIGJldHdlZW4gaW50IGFuZCBmbG9hdCwgdGhlcmUncyBhbGwgbnVtYmVycyxcbiAgICAgICAgICogdGhpcyBpcyB1c2VkIG9ubHkgdG8gcG9seWZpbGwgSmF2YSBjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZsb2F0VG9JbnRCaXRzKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmbG9hdCBtYXggdmFsdWUgaW4gSlMgaXMgdGhlIG51bWJlciBtYXggdmFsdWUuXG4gICAgICovXG4gICAgRmxvYXQuTUFYX1ZBTFVFID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBhIHBvaW50IG9mIGludGVyZXN0IGluIGFuIGltYWdlIGNvbnRhaW5pbmcgYSBiYXJjb2RlLiBUeXBpY2FsbHksIHRoaXNcbiAgICAgKiB3b3VsZCBiZSB0aGUgbG9jYXRpb24gb2YgYSBmaW5kZXIgcGF0dGVybiBvciB0aGUgY29ybmVyIG9mIHRoZSBiYXJjb2RlLCBmb3IgZXhhbXBsZS48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIFJlc3VsdFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0WCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0WSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFJlc3VsdFBvaW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJQb2ludCA9IG90aGVyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnggPT09IG90aGVyUG9pbnQueCAmJiB0aGlzLnkgPT09IG90aGVyUG9pbnQueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGhhc2hDb2RlKCkge1xuICAgICAgICAgICAgcmV0dXJuIDMxICogRmxvYXQuZmxvYXRUb0ludEJpdHModGhpcy54KSArIEZsb2F0LmZsb2F0VG9JbnRCaXRzKHRoaXMueSk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnKCcgKyB0aGlzLnggKyAnLCcgKyB0aGlzLnkgKyAnKSc7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9yZGVycyBhbiBhcnJheSBvZiB0aHJlZSBSZXN1bHRQb2ludHMgaW4gYW4gb3JkZXIgW0EsQixDXSBzdWNoIHRoYXQgQUIgaXMgbGVzcyB0aGFuIEFDXG4gICAgICAgICAqIGFuZCBCQyBpcyBsZXNzIHRoYW4gQUMsIGFuZCB0aGUgYW5nbGUgYmV0d2VlbiBCQyBhbmQgQkEgaXMgbGVzcyB0aGFuIDE4MCBkZWdyZWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGF0dGVybnMgYXJyYXkgb2YgdGhyZWUge0Bjb2RlIFJlc3VsdFBvaW50fSB0byBvcmRlclxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG9yZGVyQmVzdFBhdHRlcm5zKHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAvLyBGaW5kIGRpc3RhbmNlcyBiZXR3ZWVuIHBhdHRlcm4gY2VudGVyc1xuICAgICAgICAgICAgY29uc3QgemVyb09uZURpc3RhbmNlID0gdGhpcy5kaXN0YW5jZShwYXR0ZXJuc1swXSwgcGF0dGVybnNbMV0pO1xuICAgICAgICAgICAgY29uc3Qgb25lVHdvRGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlKHBhdHRlcm5zWzFdLCBwYXR0ZXJuc1syXSk7XG4gICAgICAgICAgICBjb25zdCB6ZXJvVHdvRGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlKHBhdHRlcm5zWzBdLCBwYXR0ZXJuc1syXSk7XG4gICAgICAgICAgICBsZXQgcG9pbnRBO1xuICAgICAgICAgICAgbGV0IHBvaW50QjtcbiAgICAgICAgICAgIGxldCBwb2ludEM7XG4gICAgICAgICAgICAvLyBBc3N1bWUgb25lIGNsb3Nlc3QgdG8gb3RoZXIgdHdvIGlzIEI7IEEgYW5kIEMgd2lsbCBqdXN0IGJlIGd1ZXNzZXMgYXQgZmlyc3RcbiAgICAgICAgICAgIGlmIChvbmVUd29EaXN0YW5jZSA+PSB6ZXJvT25lRGlzdGFuY2UgJiYgb25lVHdvRGlzdGFuY2UgPj0gemVyb1R3b0Rpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRCID0gcGF0dGVybnNbMF07XG4gICAgICAgICAgICAgICAgcG9pbnRBID0gcGF0dGVybnNbMV07XG4gICAgICAgICAgICAgICAgcG9pbnRDID0gcGF0dGVybnNbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh6ZXJvVHdvRGlzdGFuY2UgPj0gb25lVHdvRGlzdGFuY2UgJiYgemVyb1R3b0Rpc3RhbmNlID49IHplcm9PbmVEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHBvaW50QiA9IHBhdHRlcm5zWzFdO1xuICAgICAgICAgICAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzBdO1xuICAgICAgICAgICAgICAgIHBvaW50QyA9IHBhdHRlcm5zWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnRCID0gcGF0dGVybnNbMl07XG4gICAgICAgICAgICAgICAgcG9pbnRBID0gcGF0dGVybnNbMF07XG4gICAgICAgICAgICAgICAgcG9pbnRDID0gcGF0dGVybnNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgY3Jvc3MgcHJvZHVjdCB0byBmaWd1cmUgb3V0IHdoZXRoZXIgQSBhbmQgQyBhcmUgY29ycmVjdCBvciBmbGlwcGVkLlxuICAgICAgICAgICAgLy8gVGhpcyBhc2tzIHdoZXRoZXIgQkMgeCBCQSBoYXMgYSBwb3NpdGl2ZSB6IGNvbXBvbmVudCwgd2hpY2ggaXMgdGhlIGFycmFuZ2VtZW50XG4gICAgICAgICAgICAvLyB3ZSB3YW50IGZvciBBLCBCLCBDLiBJZiBpdCdzIG5lZ2F0aXZlLCB0aGVuIHdlJ3ZlIGdvdCBpdCBmbGlwcGVkIGFyb3VuZCBhbmRcbiAgICAgICAgICAgIC8vIHNob3VsZCBzd2FwIEEgYW5kIEMuXG4gICAgICAgICAgICBpZiAodGhpcy5jcm9zc1Byb2R1Y3RaKHBvaW50QSwgcG9pbnRCLCBwb2ludEMpIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcCA9IHBvaW50QTtcbiAgICAgICAgICAgICAgICBwb2ludEEgPSBwb2ludEM7XG4gICAgICAgICAgICAgICAgcG9pbnRDID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdHRlcm5zWzBdID0gcG9pbnRBO1xuICAgICAgICAgICAgcGF0dGVybnNbMV0gPSBwb2ludEI7XG4gICAgICAgICAgICBwYXR0ZXJuc1syXSA9IHBvaW50QztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHBhdHRlcm4xIGZpcnN0IHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIHBhdHRlcm4yIHNlY29uZCBwYXR0ZXJuXG4gICAgICAgICAqIEByZXR1cm4gZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGlzdGFuY2UocGF0dGVybjEsIHBhdHRlcm4yKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLmRpc3RhbmNlKHBhdHRlcm4xLngsIHBhdHRlcm4xLnksIHBhdHRlcm4yLngsIHBhdHRlcm4yLnkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB6IGNvbXBvbmVudCBvZiB0aGUgY3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIHZlY3RvcnMgQkMgYW5kIEJBLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNyb3NzUHJvZHVjdFoocG9pbnRBLCBwb2ludEIsIHBvaW50Qykge1xuICAgICAgICAgICAgY29uc3QgYlggPSBwb2ludEIueDtcbiAgICAgICAgICAgIGNvbnN0IGJZID0gcG9pbnRCLnk7XG4gICAgICAgICAgICByZXR1cm4gKChwb2ludEMueCAtIGJYKSAqIChwb2ludEEueSAtIGJZKSkgLSAoKHBvaW50Qy55IC0gYlkpICogKHBvaW50QS54IC0gYlgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIHRoZSByZXN1bHQgb2YgZGV0ZWN0aW5nIGEgYmFyY29kZSBpbiBhbiBpbWFnZS4gVGhpcyBpbmNsdWRlcyB0aGUgcmF3XG4gICAgICogbWF0cml4IG9mIGJsYWNrL3doaXRlIHBpeGVscyBjb3JyZXNwb25kaW5nIHRvIHRoZSBiYXJjb2RlLCBhbmQgcG9zc2libHkgcG9pbnRzIG9mIGludGVyZXN0XG4gICAgICogaW4gdGhlIGltYWdlLCBsaWtlIHRoZSBsb2NhdGlvbiBvZiBmaW5kZXIgcGF0dGVybnMgb3IgY29ybmVycyBvZiB0aGUgYmFyY29kZSBpbiB0aGUgaW1hZ2UuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBEZXRlY3RvclJlc3VsdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJpdHMsIHBvaW50cykge1xuICAgICAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICB9XG4gICAgICAgIGdldEJpdHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaXRzO1xuICAgICAgICB9XG4gICAgICAgIGdldFBvaW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvaW50cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTAgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RXh0ZW5kcyB7QGxpbmsgRGV0ZWN0b3JSZXN1bHR9IHdpdGggbW9yZSBpbmZvcm1hdGlvbiBzcGVjaWZpYyB0byB0aGUgQXp0ZWMgZm9ybWF0LFxuICAgICAqIGxpa2UgdGhlIG51bWJlciBvZiBsYXllcnMgYW5kIHdoZXRoZXIgaXQncyBjb21wYWN0LjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgQXp0ZWNEZXRlY3RvclJlc3VsdCBleHRlbmRzIERldGVjdG9yUmVzdWx0IHtcbiAgICAgICAgY29uc3RydWN0b3IoYml0cywgcG9pbnRzLCBjb21wYWN0LCBuYkRhdGFibG9ja3MsIG5iTGF5ZXJzKSB7XG4gICAgICAgICAgICBzdXBlcihiaXRzLCBwb2ludHMpO1xuICAgICAgICAgICAgdGhpcy5jb21wYWN0ID0gY29tcGFjdDtcbiAgICAgICAgICAgIHRoaXMubmJEYXRhYmxvY2tzID0gbmJEYXRhYmxvY2tzO1xuICAgICAgICAgICAgdGhpcy5uYkxheWVycyA9IG5iTGF5ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGdldE5iTGF5ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmJMYXllcnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TmJEYXRhYmxvY2tzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmJEYXRhYmxvY2tzO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tcGFjdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhY3Q7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEwIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPlxuICAgICAqIERldGVjdHMgYSBjYW5kaWRhdGUgYmFyY29kZS1saWtlIHJlY3Rhbmd1bGFyIHJlZ2lvbiB3aXRoaW4gYW4gaW1hZ2UuIEl0XG4gICAgICogc3RhcnRzIGFyb3VuZCB0aGUgY2VudGVyIG9mIHRoZSBpbWFnZSwgaW5jcmVhc2VzIHRoZSBzaXplIG9mIHRoZSBjYW5kaWRhdGVcbiAgICAgKiByZWdpb24gdW50aWwgaXQgZmluZHMgYSB3aGl0ZSByZWN0YW5ndWxhciByZWdpb24uIEJ5IGtlZXBpbmcgdHJhY2sgb2YgdGhlXG4gICAgICogbGFzdCBibGFjayBwb2ludHMgaXQgZW5jb3VudGVyZWQsIGl0IGRldGVybWluZXMgdGhlIGNvcm5lcnMgb2YgdGhlIGJhcmNvZGUuXG4gICAgICogPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBEYXZpZCBPbGl2aWVyXG4gICAgICovXG4gICAgY2xhc3MgV2hpdGVSZWN0YW5nbGVEZXRlY3RvciB7XG4gICAgICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIGltYWdlOiBCaXRNYXRyaXgpIC8qdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uKi8ge1xuICAgICAgICAvLyAgIHRoaXMoaW1hZ2UsIElOSVRfU0laRSwgaW1hZ2UuZ2V0V2lkdGgoKSAvIDIsIGltYWdlLmdldEhlaWdodCgpIC8gMilcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGltYWdlIGJhcmNvZGUgaW1hZ2UgdG8gZmluZCBhIHJlY3RhbmdsZSBpblxuICAgICAgICAgKiBAcGFyYW0gaW5pdFNpemUgaW5pdGlhbCBzaXplIG9mIHNlYXJjaCBhcmVhIGFyb3VuZCBjZW50ZXJcbiAgICAgICAgICogQHBhcmFtIHggeCBwb3NpdGlvbiBvZiBzZWFyY2ggY2VudGVyXG4gICAgICAgICAqIEBwYXJhbSB5IHkgcG9zaXRpb24gb2Ygc2VhcmNoIGNlbnRlclxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGltYWdlIGlzIHRvbyBzbWFsbCB0byBhY2NvbW1vZGF0ZSB7QGNvZGUgaW5pdFNpemV9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihpbWFnZSwgaW5pdFNpemUgLyppbnQqLywgeCAvKmludCovLCB5IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGluaXRTaXplIHx8IG51bGwgPT09IGluaXRTaXplKSB7XG4gICAgICAgICAgICAgICAgaW5pdFNpemUgPSBXaGl0ZVJlY3RhbmdsZURldGVjdG9yLklOSVRfU0laRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHggfHwgbnVsbCA9PT0geCkge1xuICAgICAgICAgICAgICAgIHggPSBpbWFnZS5nZXRXaWR0aCgpIC8gMiB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSB5IHx8IG51bGwgPT09IHkpIHtcbiAgICAgICAgICAgICAgICB5ID0gaW1hZ2UuZ2V0SGVpZ2h0KCkgLyAyIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhbGZzaXplID0gaW5pdFNpemUgLyAyIHwgMDtcbiAgICAgICAgICAgIHRoaXMubGVmdEluaXQgPSB4IC0gaGFsZnNpemU7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0SW5pdCA9IHggKyBoYWxmc2l6ZTtcbiAgICAgICAgICAgIHRoaXMudXBJbml0ID0geSAtIGhhbGZzaXplO1xuICAgICAgICAgICAgdGhpcy5kb3duSW5pdCA9IHkgKyBoYWxmc2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnVwSW5pdCA8IDAgfHwgdGhpcy5sZWZ0SW5pdCA8IDAgfHwgdGhpcy5kb3duSW5pdCA+PSB0aGlzLmhlaWdodCB8fCB0aGlzLnJpZ2h0SW5pdCA+PSB0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBEZXRlY3RzIGEgY2FuZGlkYXRlIGJhcmNvZGUtbGlrZSByZWN0YW5ndWxhciByZWdpb24gd2l0aGluIGFuIGltYWdlLiBJdFxuICAgICAgICAgKiBzdGFydHMgYXJvdW5kIHRoZSBjZW50ZXIgb2YgdGhlIGltYWdlLCBpbmNyZWFzZXMgdGhlIHNpemUgb2YgdGhlIGNhbmRpZGF0ZVxuICAgICAgICAgKiByZWdpb24gdW50aWwgaXQgZmluZHMgYSB3aGl0ZSByZWN0YW5ndWxhciByZWdpb24uXG4gICAgICAgICAqIDwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgUmVzdWx0UG9pbnR9W10gZGVzY3JpYmluZyB0aGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ3VsYXJcbiAgICAgICAgICogICAgICAgICByZWdpb24uIFRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgYXJlIG9wcG9zZWQgb24gdGhlIGRpYWdvbmFsLCBhc1xuICAgICAgICAgKiAgICAgICAgIGFyZSB0aGUgc2Vjb25kIGFuZCB0aGlyZC4gVGhlIGZpcnN0IHBvaW50IHdpbGwgYmUgdGhlIHRvcG1vc3RcbiAgICAgICAgICogICAgICAgICBwb2ludCBhbmQgdGhlIGxhc3QsIHRoZSBib3R0b21tb3N0LiBUaGUgc2Vjb25kIHBvaW50IHdpbGwgYmVcbiAgICAgICAgICogICAgICAgICBsZWZ0bW9zdCBhbmQgdGhlIHRoaXJkLCB0aGUgcmlnaHRtb3N0XG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgbm8gRGF0YSBNYXRyaXggQ29kZSBjYW4gYmUgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGRldGVjdCgpIHtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0SW5pdDtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHRoaXMucmlnaHRJbml0O1xuICAgICAgICAgICAgbGV0IHVwID0gdGhpcy51cEluaXQ7XG4gICAgICAgICAgICBsZXQgZG93biA9IHRoaXMuZG93bkluaXQ7XG4gICAgICAgICAgICBsZXQgc2l6ZUV4Y2VlZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgYUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25SaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkJvdHRvbSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkxlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Ub3AgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgd2hpbGUgKGFCbGFja1BvaW50Rm91bmRPbkJvcmRlcikge1xuICAgICAgICAgICAgICAgIGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIC4uLi4uXG4gICAgICAgICAgICAgICAgLy8gLiAgIHxcbiAgICAgICAgICAgICAgICAvLyAuLi4uLlxuICAgICAgICAgICAgICAgIGxldCByaWdodEJvcmRlck5vdFdoaXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHJpZ2h0Qm9yZGVyTm90V2hpdGUgfHwgIWF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPblJpZ2h0KSAmJiByaWdodCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Qm9yZGVyTm90V2hpdGUgPSB0aGlzLmNvbnRhaW5zQmxhY2tQb2ludCh1cCwgZG93biwgcmlnaHQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0Qm9yZGVyTm90V2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uUmlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25SaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmlnaHQgPj0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZUV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIC4uLi4uXG4gICAgICAgICAgICAgICAgLy8gLiAgIC5cbiAgICAgICAgICAgICAgICAvLyAuX19fLlxuICAgICAgICAgICAgICAgIGxldCBib3R0b21Cb3JkZXJOb3RXaGl0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChib3R0b21Cb3JkZXJOb3RXaGl0ZSB8fCAhYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm90dG9tKSAmJiBkb3duIDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbUJvcmRlck5vdFdoaXRlID0gdGhpcy5jb250YWluc0JsYWNrUG9pbnQobGVmdCwgcmlnaHQsIGRvd24sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm90dG9tQm9yZGVyTm90V2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd24rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3R0b20gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZG93biA+PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZUV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIC4uLi4uXG4gICAgICAgICAgICAgICAgLy8gfCAgIC5cbiAgICAgICAgICAgICAgICAvLyAuLi4uLlxuICAgICAgICAgICAgICAgIGxldCBsZWZ0Qm9yZGVyTm90V2hpdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdoaWxlICgobGVmdEJvcmRlck5vdFdoaXRlIHx8ICFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25MZWZ0KSAmJiBsZWZ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdEJvcmRlck5vdFdoaXRlID0gdGhpcy5jb250YWluc0JsYWNrUG9pbnQodXAsIGRvd24sIGxlZnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRCb3JkZXJOb3RXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgYUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkxlZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25MZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVFeGNlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAuX19fLlxuICAgICAgICAgICAgICAgIC8vIC4gICAuXG4gICAgICAgICAgICAgICAgLy8gLi4uLi5cbiAgICAgICAgICAgICAgICBsZXQgdG9wQm9yZGVyTm90V2hpdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdoaWxlICgodG9wQm9yZGVyTm90V2hpdGUgfHwgIWF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPblRvcCkgJiYgdXAgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0b3BCb3JkZXJOb3RXaGl0ZSA9IHRoaXMuY29udGFpbnNCbGFja1BvaW50KGxlZnQsIHJpZ2h0LCB1cCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3BCb3JkZXJOb3RXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXAtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Ub3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Ub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVwIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzaXplRXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFCbGFja1BvaW50Rm91bmRPbkJvcmRlcikge1xuICAgICAgICAgICAgICAgICAgICBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2l6ZUV4Y2VlZGVkICYmIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkJvcmRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFNpemUgPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICAgICAgbGV0IHogPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyB6ID09PSBudWxsICYmIGkgPCBtYXhTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeiA9IHRoaXMuZ2V0QmxhY2tQb2ludE9uU2VnbWVudChsZWZ0LCBkb3duIC0gaSwgbGVmdCArIGksIGRvd24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gZ28gZG93biByaWdodFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyB0ID09PSBudWxsICYmIGkgPCBtYXhTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHRoaXMuZ2V0QmxhY2tQb2ludE9uU2VnbWVudChsZWZ0LCB1cCArIGksIGxlZnQgKyBpLCB1cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBnbyBkb3duIGxlZnRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgeCA9PT0gbnVsbCAmJiBpIDwgbWF4U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSB0aGlzLmdldEJsYWNrUG9pbnRPblNlZ21lbnQocmlnaHQsIHVwICsgaSwgcmlnaHQgLSBpLCB1cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBnbyB1cCBsZWZ0XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IHkgPT09IG51bGwgJiYgaSA8IG1heFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRCbGFja1BvaW50T25TZWdtZW50KHJpZ2h0LCBkb3duIC0gaSwgcmlnaHQgLSBpLCBkb3duKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyRWRnZXMoeSwgeiwgeCwgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXRCbGFja1BvaW50T25TZWdtZW50KGFYIC8qZmxvYXQqLywgYVkgLypmbG9hdCovLCBiWCAvKmZsb2F0Ki8sIGJZIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgY29uc3QgZGlzdCA9IE1hdGhVdGlscy5yb3VuZChNYXRoVXRpbHMuZGlzdGFuY2UoYVgsIGFZLCBiWCwgYlkpKTtcbiAgICAgICAgICAgIGNvbnN0IHhTdGVwID0gKGJYIC0gYVgpIC8gZGlzdDtcbiAgICAgICAgICAgIGNvbnN0IHlTdGVwID0gKGJZIC0gYVkpIC8gZGlzdDtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlzdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGhVdGlscy5yb3VuZChhWCArIGkgKiB4U3RlcCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGhVdGlscy5yb3VuZChhWSArIGkgKiB5U3RlcCk7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldCh4LCB5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdFBvaW50KHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZWNlbnRlcnMgdGhlIHBvaW50cyBvZiBhIGNvbnN0YW50IGRpc3RhbmNlIHRvd2FyZHMgdGhlIGNlbnRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geSBib3R0b20gbW9zdCBwb2ludFxuICAgICAgICAgKiBAcGFyYW0geiBsZWZ0IG1vc3QgcG9pbnRcbiAgICAgICAgICogQHBhcmFtIHggcmlnaHQgbW9zdCBwb2ludFxuICAgICAgICAgKiBAcGFyYW0gdCB0b3AgbW9zdCBwb2ludFxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBSZXN1bHRQb2ludH1bXSBkZXNjcmliaW5nIHRoZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5ndWxhclxuICAgICAgICAgKiAgICAgICAgIHJlZ2lvbi4gVGhlIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgb3Bwb3NlZCBvbiB0aGUgZGlhZ29uYWwsIGFzXG4gICAgICAgICAqICAgICAgICAgYXJlIHRoZSBzZWNvbmQgYW5kIHRoaXJkLiBUaGUgZmlyc3QgcG9pbnQgd2lsbCBiZSB0aGUgdG9wbW9zdFxuICAgICAgICAgKiAgICAgICAgIHBvaW50IGFuZCB0aGUgbGFzdCwgdGhlIGJvdHRvbW1vc3QuIFRoZSBzZWNvbmQgcG9pbnQgd2lsbCBiZVxuICAgICAgICAgKiAgICAgICAgIGxlZnRtb3N0IGFuZCB0aGUgdGhpcmQsIHRoZSByaWdodG1vc3RcbiAgICAgICAgICovXG4gICAgICAgIGNlbnRlckVkZ2VzKHksIHosIHgsIHQpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgICB0ICAgICAgICAgICAgdFxuICAgICAgICAgICAgLy8gIHogICAgICAgICAgICAgICAgICAgICAgeFxuICAgICAgICAgICAgLy8gICAgICAgIHggICAgT1IgICAgelxuICAgICAgICAgICAgLy8gICB5ICAgICAgICAgICAgICAgICAgICB5XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgY29uc3QgeWkgPSB5LmdldFgoKTtcbiAgICAgICAgICAgIGNvbnN0IHlqID0geS5nZXRZKCk7XG4gICAgICAgICAgICBjb25zdCB6aSA9IHouZ2V0WCgpO1xuICAgICAgICAgICAgY29uc3QgemogPSB6LmdldFkoKTtcbiAgICAgICAgICAgIGNvbnN0IHhpID0geC5nZXRYKCk7XG4gICAgICAgICAgICBjb25zdCB4aiA9IHguZ2V0WSgpO1xuICAgICAgICAgICAgY29uc3QgdGkgPSB0LmdldFgoKTtcbiAgICAgICAgICAgIGNvbnN0IHRqID0gdC5nZXRZKCk7XG4gICAgICAgICAgICBjb25zdCBDT1JSID0gV2hpdGVSZWN0YW5nbGVEZXRlY3Rvci5DT1JSO1xuICAgICAgICAgICAgaWYgKHlpIDwgdGhpcy53aWR0aCAvIDIuMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh0aSAtIENPUlIsIHRqICsgQ09SUiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh6aSArIENPUlIsIHpqICsgQ09SUiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh4aSAtIENPUlIsIHhqIC0gQ09SUiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh5aSArIENPUlIsIHlqIC0gQ09SUilcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50KHRpICsgQ09SUiwgdGogKyBDT1JSKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50KHppICsgQ09SUiwgemogLSBDT1JSKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50KHhpIC0gQ09SUiwgeGogKyBDT1JSKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50KHlpIC0gQ09SUiwgeWogLSBDT1JSKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBhIHNlZ21lbnQgY29udGFpbnMgYSBibGFjayBwb2ludFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYSAgICAgICAgICBtaW4gdmFsdWUgb2YgdGhlIHNjYW5uZWQgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gYiAgICAgICAgICBtYXggdmFsdWUgb2YgdGhlIHNjYW5uZWQgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gZml4ZWQgICAgICB2YWx1ZSBvZiBmaXhlZCBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSBob3Jpem9udGFsIHNldCB0byB0cnVlIGlmIHNjYW4gbXVzdCBiZSBob3Jpem9udGFsLCBmYWxzZSBpZiB2ZXJ0aWNhbFxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgYSBibGFjayBwb2ludCBoYXMgYmVlbiBmb3VuZCwgZWxzZSBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5zQmxhY2tQb2ludChhIC8qaW50Ki8sIGIgLyppbnQqLywgZml4ZWQgLyppbnQqLywgaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gYTsgeCA8PSBiOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldCh4LCBmaXhlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IGE7IHkgPD0gYjsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoZml4ZWQsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBXaGl0ZVJlY3RhbmdsZURldGVjdG9yLklOSVRfU0laRSA9IDEwO1xuICAgIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IuQ09SUiA9IDE7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGNsYXNzIGNhbiwgZ2l2ZW4gbG9jYXRpb25zIG9mIGZpbmRlciBwYXR0ZXJucyBmb3IgYSBRUiBjb2RlIGluIGFuXG4gICAgICogaW1hZ2UsIHNhbXBsZSB0aGUgcmlnaHQgcG9pbnRzIGluIHRoZSBpbWFnZSB0byByZWNvbnN0cnVjdCB0aGUgUVIgY29kZSwgYWNjb3VudGluZyBmb3JcbiAgICAgKiBwZXJzcGVjdGl2ZSBkaXN0b3J0aW9uLiBJdCBpcyBhYnN0cmFjdGVkIHNpbmNlIGl0IGlzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGFuZCBzaG91bGQgYmUgYWxsb3dlZFxuICAgICAqIHRvIHRha2UgYWR2YW50YWdlIG9mIHBsYXRmb3JtLXNwZWNpZmljIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbnMsIGxpa2UgU3VuJ3MgSmF2YSBBZHZhbmNlZFxuICAgICAqIEltYWdpbmcgbGlicmFyeSwgYnV0IHdoaWNoIG1heSBub3QgYmUgYXZhaWxhYmxlIGluIG90aGVyIGVudmlyb25tZW50cyBzdWNoIGFzIEoyTUUsIGFuZCB2aWNlXG4gICAgICogdmVyc2EuXG4gICAgICpcbiAgICAgKiBUaGUgaW1wbGVtZW50YXRpb24gdXNlZCBjYW4gYmUgY29udHJvbGxlZCBieSBjYWxsaW5nIHtAbGluayAjc2V0R3JpZFNhbXBsZXIoR3JpZFNhbXBsZXIpfVxuICAgICAqIHdpdGggYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIHRoaXMgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBHcmlkU2FtcGxlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5DaGVja3MgYSBzZXQgb2YgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIHRyYW5zZm9ybWVkIHRvIHNhbXBsZSBwb2ludHMgb24gYW4gaW1hZ2UgYWdhaW5zdFxuICAgICAgICAgKiB0aGUgaW1hZ2UncyBkaW1lbnNpb25zIHRvIHNlZSBpZiB0aGUgcG9pbnQgYXJlIGV2ZW4gd2l0aGluIHRoZSBpbWFnZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlRoaXMgbWV0aG9kIHdpbGwgYWN0dWFsbHkgXCJudWRnZVwiIHRoZSBlbmRwb2ludHMgYmFjayBvbnRvIHRoZSBpbWFnZSBpZiB0aGV5IGFyZSBmb3VuZCB0byBiZVxuICAgICAgICAgKiBiYXJlbHkgKGxlc3MgdGhhbiAxIHBpeGVsKSBvZmYgdGhlIGltYWdlLiBUaGlzIGFjY291bnRzIGZvciBpbXBlcmZlY3QgZGV0ZWN0aW9uIG9mIGZpbmRlclxuICAgICAgICAgKiBwYXR0ZXJucyBpbiBhbiBpbWFnZSB3aGVyZSB0aGUgUVIgQ29kZSBydW5zIGFsbCB0aGUgd2F5IHRvIHRoZSBpbWFnZSBib3JkZXIuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5Gb3IgZWZmaWNpZW5jeSwgdGhlIG1ldGhvZCB3aWxsIGNoZWNrIHBvaW50cyBmcm9tIGVpdGhlciBlbmQgb2YgdGhlIGxpbmUgdW50aWwgb25lIGlzIGZvdW5kXG4gICAgICAgICAqIHRvIGJlIHdpdGhpbiB0aGUgaW1hZ2UuIEJlY2F1c2UgdGhlIHNldCBvZiBwb2ludHMgYXJlIGFzc3VtZWQgdG8gYmUgbGluZWFyLCB0aGlzIGlzIHZhbGlkLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlIGltYWdlIGludG8gd2hpY2ggdGhlIHBvaW50cyBzaG91bGQgbWFwXG4gICAgICAgICAqIEBwYXJhbSBwb2ludHMgYWN0dWFsIHBvaW50cyBpbiB4MSx5MSwuLi4seG4seW4gZm9ybVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGFuIGVuZHBvaW50IGlzIGxpZXMgb3V0c2lkZSB0aGUgaW1hZ2UgYm91bmRhcmllc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNoZWNrQW5kTnVkZ2VQb2ludHMoaW1hZ2UsIHBvaW50cykge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICAvLyBDaGVjayBhbmQgbnVkZ2UgcG9pbnRzIGZyb20gc3RhcnQgdW50aWwgd2Ugc2VlIHNvbWUgdGhhdCBhcmUgT0s6XG4gICAgICAgICAgICBsZXQgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IHBvaW50cy5sZW5ndGggJiYgbnVkZ2VkOyBvZmZzZXQgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKHBvaW50c1tvZmZzZXRdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihwb2ludHNbb2Zmc2V0ICsgMV0pO1xuICAgICAgICAgICAgICAgIGlmICh4IDwgLTEgfHwgeCA+IHdpZHRoIHx8IHkgPCAtMSB8fCB5ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudWRnZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldF0gPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHggPT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXRdID0gd2lkdGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gaGVpZ2h0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBhbmQgbnVkZ2UgcG9pbnRzIGZyb20gZW5kOlxuICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IHBvaW50cy5sZW5ndGggLSAyOyBvZmZzZXQgPj0gMCAmJiBudWRnZWQ7IG9mZnNldCAtPSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGguZmxvb3IocG9pbnRzW29mZnNldF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKHBvaW50c1tvZmZzZXQgKyAxXSk7XG4gICAgICAgICAgICAgICAgaWYgKHggPCAtMSB8fCB4ID4gd2lkdGggfHwgeSA8IC0xIHx8IHkgPiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG51ZGdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0XSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeCA9PT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldF0gPSB3aWR0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0ICsgMV0gPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHkgPT09IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0ICsgMV0gPSBoZWlnaHQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXG4gICAgLyoqXG4gICAgICogPHA+VGhpcyBjbGFzcyBpbXBsZW1lbnRzIGEgcGVyc3BlY3RpdmUgdHJhbnNmb3JtIGluIHR3byBkaW1lbnNpb25zLiBHaXZlbiBmb3VyIHNvdXJjZSBhbmQgZm91clxuICAgICAqIGRlc3RpbmF0aW9uIHBvaW50cywgaXQgd2lsbCBjb21wdXRlIHRoZSB0cmFuc2Zvcm1hdGlvbiBpbXBsaWVkIGJldHdlZW4gdGhlbS4gVGhlIGNvZGUgaXMgYmFzZWRcbiAgICAgKiBkaXJlY3RseSB1cG9uIHNlY3Rpb24gMy40LjIgb2YgR2VvcmdlIFdvbGJlcmcncyBcIkRpZ2l0YWwgSW1hZ2UgV2FycGluZ1wiOyBzZWUgcGFnZXMgNTQtNTYuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBQZXJzcGVjdGl2ZVRyYW5zZm9ybSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGExMSAvKmZsb2F0Ki8sIGEyMSAvKmZsb2F0Ki8sIGEzMSAvKmZsb2F0Ki8sIGExMiAvKmZsb2F0Ki8sIGEyMiAvKmZsb2F0Ki8sIGEzMiAvKmZsb2F0Ki8sIGExMyAvKmZsb2F0Ki8sIGEyMyAvKmZsb2F0Ki8sIGEzMyAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuYTExID0gYTExO1xuICAgICAgICAgICAgdGhpcy5hMjEgPSBhMjE7XG4gICAgICAgICAgICB0aGlzLmEzMSA9IGEzMTtcbiAgICAgICAgICAgIHRoaXMuYTEyID0gYTEyO1xuICAgICAgICAgICAgdGhpcy5hMjIgPSBhMjI7XG4gICAgICAgICAgICB0aGlzLmEzMiA9IGEzMjtcbiAgICAgICAgICAgIHRoaXMuYTEzID0gYTEzO1xuICAgICAgICAgICAgdGhpcy5hMjMgPSBhMjM7XG4gICAgICAgICAgICB0aGlzLmEzMyA9IGEzMztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcXVhZHJpbGF0ZXJhbFRvUXVhZHJpbGF0ZXJhbCh4MCAvKmZsb2F0Ki8sIHkwIC8qZmxvYXQqLywgeDEgLypmbG9hdCovLCB5MSAvKmZsb2F0Ki8sIHgyIC8qZmxvYXQqLywgeTIgLypmbG9hdCovLCB4MyAvKmZsb2F0Ki8sIHkzIC8qZmxvYXQqLywgeDBwIC8qZmxvYXQqLywgeTBwIC8qZmxvYXQqLywgeDFwIC8qZmxvYXQqLywgeTFwIC8qZmxvYXQqLywgeDJwIC8qZmxvYXQqLywgeTJwIC8qZmxvYXQqLywgeDNwIC8qZmxvYXQqLywgeTNwIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgY29uc3QgcVRvUyA9IFBlcnNwZWN0aXZlVHJhbnNmb3JtLnF1YWRyaWxhdGVyYWxUb1NxdWFyZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICAgICAgY29uc3Qgc1RvUSA9IFBlcnNwZWN0aXZlVHJhbnNmb3JtLnNxdWFyZVRvUXVhZHJpbGF0ZXJhbCh4MHAsIHkwcCwgeDFwLCB5MXAsIHgycCwgeTJwLCB4M3AsIHkzcCk7XG4gICAgICAgICAgICByZXR1cm4gc1RvUS50aW1lcyhxVG9TKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBtYXggPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYTExID0gdGhpcy5hMTE7XG4gICAgICAgICAgICBjb25zdCBhMTIgPSB0aGlzLmExMjtcbiAgICAgICAgICAgIGNvbnN0IGExMyA9IHRoaXMuYTEzO1xuICAgICAgICAgICAgY29uc3QgYTIxID0gdGhpcy5hMjE7XG4gICAgICAgICAgICBjb25zdCBhMjIgPSB0aGlzLmEyMjtcbiAgICAgICAgICAgIGNvbnN0IGEyMyA9IHRoaXMuYTIzO1xuICAgICAgICAgICAgY29uc3QgYTMxID0gdGhpcy5hMzE7XG4gICAgICAgICAgICBjb25zdCBhMzIgPSB0aGlzLmEzMjtcbiAgICAgICAgICAgIGNvbnN0IGEzMyA9IHRoaXMuYTMzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBwb2ludHNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVub21pbmF0b3IgPSBhMTMgKiB4ICsgYTIzICogeSArIGEzMztcbiAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSAoYTExICogeCArIGEyMSAqIHkgKyBhMzEpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IChhMTIgKiB4ICsgYTIyICogeSArIGEzMikgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFuc2Zvcm1Qb2ludHNXaXRoVmFsdWVzKHhWYWx1ZXMsIHlWYWx1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGExMSA9IHRoaXMuYTExO1xuICAgICAgICAgICAgY29uc3QgYTEyID0gdGhpcy5hMTI7XG4gICAgICAgICAgICBjb25zdCBhMTMgPSB0aGlzLmExMztcbiAgICAgICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuYTIxO1xuICAgICAgICAgICAgY29uc3QgYTIyID0gdGhpcy5hMjI7XG4gICAgICAgICAgICBjb25zdCBhMjMgPSB0aGlzLmEyMztcbiAgICAgICAgICAgIGNvbnN0IGEzMSA9IHRoaXMuYTMxO1xuICAgICAgICAgICAgY29uc3QgYTMyID0gdGhpcy5hMzI7XG4gICAgICAgICAgICBjb25zdCBhMzMgPSB0aGlzLmEzMztcbiAgICAgICAgICAgIGNvbnN0IG4gPSB4VmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHhWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHlWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVub21pbmF0b3IgPSBhMTMgKiB4ICsgYTIzICogeSArIGEzMztcbiAgICAgICAgICAgICAgICB4VmFsdWVzW2ldID0gKGExMSAqIHggKyBhMjEgKiB5ICsgYTMxKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgICAgIHlWYWx1ZXNbaV0gPSAoYTEyICogeCArIGEyMiAqIHkgKyBhMzIpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHNxdWFyZVRvUXVhZHJpbGF0ZXJhbCh4MCAvKmZsb2F0Ki8sIHkwIC8qZmxvYXQqLywgeDEgLypmbG9hdCovLCB5MSAvKmZsb2F0Ki8sIHgyIC8qZmxvYXQqLywgeTIgLypmbG9hdCovLCB4MyAvKmZsb2F0Ki8sIHkzIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgY29uc3QgZHgzID0geDAgLSB4MSArIHgyIC0geDM7XG4gICAgICAgICAgICBjb25zdCBkeTMgPSB5MCAtIHkxICsgeTIgLSB5MztcbiAgICAgICAgICAgIGlmIChkeDMgPT09IDAuMCAmJiBkeTMgPT09IDAuMCkge1xuICAgICAgICAgICAgICAgIC8vIEFmZmluZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVUcmFuc2Zvcm0oeDEgLSB4MCwgeDIgLSB4MSwgeDAsIHkxIC0geTAsIHkyIC0geTEsIHkwLCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR4MSA9IHgxIC0geDI7XG4gICAgICAgICAgICAgICAgY29uc3QgZHgyID0geDMgLSB4MjtcbiAgICAgICAgICAgICAgICBjb25zdCBkeTEgPSB5MSAtIHkyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR5MiA9IHkzIC0geTI7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVub21pbmF0b3IgPSBkeDEgKiBkeTIgLSBkeDIgKiBkeTE7XG4gICAgICAgICAgICAgICAgY29uc3QgYTEzID0gKGR4MyAqIGR5MiAtIGR4MiAqIGR5MykgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBhMjMgPSAoZHgxICogZHkzIC0gZHgzICogZHkxKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVUcmFuc2Zvcm0oeDEgLSB4MCArIGExMyAqIHgxLCB4MyAtIHgwICsgYTIzICogeDMsIHgwLCB5MSAtIHkwICsgYTEzICogeTEsIHkzIC0geTAgKyBhMjMgKiB5MywgeTAsIGExMywgYTIzLCAxLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBxdWFkcmlsYXRlcmFsVG9TcXVhcmUoeDAgLypmbG9hdCovLCB5MCAvKmZsb2F0Ki8sIHgxIC8qZmxvYXQqLywgeTEgLypmbG9hdCovLCB4MiAvKmZsb2F0Ki8sIHkyIC8qZmxvYXQqLywgeDMgLypmbG9hdCovLCB5MyAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIC8vIEhlcmUsIHRoZSBhZGpvaW50IHNlcnZlcyBhcyB0aGUgaW52ZXJzZTpcbiAgICAgICAgICAgIHJldHVybiBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5zcXVhcmVUb1F1YWRyaWxhdGVyYWwoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKS5idWlsZEFkam9pbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZEFkam9pbnQoKSB7XG4gICAgICAgICAgICAvLyBBZGpvaW50IGlzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhlIGNvZmFjdG9yIG1hdHJpeDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVUcmFuc2Zvcm0odGhpcy5hMjIgKiB0aGlzLmEzMyAtIHRoaXMuYTIzICogdGhpcy5hMzIsIHRoaXMuYTIzICogdGhpcy5hMzEgLSB0aGlzLmEyMSAqIHRoaXMuYTMzLCB0aGlzLmEyMSAqIHRoaXMuYTMyIC0gdGhpcy5hMjIgKiB0aGlzLmEzMSwgdGhpcy5hMTMgKiB0aGlzLmEzMiAtIHRoaXMuYTEyICogdGhpcy5hMzMsIHRoaXMuYTExICogdGhpcy5hMzMgLSB0aGlzLmExMyAqIHRoaXMuYTMxLCB0aGlzLmExMiAqIHRoaXMuYTMxIC0gdGhpcy5hMTEgKiB0aGlzLmEzMiwgdGhpcy5hMTIgKiB0aGlzLmEyMyAtIHRoaXMuYTEzICogdGhpcy5hMjIsIHRoaXMuYTEzICogdGhpcy5hMjEgLSB0aGlzLmExMSAqIHRoaXMuYTIzLCB0aGlzLmExMSAqIHRoaXMuYTIyIC0gdGhpcy5hMTIgKiB0aGlzLmEyMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZXMob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVUcmFuc2Zvcm0odGhpcy5hMTEgKiBvdGhlci5hMTEgKyB0aGlzLmEyMSAqIG90aGVyLmExMiArIHRoaXMuYTMxICogb3RoZXIuYTEzLCB0aGlzLmExMSAqIG90aGVyLmEyMSArIHRoaXMuYTIxICogb3RoZXIuYTIyICsgdGhpcy5hMzEgKiBvdGhlci5hMjMsIHRoaXMuYTExICogb3RoZXIuYTMxICsgdGhpcy5hMjEgKiBvdGhlci5hMzIgKyB0aGlzLmEzMSAqIG90aGVyLmEzMywgdGhpcy5hMTIgKiBvdGhlci5hMTEgKyB0aGlzLmEyMiAqIG90aGVyLmExMiArIHRoaXMuYTMyICogb3RoZXIuYTEzLCB0aGlzLmExMiAqIG90aGVyLmEyMSArIHRoaXMuYTIyICogb3RoZXIuYTIyICsgdGhpcy5hMzIgKiBvdGhlci5hMjMsIHRoaXMuYTEyICogb3RoZXIuYTMxICsgdGhpcy5hMjIgKiBvdGhlci5hMzIgKyB0aGlzLmEzMiAqIG90aGVyLmEzMywgdGhpcy5hMTMgKiBvdGhlci5hMTEgKyB0aGlzLmEyMyAqIG90aGVyLmExMiArIHRoaXMuYTMzICogb3RoZXIuYTEzLCB0aGlzLmExMyAqIG90aGVyLmEyMSArIHRoaXMuYTIzICogb3RoZXIuYTIyICsgdGhpcy5hMzMgKiBvdGhlci5hMjMsIHRoaXMuYTEzICogb3RoZXIuYTMxICsgdGhpcy5hMjMgKiBvdGhlci5hMzIgKyB0aGlzLmEzMyAqIG90aGVyLmEzMyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGVmYXVsdEdyaWRTYW1wbGVyIGV4dGVuZHMgR3JpZFNhbXBsZXIge1xuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHNhbXBsZUdyaWQoaW1hZ2UsIGRpbWVuc2lvblggLyppbnQqLywgZGltZW5zaW9uWSAvKmludCovLCBwMVRvWCAvKmZsb2F0Ki8sIHAxVG9ZIC8qZmxvYXQqLywgcDJUb1ggLypmbG9hdCovLCBwMlRvWSAvKmZsb2F0Ki8sIHAzVG9YIC8qZmxvYXQqLywgcDNUb1kgLypmbG9hdCovLCBwNFRvWCAvKmZsb2F0Ki8sIHA0VG9ZIC8qZmxvYXQqLywgcDFGcm9tWCAvKmZsb2F0Ki8sIHAxRnJvbVkgLypmbG9hdCovLCBwMkZyb21YIC8qZmxvYXQqLywgcDJGcm9tWSAvKmZsb2F0Ki8sIHAzRnJvbVggLypmbG9hdCovLCBwM0Zyb21ZIC8qZmxvYXQqLywgcDRGcm9tWCAvKmZsb2F0Ki8sIHA0RnJvbVkgLypmbG9hdCovKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5xdWFkcmlsYXRlcmFsVG9RdWFkcmlsYXRlcmFsKHAxVG9YLCBwMVRvWSwgcDJUb1gsIHAyVG9ZLCBwM1RvWCwgcDNUb1ksIHA0VG9YLCBwNFRvWSwgcDFGcm9tWCwgcDFGcm9tWSwgcDJGcm9tWCwgcDJGcm9tWSwgcDNGcm9tWCwgcDNGcm9tWSwgcDRGcm9tWCwgcDRGcm9tWSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zYW1wbGVHcmlkV2l0aFRyYW5zZm9ybShpbWFnZSwgZGltZW5zaW9uWCwgZGltZW5zaW9uWSwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHNhbXBsZUdyaWRXaXRoVHJhbnNmb3JtKGltYWdlLCBkaW1lbnNpb25YIC8qaW50Ki8sIGRpbWVuc2lvblkgLyppbnQqLywgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uWCA8PSAwIHx8IGRpbWVuc2lvblkgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYml0cyA9IG5ldyBCaXRNYXRyaXgoZGltZW5zaW9uWCwgZGltZW5zaW9uWSk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiBkaW1lbnNpb25YKTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgZGltZW5zaW9uWTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4ID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBpVmFsdWUgPSB5ICsgMC41O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbWF4OyB4ICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW3hdID0gKHggLyAyKSArIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW3ggKyAxXSA9IGlWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLnRyYW5zZm9ybVBvaW50cyhwb2ludHMpO1xuICAgICAgICAgICAgICAgIC8vIFF1aWNrIGNoZWNrIHRvIHNlZSBpZiBwb2ludHMgdHJhbnNmb3JtZWQgdG8gc29tZXRoaW5nIGluc2lkZSB0aGUgaW1hZ2VcbiAgICAgICAgICAgICAgICAvLyBzdWZmaWNpZW50IHRvIGNoZWNrIHRoZSBlbmRwb2ludHNcbiAgICAgICAgICAgICAgICBHcmlkU2FtcGxlci5jaGVja0FuZE51ZGdlUG9pbnRzKGltYWdlLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbWF4OyB4ICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoTWF0aC5mbG9vcihwb2ludHNbeF0pLCBNYXRoLmZsb29yKHBvaW50c1t4ICsgMV0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrKC1pc2gpIHBpeGVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0cy5zZXQoeCAvIDIsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChhaW9vYmUgLyo6IEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZmVlbHMgd3JvbmcsIGJ1dCwgc29tZXRpbWVzIGlmIHRoZSBmaW5kZXIgcGF0dGVybnMgYXJlIG1pc2lkZW50aWZpZWQsIHRoZSByZXN1bHRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGdldHMgXCJ0d2lzdGVkXCIgc3VjaCB0aGF0IGl0IG1hcHMgYSBzdHJhaWdodCBsaW5lIG9mIHBvaW50cyB0byBhIHNldCBvZiBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hvc2UgZW5kcG9pbnRzIGFyZSBpbiBib3VuZHMsIGJ1dCBvdGhlcnMgYXJlIG5vdC4gVGhlcmUgaXMgcHJvYmFibHkgc29tZSBtYXRoZW1hdGljYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2F5IHRvIGRldGVjdCB0aGlzIGFib3V0IHRoZSB0cmFuc2Zvcm1hdGlvbiB0aGF0IEkgZG9uJ3Qga25vdyB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVzdWx0cyBpbiBhbiB1Z2x5IHJ1bnRpbWUgZXhjZXB0aW9uIGRlc3BpdGUgb3VyIGNsZXZlciBjaGVja3MgYWJvdmUgLS0gY2FuJ3QgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0LiBXZSBjb3VsZCBjaGVjayBlYWNoIHBvaW50J3MgY29vcmRpbmF0ZXMgYnV0IHRoYXQgZmVlbHMgZHVwbGljYXRpdmUuIFdlIHNldHRsZSBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gY2F0Y2hpbmcgYW5kIHdyYXBwaW5nIEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBHcmlkU2FtcGxlckluc3RhbmNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGltcGxlbWVudGF0aW9uIG9mIEdyaWRTYW1wbGVyIHVzZWQgYnkgdGhlIGxpYnJhcnkuIE9uZSBnbG9iYWxcbiAgICAgICAgICogaW5zdGFuY2UgaXMgc3RvcmVkLCB3aGljaCBtYXkgc291bmQgcHJvYmxlbWF0aWMuIEJ1dCwgdGhlIGltcGxlbWVudGF0aW9uIHByb3ZpZGVkXG4gICAgICAgICAqIG91Z2h0IHRvIGJlIGFwcHJvcHJpYXRlIGZvciB0aGUgZW50aXJlIHBsYXRmb3JtLCBhbmQgYWxsIHVzZXMgb2YgdGhpcyBsaWJyYXJ5XG4gICAgICAgICAqIGluIHRoZSB3aG9sZSBsaWZldGltZSBvZiB0aGUgSlZNLiBGb3IgaW5zdGFuY2UsIGFuIEFuZHJvaWQgYWN0aXZpdHkgY2FuIHN3YXAgaW5cbiAgICAgICAgICogYW4gaW1wbGVtZW50YXRpb24gdGhhdCB0YWtlcyBhZHZhbnRhZ2Ugb2YgbmF0aXZlIHBsYXRmb3JtIGxpYnJhcmllcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5ld0dyaWRTYW1wbGVyIFRoZSBwbGF0Zm9ybS1zcGVjaWZpYyBvYmplY3QgdG8gaW5zdGFsbC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBzZXRHcmlkU2FtcGxlcihuZXdHcmlkU2FtcGxlcikge1xuICAgICAgICAgICAgR3JpZFNhbXBsZXJJbnN0YW5jZS5ncmlkU2FtcGxlciA9IG5ld0dyaWRTYW1wbGVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIEdyaWRTYW1wbGVyXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gR3JpZFNhbXBsZXJJbnN0YW5jZS5ncmlkU2FtcGxlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBHcmlkU2FtcGxlckluc3RhbmNlLmdyaWRTYW1wbGVyID0gbmV3IERlZmF1bHRHcmlkU2FtcGxlcigpO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMCBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIHRvUmVzdWx0UG9pbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdFBvaW50KHRoaXMuZ2V0WCgpLCB0aGlzLmdldFkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0WCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0WSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jYXBzdWxhdGVzIGxvZ2ljIHRoYXQgY2FuIGRldGVjdCBhbiBBenRlYyBDb2RlIGluIGFuIGltYWdlLCBldmVuIGlmIHRoZSBBenRlYyBDb2RlXG4gICAgICogaXMgcm90YXRlZCBvciBza2V3ZWQsIG9yIHBhcnRpYWxseSBvYnNjdXJlZC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgRGF2aWQgT2xpdmllclxuICAgICAqIEBhdXRob3IgRnJhbmsgWWVsbGluXG4gICAgICovXG4gICAgY2xhc3MgRGV0ZWN0b3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihpbWFnZSkge1xuICAgICAgICAgICAgdGhpcy5FWFBFQ1RFRF9DT1JORVJfQklUUyA9IG5ldyBJbnQzMkFycmF5KFtcbiAgICAgICAgICAgICAgICAweGVlMCxcbiAgICAgICAgICAgICAgICAweDFkYyxcbiAgICAgICAgICAgICAgICAweDgzYixcbiAgICAgICAgICAgICAgICAweDcwNyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB9XG4gICAgICAgIGRldGVjdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldGVjdE1pcnJvcihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdHMgYW4gQXp0ZWMgQ29kZSBpbiBhbiBpbWFnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGlzTWlycm9yIGlmIHRydWUsIGltYWdlIGlzIGEgbWlycm9yLWltYWdlIG9mIG9yaWdpbmFsXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIEF6dGVjRGV0ZWN0b3JSZXN1bHR9IGVuY2Fwc3VsYXRpbmcgcmVzdWx0cyBvZiBkZXRlY3RpbmcgYW4gQXp0ZWMgQ29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIG5vIEF6dGVjIENvZGUgY2FuIGJlIGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICBkZXRlY3RNaXJyb3IoaXNNaXJyb3IpIHtcbiAgICAgICAgICAgIC8vIDEuIEdldCB0aGUgY2VudGVyIG9mIHRoZSBhenRlYyBtYXRyaXhcbiAgICAgICAgICAgIGxldCBwQ2VudGVyID0gdGhpcy5nZXRNYXRyaXhDZW50ZXIoKTtcbiAgICAgICAgICAgIC8vIDIuIEdldCB0aGUgY2VudGVyIHBvaW50cyBvZiB0aGUgZm91ciBkaWFnb25hbCBwb2ludHMganVzdCBvdXRzaWRlIHRoZSBidWxsJ3MgZXllXG4gICAgICAgICAgICAvLyAgW3RvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdCwgdG9wTGVmdF1cbiAgICAgICAgICAgIGxldCBidWxsc0V5ZUNvcm5lcnMgPSB0aGlzLmdldEJ1bGxzRXllQ29ybmVycyhwQ2VudGVyKTtcbiAgICAgICAgICAgIGlmIChpc01pcnJvcikge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gYnVsbHNFeWVDb3JuZXJzWzBdO1xuICAgICAgICAgICAgICAgIGJ1bGxzRXllQ29ybmVyc1swXSA9IGJ1bGxzRXllQ29ybmVyc1syXTtcbiAgICAgICAgICAgICAgICBidWxsc0V5ZUNvcm5lcnNbMl0gPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMy4gR2V0IHRoZSBzaXplIG9mIHRoZSBtYXRyaXggYW5kIG90aGVyIHBhcmFtZXRlcnMgZnJvbSB0aGUgYnVsbCdzIGV5ZVxuICAgICAgICAgICAgdGhpcy5leHRyYWN0UGFyYW1ldGVycyhidWxsc0V5ZUNvcm5lcnMpO1xuICAgICAgICAgICAgLy8gNC4gU2FtcGxlIHRoZSBncmlkXG4gICAgICAgICAgICBsZXQgYml0cyA9IHRoaXMuc2FtcGxlR3JpZCh0aGlzLmltYWdlLCBidWxsc0V5ZUNvcm5lcnNbdGhpcy5zaGlmdCAlIDRdLCBidWxsc0V5ZUNvcm5lcnNbKHRoaXMuc2hpZnQgKyAxKSAlIDRdLCBidWxsc0V5ZUNvcm5lcnNbKHRoaXMuc2hpZnQgKyAyKSAlIDRdLCBidWxsc0V5ZUNvcm5lcnNbKHRoaXMuc2hpZnQgKyAzKSAlIDRdKTtcbiAgICAgICAgICAgIC8vIDUuIEdldCB0aGUgY29ybmVycyBvZiB0aGUgbWF0cml4LlxuICAgICAgICAgICAgbGV0IGNvcm5lcnMgPSB0aGlzLmdldE1hdHJpeENvcm5lclBvaW50cyhidWxsc0V5ZUNvcm5lcnMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBenRlY0RldGVjdG9yUmVzdWx0KGJpdHMsIGNvcm5lcnMsIHRoaXMuY29tcGFjdCwgdGhpcy5uYkRhdGFCbG9ja3MsIHRoaXMubmJMYXllcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRyYWN0cyB0aGUgbnVtYmVyIG9mIGRhdGEgbGF5ZXJzIGFuZCBkYXRhIGJsb2NrcyBmcm9tIHRoZSBsYXllciBhcm91bmQgdGhlIGJ1bGwncyBleWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBidWxsc0V5ZUNvcm5lcnMgdGhlIGFycmF5IG9mIGJ1bGwncyBleWUgY29ybmVyc1xuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGluIGNhc2Ugb2YgdG9vIG1hbnkgZXJyb3JzIG9yIGludmFsaWQgcGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZXh0cmFjdFBhcmFtZXRlcnMoYnVsbHNFeWVDb3JuZXJzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZFBvaW50KGJ1bGxzRXllQ29ybmVyc1swXSkgfHwgIXRoaXMuaXNWYWxpZFBvaW50KGJ1bGxzRXllQ29ybmVyc1sxXSkgfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5pc1ZhbGlkUG9pbnQoYnVsbHNFeWVDb3JuZXJzWzJdKSB8fCAhdGhpcy5pc1ZhbGlkUG9pbnQoYnVsbHNFeWVDb3JuZXJzWzNdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IDIgKiB0aGlzLm5iQ2VudGVyTGF5ZXJzO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBiaXRzIGFyb3VuZCB0aGUgYnVsbCdzIGV5ZVxuICAgICAgICAgICAgbGV0IHNpZGVzID0gbmV3IEludDMyQXJyYXkoW1xuICAgICAgICAgICAgICAgIHRoaXMuc2FtcGxlTGluZShidWxsc0V5ZUNvcm5lcnNbMF0sIGJ1bGxzRXllQ29ybmVyc1sxXSwgbGVuZ3RoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZUxpbmUoYnVsbHNFeWVDb3JuZXJzWzFdLCBidWxsc0V5ZUNvcm5lcnNbMl0sIGxlbmd0aCksXG4gICAgICAgICAgICAgICAgdGhpcy5zYW1wbGVMaW5lKGJ1bGxzRXllQ29ybmVyc1syXSwgYnVsbHNFeWVDb3JuZXJzWzNdLCBsZW5ndGgpLFxuICAgICAgICAgICAgICAgIHRoaXMuc2FtcGxlTGluZShidWxsc0V5ZUNvcm5lcnNbM10sIGJ1bGxzRXllQ29ybmVyc1swXSwgbGVuZ3RoKSAvLyBUb3BcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gYnVsbHNFeWVDb3JuZXJzW3NoaWZ0XSBpcyB0aGUgY29ybmVyIG9mIHRoZSBidWxscydleWUgdGhhdCBoYXMgdGhyZWVcbiAgICAgICAgICAgIC8vIG9yaWVudGF0aW9uIG1hcmtzLlxuICAgICAgICAgICAgLy8gc2lkZXNbc2hpZnRdIGlzIHRoZSByb3cvY29sdW1uIHRoYXQgZ29lcyBmcm9tIHRoZSBjb3JuZXIgd2l0aCB0aHJlZVxuICAgICAgICAgICAgLy8gb3JpZW50YXRpb24gbWFya3MgdG8gdGhlIGNvcm5lciB3aXRoIHR3by5cbiAgICAgICAgICAgIHRoaXMuc2hpZnQgPSB0aGlzLmdldFJvdGF0aW9uKHNpZGVzLCBsZW5ndGgpO1xuICAgICAgICAgICAgLy8gRmxhdHRlbiB0aGUgcGFyYW1ldGVyIGJpdHMgaW50byBhIHNpbmdsZSAyOC0gb3IgNDAtYml0IGxvbmdcbiAgICAgICAgICAgIGxldCBwYXJhbWV0ZXJEYXRhID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGUgPSBzaWRlc1sodGhpcy5zaGlmdCArIGkpICUgNF07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFjdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHNpZGUgb2YgdGhlIGZvcm0gLi5YWFhYWFhYLiB3aGVyZSBYcyBhcmUgcGFyYW1ldGVyIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyRGF0YSA8PD0gNztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyRGF0YSArPSAoc2lkZSA+PiAxKSAmIDB4N0Y7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHNpZGUgb2YgdGhlIGZvcm0gLi5YWFhYWC5YWFhYWC4gd2hlcmUgWHMgYXJlIHBhcmFtZXRlciBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlckRhdGEgPDw9IDEwO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJEYXRhICs9ICgoc2lkZSA+PiAyKSAmICgweDFmIDw8IDUpKSArICgoc2lkZSA+PiAxKSAmIDB4MUYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvcnJlY3RzIHBhcmFtZXRlciBkYXRhIHVzaW5nIFJTLiAgUmV0dXJucyBqdXN0IHRoZSBkYXRhIHBvcnRpb25cbiAgICAgICAgICAgIC8vIHdpdGhvdXQgdGhlIGVycm9yIGNvcnJlY3Rpb24uXG4gICAgICAgICAgICBsZXQgY29ycmVjdGVkRGF0YSA9IHRoaXMuZ2V0Q29ycmVjdGVkUGFyYW1ldGVyRGF0YShwYXJhbWV0ZXJEYXRhLCB0aGlzLmNvbXBhY3QpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIC8vIDggYml0czogIDIgYml0cyBsYXllcnMgYW5kIDYgYml0cyBkYXRhIGJsb2Nrc1xuICAgICAgICAgICAgICAgIHRoaXMubmJMYXllcnMgPSAoY29ycmVjdGVkRGF0YSA+PiA2KSArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5uYkRhdGFCbG9ja3MgPSAoY29ycmVjdGVkRGF0YSAmIDB4M0YpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDE2IGJpdHM6ICA1IGJpdHMgbGF5ZXJzIGFuZCAxMSBiaXRzIGRhdGEgYmxvY2tzXG4gICAgICAgICAgICAgICAgdGhpcy5uYkxheWVycyA9IChjb3JyZWN0ZWREYXRhID4+IDExKSArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5uYkRhdGFCbG9ja3MgPSAoY29ycmVjdGVkRGF0YSAmIDB4N0ZGKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Um90YXRpb24oc2lkZXMsIGxlbmd0aCkge1xuICAgICAgICAgICAgLy8gSW4gYSBub3JtYWwgcGF0dGVybiwgd2UgZXhwZWN0IHRvIFNlZVxuICAgICAgICAgICAgLy8gICAqKiAgICAuKiAgICAgICAgICAgICBEICAgICAgIEFcbiAgICAgICAgICAgIC8vICAgKiAgICAgICpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIC4gICAgICAqXG4gICAgICAgICAgICAvLyAgIC4uICAgIC4uICAgICAgICAgICAgIEMgICAgICAgQlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIDMgYml0cyBmcm9tIGVhY2ggb2YgdGhlIHNpZGVzIHRoZSBmb3JtIHRoZSBsb2NhdG9yIHBhdHRlcm4gYW5kIGNvbmNhdGVuYXRlXG4gICAgICAgICAgICAvLyBpbnRvIGEgMTItYml0IGludGVnZXIuICBTdGFydCB3aXRoIHRoZSBiaXQgYXQgQVxuICAgICAgICAgICAgbGV0IGNvcm5lckJpdHMgPSAwO1xuICAgICAgICAgICAgc2lkZXMuZm9yRWFjaCgoc2lkZSwgaWR4LCBhcnIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBYWC4uLi4uLlggd2hlcmUgWCdzIGFyZSBvcmllbnRhdGlvbiBtYXJrc1xuICAgICAgICAgICAgICAgIGxldCB0ID0gKChzaWRlID4+IChsZW5ndGggLSAyKSkgPDwgMSkgKyAoc2lkZSAmIDEpO1xuICAgICAgICAgICAgICAgIGNvcm5lckJpdHMgPSAoY29ybmVyQml0cyA8PCAzKSArIHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGZvciAodmFyIHNpZGUgaW4gc2lkZXMpIHtcbiAgICAgICAgICAgIC8vICAgICAvLyBYWC4uLi4uLlggd2hlcmUgWCdzIGFyZSBvcmllbnRhdGlvbiBtYXJrc1xuICAgICAgICAgICAgLy8gICAgIHZhciB0ID0gKChzaWRlID4+IChsZW5ndGggLSAyKSkgPDwgMSkgKyAoc2lkZSAmIDEpO1xuICAgICAgICAgICAgLy8gICAgIGNvcm5lckJpdHMgPSAoY29ybmVyQml0cyA8PCAzKSArIHQ7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBNb3YgdGhlIGJvdHRvbSBiaXQgdG8gdGhlIHRvcCwgc28gdGhhdCB0aGUgdGhyZWUgYml0cyBvZiB0aGUgbG9jYXRvciBwYXR0ZXJuIGF0IEEgYXJlXG4gICAgICAgICAgICAvLyB0b2dldGhlci4gIGNvcm5lckJpdHMgaXMgbm93OlxuICAgICAgICAgICAgLy8gIDMgb3JpZW50YXRpb24gYml0cyBhdCBBIHx8IDMgb3JpZW50YXRpb24gYml0cyBhdCBCIHx8IC4uLiB8fCAzIG9yaWVudGF0aW9uIGJpdHMgYXQgRFxuICAgICAgICAgICAgY29ybmVyQml0cyA9ICgoY29ybmVyQml0cyAmIDEpIDw8IDExKSArIChjb3JuZXJCaXRzID4+IDEpO1xuICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBzaGlmdCBpbmRpY2F0ZXMgd2hpY2ggZWxlbWVudCBvZiBCdWxsc0V5ZUNvcm5lcnNbXSBnb2VzIGludG8gdGhlIHRvcC1sZWZ0XG4gICAgICAgICAgICAvLyBjb3JuZXIuIFNpbmNlIHRoZSBmb3VyIHJvdGF0aW9uIHZhbHVlcyBoYXZlIGEgSGFtbWluZyBkaXN0YW5jZSBvZiA4LCB3ZVxuICAgICAgICAgICAgLy8gY2FuIGVhc2lseSB0b2xlcmF0ZSB0d28gZXJyb3JzLlxuICAgICAgICAgICAgZm9yIChsZXQgc2hpZnQgPSAwOyBzaGlmdCA8IDQ7IHNoaWZ0KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoSW50ZWdlci5iaXRDb3VudChjb3JuZXJCaXRzIF4gdGhpcy5FWFBFQ1RFRF9DT1JORVJfQklUU1tzaGlmdF0pIDw9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoaWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3JyZWN0cyB0aGUgcGFyYW1ldGVyIGJpdHMgdXNpbmcgUmVlZC1Tb2xvbW9uIGFsZ29yaXRobS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtZXRlckRhdGEgcGFyYW1ldGVyIGJpdHNcbiAgICAgICAgICogQHBhcmFtIGNvbXBhY3QgdHJ1ZSBpZiB0aGlzIGlzIGEgY29tcGFjdCBBenRlYyBjb2RlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgdGhlIGFycmF5IGNvbnRhaW5zIHRvbyBtYW55IGVycm9yc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29ycmVjdGVkUGFyYW1ldGVyRGF0YShwYXJhbWV0ZXJEYXRhLCBjb21wYWN0KSB7XG4gICAgICAgICAgICBsZXQgbnVtQ29kZXdvcmRzO1xuICAgICAgICAgICAgbGV0IG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIG51bUNvZGV3b3JkcyA9IDc7XG4gICAgICAgICAgICAgICAgbnVtRGF0YUNvZGV3b3JkcyA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBudW1Db2Rld29yZHMgPSAxMDtcbiAgICAgICAgICAgICAgICBudW1EYXRhQ29kZXdvcmRzID0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBudW1FQ0NvZGV3b3JkcyA9IG51bUNvZGV3b3JkcyAtIG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgICAgICBsZXQgcGFyYW1ldGVyV29yZHMgPSBuZXcgSW50MzJBcnJheShudW1Db2Rld29yZHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG51bUNvZGV3b3JkcyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyV29yZHNbaV0gPSBwYXJhbWV0ZXJEYXRhICYgMHhGO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlckRhdGEgPj49IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByc0RlY29kZXIgPSBuZXcgUmVlZFNvbG9tb25EZWNvZGVyKEdlbmVyaWNHRi5BWlRFQ19QQVJBTSk7XG4gICAgICAgICAgICAgICAgcnNEZWNvZGVyLmRlY29kZShwYXJhbWV0ZXJXb3JkcywgbnVtRUNDb2Rld29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRvc3MgdGhlIGVycm9yIGNvcnJlY3Rpb24uICBKdXN0IHJldHVybiB0aGUgZGF0YSBhcyBhbiBpbnRlZ2VyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCA0KSArIHBhcmFtZXRlcldvcmRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZHMgdGhlIGNvcm5lcnMgb2YgYSBidWxsLWV5ZSBjZW50ZXJlZCBvbiB0aGUgcGFzc2VkIHBvaW50LlxuICAgICAgICAgKiBUaGlzIHJldHVybnMgdGhlIGNlbnRlcnMgb2YgdGhlIGRpYWdvbmFsIHBvaW50cyBqdXN0IG91dHNpZGUgdGhlIGJ1bGwncyBleWVcbiAgICAgICAgICogUmV0dXJucyBbdG9wUmlnaHQsIGJvdHRvbVJpZ2h0LCBib3R0b21MZWZ0LCB0b3BMZWZ0XVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcENlbnRlciBDZW50ZXIgcG9pbnRcbiAgICAgICAgICogQHJldHVybiBUaGUgY29ybmVycyBvZiB0aGUgYnVsbC1leWVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBJZiBubyB2YWxpZCBidWxsLWV5ZSBjYW4gYmUgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGdldEJ1bGxzRXllQ29ybmVycyhwQ2VudGVyKSB7XG4gICAgICAgICAgICBsZXQgcGluYSA9IHBDZW50ZXI7XG4gICAgICAgICAgICBsZXQgcGluYiA9IHBDZW50ZXI7XG4gICAgICAgICAgICBsZXQgcGluYyA9IHBDZW50ZXI7XG4gICAgICAgICAgICBsZXQgcGluZCA9IHBDZW50ZXI7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh0aGlzLm5iQ2VudGVyTGF5ZXJzID0gMTsgdGhpcy5uYkNlbnRlckxheWVycyA8IDk7IHRoaXMubmJDZW50ZXJMYXllcnMrKykge1xuICAgICAgICAgICAgICAgIGxldCBwb3V0YSA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQocGluYSwgY29sb3IsIDEsIC0xKTtcbiAgICAgICAgICAgICAgICBsZXQgcG91dGIgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KHBpbmIsIGNvbG9yLCAxLCAxKTtcbiAgICAgICAgICAgICAgICBsZXQgcG91dGMgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KHBpbmMsIGNvbG9yLCAtMSwgMSk7XG4gICAgICAgICAgICAgICAgbGV0IHBvdXRkID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChwaW5kLCBjb2xvciwgLTEsIC0xKTtcbiAgICAgICAgICAgICAgICAvLyBkICAgICAgYVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gYyAgICAgIGJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uYkNlbnRlckxheWVycyA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHEgPSAodGhpcy5kaXN0YW5jZVBvaW50KHBvdXRkLCBwb3V0YSkgKiB0aGlzLm5iQ2VudGVyTGF5ZXJzKSAvICh0aGlzLmRpc3RhbmNlUG9pbnQocGluZCwgcGluYSkgKiAodGhpcy5uYkNlbnRlckxheWVycyArIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHEgPCAwLjc1IHx8IHEgPiAxLjI1IHx8ICF0aGlzLmlzV2hpdGVPckJsYWNrUmVjdGFuZ2xlKHBvdXRhLCBwb3V0YiwgcG91dGMsIHBvdXRkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGluYSA9IHBvdXRhO1xuICAgICAgICAgICAgICAgIHBpbmIgPSBwb3V0YjtcbiAgICAgICAgICAgICAgICBwaW5jID0gcG91dGM7XG4gICAgICAgICAgICAgICAgcGluZCA9IHBvdXRkO1xuICAgICAgICAgICAgICAgIGNvbG9yID0gIWNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubmJDZW50ZXJMYXllcnMgIT09IDUgJiYgdGhpcy5uYkNlbnRlckxheWVycyAhPT0gNykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21wYWN0ID0gdGhpcy5uYkNlbnRlckxheWVycyA9PT0gNTtcbiAgICAgICAgICAgIC8vIEV4cGFuZCB0aGUgc3F1YXJlIGJ5IC41IHBpeGVsIGluIGVhY2ggZGlyZWN0aW9uIHNvIHRoYXQgd2UncmUgb24gdGhlIGJvcmRlclxuICAgICAgICAgICAgLy8gYmV0d2VlbiB0aGUgd2hpdGUgc3F1YXJlIGFuZCB0aGUgYmxhY2sgc3F1YXJlXG4gICAgICAgICAgICBsZXQgcGluYXggPSBuZXcgUmVzdWx0UG9pbnQocGluYS5nZXRYKCkgKyAwLjUsIHBpbmEuZ2V0WSgpIC0gMC41KTtcbiAgICAgICAgICAgIGxldCBwaW5ieCA9IG5ldyBSZXN1bHRQb2ludChwaW5iLmdldFgoKSArIDAuNSwgcGluYi5nZXRZKCkgKyAwLjUpO1xuICAgICAgICAgICAgbGV0IHBpbmN4ID0gbmV3IFJlc3VsdFBvaW50KHBpbmMuZ2V0WCgpIC0gMC41LCBwaW5jLmdldFkoKSArIDAuNSk7XG4gICAgICAgICAgICBsZXQgcGluZHggPSBuZXcgUmVzdWx0UG9pbnQocGluZC5nZXRYKCkgLSAwLjUsIHBpbmQuZ2V0WSgpIC0gMC41KTtcbiAgICAgICAgICAgIC8vIEV4cGFuZCB0aGUgc3F1YXJlIHNvIHRoYXQgaXRzIGNvcm5lcnMgYXJlIHRoZSBjZW50ZXJzIG9mIHRoZSBwb2ludHNcbiAgICAgICAgICAgIC8vIGp1c3Qgb3V0c2lkZSB0aGUgYnVsbCdzIGV5ZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZFNxdWFyZShbcGluYXgsIHBpbmJ4LCBwaW5jeCwgcGluZHhdLCAyICogdGhpcy5uYkNlbnRlckxheWVycyAtIDMsIDIgKiB0aGlzLm5iQ2VudGVyTGF5ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZHMgYSBjYW5kaWRhdGUgY2VudGVyIHBvaW50IG9mIGFuIEF6dGVjIGNvZGUgZnJvbSBhbiBpbWFnZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBjZW50ZXIgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIGdldE1hdHJpeENlbnRlcigpIHtcbiAgICAgICAgICAgIGxldCBwb2ludEE7XG4gICAgICAgICAgICBsZXQgcG9pbnRCO1xuICAgICAgICAgICAgbGV0IHBvaW50QztcbiAgICAgICAgICAgIGxldCBwb2ludEQ7XG4gICAgICAgICAgICAvLyBHZXQgYSB3aGl0ZSByZWN0YW5nbGUgdGhhdCBjYW4gYmUgdGhlIGJvcmRlciBvZiB0aGUgbWF0cml4IGluIGNlbnRlciBidWxsJ3MgZXllIG9yXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBjb3JuZXJQb2ludHMgPSBuZXcgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvcih0aGlzLmltYWdlKS5kZXRlY3QoKTtcbiAgICAgICAgICAgICAgICBwb2ludEEgPSBjb3JuZXJQb2ludHNbMF07XG4gICAgICAgICAgICAgICAgcG9pbnRCID0gY29ybmVyUG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgIHBvaW50QyA9IGNvcm5lclBvaW50c1syXTtcbiAgICAgICAgICAgICAgICBwb2ludEQgPSBjb3JuZXJQb2ludHNbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZXhjZXB0aW9uIGNhbiBiZSBpbiBjYXNlIHRoZSBpbml0aWFsIHJlY3RhbmdsZSBpcyB3aGl0ZVxuICAgICAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSwgc3VyZWx5IGluIHRoZSBidWxsJ3MgZXllLCB3ZSB0cnkgdG8gZXhwYW5kIHRoZSByZWN0YW5nbGUuXG4gICAgICAgICAgICAgICAgbGV0IGN4ID0gdGhpcy5pbWFnZS5nZXRXaWR0aCgpIC8gMjtcbiAgICAgICAgICAgICAgICBsZXQgY3kgPSB0aGlzLmltYWdlLmdldEhlaWdodCgpIC8gMjtcbiAgICAgICAgICAgICAgICBwb2ludEEgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCArIDcsIGN5IC0gNyksIGZhbHNlLCAxLCAtMSkudG9SZXN1bHRQb2ludCgpO1xuICAgICAgICAgICAgICAgIHBvaW50QiA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4ICsgNywgY3kgKyA3KSwgZmFsc2UsIDEsIDEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwb2ludEMgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCAtIDcsIGN5ICsgNyksIGZhbHNlLCAtMSwgMSkudG9SZXN1bHRQb2ludCgpO1xuICAgICAgICAgICAgICAgIHBvaW50RCA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4IC0gNywgY3kgLSA3KSwgZmFsc2UsIC0xLCAtMSkudG9SZXN1bHRQb2ludCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY2VudGVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICAgIGxldCBjeCA9IE1hdGhVdGlscy5yb3VuZCgocG9pbnRBLmdldFgoKSArIHBvaW50RC5nZXRYKCkgKyBwb2ludEIuZ2V0WCgpICsgcG9pbnRDLmdldFgoKSkgLyA0LjApO1xuICAgICAgICAgICAgbGV0IGN5ID0gTWF0aFV0aWxzLnJvdW5kKChwb2ludEEuZ2V0WSgpICsgcG9pbnRELmdldFkoKSArIHBvaW50Qi5nZXRZKCkgKyBwb2ludEMuZ2V0WSgpKSAvIDQuMCk7XG4gICAgICAgICAgICAvLyBSZWRldGVybWluZSB0aGUgd2hpdGUgcmVjdGFuZ2xlIHN0YXJ0aW5nIGZyb20gcHJldmlvdXNseSBjb21wdXRlZCBjZW50ZXIuXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgd2UgZW5kIHVwIHdpdGggYSB3aGl0ZSByZWN0YW5nbGUgaW4gY2VudGVyIGJ1bGwncyBleWVcbiAgICAgICAgICAgIC8vIGluIG9yZGVyIHRvIGNvbXB1dGUgYSBtb3JlIGFjY3VyYXRlIGNlbnRlci5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvcm5lclBvaW50cyA9IG5ldyBXaGl0ZVJlY3RhbmdsZURldGVjdG9yKHRoaXMuaW1hZ2UsIDE1LCBjeCwgY3kpLmRldGVjdCgpO1xuICAgICAgICAgICAgICAgIHBvaW50QSA9IGNvcm5lclBvaW50c1swXTtcbiAgICAgICAgICAgICAgICBwb2ludEIgPSBjb3JuZXJQb2ludHNbMV07XG4gICAgICAgICAgICAgICAgcG9pbnRDID0gY29ybmVyUG9pbnRzWzJdO1xuICAgICAgICAgICAgICAgIHBvaW50RCA9IGNvcm5lclBvaW50c1szXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBleGNlcHRpb24gY2FuIGJlIGluIGNhc2UgdGhlIGluaXRpYWwgcmVjdGFuZ2xlIGlzIHdoaXRlXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIHdlIHRyeSB0byBleHBhbmQgdGhlIHJlY3RhbmdsZS5cbiAgICAgICAgICAgICAgICBwb2ludEEgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCArIDcsIGN5IC0gNyksIGZhbHNlLCAxLCAtMSkudG9SZXN1bHRQb2ludCgpO1xuICAgICAgICAgICAgICAgIHBvaW50QiA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4ICsgNywgY3kgKyA3KSwgZmFsc2UsIDEsIDEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwb2ludEMgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCAtIDcsIGN5ICsgNyksIGZhbHNlLCAtMSwgMSkudG9SZXN1bHRQb2ludCgpO1xuICAgICAgICAgICAgICAgIHBvaW50RCA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4IC0gNywgY3kgLSA3KSwgZmFsc2UsIC0xLCAtMSkudG9SZXN1bHRQb2ludCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVjb21wdXRlIHRoZSBjZW50ZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAgICAgICAgY3ggPSBNYXRoVXRpbHMucm91bmQoKHBvaW50QS5nZXRYKCkgKyBwb2ludEQuZ2V0WCgpICsgcG9pbnRCLmdldFgoKSArIHBvaW50Qy5nZXRYKCkpIC8gNC4wKTtcbiAgICAgICAgICAgIGN5ID0gTWF0aFV0aWxzLnJvdW5kKChwb2ludEEuZ2V0WSgpICsgcG9pbnRELmdldFkoKSArIHBvaW50Qi5nZXRZKCkgKyBwb2ludEMuZ2V0WSgpKSAvIDQuMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KGN4LCBjeSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIEF6dGVjIGNvZGUgY29ybmVycyBmcm9tIHRoZSBidWxsJ3MgZXllIGNvcm5lcnMgYW5kIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnVsbHNFeWVDb3JuZXJzIHRoZSBhcnJheSBvZiBidWxsJ3MgZXllIGNvcm5lcnNcbiAgICAgICAgICogQHJldHVybiB0aGUgYXJyYXkgb2YgYXp0ZWMgY29kZSBjb3JuZXJzXG4gICAgICAgICAqL1xuICAgICAgICBnZXRNYXRyaXhDb3JuZXJQb2ludHMoYnVsbHNFeWVDb3JuZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRTcXVhcmUoYnVsbHNFeWVDb3JuZXJzLCAyICogdGhpcy5uYkNlbnRlckxheWVycywgdGhpcy5nZXREaW1lbnNpb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBCaXRNYXRyaXggYnkgc2FtcGxpbmcgdGhlIHByb3ZpZGVkIGltYWdlLlxuICAgICAgICAgKiB0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQsIGFuZCBib3R0b21MZWZ0IGFyZSB0aGUgY2VudGVycyBvZiB0aGUgc3F1YXJlcyBvbiB0aGVcbiAgICAgICAgICogZGlhZ29uYWwganVzdCBvdXRzaWRlIHRoZSBidWxsJ3MgZXllLlxuICAgICAgICAgKi9cbiAgICAgICAgc2FtcGxlR3JpZChpbWFnZSwgdG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbVJpZ2h0LCBib3R0b21MZWZ0KSB7XG4gICAgICAgICAgICBsZXQgc2FtcGxlciA9IEdyaWRTYW1wbGVySW5zdGFuY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGxldCBkaW1lbnNpb24gPSB0aGlzLmdldERpbWVuc2lvbigpO1xuICAgICAgICAgICAgbGV0IGxvdyA9IGRpbWVuc2lvbiAvIDIgLSB0aGlzLm5iQ2VudGVyTGF5ZXJzO1xuICAgICAgICAgICAgbGV0IGhpZ2ggPSBkaW1lbnNpb24gLyAyICsgdGhpcy5uYkNlbnRlckxheWVycztcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVyLnNhbXBsZUdyaWQoaW1hZ2UsIGRpbWVuc2lvbiwgZGltZW5zaW9uLCBsb3csIGxvdywgLy8gdG9wbGVmdFxuICAgICAgICAgICAgaGlnaCwgbG93LCAvLyB0b3ByaWdodFxuICAgICAgICAgICAgaGlnaCwgaGlnaCwgLy8gYm90dG9tcmlnaHRcbiAgICAgICAgICAgIGxvdywgaGlnaCwgLy8gYm90dG9tbGVmdFxuICAgICAgICAgICAgdG9wTGVmdC5nZXRYKCksIHRvcExlZnQuZ2V0WSgpLCB0b3BSaWdodC5nZXRYKCksIHRvcFJpZ2h0LmdldFkoKSwgYm90dG9tUmlnaHQuZ2V0WCgpLCBib3R0b21SaWdodC5nZXRZKCksIGJvdHRvbUxlZnQuZ2V0WCgpLCBib3R0b21MZWZ0LmdldFkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhbXBsZXMgYSBsaW5lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcDEgICBzdGFydCBwb2ludCAoaW5jbHVzaXZlKVxuICAgICAgICAgKiBAcGFyYW0gcDIgICBlbmQgcG9pbnQgKGV4Y2x1c2l2ZSlcbiAgICAgICAgICogQHBhcmFtIHNpemUgbnVtYmVyIG9mIGJpdHNcbiAgICAgICAgICogQHJldHVybiB0aGUgYXJyYXkgb2YgYml0cyBhcyBhbiBpbnQgKGZpcnN0IGJpdCBpcyBoaWdoLW9yZGVyIGJpdCBvZiByZXN1bHQpXG4gICAgICAgICAqL1xuICAgICAgICBzYW1wbGVMaW5lKHAxLCBwMiwgc2l6ZSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXMuZGlzdGFuY2VSZXN1bHRQb2ludChwMSwgcDIpO1xuICAgICAgICAgICAgbGV0IG1vZHVsZVNpemUgPSBkIC8gc2l6ZTtcbiAgICAgICAgICAgIGxldCBweCA9IHAxLmdldFgoKTtcbiAgICAgICAgICAgIGxldCBweSA9IHAxLmdldFkoKTtcbiAgICAgICAgICAgIGxldCBkeCA9IG1vZHVsZVNpemUgKiAocDIuZ2V0WCgpIC0gcDEuZ2V0WCgpKSAvIGQ7XG4gICAgICAgICAgICBsZXQgZHkgPSBtb2R1bGVTaXplICogKHAyLmdldFkoKSAtIHAxLmdldFkoKSkgLyBkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbWFnZS5nZXQoTWF0aFV0aWxzLnJvdW5kKHB4ICsgaSAqIGR4KSwgTWF0aFV0aWxzLnJvdW5kKHB5ICsgaSAqIGR5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IDEgPDwgKHNpemUgLSBpIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBib3JkZXIgb2YgdGhlIHJlY3RhbmdsZSBwYXNzZWQgaW4gcGFyYW1ldGVyIGlzIGNvbXBvdW5kIG9mIHdoaXRlIHBvaW50cyBvbmx5XG4gICAgICAgICAqICAgICAgICAgb3IgYmxhY2sgcG9pbnRzIG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGlzV2hpdGVPckJsYWNrUmVjdGFuZ2xlKHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICBsZXQgY29yciA9IDM7XG4gICAgICAgICAgICBwMSA9IG5ldyBQb2ludChwMS5nZXRYKCkgLSBjb3JyLCBwMS5nZXRZKCkgKyBjb3JyKTtcbiAgICAgICAgICAgIHAyID0gbmV3IFBvaW50KHAyLmdldFgoKSAtIGNvcnIsIHAyLmdldFkoKSAtIGNvcnIpO1xuICAgICAgICAgICAgcDMgPSBuZXcgUG9pbnQocDMuZ2V0WCgpICsgY29yciwgcDMuZ2V0WSgpIC0gY29ycik7XG4gICAgICAgICAgICBwNCA9IG5ldyBQb2ludChwNC5nZXRYKCkgKyBjb3JyLCBwNC5nZXRZKCkgKyBjb3JyKTtcbiAgICAgICAgICAgIGxldCBjSW5pdCA9IHRoaXMuZ2V0Q29sb3IocDQsIHAxKTtcbiAgICAgICAgICAgIGlmIChjSW5pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjID0gdGhpcy5nZXRDb2xvcihwMSwgcDIpO1xuICAgICAgICAgICAgaWYgKGMgIT09IGNJbml0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyA9IHRoaXMuZ2V0Q29sb3IocDIsIHAzKTtcbiAgICAgICAgICAgIGlmIChjICE9PSBjSW5pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSB0aGlzLmdldENvbG9yKHAzLCBwNCk7XG4gICAgICAgICAgICByZXR1cm4gYyA9PT0gY0luaXQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGNvbG9yIG9mIGEgc2VnbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIDEgaWYgc2VnbWVudCBtb3JlIHRoYW4gOTAlIGJsYWNrLCAtMSBpZiBzZWdtZW50IGlzIG1vcmUgdGhhbiA5MCUgd2hpdGUsIDAgZWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29sb3IocDEsIHAyKSB7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXMuZGlzdGFuY2VQb2ludChwMSwgcDIpO1xuICAgICAgICAgICAgbGV0IGR4ID0gKHAyLmdldFgoKSAtIHAxLmdldFgoKSkgLyBkO1xuICAgICAgICAgICAgbGV0IGR5ID0gKHAyLmdldFkoKSAtIHAxLmdldFkoKSkgLyBkO1xuICAgICAgICAgICAgbGV0IGVycm9yID0gMDtcbiAgICAgICAgICAgIGxldCBweCA9IHAxLmdldFgoKTtcbiAgICAgICAgICAgIGxldCBweSA9IHAxLmdldFkoKTtcbiAgICAgICAgICAgIGxldCBjb2xvck1vZGVsID0gdGhpcy5pbWFnZS5nZXQocDEuZ2V0WCgpLCBwMS5nZXRZKCkpO1xuICAgICAgICAgICAgbGV0IGlNYXggPSBNYXRoLmNlaWwoZCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIHB4ICs9IGR4O1xuICAgICAgICAgICAgICAgIHB5ICs9IGR5O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmltYWdlLmdldChNYXRoVXRpbHMucm91bmQocHgpLCBNYXRoVXRpbHMucm91bmQocHkpKSAhPT0gY29sb3JNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlcnJSYXRpbyA9IGVycm9yIC8gZDtcbiAgICAgICAgICAgIGlmIChlcnJSYXRpbyA+IDAuMSAmJiBlcnJSYXRpbyA8IDAuOSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChlcnJSYXRpbyA8PSAwLjEpID09PSBjb2xvck1vZGVsID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludCB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIGluIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGdldEZpcnN0RGlmZmVyZW50KGluaXQsIGNvbG9yLCBkeCwgZHkpIHtcbiAgICAgICAgICAgIGxldCB4ID0gaW5pdC5nZXRYKCkgKyBkeDtcbiAgICAgICAgICAgIGxldCB5ID0gaW5pdC5nZXRZKCkgKyBkeTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzVmFsaWQoeCwgeSkgJiYgdGhpcy5pbWFnZS5nZXQoeCwgeSkgPT09IGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgeCArPSBkeDtcbiAgICAgICAgICAgICAgICB5ICs9IGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCAtPSBkeDtcbiAgICAgICAgICAgIHkgLT0gZHk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc1ZhbGlkKHgsIHkpICYmIHRoaXMuaW1hZ2UuZ2V0KHgsIHkpID09PSBjb2xvcikge1xuICAgICAgICAgICAgICAgIHggKz0gZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4IC09IGR4O1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNWYWxpZCh4LCB5KSAmJiB0aGlzLmltYWdlLmdldCh4LCB5KSA9PT0gY29sb3IpIHtcbiAgICAgICAgICAgICAgICB5ICs9IGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeSAtPSBkeTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cGFuZCB0aGUgc3F1YXJlIHJlcHJlc2VudGVkIGJ5IHRoZSBjb3JuZXIgcG9pbnRzIGJ5IHB1c2hpbmcgb3V0IGVxdWFsbHkgaW4gYWxsIGRpcmVjdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvcm5lclBvaW50cyB0aGUgY29ybmVycyBvZiB0aGUgc3F1YXJlLCB3aGljaCBoYXMgdGhlIGJ1bGwncyBleWUgYXQgaXRzIGNlbnRlclxuICAgICAgICAgKiBAcGFyYW0gb2xkU2lkZSB0aGUgb3JpZ2luYWwgbGVuZ3RoIG9mIHRoZSBzaWRlIG9mIHRoZSBzcXVhcmUgaW4gdGhlIHRhcmdldCBiaXQgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSBuZXdTaWRlIHRoZSBuZXcgbGVuZ3RoIG9mIHRoZSBzaXplIG9mIHRoZSBzcXVhcmUgaW4gdGhlIHRhcmdldCBiaXQgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4gdGhlIGNvcm5lcnMgb2YgdGhlIGV4cGFuZGVkIHNxdWFyZVxuICAgICAgICAgKi9cbiAgICAgICAgZXhwYW5kU3F1YXJlKGNvcm5lclBvaW50cywgb2xkU2lkZSwgbmV3U2lkZSkge1xuICAgICAgICAgICAgbGV0IHJhdGlvID0gbmV3U2lkZSAvICgyLjAgKiBvbGRTaWRlKTtcbiAgICAgICAgICAgIGxldCBkeCA9IGNvcm5lclBvaW50c1swXS5nZXRYKCkgLSBjb3JuZXJQb2ludHNbMl0uZ2V0WCgpO1xuICAgICAgICAgICAgbGV0IGR5ID0gY29ybmVyUG9pbnRzWzBdLmdldFkoKSAtIGNvcm5lclBvaW50c1syXS5nZXRZKCk7XG4gICAgICAgICAgICBsZXQgY2VudGVyeCA9IChjb3JuZXJQb2ludHNbMF0uZ2V0WCgpICsgY29ybmVyUG9pbnRzWzJdLmdldFgoKSkgLyAyLjA7XG4gICAgICAgICAgICBsZXQgY2VudGVyeSA9IChjb3JuZXJQb2ludHNbMF0uZ2V0WSgpICsgY29ybmVyUG9pbnRzWzJdLmdldFkoKSkgLyAyLjA7XG4gICAgICAgICAgICBsZXQgcmVzdWx0MCA9IG5ldyBSZXN1bHRQb2ludChjZW50ZXJ4ICsgcmF0aW8gKiBkeCwgY2VudGVyeSArIHJhdGlvICogZHkpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDIgPSBuZXcgUmVzdWx0UG9pbnQoY2VudGVyeCAtIHJhdGlvICogZHgsIGNlbnRlcnkgLSByYXRpbyAqIGR5KTtcbiAgICAgICAgICAgIGR4ID0gY29ybmVyUG9pbnRzWzFdLmdldFgoKSAtIGNvcm5lclBvaW50c1szXS5nZXRYKCk7XG4gICAgICAgICAgICBkeSA9IGNvcm5lclBvaW50c1sxXS5nZXRZKCkgLSBjb3JuZXJQb2ludHNbM10uZ2V0WSgpO1xuICAgICAgICAgICAgY2VudGVyeCA9IChjb3JuZXJQb2ludHNbMV0uZ2V0WCgpICsgY29ybmVyUG9pbnRzWzNdLmdldFgoKSkgLyAyLjA7XG4gICAgICAgICAgICBjZW50ZXJ5ID0gKGNvcm5lclBvaW50c1sxXS5nZXRZKCkgKyBjb3JuZXJQb2ludHNbM10uZ2V0WSgpKSAvIDIuMDtcbiAgICAgICAgICAgIGxldCByZXN1bHQxID0gbmV3IFJlc3VsdFBvaW50KGNlbnRlcnggKyByYXRpbyAqIGR4LCBjZW50ZXJ5ICsgcmF0aW8gKiBkeSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0MyA9IG5ldyBSZXN1bHRQb2ludChjZW50ZXJ4IC0gcmF0aW8gKiBkeCwgY2VudGVyeSAtIHJhdGlvICogZHkpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0M107XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBpc1ZhbGlkKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4ID49IDAgJiYgeCA8IHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSAmJiB5ID4gMCAmJiB5IDwgdGhpcy5pbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpc1ZhbGlkUG9pbnQocG9pbnQpIHtcbiAgICAgICAgICAgIGxldCB4ID0gTWF0aFV0aWxzLnJvdW5kKHBvaW50LmdldFgoKSk7XG4gICAgICAgICAgICBsZXQgeSA9IE1hdGhVdGlscy5yb3VuZChwb2ludC5nZXRZKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBkaXN0YW5jZVBvaW50KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuZGlzdGFuY2UoYS5nZXRYKCksIGEuZ2V0WSgpLCBiLmdldFgoKSwgYi5nZXRZKCkpO1xuICAgICAgICB9XG4gICAgICAgIGRpc3RhbmNlUmVzdWx0UG9pbnQoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5kaXN0YW5jZShhLmdldFgoKSwgYS5nZXRZKCksIGIuZ2V0WCgpLCBiLmdldFkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGltZW5zaW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA0ICogdGhpcy5uYkxheWVycyArIDExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubmJMYXllcnMgPD0gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA0ICogdGhpcy5uYkxheWVycyArIDE1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDQgKiB0aGlzLm5iTGF5ZXJzICsgMiAqIChJbnRlZ2VyLnRydW5jRGl2aXNpb24oKHRoaXMubmJMYXllcnMgLSA0KSwgOCkgKyAxKSArIDE1O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMCBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5NYXA7XG4gICAgLyoqXG4gICAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjYW4gZGV0ZWN0IGFuZCBkZWNvZGUgQXp0ZWMgY29kZXMgaW4gYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcbiAgICAgKi9cbiAgICBjbGFzcyBBenRlY1JlYWRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2NhdGVzIGFuZCBkZWNvZGVzIGEgRGF0YSBNYXRyaXggY29kZSBpbiBhbiBpbWFnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBhIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvbnRlbnQgZW5jb2RlZCBieSB0aGUgRGF0YSBNYXRyaXggY29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGEgRGF0YSBNYXRyaXggY29kZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgYSBEYXRhIE1hdHJpeCBjb2RlIGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGUoaW1hZ2UsIGhpbnRzID0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGV4Y2VwdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGV0ZWN0b3IgPSBuZXcgRGV0ZWN0b3IoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSk7XG4gICAgICAgICAgICBsZXQgcG9pbnRzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBkZWNvZGVyUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGRldGVjdG9yUmVzdWx0ID0gZGV0ZWN0b3IuZGV0ZWN0TWlycm9yKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBkZXRlY3RvclJlc3VsdC5nZXRQb2ludHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEZvdW5kUmVzdWx0UG9pbnRzKGhpbnRzLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgIGRlY29kZXJSZXN1bHQgPSBuZXcgRGVjb2RlcigpLmRlY29kZShkZXRlY3RvclJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjb2RlclJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRldGVjdG9yUmVzdWx0ID0gZGV0ZWN0b3IuZGV0ZWN0TWlycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBkZXRlY3RvclJlc3VsdC5nZXRQb2ludHMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRGb3VuZFJlc3VsdFBvaW50cyhoaW50cywgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlclJlc3VsdCA9IG5ldyBEZWNvZGVyKCkuZGVjb2RlKGRldGVjdG9yUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2VwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFJlc3VsdChkZWNvZGVyUmVzdWx0LmdldFRleHQoKSwgZGVjb2RlclJlc3VsdC5nZXRSYXdCeXRlcygpLCBkZWNvZGVyUmVzdWx0LmdldE51bUJpdHMoKSwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0JDEuQVpURUMsIFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpKTtcbiAgICAgICAgICAgIGxldCBieXRlU2VnbWVudHMgPSBkZWNvZGVyUmVzdWx0LmdldEJ5dGVTZWdtZW50cygpO1xuICAgICAgICAgICAgaWYgKGJ5dGVTZWdtZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLkJZVEVfU0VHTUVOVFMsIGJ5dGVTZWdtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZWNMZXZlbCA9IGRlY29kZXJSZXN1bHQuZ2V0RUNMZXZlbCgpO1xuICAgICAgICAgICAgaWYgKGVjTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OX0xFVkVMLCBlY0xldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVwb3J0Rm91bmRSZXN1bHRQb2ludHMoaGludHMsIHBvaW50cykge1xuICAgICAgICAgICAgaWYgKGhpbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgcnBjYiA9IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLk5FRURfUkVTVUxUX1BPSU5UX0NBTExCQUNLKTtcbiAgICAgICAgICAgICAgICBpZiAocnBjYiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5mb3JFYWNoKChwb2ludCwgaWR4LCBhcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJwY2IuZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF6dGVjIENvZGUgcmVhZGVyIHRvIHVzZSBmcm9tIGJyb3dzZXIuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQnJvd3NlckF6dGVjQ29kZVJlYWRlclxuICAgICAqIEBleHRlbmRzIHtCcm93c2VyQ29kZVJlYWRlcn1cbiAgICAgKi9cbiAgICBjbGFzcyBCcm93c2VyQXp0ZWNDb2RlUmVhZGVyIGV4dGVuZHMgQnJvd3NlckNvZGVSZWFkZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCcm93c2VyQXp0ZWNDb2RlUmVhZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVCZXR3ZWVuU2NhbnNNaWxsaXM9NTAwXSB0aGUgdGltZSBkZWxheSBiZXR3ZWVuIHN1YnNlcXVlbnQgZGVjb2RlIHRyaWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQXp0ZWNDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcih0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwKSB7XG4gICAgICAgICAgICBzdXBlcihuZXcgQXp0ZWNSZWFkZXIoKSwgdGltZUJldHdlZW5TY2Fuc01pbGxpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNhcHN1bGF0ZXMgZnVuY3Rpb25hbGl0eSBhbmQgaW1wbGVtZW50YXRpb24gdGhhdCBpcyBjb21tb24gdG8gYWxsIGZhbWlsaWVzXG4gICAgICogb2Ygb25lLWRpbWVuc2lvbmFsIGJhcmNvZGVzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIE9uZURSZWFkZXIge1xuICAgICAgICAvKlxuICAgICAgICBAT3ZlcnJpZGVcbiAgICAgICAgcHVibGljIFJlc3VsdCBkZWNvZGUoQmluYXJ5Qml0bWFwIGltYWdlKSB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZShpbWFnZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGRvbid0IHRyeSByb3RhdGlvbiB3aXRob3V0IHRoZSB0cnkgaGFyZGVyIGZsYWcsIGV2ZW4gaWYgcm90YXRpb24gd2FzIHN1cHBvcnRlZC5cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZShpbWFnZSwgaGludHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9EZWNvZGUoaW1hZ2UsIGhpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChuZmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cnlIYXJkZXIgPSBoaW50cyAmJiAoaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuVFJZX0hBUkRFUikgPT09IHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIgJiYgaW1hZ2UuaXNSb3RhdGVTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3RhdGVkSW1hZ2UgPSBpbWFnZS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZG9EZWNvZGUocm90YXRlZEltYWdlLCBoaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY29yZCB0aGF0IHdlIGZvdW5kIGl0IHJvdGF0ZWQgOTAgZGVncmVlcyBDQ1cgLyAyNzAgZGVncmVlcyBDV1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHJlc3VsdC5nZXRSZXN1bHRNZXRhZGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3JpZW50YXRpb24gPSAyNzA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSAhPT0gbnVsbCAmJiAobWV0YWRhdGEuZ2V0KFJlc3VsdE1ldGFkYXRhVHlwZSQxLk9SSUVOVEFUSU9OKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBpZiB3ZSBmb3VuZCBpdCByZXZlcnNlZCBpbiBkb0RlY29kZSgpLCBhZGQgaW4gdGhhdCByZXN1bHQgaGVyZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uID0gKG9yaWVudGF0aW9uICsgbWV0YWRhdGEuZ2V0KFJlc3VsdE1ldGFkYXRhVHlwZSQxLk9SSUVOVEFUSU9OKSAlIDM2MCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLk9SSUVOVEFUSU9OLCBvcmllbnRhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSByZXN1bHQgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IHJlc3VsdC5nZXRSZXN1bHRQb2ludHMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gcm90YXRlZEltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSBuZXcgUmVzdWx0UG9pbnQoaGVpZ2h0IC0gcG9pbnRzW2ldLmdldFkoKSAtIDEsIHBvaW50c1tpXS5nZXRYKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSdyZSBnb2luZyB0byBleGFtaW5lIHJvd3MgZnJvbSB0aGUgbWlkZGxlIG91dHdhcmQsIHNlYXJjaGluZyBhbHRlcm5hdGVseSBhYm92ZSBhbmQgYmVsb3cgdGhlXG4gICAgICAgICAqIG1pZGRsZSwgYW5kIGZhcnRoZXIgb3V0IGVhY2ggdGltZS4gcm93U3RlcCBpcyB0aGUgbnVtYmVyIG9mIHJvd3MgYmV0d2VlbiBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgICAgICogYXR0ZW1wdCBhYm92ZSBhbmQgYmVsb3cgdGhlIG1pZGRsZS4gU28gd2UnZCBzY2FuIHJvdyBtaWRkbGUsIHRoZW4gbWlkZGxlIC0gcm93U3RlcCwgdGhlblxuICAgICAgICAgKiBtaWRkbGUgKyByb3dTdGVwLCB0aGVuIG1pZGRsZSAtICgyICogcm93U3RlcCksIGV0Yy5cbiAgICAgICAgICogcm93U3RlcCBpcyBiaWdnZXIgYXMgdGhlIGltYWdlIGlzIHRhbGxlciwgYnV0IGlzIGFsd2F5cyBhdCBsZWFzdCAxLiBXZSd2ZSBzb21ld2hhdCBhcmJpdHJhcmlseVxuICAgICAgICAgKiBkZWNpZGVkIHRoYXQgbW92aW5nIHVwIGFuZCBkb3duIGJ5IGFib3V0IDEvMTYgb2YgdGhlIGltYWdlIGlzIHByZXR0eSBnb29kOyB3ZSB0cnkgbW9yZSBvZiB0aGVcbiAgICAgICAgICogaW1hZ2UgaWYgXCJ0cnlpbmcgaGFyZGVyXCIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBUaGUgaW1hZ2UgdG8gZGVjb2RlXG4gICAgICAgICAqIEBwYXJhbSBoaW50cyBBbnkgaGludHMgdGhhdCB3ZXJlIHJlcXVlc3RlZFxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBjb250ZW50cyBvZiB0aGUgZGVjb2RlZCBiYXJjb2RlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gQW55IHNwb250YW5lb3VzIGVycm9ycyB3aGljaCBvY2N1clxuICAgICAgICAgKi9cbiAgICAgICAgZG9EZWNvZGUoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGxldCByb3cgPSBuZXcgQml0QXJyYXkod2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgdHJ5SGFyZGVyID0gaGludHMgJiYgKGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlRSWV9IQVJERVIpID09PSB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHJvd1N0ZXAgPSBNYXRoLm1heCgxLCBoZWlnaHQgPj4gKHRyeUhhcmRlciA/IDggOiA1KSk7XG4gICAgICAgICAgICBsZXQgbWF4TGluZXM7XG4gICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgbWF4TGluZXMgPSBoZWlnaHQ7IC8vIExvb2sgYXQgdGhlIHdob2xlIGltYWdlLCBub3QganVzdCB0aGUgY2VudGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXhMaW5lcyA9IDE1OyAvLyAxNSByb3dzIHNwYWNlZCAxLzMyIGFwYXJ0IGlzIHJvdWdobHkgdGhlIG1pZGRsZSBoYWxmIG9mIHRoZSBpbWFnZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWlkZGxlID0gTWF0aC50cnVuYyhoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbWF4TGluZXM7IHgrKykge1xuICAgICAgICAgICAgICAgIC8vIFNjYW5uaW5nIGZyb20gdGhlIG1pZGRsZSBvdXQuIERldGVybWluZSB3aGljaCByb3cgd2UncmUgbG9va2luZyBhdCBuZXh0OlxuICAgICAgICAgICAgICAgIGNvbnN0IHJvd1N0ZXBzQWJvdmVPckJlbG93ID0gTWF0aC50cnVuYygoeCArIDEpIC8gMik7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBYm92ZSA9ICh4ICYgMHgwMSkgPT09IDA7IC8vIGkuZS4gaXMgeCBldmVuP1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd051bWJlciA9IG1pZGRsZSArIHJvd1N0ZXAgKiAoaXNBYm92ZSA/IHJvd1N0ZXBzQWJvdmVPckJlbG93IDogLXJvd1N0ZXBzQWJvdmVPckJlbG93KTtcbiAgICAgICAgICAgICAgICBpZiAocm93TnVtYmVyIDwgMCB8fCByb3dOdW1iZXIgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9vcHMsIGlmIHdlIHJ1biBvZmYgdGhlIHRvcCBvciBib3R0b20sIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVzdGltYXRlIGJsYWNrIHBvaW50IGZvciB0aGlzIHJvdyBhbmQgbG9hZCBpdDpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBpbWFnZS5nZXRCbGFja1Jvdyhyb3dOdW1iZXIsIHJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXaGlsZSB3ZSBoYXZlIHRoZSBpbWFnZSBkYXRhIGluIGEgQml0QXJyYXksIGl0J3MgZmFpcmx5IGNoZWFwIHRvIHJldmVyc2UgaXQgaW4gcGxhY2UgdG9cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZGVjb2RpbmcgdXBzaWRlIGRvd24gYmFyY29kZXMuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCAyOyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPT09IDEpIHsgLy8gdHJ5aW5nIGFnYWluP1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnJldmVyc2UoKTsgLy8gcmV2ZXJzZSB0aGUgcm93IGFuZCBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB3ZSB3aWxsIG9ubHkgZXZlciBkcmF3IHJlc3VsdCBwb2ludHMgKm9uY2UqIGluIHRoZSBsaWZlIG9mIHRoaXMgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSB3YW50IHRvIGF2b2lkIGRyYXdpbmcgdGhlIHdyb25nIHBvaW50cyBhZnRlciBmbGlwcGluZyB0aGUgcm93LCBhbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCB3YW50IHRvIGNsdXR0ZXIgd2l0aCBub2lzZSBmcm9tIGV2ZXJ5IHNpbmdsZSByb3cgc2NhbiAtLSBqdXN0IHRoZSBzY2Fuc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBzdGFydCBvbiB0aGUgY2VudGVyIGxpbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGludHMgJiYgKGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLk5FRURfUkVTVUxUX1BPSU5UX0NBTExCQUNLKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdIaW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaW50cy5mb3JFYWNoKChoaW50LCBrZXkpID0+IG5ld0hpbnRzLnNldChrZXksIGhpbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdIaW50cy5kZWxldGUoRGVjb2RlSGludFR5cGUkMS5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGludHMgPSBuZXdIaW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYSBiYXJjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgb3VyIGJhcmNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGl0IHdhcyB1cHNpZGUgZG93biwgc28gbm90ZSB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLk9SSUVOVEFUSU9OLCAxODApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZCByZW1lbWJlciB0byBmbGlwIHRoZSByZXN1bHQgcG9pbnRzIGhvcml6b250YWxseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSByZXN1bHQuZ2V0UmVzdWx0UG9pbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBuZXcgUmVzdWx0UG9pbnQod2lkdGggLSBwb2ludHNbMF0uZ2V0WCgpIC0gMSwgcG9pbnRzWzBdLmdldFkoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1sxXSA9IG5ldyBSZXN1bHRQb2ludCh3aWR0aCAtIHBvaW50c1sxXS5nZXRYKCkgLSAxLCBwb2ludHNbMV0uZ2V0WSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgLS0ganVzdCBjb3VsZG4ndCBkZWNvZGUgdGhpcyByb3dcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWNvcmRzIHRoZSBzaXplIG9mIHN1Y2Nlc3NpdmUgcnVucyBvZiB3aGl0ZSBhbmQgYmxhY2sgcGl4ZWxzIGluIGEgcm93LCBzdGFydGluZyBhdCBhIGdpdmVuIHBvaW50LlxuICAgICAgICAgKiBUaGUgdmFsdWVzIGFyZSByZWNvcmRlZCBpbiB0aGUgZ2l2ZW4gYXJyYXksIGFuZCB0aGUgbnVtYmVyIG9mIHJ1bnMgcmVjb3JkZWQgaXMgZXF1YWwgdG8gdGhlIHNpemVcbiAgICAgICAgICogb2YgdGhlIGFycmF5LiBJZiB0aGUgcm93IHN0YXJ0cyBvbiBhIHdoaXRlIHBpeGVsIGF0IHRoZSBnaXZlbiBzdGFydCBwb2ludCwgdGhlbiB0aGUgZmlyc3QgY291bnRcbiAgICAgICAgICogcmVjb3JkZWQgaXMgdGhlIHJ1biBvZiB3aGl0ZSBwaXhlbHMgc3RhcnRpbmcgZnJvbSB0aGF0IHBvaW50OyBsaWtld2lzZSBpdCBpcyB0aGUgY291bnQgb2YgYSBydW5cbiAgICAgICAgICogb2YgYmxhY2sgcGl4ZWxzIGlmIHRoZSByb3cgYmVnaW4gb24gYSBibGFjayBwaXhlbHMgYXQgdGhhdCBwb2ludC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvdyByb3cgdG8gY291bnQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gc3RhcnQgb2Zmc2V0IGludG8gcm93IHRvIHN0YXJ0IGF0XG4gICAgICAgICAqIEBwYXJhbSBjb3VudGVycyBhcnJheSBpbnRvIHdoaWNoIHRvIHJlY29yZCBjb3VudHNcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBjb3VudGVycyBjYW5ub3QgYmUgZmlsbGVkIGVudGlyZWx5IGZyb20gcm93IGJlZm9yZSBydW5uaW5nIG91dFxuICAgICAgICAgKiAgb2YgcGl4ZWxzXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcmVjb3JkUGF0dGVybihyb3csIHN0YXJ0LCBjb3VudGVycykge1xuICAgICAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbnVtQ291bnRlcnM7IGluZGV4KyspXG4gICAgICAgICAgICAgICAgY291bnRlcnNbaW5kZXhdID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaXNXaGl0ZSA9ICFyb3cuZ2V0KHN0YXJ0KTtcbiAgICAgICAgICAgIGxldCBjb3VudGVyUG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgbGV0IGkgPSBzdGFydDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoaSkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrY291bnRlclBvc2l0aW9uID09PSBudW1Db3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSByZWFkIGZ1bGx5IHRoZSBsYXN0IHNlY3Rpb24gb2YgcGl4ZWxzIGFuZCBmaWxsZWQgdXAgb3VyIGNvdW50ZXJzIC0tIG9yIGZpbGxlZFxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgY291bnRlciBidXQgcmFuIG9mZiB0aGUgc2lkZSBvZiB0aGUgaW1hZ2UsIE9LLiBPdGhlcndpc2UsIGEgcHJvYmxlbS5cbiAgICAgICAgICAgIGlmICghKGNvdW50ZXJQb3NpdGlvbiA9PT0gbnVtQ291bnRlcnMgfHwgKGNvdW50ZXJQb3NpdGlvbiA9PT0gbnVtQ291bnRlcnMgLSAxICYmIGkgPT09IGVuZCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHJlY29yZFBhdHRlcm5JblJldmVyc2Uocm93LCBzdGFydCwgY291bnRlcnMpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY291bGQgYmUgbW9yZSBlZmZpY2llbnQgSSBndWVzc1xuICAgICAgICAgICAgbGV0IG51bVRyYW5zaXRpb25zTGVmdCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gcm93LmdldChzdGFydCk7XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIG51bVRyYW5zaXRpb25zTGVmdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoLS1zdGFydCkgIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtVHJhbnNpdGlvbnNMZWZ0LS07XG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSAhbGFzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVtVHJhbnNpdGlvbnNMZWZ0ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9uZURSZWFkZXIucmVjb3JkUGF0dGVybihyb3csIHN0YXJ0ICsgMSwgY291bnRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGhvdyBjbG9zZWx5IGEgc2V0IG9mIG9ic2VydmVkIGNvdW50cyBvZiBydW5zIG9mIGJsYWNrL3doaXRlIHZhbHVlcyBtYXRjaGVzIGEgZ2l2ZW5cbiAgICAgICAgICogdGFyZ2V0IHBhdHRlcm4uIFRoaXMgaXMgcmVwb3J0ZWQgYXMgdGhlIHJhdGlvIG9mIHRoZSB0b3RhbCB2YXJpYW5jZSBmcm9tIHRoZSBleHBlY3RlZCBwYXR0ZXJuXG4gICAgICAgICAqIHByb3BvcnRpb25zIGFjcm9zcyBhbGwgcGF0dGVybiBlbGVtZW50cywgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcGF0dGVybi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvdW50ZXJzIG9ic2VydmVkIGNvdW50ZXJzXG4gICAgICAgICAqIEBwYXJhbSBwYXR0ZXJuIGV4cGVjdGVkIHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIG1heEluZGl2aWR1YWxWYXJpYW5jZSBUaGUgbW9zdCBhbnkgY291bnRlciBjYW4gZGlmZmVyIGJlZm9yZSB3ZSBnaXZlIHVwXG4gICAgICAgICAqIEByZXR1cm4gcmF0aW8gb2YgdG90YWwgdmFyaWFuY2UgYmV0d2VlbiBjb3VudGVycyBhbmQgcGF0dGVybiBjb21wYXJlZCB0byB0b3RhbCBwYXR0ZXJuIHNpemVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBwYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgcGF0dGVybiwgbWF4SW5kaXZpZHVhbFZhcmlhbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVybkxlbmd0aCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuTGVuZ3RoICs9IHBhdHRlcm5baV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG90YWwgPCBwYXR0ZXJuTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIG9uZSBwaXhlbCBwZXIgdW5pdCBvZiBiYXIgd2lkdGgsIGFzc3VtZSB0aGlzIGlzIHRvbyBzbWFsbFxuICAgICAgICAgICAgICAgIC8vIHRvIHJlbGlhYmx5IG1hdGNoLCBzbyBmYWlsOlxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1bml0QmFyV2lkdGggPSB0b3RhbCAvIHBhdHRlcm5MZW5ndGg7XG4gICAgICAgICAgICBtYXhJbmRpdmlkdWFsVmFyaWFuY2UgKj0gdW5pdEJhcldpZHRoO1xuICAgICAgICAgICAgbGV0IHRvdGFsVmFyaWFuY2UgPSAwLjA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG51bUNvdW50ZXJzOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudGVyID0gY291bnRlcnNbeF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVkUGF0dGVybiA9IHBhdHRlcm5beF0gKiB1bml0QmFyV2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFuY2UgPSBjb3VudGVyID4gc2NhbGVkUGF0dGVybiA/IGNvdW50ZXIgLSBzY2FsZWRQYXR0ZXJuIDogc2NhbGVkUGF0dGVybiAtIGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhbmNlID4gbWF4SW5kaXZpZHVhbFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvdGFsVmFyaWFuY2UgKz0gdmFyaWFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG90YWxWYXJpYW5jZSAvIHRvdGFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPHA+RGVjb2RlcyBDb2RlIDEyOCBiYXJjb2Rlcy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIENvZGUxMjhSZWFkZXIgZXh0ZW5kcyBPbmVEUmVhZGVyIHtcbiAgICAgICAgc3RhdGljIGZpbmRTdGFydFBhdHRlcm4ocm93KSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBjb25zdCByb3dPZmZzZXQgPSByb3cuZ2V0TmV4dFNldCgwKTtcbiAgICAgICAgICAgIGxldCBjb3VudGVyUG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gSW50MzJBcnJheS5mcm9tKFswLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5MZW5ndGggPSA2O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHJvd09mZnNldDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmdldChpKSAhPT0gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSAocGF0dGVybkxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmVzdFZhcmlhbmNlID0gQ29kZTEyOFJlYWRlci5NQVhfQVZHX1ZBUklBTkNFO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3RhcnRDb2RlID0gQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0E7IHN0YXJ0Q29kZSA8PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQzsgc3RhcnRDb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YXJpYW5jZSA9IE9uZURSZWFkZXIucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIENvZGUxMjhSZWFkZXIuQ09ERV9QQVRURVJOU1tzdGFydENvZGVdLCBDb2RlMTI4UmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFuY2UgPCBiZXN0VmFyaWFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IHN0YXJ0Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGZvciB3aGl0ZXNwYWNlIGJlZm9yZSBzdGFydCBwYXR0ZXJuLCA+PSA1MCUgb2Ygd2lkdGggb2Ygc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LmlzUmFuZ2UoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKGkgLSBwYXR0ZXJuU3RhcnQpIC8gMiksIHBhdHRlcm5TdGFydCwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbcGF0dGVyblN0YXJ0LCBpLCBiZXN0TWF0Y2hdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnMgPSBjb3VudGVycy5zbGljZSgyLCBjb3VudGVycy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbiAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNvZGVDb2RlKHJvdywgY291bnRlcnMsIHJvd09mZnNldCkge1xuICAgICAgICAgICAgT25lRFJlYWRlci5yZWNvcmRQYXR0ZXJuKHJvdywgcm93T2Zmc2V0LCBjb3VudGVycyk7XG4gICAgICAgICAgICBsZXQgYmVzdFZhcmlhbmNlID0gQ29kZTEyOFJlYWRlci5NQVhfQVZHX1ZBUklBTkNFOyAvLyB3b3JzdCB2YXJpYW5jZSB3ZSdsbCBhY2NlcHRcbiAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgQ29kZTEyOFJlYWRlci5DT0RFX1BBVFRFUk5TLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IENvZGUxMjhSZWFkZXIuQ09ERV9QQVRURVJOU1tkXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYW5jZSA9IHRoaXMucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIENvZGUxMjhSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYW5jZSA8IGJlc3RWYXJpYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0VmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPIFdlJ3JlIG92ZXJsb29raW5nIHRoZSBmYWN0IHRoYXQgdGhlIFNUT1AgcGF0dGVybiBoYXMgNyB2YWx1ZXMsIG5vdCA2LlxuICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRGTkMxID0gaGludHMgJiYgKGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLkFTU1VNRV9HUzEpID09PSB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UGF0dGVybkluZm8gPSBDb2RlMTI4UmVhZGVyLmZpbmRTdGFydFBhdHRlcm4ocm93KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q29kZSA9IHN0YXJ0UGF0dGVybkluZm9bMl07XG4gICAgICAgICAgICBsZXQgY3VycmVudFJhd0NvZGVzSW5kZXggPSAwO1xuICAgICAgICAgICAgY29uc3QgcmF3Q29kZXMgPSBuZXcgVWludDhBcnJheSgyMCk7XG4gICAgICAgICAgICByYXdDb2Rlc1tjdXJyZW50UmF3Q29kZXNJbmRleCsrXSA9IHN0YXJ0Q29kZTtcbiAgICAgICAgICAgIGxldCBjb2RlU2V0O1xuICAgICAgICAgICAgc3dpdGNoIChzdGFydENvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9BOlxuICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQjpcbiAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0M6XG4gICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGlzTmV4dFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGxldCBsYXN0U3RhcnQgPSBzdGFydFBhdHRlcm5JbmZvWzBdO1xuICAgICAgICAgICAgbGV0IG5leHRTdGFydCA9IHN0YXJ0UGF0dGVybkluZm9bMV07XG4gICAgICAgICAgICBjb25zdCBjb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgbGV0IGxhc3RDb2RlID0gMDtcbiAgICAgICAgICAgIGxldCBjb2RlID0gMDtcbiAgICAgICAgICAgIGxldCBjaGVja3N1bVRvdGFsID0gc3RhcnRDb2RlO1xuICAgICAgICAgICAgbGV0IG11bHRpcGxpZXIgPSAwO1xuICAgICAgICAgICAgbGV0IGxhc3RDaGFyYWN0ZXJXYXNQcmludGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bnNoaWZ0ID0gaXNOZXh0U2hpZnRlZDtcbiAgICAgICAgICAgICAgICBpc05leHRTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBvZmYgbGFzdCBjb2RlXG4gICAgICAgICAgICAgICAgbGFzdENvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIC8vIERlY29kZSBhbm90aGVyIGNvZGUgZnJvbSBpbWFnZVxuICAgICAgICAgICAgICAgIGNvZGUgPSBDb2RlMTI4UmVhZGVyLmRlY29kZUNvZGUocm93LCBjb3VudGVycywgbmV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICByYXdDb2Rlc1tjdXJyZW50UmF3Q29kZXNJbmRleCsrXSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgd2hldGhlciB0aGUgbGFzdCBjb2RlIHdhcyBwcmludGFibGUgb3Igbm90IChleGNsdWRpbmcgQ09ERV9TVE9QKVxuICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIGNoZWNrc3VtIGNvbXB1dGF0aW9uIChpZiBub3QgQ09ERV9TVE9QIG9mIGNvdXJzZSlcbiAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gQ29kZTEyOFJlYWRlci5DT0RFX1NUT1ApIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllcisrO1xuICAgICAgICAgICAgICAgICAgICBjaGVja3N1bVRvdGFsICs9IG11bHRpcGxpZXIgKiBjb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHdoZXJlIHRoZSBuZXh0IGNvZGUgd2lsbCB0byBzdGFydFxuICAgICAgICAgICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcbiAgICAgICAgICAgICAgICBuZXh0U3RhcnQgKz0gY291bnRlcnMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4gcHJldmlvdXMgKyBjdXJyZW50LCAwKTtcbiAgICAgICAgICAgICAgICAvLyBUYWtlIGNhcmUgb2YgaWxsZWdhbCBzdGFydCBjb2Rlc1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9BOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9COlxuICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGVTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPCA2NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGlmdFVwcGVyTW9kZSA9PT0gdXBwZXJNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnICcuY2hhckNvZGVBdCgwKSArIGNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnICcuY2hhckNvZGVBdCgwKSArIGNvZGUgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPCA5Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGlmdFVwcGVyTW9kZSA9PT0gdXBwZXJNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlIC0gNjQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlICsgNjQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGxldCBDT0RFX1NUT1AsIHdoaWNoIGFsd2F5cyBhcHBlYXJzLCBhZmZlY3Qgd2hldGhlciB3aGV0aGVyIHdlIHRoaW5rIHRoZSBsYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29kZSB3YXMgcHJpbnRhYmxlIG9yIG5vdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gQ29kZTEyOFJlYWRlci5DT0RFX1NUT1ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENoYXJhY3Rlcldhc1ByaW50YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udmVydEZOQzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHUzEgc3BlY2lmaWNhdGlvbiA1LjQuMy43LiBhbmQgNS40LjYuNC4gSWYgdGhlIGZpcnN0IGNoYXIgYWZ0ZXIgdGhlIHN0YXJ0IGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgRk5DMSB0aGVuIHRoaXMgaXMgR1MxLTEyOC4gV2UgYWRkIHRoZSBzeW1ib2xvZ3kgaWRlbnRpZmllci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICddQzEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR1MxIHNwZWNpZmljYXRpb24gNS40LjcuNS4gRXZlcnkgc3Vic2VxdWVudCBGTkMxIGlzIHJldHVybmVkIGFzIEFTQ0lJIDI5IChHUylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ180X0E6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVwcGVyTW9kZSAmJiBzaGlmdFVwcGVyTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVwcGVyTW9kZSAmJiBzaGlmdFVwcGVyTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05leHRTaGlmdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUT1A6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoaWZ0VXBwZXJNb2RlID09PSB1cHBlck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcgJy5jaGFyQ29kZUF0KDApICsgY29kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcgJy5jaGFyQ29kZUF0KDApICsgY29kZSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGFyYWN0ZXJXYXNQcmludGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18xOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnZlcnRGTkMxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR1MxIHNwZWNpZmljYXRpb24gNS40LjMuNy4gYW5kIDUuNC42LjQuIElmIHRoZSBmaXJzdCBjaGFyIGFmdGVyIHRoZSBzdGFydCBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIEZOQzEgdGhlbiB0aGlzIGlzIEdTMS0xMjguIFdlIGFkZCB0aGUgc3ltYm9sb2d5IGlkZW50aWZpZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXUMxJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdTMSBzcGVjaWZpY2F0aW9uIDUuNC43LjUuIEV2ZXJ5IHN1YnNlcXVlbnQgRk5DMSBpcyByZXR1cm5lZCBhcyBBU0NJSSAyOSAoR1MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfNF9COlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1cHBlck1vZGUgJiYgc2hpZnRVcHBlck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlck1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh1cHBlck1vZGUgJiYgc2hpZnRVcHBlck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOZXh0U2hpZnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGFyYWN0ZXJXYXNQcmludGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18xOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnZlcnRGTkMxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR1MxIHNwZWNpZmljYXRpb24gNS40LjMuNy4gYW5kIDUuNC42LjQuIElmIHRoZSBmaXJzdCBjaGFyIGFmdGVyIHRoZSBzdGFydCBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIEZOQzEgdGhlbiB0aGlzIGlzIEdTMS0xMjguIFdlIGFkZCB0aGUgc3ltYm9sb2d5IGlkZW50aWZpZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXUMxJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdTMSBzcGVjaWZpY2F0aW9uIDUuNC43LjUuIEV2ZXJ5IHN1YnNlcXVlbnQgRk5DMSBpcyByZXR1cm5lZCBhcyBBU0NJSSAyOSAoR1MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVuc2hpZnQgYmFjayB0byBhbm90aGVyIGNvZGUgc2V0IGlmIHdlIHdlcmUgc2hpZnRlZFxuICAgICAgICAgICAgICAgIGlmICh1bnNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBjb2RlU2V0ID09PSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BID8gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQiA6IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGFzdFBhdHRlcm5TaXplID0gbmV4dFN0YXJ0IC0gbGFzdFN0YXJ0O1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGFtcGxlIHdoaXRlc3BhY2UgZm9sbG93aW5nIHBhdHRlcm4sIGJ1dCwgdG8gZG8gdGhpcyB3ZSBmaXJzdCBuZWVkIHRvIHJlbWVtYmVyIHRoYXRcbiAgICAgICAgICAgIC8vIHdlIGZ1ZGdlZCBkZWNvZGluZyBDT0RFX1NUT1Agc2luY2UgaXQgYWN0dWFsbHkgaGFzIDcgYmFycywgbm90IDYuIFRoZXJlIGlzIGEgYmxhY2sgYmFyIGxlZnRcbiAgICAgICAgICAgIC8vIHRvIHJlYWQgb2ZmLiBXb3VsZCBiZSBzbGlnaHRseSBiZXR0ZXIgdG8gcHJvcGVybHkgcmVhZC4gSGVyZSB3ZSBqdXN0IHNraXAgaXQ6XG4gICAgICAgICAgICBuZXh0U3RhcnQgPSByb3cuZ2V0TmV4dFVuc2V0KG5leHRTdGFydCk7XG4gICAgICAgICAgICBpZiAoIXJvdy5pc1JhbmdlKG5leHRTdGFydCwgTWF0aC5taW4ocm93LmdldFNpemUoKSwgbmV4dFN0YXJ0ICsgKG5leHRTdGFydCAtIGxhc3RTdGFydCkgLyAyKSwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQdWxsIG91dCBmcm9tIHN1bSB0aGUgdmFsdWUgb2YgdGhlIHBlbnVsdGltYXRlIGNoZWNrIGNvZGVcbiAgICAgICAgICAgIGNoZWNrc3VtVG90YWwgLT0gbXVsdGlwbGllciAqIGxhc3RDb2RlO1xuICAgICAgICAgICAgLy8gbGFzdENvZGUgaXMgdGhlIGNoZWNrc3VtIHRoZW46XG4gICAgICAgICAgICBpZiAoY2hlY2tzdW1Ub3RhbCAlIDEwMyAhPT0gbGFzdENvZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2hlY2tzdW1FeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5lZWQgdG8gcHVsbCBvdXQgdGhlIGNoZWNrIGRpZ2l0cyBmcm9tIHN0cmluZ1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0TGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChyZXN1bHRMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBmYWxzZSBwb3NpdGl2ZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBib3RoZXIgaWYgdGhlIHJlc3VsdCBoYWQgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciwgYW5kIGlmIHRoZSBjaGVja3N1bSBkaWdpdCBoYXBwZW5lZCB0b1xuICAgICAgICAgICAgLy8gYmUgYSBwcmludGFibGUgY2hhcmFjdGVyLiBJZiBpdCB3YXMganVzdCBpbnRlcnByZXRlZCBhcyBhIGNvbnRyb2wgY29kZSwgbm90aGluZyB0byByZW1vdmUuXG4gICAgICAgICAgICBpZiAocmVzdWx0TGVuZ3RoID4gMCAmJiBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVTZXQgPT09IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygwLCByZXN1bHRMZW5ndGggLSAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMCwgcmVzdWx0TGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IChzdGFydFBhdHRlcm5JbmZvWzFdICsgc3RhcnRQYXR0ZXJuSW5mb1swXSkgLyAyLjA7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGxhc3RTdGFydCArIGxhc3RQYXR0ZXJuU2l6ZSAvIDIuMDtcbiAgICAgICAgICAgIGNvbnN0IHJhd0NvZGVzU2l6ZSA9IHJhd0NvZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHJhd0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkocmF3Q29kZXNTaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Q29kZXNTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICByYXdCeXRlc1tpXSA9IHJhd0NvZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW25ldyBSZXN1bHRQb2ludChsZWZ0LCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnQocmlnaHQsIHJvd051bWJlcildO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQocmVzdWx0LCByYXdCeXRlcywgMCwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0JDEuQ09ERV8xMjgsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfUEFUVEVSTlMgPSBbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMiwgMiwgMiwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDIsIDEsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAyLCAyLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgMiwgMiwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDMsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAyLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMiwgMiwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDIsIDMsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAyLCAyLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMiwgMSwgMiwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDMsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAxLCAyLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMiwgMiwgMywgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDIsIDEsIDMsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAyLCAyLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMywgMiwgMiwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDMsIDEsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAzLCAyLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMiwgMywgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDEsIDMsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCAyLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMywgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDMsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCAyLCAxLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMiwgMiwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDIsIDEsIDEsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAyLCAxLCAyLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMiwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDIsIDIsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAyLCAyLCAyLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMiwgMSwgMiwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDIsIDMsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAyLCAxLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMywgMiwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDEsIDEsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAzLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMiwgMywgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDIsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAyLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMSwgMywgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDMsIDEsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAxLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMiwgMSwgMywgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDMsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAyLCAxLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMywgMSwgMiwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDMsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAzLCAxLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMywgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDEsIDMsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAxLCAxLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMywgMSwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDMsIDMsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAzLCAxLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMSwgMiwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDMsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAzLCAxLCAxLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMiwgMSwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDIsIDMsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAzLCAyLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgNCwgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDQsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAzLCAxLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMiwgMiwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDQsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAxLCAxLCAyLCA0XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgNCwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDQsIDEsIDEsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA0LCAxLCAyLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMiwgMiwgMSwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDQsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAyLCAxLCAxLCA0XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMiwgNCwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDQsIDIsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA0LCAyLCAyLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgNCwgMSwgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDEsIDEsIDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAxLCAzLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgNCwgMSwgMSwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDQsIDEsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAyLCA0LCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgMSwgNCwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDIsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCA0LCAyLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgNCwgMSwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDQsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAxLCAxLCAyLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMiwgMSwgMSwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzQsIDIsIDEsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAyLCAxLCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgNCwgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzQsIDEsIDIsIDEsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCA0LCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMywgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDEsIDEsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCA0LCAxLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgNCwgMywgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzQsIDEsIDEsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAxLCAxLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMywgMSwgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDQsIDEsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCAxLCAxLCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMSwgMSwgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDEsIDQsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAxLCAyLCAxLCA0XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMSwgMiwgMywgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDMsIDMsIDEsIDEsIDEsIDJdKSxcbiAgICBdO1xuICAgIENvZGUxMjhSZWFkZXIuTUFYX0FWR19WQVJJQU5DRSA9IDAuMjU7XG4gICAgQ29kZTEyOFJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSA9IDAuNztcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfU0hJRlQgPSA5ODtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DID0gOTk7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQiA9IDEwMDtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BID0gMTAxO1xuICAgIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMSA9IDEwMjtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzIgPSA5NztcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzMgPSA5NjtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzRfQSA9IDEwMTtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzRfQiA9IDEwMDtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQSA9IDEwMztcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQiA9IDEwNDtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQyA9IDEwNTtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCA9IDEwNjtcblxuICAgIC8qKlxuICAgICAqIDxwPkRlY29kZXMgQ29kZSAzOSBiYXJjb2Rlcy4gU3VwcG9ydHMgXCJGdWxsIEFTQ0lJIENvZGUgMzlcIiBpZiBVU0VfQ09ERV8zOV9FWFRFTkRFRF9NT0RFIGlzIHNldC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBzZWUgQ29kZTkzUmVhZGVyXG4gICAgICovXG4gICAgY2xhc3MgQ29kZTM5UmVhZGVyIGV4dGVuZHMgT25lRFJlYWRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcmVhZGVyIHRoYXQgYXNzdW1lcyBhbGwgZW5jb2RlZCBkYXRhIGlzIGRhdGEsIGFuZCBkb2VzIG5vdCB0cmVhdCB0aGUgZmluYWxcbiAgICAgICAgICogY2hhcmFjdGVyIGFzIGEgY2hlY2sgZGlnaXQuIEl0IHdpbGwgbm90IGRlY29kZWQgXCJleHRlbmRlZCBDb2RlIDM5XCIgc2VxdWVuY2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIENvZGUzOVJlYWRlcigpIHtcbiAgICAgICAgLy8gICB0aGlzKGZhbHNlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHJlYWRlciB0aGF0IGNhbiBiZSBjb25maWd1cmVkIHRvIGNoZWNrIHRoZSBsYXN0IGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LlxuICAgICAgICAgKiBJdCB3aWxsIG5vdCBkZWNvZGVkIFwiZXh0ZW5kZWQgQ29kZSAzOVwiIHNlcXVlbmNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVzaW5nQ2hlY2tEaWdpdCBpZiB0cnVlLCB0cmVhdCB0aGUgbGFzdCBkYXRhIGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LCBub3RcbiAgICAgICAgICogZGF0YSwgYW5kIHZlcmlmeSB0aGF0IHRoZSBjaGVja3N1bSBwYXNzZXMuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgQ29kZTM5UmVhZGVyKGJvb2xlYW4gdXNpbmdDaGVja0RpZ2l0KSB7XG4gICAgICAgIC8vICAgdGhpcyh1c2luZ0NoZWNrRGlnaXQsIGZhbHNlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHJlYWRlciB0aGF0IGNhbiBiZSBjb25maWd1cmVkIHRvIGNoZWNrIHRoZSBsYXN0IGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LFxuICAgICAgICAgKiBvciBvcHRpb25hbGx5IGF0dGVtcHQgdG8gZGVjb2RlIFwiZXh0ZW5kZWQgQ29kZSAzOVwiIHNlcXVlbmNlcyB0aGF0IGFyZSB1c2VkIHRvIGVuY29kZVxuICAgICAgICAgKiB0aGUgZnVsbCBBU0NJSSBjaGFyYWN0ZXIgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdXNpbmdDaGVja0RpZ2l0IGlmIHRydWUsIHRyZWF0IHRoZSBsYXN0IGRhdGEgY2hhcmFjdGVyIGFzIGEgY2hlY2sgZGlnaXQsIG5vdFxuICAgICAgICAgKiBkYXRhLCBhbmQgdmVyaWZ5IHRoYXQgdGhlIGNoZWNrc3VtIHBhc3Nlcy5cbiAgICAgICAgICogQHBhcmFtIGV4dGVuZGVkTW9kZSBpZiB0cnVlLCB3aWxsIGF0dGVtcHQgdG8gZGVjb2RlIGV4dGVuZGVkIENvZGUgMzkgc2VxdWVuY2VzIGluIHRoZVxuICAgICAgICAgKiB0ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IodXNpbmdDaGVja0RpZ2l0ID0gZmFsc2UsIGV4dGVuZGVkTW9kZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy51c2luZ0NoZWNrRGlnaXQgPSB1c2luZ0NoZWNrRGlnaXQ7XG4gICAgICAgICAgICB0aGlzLmV4dGVuZGVkTW9kZSA9IGV4dGVuZGVkTW9kZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlUm93UmVzdWx0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJzID0gbmV3IEludDMyQXJyYXkoOSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICAgICAgbGV0IHRoZUNvdW50ZXJzID0gdGhpcy5jb3VudGVycztcbiAgICAgICAgICAgIHRoZUNvdW50ZXJzLmZpbGwoMCk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCA9ICcnO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gQ29kZTM5UmVhZGVyLmZpbmRBc3Rlcmlza1BhdHRlcm4ocm93LCB0aGVDb3VudGVycyk7XG4gICAgICAgICAgICAvLyBSZWFkIG9mZiB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgbGV0IG5leHRTdGFydCA9IHJvdy5nZXROZXh0U2V0KHN0YXJ0WzFdKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IGRlY29kZWRDaGFyO1xuICAgICAgICAgICAgbGV0IGxhc3RTdGFydDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBDb2RlMzlSZWFkZXIucmVjb3JkUGF0dGVybihyb3csIG5leHRTdGFydCwgdGhlQ291bnRlcnMpO1xuICAgICAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gQ29kZTM5UmVhZGVyLnRvTmFycm93V2lkZVBhdHRlcm4odGhlQ291bnRlcnMpO1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBDb2RlMzlSZWFkZXIucGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCArPSBkZWNvZGVkQ2hhcjtcbiAgICAgICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY291bnRlciBvZiB0aGVDb3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhcnQgKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVhZCBvZmYgd2hpdGUgc3BhY2VcbiAgICAgICAgICAgICAgICBuZXh0U3RhcnQgPSByb3cuZ2V0TmV4dFNldChuZXh0U3RhcnQpO1xuICAgICAgICAgICAgfSB3aGlsZSAoZGVjb2RlZENoYXIgIT09ICcqJyk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCA9IHRoaXMuZGVjb2RlUm93UmVzdWx0LnN1YnN0cmluZygwLCB0aGlzLmRlY29kZVJvd1Jlc3VsdC5sZW5ndGggLSAxKTsgLy8gcmVtb3ZlIGFzdGVyaXNrXG4gICAgICAgICAgICAvLyBMb29rIGZvciB3aGl0ZXNwYWNlIGFmdGVyIHBhdHRlcm46XG4gICAgICAgICAgICBsZXQgbGFzdFBhdHRlcm5TaXplID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgdGhlQ291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICBsYXN0UGF0dGVyblNpemUgKz0gY291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB3aGl0ZVNwYWNlQWZ0ZXJFbmQgPSBuZXh0U3RhcnQgLSBsYXN0U3RhcnQgLSBsYXN0UGF0dGVyblNpemU7XG4gICAgICAgICAgICAvLyBJZiA1MCUgb2YgbGFzdCBwYXR0ZXJuIHNpemUsIGZvbGxvd2luZyBsYXN0IHBhdHRlcm4sIGlzIG5vdCB3aGl0ZXNwYWNlLCBmYWlsXG4gICAgICAgICAgICAvLyAoYnV0IGlmIGl0J3Mgd2hpdGVzcGFjZSB0byB0aGUgdmVyeSBlbmQgb2YgdGhlIGltYWdlLCB0aGF0J3MgT0spXG4gICAgICAgICAgICBpZiAobmV4dFN0YXJ0ICE9PSBlbmQgJiYgKHdoaXRlU3BhY2VBZnRlckVuZCAqIDIpIDwgbGFzdFBhdHRlcm5TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy51c2luZ0NoZWNrRGlnaXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF4ID0gdGhpcy5kZWNvZGVSb3dSZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gQ29kZTM5UmVhZGVyLkFMUEhBQkVUX1NUUklORy5pbmRleE9mKHRoaXMuZGVjb2RlUm93UmVzdWx0LmNoYXJBdChpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlY29kZVJvd1Jlc3VsdC5jaGFyQXQobWF4KSAhPT0gQ29kZTM5UmVhZGVyLkFMUEhBQkVUX1NUUklORy5jaGFyQXQodG90YWwgJSA0MykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENoZWNrc3VtRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlUm93UmVzdWx0ID0gdGhpcy5kZWNvZGVSb3dSZXN1bHQuc3Vic3RyaW5nKDAsIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kZWNvZGVSb3dSZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFsc2UgcG9zaXRpdmVcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHRTdHJpbmc7XG4gICAgICAgICAgICBpZiAodGhpcy5leHRlbmRlZE1vZGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgPSBDb2RlMzlSZWFkZXIuZGVjb2RlRXh0ZW5kZWQodGhpcy5kZWNvZGVSb3dSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nID0gdGhpcy5kZWNvZGVSb3dSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGVmdCA9IChzdGFydFsxXSArIHN0YXJ0WzBdKSAvIDIuMDtcbiAgICAgICAgICAgIGxldCByaWdodCA9IGxhc3RTdGFydCArIGxhc3RQYXR0ZXJuU2l6ZSAvIDIuMDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0KHJlc3VsdFN0cmluZywgbnVsbCwgMCwgW25ldyBSZXN1bHRQb2ludChsZWZ0LCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnQocmlnaHQsIHJvd051bWJlcildLCBCYXJjb2RlRm9ybWF0JDEuQ09ERV8zOSwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmaW5kQXN0ZXJpc2tQYXR0ZXJuKHJvdywgY291bnRlcnMpIHtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgcm93T2Zmc2V0ID0gcm93LmdldE5leHRTZXQoMCk7XG4gICAgICAgICAgICBsZXQgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSByb3dPZmZzZXQ7XG4gICAgICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5MZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcm93T2Zmc2V0OyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuZ2V0KGkpICE9PSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IHBhdHRlcm5MZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGZvciB3aGl0ZXNwYWNlIGJlZm9yZSBzdGFydCBwYXR0ZXJuLCA+PSA1MCUgb2Ygd2lkdGggb2Ygc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG9OYXJyb3dXaWRlUGF0dGVybihjb3VudGVycykgPT09IENvZGUzOVJlYWRlci5BU1RFUklTS19FTkNPRElORyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5pc1JhbmdlKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtIE1hdGguZmxvb3IoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gMikpLCBwYXR0ZXJuU3RhcnQsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbcGF0dGVyblN0YXJ0LCBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnMuY29weVdpdGhpbigwLCAyLCAyICsgY291bnRlclBvc2l0aW9uIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgZWZmaWNpZW5jeSwgcmV0dXJucyAtMSBvbiBmYWlsdXJlLiBOb3QgdGhyb3dpbmcgaGVyZSBzYXZlZCBhcyBtYW55IGFzIDcwMCBleGNlcHRpb25zXG4gICAgICAgIC8vIHBlciBpbWFnZSB3aGVuIHVzaW5nIHNvbWUgb2Ygb3VyIGJsYWNrYm94IGltYWdlcy5cbiAgICAgICAgc3RhdGljIHRvTmFycm93V2lkZVBhdHRlcm4oY291bnRlcnMpIHtcbiAgICAgICAgICAgIGxldCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBtYXhOYXJyb3dDb3VudGVyID0gMDtcbiAgICAgICAgICAgIGxldCB3aWRlQ291bnRlcnM7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IG1pbkNvdW50ZXIgPSAweDdmZmZmZmZmO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgPCBtaW5Db3VudGVyICYmIGNvdW50ZXIgPiBtYXhOYXJyb3dDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5Db3VudGVyID0gY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXhOYXJyb3dDb3VudGVyID0gbWluQ291bnRlcjtcbiAgICAgICAgICAgICAgICB3aWRlQ291bnRlcnMgPSAwO1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbFdpZGVDb3VudGVyc1dpZHRoID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb3VudGVyID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyID4gbWF4TmFycm93Q291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiB8PSAxIDw8IChudW1Db3VudGVycyAtIDEgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZGVDb3VudGVycysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxXaWRlQ291bnRlcnNXaWR0aCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3aWRlQ291bnRlcnMgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgMyB3aWRlIGNvdW50ZXJzLCBidXQgYXJlIHRoZXkgY2xvc2UgZW5vdWdoIGluIHdpZHRoP1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gcGVyZm9ybSBhIGNoZWFwLCBjb25zZXJ2YXRpdmUgY2hlY2sgdG8gc2VlIGlmIGFueSBpbmRpdmlkdWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvdW50ZXIgaXMgbW9yZSB0aGFuIDEuNSB0aW1lcyB0aGUgYXZlcmFnZTpcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVycyAmJiB3aWRlQ291bnRlcnMgPiAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3VudGVyID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciA+IG1heE5hcnJvd0NvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRlQ291bnRlcnMtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0b3RhbFdpZGVDb3VudGVyc1dpZHRoID0gMyAqIGF2ZXJhZ2UsIHNvIHRoaXMgY2hlY2tzIGlmIGNvdW50ZXIgPj0gMy8yICogYXZlcmFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY291bnRlciAqIDIpID49IHRvdGFsV2lkZUNvdW50ZXJzV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICh3aWRlQ291bnRlcnMgPiAzKTtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcGF0dGVyblRvQ2hhcihwYXR0ZXJuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENvZGUzOVJlYWRlci5DSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKENvZGUzOVJlYWRlci5DSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb2RlMzlSZWFkZXIuQUxQSEFCRVRfU1RSSU5HLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0dGVybiA9PT0gQ29kZTM5UmVhZGVyLkFTVEVSSVNLX0VOQ09ESU5HKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcqJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNvZGVFeHRlbmRlZChlbmNvZGVkKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gZW5jb2RlZC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgZGVjb2RlZCA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjID0gZW5jb2RlZC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICcrJyB8fCBjID09PSAnJCcgfHwgYyA9PT0gJyUnIHx8IGMgPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGVuY29kZWQuY2hhckF0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlY29kZWRDaGFyID0gJ1xcMCc7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gK0EgdG8gK1ogbWFwIHRvIGEgdG8gelxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49ICdBJyAmJiBuZXh0IDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApICsgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRBIHRvICRaIG1hcCB0byBjb250cm9sIGNvZGVzIFNIIHRvIFNCXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gJ0EnICYmIG5leHQgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgLSA2NCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJUEgdG8gJUUgbWFwIHRvIGNvbnRyb2wgY29kZXMgRVNDIHRvIFVTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gJ0EnICYmIG5leHQgPD0gJ0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgLSAzOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gJ0YnICYmIG5leHQgPD0gJ0onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgLSAxMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gJ0snICYmIG5leHQgPD0gJ08nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgKyAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gJ1AnICYmIG5leHQgPD0gJ1QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgKyA0Myk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdVJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICdcXDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnVicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnQCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdXJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICdgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1gnIHx8IG5leHQgPT09ICdZJyB8fCBuZXh0ID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnXFx4N2YnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC9BIHRvIC9PIG1hcCB0byAhIHRvICwgYW5kIC9aIG1hcHMgdG8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49ICdBJyAmJiBuZXh0IDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApIC0gMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZWQgKz0gZGVjb2RlZENoYXI7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1bXAgdXAgaSBhZ2FpbiBzaW5jZSB3ZSByZWFkIHR3byBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZWQgKz0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb2RlMzlSZWFkZXIuQUxQSEFCRVRfU1RSSU5HID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi0uICQvKyUnO1xuICAgIC8qKlxuICAgICAqIFRoZXNlIHJlcHJlc2VudCB0aGUgZW5jb2RpbmdzIG9mIGNoYXJhY3RlcnMsIGFzIHBhdHRlcm5zIG9mIHdpZGUgYW5kIG5hcnJvdyBiYXJzLlxuICAgICAqIFRoZSA5IGxlYXN0LXNpZ25pZmljYW50IGJpdHMgb2YgZWFjaCBpbnQgY29ycmVzcG9uZCB0byB0aGUgcGF0dGVybiBvZiB3aWRlIGFuZCBuYXJyb3csXG4gICAgICogd2l0aCAxcyByZXByZXNlbnRpbmcgXCJ3aWRlXCIgYW5kIDBzIHJlcHJlc2VudGluZyBuYXJyb3cuXG4gICAgICovXG4gICAgQ29kZTM5UmVhZGVyLkNIQVJBQ1RFUl9FTkNPRElOR1MgPSBbXG4gICAgICAgIDB4MDM0LCAweDEyMSwgMHgwNjEsIDB4MTYwLCAweDAzMSwgMHgxMzAsIDB4MDcwLCAweDAyNSwgMHgxMjQsIDB4MDY0LFxuICAgICAgICAweDEwOSwgMHgwNDksIDB4MTQ4LCAweDAxOSwgMHgxMTgsIDB4MDU4LCAweDAwRCwgMHgxMEMsIDB4MDRDLCAweDAxQyxcbiAgICAgICAgMHgxMDMsIDB4MDQzLCAweDE0MiwgMHgwMTMsIDB4MTEyLCAweDA1MiwgMHgwMDcsIDB4MTA2LCAweDA0NiwgMHgwMTYsXG4gICAgICAgIDB4MTgxLCAweDBDMSwgMHgxQzAsIDB4MDkxLCAweDE5MCwgMHgwRDAsIDB4MDg1LCAweDE4NCwgMHgwQzQsIDB4MEE4LFxuICAgICAgICAweDBBMiwgMHgwOEEsIDB4MDJBIC8vIC8tJVxuICAgIF07XG4gICAgQ29kZTM5UmVhZGVyLkFTVEVSSVNLX0VOQ09ESU5HID0gMHgwOTQ7XG5cbiAgICAvKipcbiAgICAgKiA8cD5EZWNvZGVzIElURiBiYXJjb2Rlcy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFRqaWVjb1xuICAgICAqL1xuICAgIGNsYXNzIElURlJlYWRlciBleHRlbmRzIE9uZURSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vIHByaXZhdGUgc3RhdGljIFcgPSAzOyAvLyBQaXhlbCB3aWR0aCBvZiBhIDN4IHdpZGUgbGluZVxuICAgICAgICAgICAgLy8gcHJpdmF0ZSBzdGF0aWMgdyA9IDI7IC8vIFBpeGVsIHdpZHRoIG9mIGEgMnggd2lkZSBsaW5lXG4gICAgICAgICAgICAvLyBwcml2YXRlIHN0YXRpYyBOID0gMTsgLy8gUGl4ZWQgd2lkdGggb2YgYSBuYXJyb3cgbGluZVxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIFN0b3JlcyB0aGUgYWN0dWFsIG5hcnJvdyBsaW5lIHdpZHRoIG9mIHRoZSBpbWFnZSBiZWluZyBkZWNvZGVkLlxuICAgICAgICAgICAgdGhpcy5uYXJyb3dMaW5lV2lkdGggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgSVRGV3JpdGVyLlBBVFRFUk5TXG4gICAgICAgIC8qXG4gICAgICBcbiAgICAgICAgLyEqKlxuICAgICAgICAgKiBQYXR0ZXJucyBvZiBXaWRlIC8gTmFycm93IGxpbmVzIHRvIGluZGljYXRlIGVhY2ggZGlnaXRcbiAgICAgICAgICohL1xuICAgICAgICAqL1xuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgICAgICAvLyBGaW5kIG91dCB3aGVyZSB0aGUgTWlkZGxlIHNlY3Rpb24gKHBheWxvYWQpIHN0YXJ0cyAmIGVuZHNcbiAgICAgICAgICAgIGxldCBzdGFydFJhbmdlID0gdGhpcy5kZWNvZGVTdGFydChyb3cpO1xuICAgICAgICAgICAgbGV0IGVuZFJhbmdlID0gdGhpcy5kZWNvZGVFbmQocm93KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgSVRGUmVhZGVyLmRlY29kZU1pZGRsZShyb3csIHN0YXJ0UmFuZ2VbMV0sIGVuZFJhbmdlWzBdLCByZXN1bHQpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdFN0cmluZyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IGFsbG93ZWRMZW5ndGhzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChoaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dlZExlbmd0aHMgPSBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5BTExPV0VEX0xFTkdUSFMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbG93ZWRMZW5ndGhzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhbGxvd2VkTGVuZ3RocyA9IElURlJlYWRlci5ERUZBVUxUX0FMTE9XRURfTEVOR1RIUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlcyB3aXRoIDJEIGJhcmNvZGVzIChhbmQgb3RoZXIgcGF0dGVybnMpLCBtYWtlXG4gICAgICAgICAgICAvLyBhbiBhc3N1bXB0aW9uIHRoYXQgdGhlIGRlY29kZWQgc3RyaW5nIG11c3QgYmUgYSAnc3RhbmRhcmQnIGxlbmd0aCBpZiBpdCdzIHNob3J0XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gcmVzdWx0U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBsZW5ndGhPSyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG1heEFsbG93ZWRMZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgYWxsb3dlZExlbmd0aHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGhPSyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBtYXhBbGxvd2VkTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heEFsbG93ZWRMZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxlbmd0aE9LICYmIGxlbmd0aCA+IG1heEFsbG93ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGhPSyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxlbmd0aE9LKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW25ldyBSZXN1bHRQb2ludChzdGFydFJhbmdlWzFdLCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnQoZW5kUmFuZ2VbMF0sIHJvd051bWJlcildO1xuICAgICAgICAgICAgbGV0IHJlc3VsdFJldHVybiA9IG5ldyBSZXN1bHQocmVzdWx0U3RyaW5nLCBudWxsLCAvLyBubyBuYXR1cmFsIGJ5dGUgcmVwcmVzZW50YXRpb24gZm9yIHRoZXNlIGJhcmNvZGVzXG4gICAgICAgICAgICAwLCBwb2ludHMsIEJhcmNvZGVGb3JtYXQkMS5JVEYsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRSZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgLyEqKlxuICAgICAgICAgKiBAcGFyYW0gcm93ICAgICAgICAgIHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSBwYXlsb2FkU3RhcnQgb2Zmc2V0IG9mIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIHJlc3VsdFN0cmluZyB7QGxpbmsgU3RyaW5nQnVpbGRlcn0gdG8gYXBwZW5kIGRlY29kZWQgY2hhcnMgdG9cbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBkZWNvZGluZyBjb3VsZCBub3QgY29tcGxldGUgc3VjY2Vzc2Z1bGx5XG4gICAgICAgICAqIS8qL1xuICAgICAgICBzdGF0aWMgZGVjb2RlTWlkZGxlKHJvdywgcGF5bG9hZFN0YXJ0LCBwYXlsb2FkRW5kLCByZXN1bHRTdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIERpZ2l0cyBhcmUgaW50ZXJsZWF2ZWQgaW4gcGFpcnMgLSA1IGJsYWNrIGxpbmVzIGZvciBvbmUgZGlnaXQsIGFuZCB0aGVcbiAgICAgICAgICAgIC8vIDVcbiAgICAgICAgICAgIC8vIGludGVybGVhdmVkIHdoaXRlIGxpbmVzIGZvciB0aGUgc2Vjb25kIGRpZ2l0LlxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCBuZWVkIHRvIHNjYW4gMTAgbGluZXMgYW5kIHRoZW5cbiAgICAgICAgICAgIC8vIHNwbGl0IHRoZXNlIGludG8gdHdvIGFycmF5c1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJEaWdpdFBhaXIgPSBuZXcgSW50MzJBcnJheSgxMCk7IC8vIDEwXG4gICAgICAgICAgICBsZXQgY291bnRlckJsYWNrID0gbmV3IEludDMyQXJyYXkoNSk7IC8vIDVcbiAgICAgICAgICAgIGxldCBjb3VudGVyV2hpdGUgPSBuZXcgSW50MzJBcnJheSg1KTsgLy8gNVxuICAgICAgICAgICAgY291bnRlckRpZ2l0UGFpci5maWxsKDApO1xuICAgICAgICAgICAgY291bnRlckJsYWNrLmZpbGwoMCk7XG4gICAgICAgICAgICBjb3VudGVyV2hpdGUuZmlsbCgwKTtcbiAgICAgICAgICAgIHdoaWxlIChwYXlsb2FkU3RhcnQgPCBwYXlsb2FkRW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IDEwIHJ1bnMgb2YgYmxhY2svd2hpdGUuXG4gICAgICAgICAgICAgICAgT25lRFJlYWRlci5yZWNvcmRQYXR0ZXJuKHJvdywgcGF5bG9hZFN0YXJ0LCBjb3VudGVyRGlnaXRQYWlyKTtcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCB0aGVtIGludG8gZWFjaCBhcnJheVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgNTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0d29LID0gMiAqIGs7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJCbGFja1trXSA9IGNvdW50ZXJEaWdpdFBhaXJbdHdvS107XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJXaGl0ZVtrXSA9IGNvdW50ZXJEaWdpdFBhaXJbdHdvSyArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gSVRGUmVhZGVyLmRlY29kZURpZ2l0KGNvdW50ZXJCbGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nLmFwcGVuZChiZXN0TWF0Y2gudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gdGhpcy5kZWNvZGVEaWdpdChjb3VudGVyV2hpdGUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZy5hcHBlbmQoYmVzdE1hdGNoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJEaWdpdFBhaXIuZm9yRWFjaChmdW5jdGlvbiAoY291bnRlckRpZ2l0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWRTdGFydCArPSBjb3VudGVyRGlnaXQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyovISoqXG4gICAgICAgICAqIElkZW50aWZ5IHdoZXJlIHRoZSBzdGFydCBvZiB0aGUgbWlkZGxlIC8gcGF5bG9hZCBzZWN0aW9uIHN0YXJ0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvdyByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcmV0dXJuIEFycmF5LCBjb250YWluaW5nIGluZGV4IG9mIHN0YXJ0IG9mICdzdGFydCBibG9jaycgYW5kIGVuZCBvZlxuICAgICAgICAgKiAgICAgICAgICdzdGFydCBibG9jaydcbiAgICAgICAgICohLyovXG4gICAgICAgIGRlY29kZVN0YXJ0KHJvdykge1xuICAgICAgICAgICAgbGV0IGVuZFN0YXJ0ID0gSVRGUmVhZGVyLnNraXBXaGl0ZVNwYWNlKHJvdyk7XG4gICAgICAgICAgICBsZXQgc3RhcnRQYXR0ZXJuID0gSVRGUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4ocm93LCBlbmRTdGFydCwgSVRGUmVhZGVyLlNUQVJUX1BBVFRFUk4pO1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB3aWR0aCBvZiBhIG5hcnJvdyBsaW5lIGluIHBpeGVscy4gV2UgY2FuIGRvIHRoaXMgYnlcbiAgICAgICAgICAgIC8vIGdldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSBzdGFydCBwYXR0ZXJuIGFuZCBkaXZpZGluZyBieSA0IGJlY2F1c2UgaXRzXG4gICAgICAgICAgICAvLyBtYWRlIHVwIG9mIDQgbmFycm93IGxpbmVzLlxuICAgICAgICAgICAgdGhpcy5uYXJyb3dMaW5lV2lkdGggPSAoc3RhcnRQYXR0ZXJuWzFdIC0gc3RhcnRQYXR0ZXJuWzBdKSAvIDQ7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUXVpZXRab25lKHJvdywgc3RhcnRQYXR0ZXJuWzBdKTtcbiAgICAgICAgICAgIHJldHVybiBzdGFydFBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgLyovISoqXG4gICAgICAgICAqIFRoZSBzdGFydCAmIGVuZCBwYXR0ZXJucyBtdXN0IGJlIHByZS9wb3N0IGZpeGVkIGJ5IGEgcXVpZXQgem9uZS4gVGhpc1xuICAgICAgICAgKiB6b25lIG11c3QgYmUgYXQgbGVhc3QgMTAgdGltZXMgdGhlIHdpZHRoIG9mIGEgbmFycm93IGxpbmUuICBTY2FuIGJhY2sgdW50aWxcbiAgICAgICAgICogd2UgZWl0aGVyIGdldCB0byB0aGUgc3RhcnQgb2YgdGhlIGJhcmNvZGUgb3IgbWF0Y2ggdGhlIG5lY2Vzc2FyeSBudW1iZXIgb2ZcbiAgICAgICAgICogcXVpZXQgem9uZSBwaXhlbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IEl0cyBhc3N1bWVkIHRoZSByb3cgaXMgcmV2ZXJzZWQgd2hlbiB1c2luZyB0aGlzIG1ldGhvZCB0byBmaW5kXG4gICAgICAgICAqIHF1aWV0IHpvbmUgYWZ0ZXIgdGhlIGVuZCBwYXR0ZXJuLlxuICAgICAgICAgKlxuICAgICAgICAgKiByZWY6IGh0dHA6Ly93d3cuYmFyY29kZS0xLm5ldC9pMjVjb2RlLmh0bWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvdyBiaXQgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBzY2FubmVkIGJhcmNvZGUuXG4gICAgICAgICAqIEBwYXJhbSBzdGFydFBhdHRlcm4gaW5kZXggaW50byByb3cgb2YgdGhlIHN0YXJ0IG9yIGVuZCBwYXR0ZXJuLlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIHRoZSBxdWlldCB6b25lIGNhbm5vdCBiZSBmb3VuZFxuICAgICAgICAgKiEvKi9cbiAgICAgICAgdmFsaWRhdGVRdWlldFpvbmUocm93LCBzdGFydFBhdHRlcm4pIHtcbiAgICAgICAgICAgIGxldCBxdWlldENvdW50ID0gdGhpcy5uYXJyb3dMaW5lV2lkdGggKiAxMDsgLy8gZXhwZWN0IHRvIGZpbmQgdGhpcyBtYW55IHBpeGVscyBvZiBxdWlldCB6b25lXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm90IHNvIG1hbnkgcGl4ZWwgYXQgYWxsIGxldCdzIHRyeSBhcyBtYW55IGFzIHBvc3NpYmxlXG4gICAgICAgICAgICBxdWlldENvdW50ID0gcXVpZXRDb3VudCA8IHN0YXJ0UGF0dGVybiA/IHF1aWV0Q291bnQgOiBzdGFydFBhdHRlcm47XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRQYXR0ZXJuIC0gMTsgcXVpZXRDb3VudCA+IDAgJiYgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmdldChpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXVpZXRDb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHF1aWV0Q291bnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBVbmFibGUgdG8gZmluZCB0aGUgbmVjZXNzYXJ5IG51bWJlciBvZiBxdWlldCB6b25lIHBpeGVscy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAvISoqXG4gICAgICAgICAqIFNraXAgYWxsIHdoaXRlc3BhY2UgdW50aWwgd2UgZ2V0IHRvIHRoZSBmaXJzdCBibGFjayBsaW5lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcm93IHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXG4gICAgICAgICAqIEByZXR1cm4gaW5kZXggb2YgdGhlIGZpcnN0IGJsYWNrIGxpbmUuXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gVGhyb3dzIGV4Y2VwdGlvbiBpZiBubyBibGFjayBsaW5lcyBhcmUgZm91bmQgaW4gdGhlIHJvd1xuICAgICAgICAgKiEvKi9cbiAgICAgICAgc3RhdGljIHNraXBXaGl0ZVNwYWNlKHJvdykge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgZW5kU3RhcnQgPSByb3cuZ2V0TmV4dFNldCgwKTtcbiAgICAgICAgICAgIGlmIChlbmRTdGFydCA9PT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbmRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICAvKi8hKipcbiAgICAgICAgICogSWRlbnRpZnkgd2hlcmUgdGhlIGVuZCBvZiB0aGUgbWlkZGxlIC8gcGF5bG9hZCBzZWN0aW9uIGVuZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByb3cgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcbiAgICAgICAgICogQHJldHVybiBBcnJheSwgY29udGFpbmluZyBpbmRleCBvZiBzdGFydCBvZiAnZW5kIGJsb2NrJyBhbmQgZW5kIG9mICdlbmRcbiAgICAgICAgICogICAgICAgICBibG9jaydcbiAgICAgICAgICohLyovXG4gICAgICAgIGRlY29kZUVuZChyb3cpIHtcbiAgICAgICAgICAgIC8vIEZvciBjb252ZW5pZW5jZSwgcmV2ZXJzZSB0aGUgcm93IGFuZCB0aGVuXG4gICAgICAgICAgICAvLyBzZWFyY2ggZnJvbSAndGhlIHN0YXJ0JyBmb3IgdGhlIGVuZCBibG9ja1xuICAgICAgICAgICAgcm93LnJldmVyc2UoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFN0YXJ0ID0gSVRGUmVhZGVyLnNraXBXaGl0ZVNwYWNlKHJvdyk7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBhdHRlcm47XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZW5kUGF0dGVybiA9IElURlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKHJvdywgZW5kU3RhcnQsIElURlJlYWRlci5FTkRfUEFUVEVSTl9SRVZFUlNFRFswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUGF0dGVybiA9IElURlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKHJvdywgZW5kU3RhcnQsIElURlJlYWRlci5FTkRfUEFUVEVSTl9SRVZFUlNFRFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIHN0YXJ0ICYgZW5kIHBhdHRlcm5zIG11c3QgYmUgcHJlL3Bvc3QgZml4ZWQgYnkgYSBxdWlldCB6b25lLiBUaGlzXG4gICAgICAgICAgICAgICAgLy8gem9uZSBtdXN0IGJlIGF0IGxlYXN0IDEwIHRpbWVzIHRoZSB3aWR0aCBvZiBhIG5hcnJvdyBsaW5lLlxuICAgICAgICAgICAgICAgIC8vIHJlZjogaHR0cDovL3d3dy5iYXJjb2RlLTEubmV0L2kyNWNvZGUuaHRtbFxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVRdWlldFpvbmUocm93LCBlbmRQYXR0ZXJuWzBdKTtcbiAgICAgICAgICAgICAgICAvLyBOb3cgcmVjYWxjdWxhdGUgdGhlIGluZGljZXMgb2Ygd2hlcmUgdGhlICdlbmRibG9jaycgc3RhcnRzICYgc3RvcHMgdG9cbiAgICAgICAgICAgICAgICAvLyBhY2NvbW1vZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXZlcnNlZCBuYXR1cmUgb2YgdGhlIHNlYXJjaFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gZW5kUGF0dGVyblswXTtcbiAgICAgICAgICAgICAgICBlbmRQYXR0ZXJuWzBdID0gcm93LmdldFNpemUoKSAtIGVuZFBhdHRlcm5bMV07XG4gICAgICAgICAgICAgICAgZW5kUGF0dGVyblsxXSA9IHJvdy5nZXRTaXplKCkgLSB0ZW1wO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRQYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gUHV0IHRoZSByb3cgYmFjayB0aGUgcmlnaHQgd2F5LlxuICAgICAgICAgICAgICAgIHJvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgLyEqKlxuICAgICAgICAgKiBAcGFyYW0gcm93ICAgICAgIHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSByb3dPZmZzZXQgcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSBwYXR0ZXJuICAgcGF0dGVybiBvZiBjb3VudHMgb2YgbnVtYmVyIG9mIGJsYWNrIGFuZCB3aGl0ZSBwaXhlbHMgdGhhdCBhcmVcbiAgICAgICAgICogICAgICAgICAgICAgICAgICBiZWluZyBzZWFyY2hlZCBmb3IgYXMgYSBwYXR0ZXJuXG4gICAgICAgICAqIEByZXR1cm4gc3RhcnQvZW5kIGhvcml6b250YWwgb2Zmc2V0IG9mIGd1YXJkIHBhdHRlcm4sIGFzIGFuIGFycmF5IG9mIHR3b1xuICAgICAgICAgKiAgICAgICAgIGludHNcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBwYXR0ZXJuIGlzIG5vdCBmb3VuZFxuICAgICAgICAgKiEvKi9cbiAgICAgICAgc3RhdGljIGZpbmRHdWFyZFBhdHRlcm4ocm93LCByb3dPZmZzZXQsIHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuTGVuZ3RoID0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgY291bnRlcnMgPSBuZXcgSW50MzJBcnJheShwYXR0ZXJuTGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICAgICAgY291bnRlcnMuZmlsbCgwKTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSByb3dPZmZzZXQ7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoeCkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3NpdGlvbiA9PT0gcGF0dGVybkxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBJVEZSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpIDwgSVRGUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3BhdHRlcm5TdGFydCwgeF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoY291bnRlcnMsIDIsIGNvdW50ZXJzLCAwLCBjb3VudGVyUG9zaXRpb24gLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbiAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8qLyEqKlxuICAgICAgICAgKiBBdHRlbXB0cyB0byBkZWNvZGUgYSBzZXF1ZW5jZSBvZiBJVEYgYmxhY2svd2hpdGUgbGluZXMgaW50byBzaW5nbGVcbiAgICAgICAgICogZGlnaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb3VudGVycyB0aGUgY291bnRzIG9mIHJ1bnMgb2Ygb2JzZXJ2ZWQgYmxhY2svd2hpdGUvYmxhY2svLi4uIHZhbHVlc1xuICAgICAgICAgKiBAcmV0dXJuIFRoZSBkZWNvZGVkIGRpZ2l0XG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgZGlnaXQgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgICAgICohLyovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVEaWdpdChjb3VudGVycykge1xuICAgICAgICAgICAgbGV0IGJlc3RWYXJpYW5jZSA9IElURlJlYWRlci5NQVhfQVZHX1ZBUklBTkNFOyAvLyB3b3JzdCB2YXJpYW5jZSB3ZSdsbCBhY2NlcHRcbiAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSAtMTtcbiAgICAgICAgICAgIGxldCBtYXggPSBJVEZSZWFkZXIuUEFUVEVSTlMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gSVRGUmVhZGVyLlBBVFRFUk5TW2ldO1xuICAgICAgICAgICAgICAgIGxldCB2YXJpYW5jZSA9IE9uZURSZWFkZXIucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIElURlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhbmNlIDwgYmVzdFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RWYXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YXJpYW5jZSA9PT0gYmVzdFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGZpbmQgYSBzZWNvbmQgJ2Jlc3QgbWF0Y2gnIHdpdGggdGhlIHNhbWUgdmFyaWFuY2UsIHdlIGNhbiBub3QgcmVsaWFibHkgcmVwb3J0IHRvIGhhdmUgYSBzdWl0YWJsZSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmVzdE1hdGNoID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoICUgMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBJVEZSZWFkZXIuUEFUVEVSTlMgPSBbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMiwgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAyLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAxLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCAxLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMSwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDMsIDEsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMywgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDMsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAzLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDEsIDMsIDFdKSAvLyA5XG4gICAgXTtcbiAgICBJVEZSZWFkZXIuTUFYX0FWR19WQVJJQU5DRSA9IDAuMzg7XG4gICAgSVRGUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFID0gMC41O1xuICAgIC8qIC8hKiogVmFsaWQgSVRGIGxlbmd0aHMuIEFueXRoaW5nIGxvbmdlciB0aGFuIHRoZSBsYXJnZXN0IHZhbHVlIGlzIGFsc28gYWxsb3dlZC4gKiEvKi9cbiAgICBJVEZSZWFkZXIuREVGQVVMVF9BTExPV0VEX0xFTkdUSFMgPSBbNiwgOCwgMTAsIDEyLCAxNF07XG4gICAgLyovISoqXG4gICAgICogU3RhcnQvZW5kIGd1YXJkIHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGUgZW5kIHBhdHRlcm4gaXMgcmV2ZXJzZWQgYmVjYXVzZSB0aGUgcm93IGlzIHJldmVyc2VkIGJlZm9yZVxuICAgICAqIHNlYXJjaGluZyBmb3IgdGhlIEVORF9QQVRURVJOXG4gICAgICohLyovXG4gICAgSVRGUmVhZGVyLlNUQVJUX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDFdKTtcbiAgICBJVEZSZWFkZXIuRU5EX1BBVFRFUk5fUkVWRVJTRUQgPSBbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDNdKSAvLyAzeFxuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgZnVuY3Rpb25hbGl0eSBhbmQgaW1wbGVtZW50YXRpb24gdGhhdCBpcyBjb21tb24gdG8gVVBDIGFuZCBFQU4gZmFtaWxpZXNcbiAgICAgKiBvZiBvbmUtZGltZW5zaW9uYWwgYmFyY29kZXMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgYWxhc2RhaXJAZ29vZ2xlLmNvbSAoQWxhc2RhaXIgTWFja2ludG9zaClcbiAgICAgKi9cbiAgICBjbGFzcyBBYnN0cmFjdFVQQ0VBTlJlYWRlciBleHRlbmRzIE9uZURSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlciA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGZpbmRTdGFydEd1YXJkUGF0dGVybihyb3cpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZFN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc3RhcnRSYW5nZTtcbiAgICAgICAgICAgIGxldCBuZXh0U3RhcnQgPSAwO1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSk7XG4gICAgICAgICAgICB3aGlsZSAoIWZvdW5kU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pO1xuICAgICAgICAgICAgICAgIHN0YXJ0UmFuZ2UgPSBBYnN0cmFjdFVQQ0VBTlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKHJvdywgbmV4dFN0YXJ0LCBmYWxzZSwgdGhpcy5TVEFSVF9FTkRfUEFUVEVSTiwgY291bnRlcnMpO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHN0YXJ0UmFuZ2VbMF07XG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ID0gc3RhcnRSYW5nZVsxXTtcbiAgICAgICAgICAgICAgICBsZXQgcXVpZXRTdGFydCA9IHN0YXJ0IC0gKG5leHRTdGFydCAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAocXVpZXRTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kU3RhcnQgPSByb3cuaXNSYW5nZShxdWlldFN0YXJ0LCBzdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFydFJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaGVja0NoZWNrc3VtKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBBYnN0cmFjdFVQQ0VBTlJlYWRlci5jaGVja1N0YW5kYXJkVVBDRUFOQ2hlY2tzdW0ocyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNoZWNrU3RhbmRhcmRVUENFQU5DaGVja3N1bShzKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjaGVjayA9IHBhcnNlSW50KHMuY2hhckF0KGxlbmd0aCAtIDEpLCAxMCk7XG4gICAgICAgICAgICByZXR1cm4gQWJzdHJhY3RVUENFQU5SZWFkZXIuZ2V0U3RhbmRhcmRVUENFQU5DaGVja3N1bShzLnN1YnN0cmluZygwLCBsZW5ndGggLSAxKSkgPT09IGNoZWNrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRTdGFuZGFyZFVQQ0VBTkNoZWNrc3VtKHMpIHtcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSBzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpZ2l0ID0gcy5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGlmIChkaWdpdCA8IDAgfHwgZGlnaXQgPiA5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtICs9IGRpZ2l0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtICo9IDM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlnaXQgPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZ2l0IDwgMCB8fCBkaWdpdCA+IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdW0gKz0gZGlnaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDEwMDAgLSBzdW0pICUgMTA7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlY29kZUVuZChyb3csIGVuZFN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gQWJzdHJhY3RVUENFQU5SZWFkZXIuZmluZEd1YXJkUGF0dGVybihyb3csIGVuZFN0YXJ0LCBmYWxzZSwgQWJzdHJhY3RVUENFQU5SZWFkZXIuU1RBUlRfRU5EX1BBVFRFUk4sIG5ldyBJbnQzMkFycmF5KEFic3RyYWN0VVBDRUFOUmVhZGVyLlNUQVJUX0VORF9QQVRURVJOLmxlbmd0aCkuZmlsbCgwKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmaW5kR3VhcmRQYXR0ZXJuV2l0aG91dENvdW50ZXJzKHJvdywgcm93T2Zmc2V0LCB3aGl0ZUZpcnN0LCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kR3VhcmRQYXR0ZXJuKHJvdywgcm93T2Zmc2V0LCB3aGl0ZUZpcnN0LCBwYXR0ZXJuLCBuZXcgSW50MzJBcnJheShwYXR0ZXJuLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gcm93IHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSByb3dPZmZzZXQgcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSB3aGl0ZUZpcnN0IGlmIHRydWUsIGluZGljYXRlcyB0aGF0IHRoZSBwYXR0ZXJuIHNwZWNpZmllcyB3aGl0ZS9ibGFjay93aGl0ZS8uLi5cbiAgICAgICAgICogcGl4ZWwgY291bnRzLCBvdGhlcndpc2UsIGl0IGlzIGludGVycHJldGVkIGFzIGJsYWNrL3doaXRlL2JsYWNrLy4uLlxuICAgICAgICAgKiBAcGFyYW0gcGF0dGVybiBwYXR0ZXJuIG9mIGNvdW50cyBvZiBudW1iZXIgb2YgYmxhY2sgYW5kIHdoaXRlIHBpeGVscyB0aGF0IGFyZSBiZWluZ1xuICAgICAgICAgKiBzZWFyY2hlZCBmb3IgYXMgYSBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBjb3VudGVycyBhcnJheSBvZiBjb3VudGVycywgYXMgbG9uZyBhcyBwYXR0ZXJuLCB0byByZS11c2VcbiAgICAgICAgICogQHJldHVybiBzdGFydC9lbmQgaG9yaXpvbnRhbCBvZmZzZXQgb2YgZ3VhcmQgcGF0dGVybiwgYXMgYW4gYXJyYXkgb2YgdHdvIGludHNcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBwYXR0ZXJuIGlzIG5vdCBmb3VuZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZpbmRHdWFyZFBhdHRlcm4ocm93LCByb3dPZmZzZXQsIHdoaXRlRmlyc3QsIHBhdHRlcm4sIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgcm93T2Zmc2V0ID0gd2hpdGVGaXJzdCA/IHJvdy5nZXROZXh0VW5zZXQocm93T2Zmc2V0KSA6IHJvdy5nZXROZXh0U2V0KHJvd09mZnNldCk7XG4gICAgICAgICAgICBsZXQgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSByb3dPZmZzZXQ7XG4gICAgICAgICAgICBsZXQgcGF0dGVybkxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGlzV2hpdGUgPSB3aGl0ZUZpcnN0O1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IHJvd09mZnNldDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmdldCh4KSAhPT0gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSBwYXR0ZXJuTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9uZURSZWFkZXIucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIEFic3RyYWN0VVBDRUFOUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKSA8IEFic3RyYWN0VVBDRUFOUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSW50MzJBcnJheS5mcm9tKFtwYXR0ZXJuU3RhcnQsIHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNsaWNlID0gY291bnRlcnMuc2xpY2UoMiwgY291bnRlcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXJQb3NpdGlvbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2ldID0gc2xpY2VbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBwYXR0ZXJucykge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRQYXR0ZXJuKHJvdywgcm93T2Zmc2V0LCBjb3VudGVycyk7XG4gICAgICAgICAgICBsZXQgYmVzdFZhcmlhbmNlID0gdGhpcy5NQVhfQVZHX1ZBUklBTkNFO1xuICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IC0xO1xuICAgICAgICAgICAgbGV0IG1heCA9IHBhdHRlcm5zLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IHBhdHRlcm5zW2ldO1xuICAgICAgICAgICAgICAgIGxldCB2YXJpYW5jZSA9IE9uZURSZWFkZXIucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIEFic3RyYWN0VVBDRUFOUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFuY2UgPCBiZXN0VmFyaWFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoZXNlIHR3byB2YWx1ZXMgYXJlIGNyaXRpY2FsIGZvciBkZXRlcm1pbmluZyBob3cgcGVybWlzc2l2ZSB0aGUgZGVjb2Rpbmcgd2lsbCBiZS5cbiAgICAvLyBXZSd2ZSBhcnJpdmVkIGF0IHRoZXNlIHZhbHVlcyB0aHJvdWdoIGEgbG90IG9mIHRyaWFsIGFuZCBlcnJvci4gU2V0dGluZyB0aGVtIGFueSBoaWdoZXJcbiAgICAvLyBsZXRzIGZhbHNlIHBvc2l0aXZlcyBjcmVlcCBpbiBxdWlja2x5LlxuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UgPSAwLjQ4O1xuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFID0gMC43O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0L2VuZCBndWFyZCBwYXR0ZXJuLlxuICAgICAqL1xuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLlNUQVJUX0VORF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxXSk7XG4gICAgLyoqXG4gICAgICogUGF0dGVybiBtYXJraW5nIHRoZSBtaWRkbGUgb2YgYSBVUEMvRUFOIHBhdHRlcm4sIHNlcGFyYXRpbmcgdGhlIHR3byBoYWx2ZXMuXG4gICAgICovXG4gICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuTUlERExFX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDEsIDFdKTtcbiAgICAvKipcbiAgICAgKiBlbmQgZ3VhcmQgcGF0dGVybi5cbiAgICAgKi9cbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5FTkRfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMSwgMSwgMV0pO1xuICAgIC8qKlxuICAgICAqIFwiT2RkXCIsIG9yIFwiTFwiIHBhdHRlcm5zIHVzZWQgdG8gZW5jb2RlIFVQQy9FQU4gZGlnaXRzLlxuICAgICAqL1xuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLkxfUEFUVEVSTlMgPSBbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgNCwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMl0pLFxuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIFVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0XG4gICAgICovXG4gICAgY2xhc3MgVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuQ0hFQ0tfRElHSVRfRU5DT0RJTkdTID0gWzB4MTgsIDB4MTQsIDB4MTIsIDB4MTEsIDB4MEMsIDB4MDYsIDB4MDMsIDB4MEEsIDB4MDksIDB4MDVdO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXIgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGV4dGVuc2lvblN0YXJ0UmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlcjtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLmRlY29kZU1pZGRsZShyb3csIGV4dGVuc2lvblN0YXJ0UmFuZ2UsIHJlc3VsdCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0U3RyaW5nID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uRGF0YSA9IFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0LnBhcnNlRXh0ZW5zaW9uU3RyaW5nKHJlc3VsdFN0cmluZyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0UG9pbnRzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCgoZXh0ZW5zaW9uU3RhcnRSYW5nZVswXSArIGV4dGVuc2lvblN0YXJ0UmFuZ2VbMV0pIC8gMi4wLCByb3dOdW1iZXIpLFxuICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludChlbmQsIHJvd051bWJlcilcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uUmVzdWx0ID0gbmV3IFJlc3VsdChyZXN1bHRTdHJpbmcsIG51bGwsIDAsIHJlc3VsdFBvaW50cywgQmFyY29kZUZvcm1hdCQxLlVQQ19FQU5fRVhURU5TSU9OLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uUmVzdWx0LnB1dEFsbE1ldGFkYXRhKGV4dGVuc2lvbkRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvblJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlLCByZXN1bHRTdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnM7XG4gICAgICAgICAgICBjb3VudGVyc1swXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1sxXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1syXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1szXSA9IDA7XG4gICAgICAgICAgICBsZXQgZW5kID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCByb3dPZmZzZXQgPSBzdGFydFJhbmdlWzFdO1xuICAgICAgICAgICAgbGV0IGxnUGF0dGVybkZvdW5kID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNSAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSBBYnN0cmFjdFVQQ0VBTlJlYWRlci5kZWNvZGVEaWdpdChcbiAgICAgICAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICAgICAgICBjb3VudGVycyxcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5MX0FORF9HX1BBVFRFUk5TKTtcbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJzAnLmNoYXJDb2RlQXQoMCkgKyBiZXN0TWF0Y2ggJSAxMCkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgbGdQYXR0ZXJuRm91bmQgfD0gMSA8PCAoNCAtIHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeCAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIG9mZiBzZXBhcmF0b3IgaWYgbm90IGxhc3RcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gcm93LmdldE5leHRTZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gcm93LmdldE5leHRVbnNldChyb3dPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHRTdHJpbmcubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hlY2tEaWdpdCA9IHRoaXMuZGV0ZXJtaW5lQ2hlY2tEaWdpdChsZ1BhdHRlcm5Gb3VuZCk7XG4gICAgICAgICAgICBpZiAoVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQuZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0U3RyaW5nLnRvU3RyaW5nKCkpICE9PSBjaGVja0RpZ2l0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBleHRlbnNpb25DaGVja3N1bShzKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgICAgIHN1bSArPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gKj0gMztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgICAgIHN1bSArPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gKj0gMztcbiAgICAgICAgICAgIHJldHVybiBzdW0gJSAxMDtcbiAgICAgICAgfVxuICAgICAgICBkZXRlcm1pbmVDaGVja0RpZ2l0KGxnUGF0dGVybkZvdW5kKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDEwOyBkKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGdQYXR0ZXJuRm91bmQgPT09IHRoaXMuQ0hFQ0tfRElHSVRfRU5DT0RJTkdTW2RdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBwYXJzZUV4dGVuc2lvblN0cmluZyhyYXcpIHtcbiAgICAgICAgICAgIGlmIChyYXcubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBVUENFQU5FeHRlbnNpb241U3VwcG9ydC5wYXJzZUV4dGVuc2lvbjVTdHJpbmcocmF3KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcChbW1Jlc3VsdE1ldGFkYXRhVHlwZSQxLlNVR0dFU1RFRF9QUklDRSwgdmFsdWVdXSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHBhcnNlRXh0ZW5zaW9uNVN0cmluZyhyYXcpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeTtcbiAgICAgICAgICAgIHN3aXRjaCAocmF3LmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeSA9ICfCoyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzUnOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeSA9ICckJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZTogaHR0cDovL3d3dy5qb2xseXRlY2guY29tXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmF3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc5MDAwMCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gc3VnZ2VzdGVkIHJldGFpbCBwcmljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOTk5OTEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBsZW1lbnRhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzAuMDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOTk5OTAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnVXNlZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLi4uIHVua25vd24gY3VycmVuY3k/XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJhd0Ftb3VudCA9IHBhcnNlSW50KHJhdy5zdWJzdHJpbmcoMSkpO1xuICAgICAgICAgICAgbGV0IHVuaXRzU3RyaW5nID0gKHJhd0Ftb3VudCAvIDEwMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBodW5kcmVkdGhzID0gcmF3QW1vdW50ICUgMTAwO1xuICAgICAgICAgICAgbGV0IGh1bmRyZWR0aHNTdHJpbmcgPSBodW5kcmVkdGhzIDwgMTAgPyAnMCcgKyBodW5kcmVkdGhzIDogaHVuZHJlZHRocy50b1N0cmluZygpOyAvLyBmaXhtZVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbmN5ICsgdW5pdHNTdHJpbmcgKyAnLicgKyBodW5kcmVkdGhzU3RyaW5nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBVUENFQU5FeHRlbnNpb241U3VwcG9ydFxuICAgICAqL1xuICAgIGNsYXNzIFVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzID0gSW50MzJBcnJheS5mcm9tKFswLCAwLCAwLCAwXSk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlciA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgZXh0ZW5zaW9uU3RhcnRSYW5nZSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMuZGVjb2RlTWlkZGxlKHJvdywgZXh0ZW5zaW9uU3RhcnRSYW5nZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIGxldCByZXN1bHRTdHJpbmcgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb25EYXRhID0gVVBDRUFORXh0ZW5zaW9uMlN1cHBvcnQucGFyc2VFeHRlbnNpb25TdHJpbmcocmVzdWx0U3RyaW5nKTtcbiAgICAgICAgICAgIGxldCByZXN1bHRQb2ludHMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50KChleHRlbnNpb25TdGFydFJhbmdlWzBdICsgZXh0ZW5zaW9uU3RhcnRSYW5nZVsxXSkgLyAyLjAsIHJvd051bWJlciksXG4gICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50KGVuZCwgcm93TnVtYmVyKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb25SZXN1bHQgPSBuZXcgUmVzdWx0KHJlc3VsdFN0cmluZywgbnVsbCwgMCwgcmVzdWx0UG9pbnRzLCBCYXJjb2RlRm9ybWF0JDEuVVBDX0VBTl9FWFRFTlNJT04sIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb25EYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25SZXN1bHQucHV0QWxsTWV0YWRhdGEoZXh0ZW5zaW9uRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZU1pZGRsZShyb3csIHN0YXJ0UmFuZ2UsIHJlc3VsdFN0cmluZykge1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycztcbiAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgIGxldCBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IHJvd09mZnNldCA9IHN0YXJ0UmFuZ2VbMV07XG4gICAgICAgICAgICBsZXQgY2hlY2tQYXJpdHkgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAyICYmIHJvd09mZnNldCA8IGVuZDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IEFic3RyYWN0VVBDRUFOUmVhZGVyLmRlY29kZURpZ2l0KHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgQWJzdHJhY3RVUENFQU5SZWFkZXIuTF9BTkRfR19QQVRURVJOUyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoICUgMTApKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoID49IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrUGFyaXR5IHw9IDEgPDwgKDEgLSB4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBvZmYgc2VwYXJhdG9yIGlmIG5vdCBsYXN0XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IHJvdy5nZXROZXh0U2V0KHJvd09mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IHJvdy5nZXROZXh0VW5zZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0U3RyaW5nLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlSW50KHJlc3VsdFN0cmluZy50b1N0cmluZygpKSAlIDQgIT09IGNoZWNrUGFyaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBwYXJzZUV4dGVuc2lvblN0cmluZyhyYXcpIHtcbiAgICAgICAgICAgIGlmIChyYXcubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcChbW1Jlc3VsdE1ldGFkYXRhVHlwZSQxLklTU1VFX05VTUJFUiwgcGFyc2VJbnQocmF3KV1dKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIFVQQ0VBTkV4dGVuc2lvblN1cHBvcnQge1xuICAgICAgICBzdGF0aWMgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCByb3dPZmZzZXQpIHtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb25TdGFydFJhbmdlID0gQWJzdHJhY3RVUENFQU5SZWFkZXIuZmluZEd1YXJkUGF0dGVybihcbiAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHRoaXMuRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4sXG4gICAgICAgICAgICAgICAgbmV3IEludDMyQXJyYXkodGhpcy5FWFRFTlNJT05fU1RBUlRfUEFUVEVSTi5sZW5ndGgpLmZpbGwoMCkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgZml2ZVN1cHBvcnQgPSBuZXcgVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml2ZVN1cHBvcnQuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBleHRlbnNpb25TdGFydFJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgdHdvU3VwcG9ydCA9IG5ldyBVUENFQU5FeHRlbnNpb24yU3VwcG9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0d29TdXBwb3J0LmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgZXh0ZW5zaW9uU3RhcnRSYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgVVBDRUFORXh0ZW5zaW9uU3VwcG9ydC5FWFRFTlNJT05fU1RBUlRfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbMSwgMSwgMl0pO1xuXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGZ1bmN0aW9uYWxpdHkgYW5kIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgY29tbW9uIHRvIFVQQyBhbmQgRUFOIGZhbWlsaWVzXG4gICAgICogb2Ygb25lLWRpbWVuc2lvbmFsIGJhcmNvZGVzLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIGFsYXNkYWlyQGdvb2dsZS5jb20gKEFsYXNkYWlyIE1hY2tpbnRvc2gpXG4gICAgICovXG4gICAgY2xhc3MgVVBDRUFOUmVhZGVyIGV4dGVuZHMgQWJzdHJhY3RVUENFQU5SZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlciA9ICcnO1xuICAgICAgICAgICAgVVBDRUFOUmVhZGVyLkxfQU5EX0dfUEFUVEVSTlMgPSBVUENFQU5SZWFkZXIuTF9QQVRURVJOUy5tYXAoYXJyID0+IEludDMyQXJyYXkuZnJvbShhcnIpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxMDsgaSA8IDIwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgd2lkdGhzID0gVVBDRUFOUmVhZGVyLkxfUEFUVEVSTlNbaSAtIDEwXTtcbiAgICAgICAgICAgICAgICBsZXQgcmV2ZXJzZWRXaWR0aHMgPSBuZXcgSW50MzJBcnJheSh3aWR0aHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlZFdpZHRoc1tqXSA9IHdpZHRoc1t3aWR0aHMubGVuZ3RoIC0gaiAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBVUENFQU5SZWFkZXIuTF9BTkRfR19QQVRURVJOU1tpXSA9IHJldmVyc2VkV2lkdGhzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydEd1YXJkUmFuZ2UgPSBVUENFQU5SZWFkZXIuZmluZFN0YXJ0R3VhcmRQYXR0ZXJuKHJvdyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0UG9pbnRDYWxsYmFjayA9IGhpbnRzID09IG51bGwgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0spO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFBvaW50Q2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdFBvaW50ID0gbmV3IFJlc3VsdFBvaW50KChzdGFydEd1YXJkUmFuZ2VbMF0gKyBzdGFydEd1YXJkUmFuZ2VbMV0pIC8gMi4wLCByb3dOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFBvaW50Q2FsbGJhY2suZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KHJlc3VsdFBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBidWRlbGxvID0gdGhpcy5kZWNvZGVNaWRkbGUocm93LCBzdGFydEd1YXJkUmFuZ2UsIHRoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyKTtcbiAgICAgICAgICAgIGxldCBlbmRTdGFydCA9IGJ1ZGVsbG8ucm93T2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGJ1ZGVsbG8ucmVzdWx0U3RyaW5nO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFBvaW50Q2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdFBvaW50ID0gbmV3IFJlc3VsdFBvaW50KGVuZFN0YXJ0LCByb3dOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFBvaW50Q2FsbGJhY2suZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KHJlc3VsdFBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbmRSYW5nZSA9IHRoaXMuZGVjb2RlRW5kKHJvdywgZW5kU3RhcnQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFBvaW50Q2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdFBvaW50ID0gbmV3IFJlc3VsdFBvaW50KChlbmRSYW5nZVswXSArIGVuZFJhbmdlWzFdKSAvIDIuMCwgcm93TnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXN1bHRQb2ludENhbGxiYWNrLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChyZXN1bHRQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXMgYSBxdWlldCB6b25lIGF0IGxlYXN0IGFzIGJpZyBhcyB0aGUgZW5kIHBhdHRlcm4gYWZ0ZXIgdGhlIGJhcmNvZGUuIFRoZVxuICAgICAgICAgICAgLy8gc3BlYyBtaWdodCB3YW50IG1vcmUgd2hpdGVzcGFjZSwgYnV0IGluIHByYWN0aWNlIHRoaXMgaXMgdGhlIG1heGltdW0gd2UgY2FuIGNvdW50IG9uLlxuICAgICAgICAgICAgbGV0IGVuZCA9IGVuZFJhbmdlWzFdO1xuICAgICAgICAgICAgbGV0IHF1aWV0RW5kID0gZW5kICsgKGVuZCAtIGVuZFJhbmdlWzBdKTtcbiAgICAgICAgICAgIGlmIChxdWlldEVuZCA+PSByb3cuZ2V0U2l6ZSgpIHx8ICFyb3cuaXNSYW5nZShlbmQsIHF1aWV0RW5kLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHRTdHJpbmcgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIFVQQy9FQU4gc2hvdWxkIG5ldmVyIGJlIGxlc3MgdGhhbiA4IGNoYXJzIGFueXdheVxuICAgICAgICAgICAgaWYgKHJlc3VsdFN0cmluZy5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFVUENFQU5SZWFkZXIuY2hlY2tDaGVja3N1bShyZXN1bHRTdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENoZWNrc3VtRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGVmdCA9IChzdGFydEd1YXJkUmFuZ2VbMV0gKyBzdGFydEd1YXJkUmFuZ2VbMF0pIC8gMi4wO1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gKGVuZFJhbmdlWzFdICsgZW5kUmFuZ2VbMF0pIC8gMi4wO1xuICAgICAgICAgICAgbGV0IGZvcm1hdCA9IHRoaXMuZ2V0QmFyY29kZUZvcm1hdCgpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdFBvaW50ID0gW25ldyBSZXN1bHRQb2ludChsZWZ0LCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnQocmlnaHQsIHJvd051bWJlcildO1xuICAgICAgICAgICAgbGV0IGRlY29kZVJlc3VsdCA9IG5ldyBSZXN1bHQocmVzdWx0U3RyaW5nLCBudWxsLCAwLCByZXN1bHRQb2ludCwgZm9ybWF0LCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4dGVuc2lvblJlc3VsdCA9IFVQQ0VBTkV4dGVuc2lvblN1cHBvcnQuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBlbmRSYW5nZVsxXSk7XG4gICAgICAgICAgICAgICAgZGVjb2RlUmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLlVQQ19FQU5fRVhURU5TSU9OLCBleHRlbnNpb25SZXN1bHQuZ2V0VGV4dCgpKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVSZXN1bHQucHV0QWxsTWV0YWRhdGEoZXh0ZW5zaW9uUmVzdWx0LmdldFJlc3VsdE1ldGFkYXRhKCkpO1xuICAgICAgICAgICAgICAgIGRlY29kZVJlc3VsdC5hZGRSZXN1bHRQb2ludHMoZXh0ZW5zaW9uUmVzdWx0LmdldFJlc3VsdFBvaW50cygpKTtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25MZW5ndGggPSBleHRlbnNpb25SZXN1bHQuZ2V0VGV4dCgpLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVFcnJvcikge31cbiAgICAgICAgICAgIGxldCBhbGxvd2VkRXh0ZW5zaW9ucyA9IGhpbnRzID09IG51bGwgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuQUxMT1dFRF9FQU5fRVhURU5TSU9OUyk7XG4gICAgICAgICAgICBpZiAoYWxsb3dlZEV4dGVuc2lvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGxlbmd0aCBpbiBhbGxvd2VkRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uTGVuZ3RoLnRvU3RyaW5nKCkgPT09IGxlbmd0aCkgeyAvLyBjaGVjayBtZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZUVuZChyb3csIGVuZFN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gVVBDRUFOUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4oXG4gICAgICAgICAgICAgICAgcm93LCBlbmRTdGFydCwgZmFsc2UsIFVQQ0VBTlJlYWRlci5TVEFSVF9FTkRfUEFUVEVSTixcbiAgICAgICAgICAgICAgICBuZXcgSW50MzJBcnJheShVUENFQU5SZWFkZXIuU1RBUlRfRU5EX1BBVFRFUk4ubGVuZ3RoKS5maWxsKDApKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2hlY2tDaGVja3N1bShzKSB7XG4gICAgICAgICAgICByZXR1cm4gVVBDRUFOUmVhZGVyLmNoZWNrU3RhbmRhcmRVUENFQU5DaGVja3N1bShzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2hlY2tTdGFuZGFyZFVQQ0VBTkNoZWNrc3VtKHMpIHtcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSBzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNoZWNrID0gcGFyc2VJbnQocy5jaGFyQXQobGVuZ3RoIC0gMSksIDEwKTtcbiAgICAgICAgICAgIHJldHVybiBVUENFQU5SZWFkZXIuZ2V0U3RhbmRhcmRVUENFQU5DaGVja3N1bShzLnN1YnN0cmluZygwLCBsZW5ndGggLSAxKSkgPT09IGNoZWNrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRTdGFuZGFyZFVQQ0VBTkNoZWNrc3VtKHMpIHtcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSBzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpZ2l0ID0gcy5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGlmIChkaWdpdCA8IDAgfHwgZGlnaXQgPiA5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtICs9IGRpZ2l0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtICo9IDM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlnaXQgPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZ2l0IDwgMCB8fCBkaWdpdCA+IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdW0gKz0gZGlnaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDEwMDAgLSBzdW0pICUgMTA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8cD5JbXBsZW1lbnRzIGRlY29kaW5nIG9mIHRoZSBFQU4tMTMgZm9ybWF0LjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIGFsYXNkYWlyQGdvb2dsZS5jb20gKEFsYXNkYWlyIE1hY2tpbnRvc2gpXG4gICAgICovXG4gICAgY2xhc3MgRUFOMTNSZWFkZXIgZXh0ZW5kcyBVUENFQU5SZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzID0gSW50MzJBcnJheS5mcm9tKFswLCAwLCAwLCAwXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlTWlkZGxlKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0U3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgY291bnRlcnMgPSB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzO1xuICAgICAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMV0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMl0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgcm93T2Zmc2V0ID0gc3RhcnRSYW5nZVsxXTtcbiAgICAgICAgICAgIGxldCBsZ1BhdHRlcm5Gb3VuZCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDYgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gVVBDRUFOUmVhZGVyLmRlY29kZURpZ2l0KHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgVVBDRUFOUmVhZGVyLkxfQU5EX0dfUEFUVEVSTlMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGJlc3RNYXRjaCAlIDEwKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY291bnRlciBvZiBjb3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICBsZ1BhdHRlcm5Gb3VuZCB8PSAxIDw8ICg1IC0geCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0U3RyaW5nID0gRUFOMTNSZWFkZXIuZGV0ZXJtaW5lRmlyc3REaWdpdChyZXN1bHRTdHJpbmcsIGxnUGF0dGVybkZvdW5kKTtcbiAgICAgICAgICAgIGxldCBtaWRkbGVSYW5nZSA9IFVQQ0VBTlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKFxuICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICByb3dPZmZzZXQsXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBVUENFQU5SZWFkZXIuTUlERExFX1BBVFRFUk4sXG4gICAgICAgICAgICAgICAgbmV3IEludDMyQXJyYXkoVVBDRUFOUmVhZGVyLk1JRERMRV9QQVRURVJOLmxlbmd0aCkuZmlsbCgwKSk7XG4gICAgICAgICAgICByb3dPZmZzZXQgPSBtaWRkbGVSYW5nZVsxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNiAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSBVUENFQU5SZWFkZXIuZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBVUENFQU5SZWFkZXIuTF9QQVRURVJOUyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY291bnRlciBvZiBjb3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyByb3dPZmZzZXQsIHJlc3VsdFN0cmluZyB9O1xuICAgICAgICB9XG4gICAgICAgIGdldEJhcmNvZGVGb3JtYXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gQmFyY29kZUZvcm1hdCQxLkVBTl8xMztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGV0ZXJtaW5lRmlyc3REaWdpdChyZXN1bHRTdHJpbmcsIGxnUGF0dGVybkZvdW5kKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDEwOyBkKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGdQYXR0ZXJuRm91bmQgPT09IHRoaXMuRklSU1RfRElHSVRfRU5DT0RJTkdTW2RdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgZCkpICsgcmVzdWx0U3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0U3RyaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVBTjEzUmVhZGVyLkZJUlNUX0RJR0lUX0VOQ09ESU5HUyA9IFsweDAwLCAweDBCLCAweDBELCAweEUsIDB4MTMsIDB4MTksIDB4MUMsIDB4MTUsIDB4MTYsIDB4MUFdO1xuXG4gICAgLyoqXG4gICAgICogPHA+SW1wbGVtZW50cyBkZWNvZGluZyBvZiB0aGUgRUFOLTggZm9ybWF0LjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRUFOOFJlYWRlciBleHRlbmRzIFVQQ0VBTlJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlLCByZXN1bHRTdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycztcbiAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgIGxldCBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IHJvd09mZnNldCA9IHN0YXJ0UmFuZ2VbMV07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDQgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gVVBDRUFOUmVhZGVyLmRlY29kZURpZ2l0KHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgVVBDRUFOUmVhZGVyLkxfUEFUVEVSTlMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1pZGRsZVJhbmdlID0gVVBDRUFOUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4ocm93LCByb3dPZmZzZXQsIHRydWUsIFVQQ0VBTlJlYWRlci5NSURETEVfUEFUVEVSTiwgbmV3IEludDMyQXJyYXkoVVBDRUFOUmVhZGVyLk1JRERMRV9QQVRURVJOLmxlbmd0aCkuZmlsbCgwKSk7XG4gICAgICAgICAgICByb3dPZmZzZXQgPSBtaWRkbGVSYW5nZVsxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNCAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSBVUENFQU5SZWFkZXIuZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBVUENFQU5SZWFkZXIuTF9QQVRURVJOUyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY291bnRlciBvZiBjb3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyByb3dPZmZzZXQsIHJlc3VsdFN0cmluZyB9O1xuICAgICAgICB9XG4gICAgICAgIGdldEJhcmNvZGVGb3JtYXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gQmFyY29kZUZvcm1hdCQxLkVBTl84O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jYXBzdWxhdGVzIGZ1bmN0aW9uYWxpdHkgYW5kIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgY29tbW9uIHRvIGFsbCBmYW1pbGllc1xuICAgICAqIG9mIG9uZS1kaW1lbnNpb25hbCBiYXJjb2Rlcy5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIHNhbTIzMzIgKFNhbSBSdWRsb2ZmKVxuICAgICAqXG4gICAgICogQHNvdXJjZSBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi8zYzk2OTIzMjc2ZGQ1Nzg1ZDU4ZWI5NzBiNmJhM2Y4MGQzNmE5NTA1L2NvcmUvc3JjL21haW4vamF2YS9jb20vZ29vZ2xlL3p4aW5nL29uZWQvVVBDQVJlYWRlci5qYXZhXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgY2xhc3MgVVBDQVJlYWRlciBleHRlbmRzIFVQQ0VBTlJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuZWFuMTNSZWFkZXIgPSBuZXcgRUFOMTNSZWFkZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZ2V0QmFyY29kZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBCYXJjb2RlRm9ybWF0JDEuVVBDX0E7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGRvbid0IHRyeSByb3RhdGlvbiB3aXRob3V0IHRoZSB0cnkgaGFyZGVyIGZsYWcsIGV2ZW4gaWYgcm90YXRpb24gd2FzIHN1cHBvcnRlZC5cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZShpbWFnZSwgaGludHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heWJlUmV0dXJuUmVzdWx0KHRoaXMuZWFuMTNSZWFkZXIuZGVjb2RlKGltYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heWJlUmV0dXJuUmVzdWx0KHRoaXMuZWFuMTNSZWFkZXIuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlLCByZXN1bHRTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhbjEzUmVhZGVyLmRlY29kZU1pZGRsZShyb3csIHN0YXJ0UmFuZ2UsIHJlc3VsdFN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgbWF5YmVSZXR1cm5SZXN1bHQocmVzdWx0KSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IHJlc3VsdC5nZXRUZXh0KCk7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGxldCB1cGNhUmVzdWx0ID0gbmV3IFJlc3VsdCh0ZXh0LnN1YnN0cmluZygxKSwgbnVsbCwgbnVsbCwgcmVzdWx0LmdldFJlc3VsdFBvaW50cygpLCBCYXJjb2RlRm9ybWF0JDEuVVBDX0EpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZ2V0UmVzdWx0TWV0YWRhdGEoKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwY2FSZXN1bHQucHV0QWxsTWV0YWRhdGEocmVzdWx0LmdldFJlc3VsdE1ldGFkYXRhKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdXBjYVJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgdGhpcy5lYW4xM1JlYWRlci5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPHA+SW1wbGVtZW50cyBkZWNvZGluZyBvZiB0aGUgVVBDLUUgZm9ybWF0LjwvcD5cbiAgICAgKiA8cD48YSBocmVmPVwiaHR0cDovL3d3dy5iYXJjb2RlaXNsYW5kLmNvbS91cGNlLnBodG1sXCI+VGhpczwvYT4gaXMgYSBncmVhdCByZWZlcmVuY2UgZm9yXG4gICAgICogVVBDLUUgaW5mb3JtYXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKlxuICAgICAqIEBzb3VyY2UgaHR0cHM6Ly9naXRodWIuY29tL3p4aW5nL3p4aW5nL2Jsb2IvM2M5NjkyMzI3NmRkNTc4NWQ1OGViOTcwYjZiYTNmODBkMzZhOTUwNS9jb3JlL3NyYy9tYWluL2phdmEvY29tL2dvb2dsZS96eGluZy9vbmVkL1VQQ0VSZWFkZXIuamF2YVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIC8qIGZpbmFsICovIGNsYXNzIFVQQ0VSZWFkZXIgZXh0ZW5kcyBVUENFQU5SZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzID0gbmV3IEludDMyQXJyYXkoNCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycy5tYXAoeCA9PiB4KTtcbiAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgcm93T2Zmc2V0ID0gc3RhcnRSYW5nZVsxXTtcbiAgICAgICAgICAgIGxldCBsZ1BhdHRlcm5Gb3VuZCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDYgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSBVUENFUmVhZGVyLmRlY29kZURpZ2l0KFxuICAgICAgICAgICAgICAgICAgICByb3csIGNvdW50ZXJzLCByb3dPZmZzZXQsIFVQQ0VSZWFkZXIuTF9BTkRfR19QQVRURVJOUyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgKGJlc3RNYXRjaCAlIDEwKSkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgbGdQYXR0ZXJuRm91bmQgfD0gKDEgPDwgKDUgLSB4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdFN0cmluZyA9IFVQQ0VSZWFkZXIuZGV0ZXJtaW5lTnVtU3lzQW5kQ2hlY2tEaWdpdChcbiAgICAgICAgICAgICAgICByZXN1bHQsIGxnUGF0dGVybkZvdW5kKTtcbiAgICAgICAgICAgIHJldHVybiB7cm93T2Zmc2V0LCByZXN1bHRTdHJpbmd9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZGVjb2RlRW5kKHJvdywgZW5kU3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBVUENFUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm5XaXRob3V0Q291bnRlcnMoXG4gICAgICAgICAgICAgICAgcm93LCBlbmRTdGFydCwgdHJ1ZSwgVVBDRVJlYWRlci5NSURETEVfRU5EX1BBVFRFUk4pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGNoZWNrQ2hlY2tzdW0ocykge1xuICAgICAgICAgICAgcmV0dXJuIFVQQ0VBTlJlYWRlci5jaGVja0NoZWNrc3VtKFVQQ0VSZWFkZXIuY29udmVydFVQQ0V0b1VQQ0EocykpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGV0ZXJtaW5lTnVtU3lzQW5kQ2hlY2tEaWdpdChyZXN1bHRTdHJpbmcsIGxnUGF0dGVybkZvdW5kKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBudW1TeXMgPSAwOyBudW1TeXMgPD0gMTsgbnVtU3lzKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDEwOyBkKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxnUGF0dGVybkZvdW5kID09PSB0aGlzLk5VTVNZU19BTkRfQ0hFQ0tfRElHSVRfUEFUVEVSTlNbbnVtU3lzXVtkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByZWZpeCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJzAnLmNoYXJDb2RlQXQoMCkgKyBudW1TeXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJzAnLmNoYXJDb2RlQXQoMCkgKyBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyByZXN1bHRTdHJpbmcgKyBzdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBOb3RGb3VuZEV4Y2VwdGlvbi5nZXROb3RGb3VuZEluc3RhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGdldEJhcmNvZGVGb3JtYXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gQmFyY29kZUZvcm1hdCQxLlVQQ19FO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBhbmRzIGEgVVBDLUUgdmFsdWUgYmFjayBpbnRvIGl0cyBmdWxsLCBlcXVpdmFsZW50IFVQQy1BIGNvZGUgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB1cGNlIFVQQy1FIGNvZGUgYXMgc3RyaW5nIG9mIGRpZ2l0c1xuICAgICAgICAgKiBAcmV0dXJuIGVxdWl2YWxlbnQgVVBDLUEgY29kZSBhcyBzdHJpbmcgb2YgZGlnaXRzXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY29udmVydFVQQ0V0b1VQQ0EodXBjZSkge1xuICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBsaW5lIGlzIGVxdWl2YWxlbnQgdG8gdXBjZS5nZXRDaGFycygxLCA3LCB1cGNlQ2hhcnMsIDApO1xuICAgICAgICAgICAgY29uc3QgdXBjZUNoYXJzID0gdXBjZS5zbGljZSgxLCA3KS5zcGxpdCgnJykubWFwKHggPT4geC5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCAvKjEyKi8pO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh1cGNlLmNoYXJBdCgwKSk7XG4gICAgICAgICAgICBsZXQgbGFzdENoYXIgPSB1cGNlQ2hhcnNbNV07XG4gICAgICAgICAgICBzd2l0Y2ggKGxhc3RDaGFyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRDaGFycyh1cGNlQ2hhcnMsIDAsIDIpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGxhc3RDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnMDAwMCcpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kQ2hhcnModXBjZUNoYXJzLCAyLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kQ2hhcnModXBjZUNoYXJzLCAwLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnMDAwMDAnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZENoYXJzKHVwY2VDaGFycywgMywgMik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZENoYXJzKHVwY2VDaGFycywgMCwgNCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJzAwMDAwJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodXBjZUNoYXJzWzRdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZENoYXJzKHVwY2VDaGFycywgMCwgNSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJzAwMDAnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChsYXN0Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBhcHBlbmQgY2hlY2sgZGlnaXQgaW4gY29udmVyc2lvbiBpZiBzdXBwbGllZFxuICAgICAgICAgICAgaWYgKHVwY2UubGVuZ3RoID49IDgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHVwY2UuY2hhckF0KDcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcGF0dGVybiB0aGF0IG1hcmtzIHRoZSBtaWRkbGUsIGFuZCBlbmQsIG9mIGEgVVBDLUUgcGF0dGVybi5cbiAgICAgKiBUaGVyZSBpcyBubyBcInNlY29uZCBoYWxmXCIgdG8gYSBVUEMtRSBiYXJjb2RlLlxuICAgICAqL1xuICAgIFVQQ0VSZWFkZXIuTUlERExFX0VORF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxLCAxXSk7XG4gICAgLy8gRm9yIGFuIFVQQy1FIGJhcmNvZGUsIHRoZSBmaW5hbCBkaWdpdCBpcyByZXByZXNlbnRlZCBieSB0aGUgcGFyaXRpZXMgdXNlZFxuICAgIC8vIHRvIGVuY29kZSB0aGUgbWlkZGxlIHNpeCBkaWdpdHMsIGFjY29yZGluZyB0byB0aGUgdGFibGUgYmVsb3cuXG4gICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgICBQYXJpdHkgb2YgbmV4dCA2IGRpZ2l0c1xuICAgIC8vICAgIERpZ2l0ICAgMCAgICAgMSAgICAgMiAgICAgMyAgICAgNCAgICAgNVxuICAgIC8vICAgICAgIDAgICAgRXZlbiAgIEV2ZW4gIEV2ZW4gT2RkICBPZGQgICBPZGRcbiAgICAvLyAgICAgICAxICAgIEV2ZW4gICBFdmVuICBPZGQgIEV2ZW4gT2RkICAgT2RkXG4gICAgLy8gICAgICAgMiAgICBFdmVuICAgRXZlbiAgT2RkICBPZGQgIEV2ZW4gIE9kZFxuICAgIC8vICAgICAgIDMgICAgRXZlbiAgIEV2ZW4gIE9kZCAgT2RkICBPZGQgICBFdmVuXG4gICAgLy8gICAgICAgNCAgICBFdmVuICAgT2RkICAgRXZlbiBFdmVuIE9kZCAgIE9kZFxuICAgIC8vICAgICAgIDUgICAgRXZlbiAgIE9kZCAgIE9kZCAgRXZlbiBFdmVuICBPZGRcbiAgICAvLyAgICAgICA2ICAgIEV2ZW4gICBPZGQgICBPZGQgIE9kZCAgRXZlbiAgRXZlblxuICAgIC8vICAgICAgIDcgICAgRXZlbiAgIE9kZCAgIEV2ZW4gT2RkICBFdmVuICBPZGRcbiAgICAvLyAgICAgICA4ICAgIEV2ZW4gICBPZGQgICBFdmVuIE9kZCAgT2RkICAgRXZlblxuICAgIC8vICAgICAgIDkgICAgRXZlbiAgIE9kZCAgIE9kZCAgRXZlbiBPZGQgICBFdmVuXG4gICAgLy9cbiAgICAvLyBUaGUgZW5jb2RpbmcgaXMgcmVwcmVzZW50ZWQgYnkgdGhlIGZvbGxvd2luZyBhcnJheSwgd2hpY2ggaXMgYSBiaXQgcGF0dGVyblxuICAgIC8vIHVzaW5nIE9kZCA9IDAgYW5kIEV2ZW4gPSAxLiBGb3IgZXhhbXBsZSwgNSBpcyByZXByZXNlbnRlZCBieTpcbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICBPZGQgRXZlbiBFdmVuIE9kZCBPZGQgRXZlblxuICAgIC8vIGluIGJpbmFyeTpcbiAgICAvLyAgICAgICAgICAgICAgICAwICAgIDEgICAgMSAgIDAgICAwICAgIDEgICA9PSAweDE5XG4gICAgLy9cbiAgICAvKipcbiAgICAgKiBTZWUge0BsaW5rICNMX0FORF9HX1BBVFRFUk5TfTsgdGhlc2UgdmFsdWVzIHNpbWlsYXJseSByZXByZXNlbnQgcGF0dGVybnMgb2ZcbiAgICAgKiBldmVuLW9kZCBwYXJpdHkgZW5jb2RpbmdzIG9mIGRpZ2l0cyB0aGF0IGltcGx5IGJvdGggdGhlIG51bWJlciBzeXN0ZW0gKDAgb3IgMSlcbiAgICAgKiB1c2VkLCBhbmQgdGhlIGNoZWNrIGRpZ2l0LlxuICAgICAqL1xuICAgIFVQQ0VSZWFkZXIuTlVNU1lTX0FORF9DSEVDS19ESUdJVF9QQVRURVJOUyA9IFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDM4LCAweDM0LCAweDMyLCAweDMxLCAweDJDLCAweDI2LCAweDIzLCAweDJBLCAweDI5LCAweDI1XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgwNywgMHgwQiwgMHgwRCwgMHgwRSwgMHgxMywgMHgxOSwgMHgxQywgMHgxNSwgMHgxNiwgMHgxQV0pLFxuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiA8cD5BIHJlYWRlciB0aGF0IGNhbiByZWFkIGFsbCBhdmFpbGFibGUgVVBDL0VBTiBmb3JtYXRzLiBJZiBhIGNhbGxlciB3YW50cyB0byB0cnkgdG9cbiAgICAgKiByZWFkIGFsbCBzdWNoIGZvcm1hdHMsIGl0IGlzIG1vc3QgZWZmaWNpZW50IHRvIHVzZSB0aGlzIGltcGxlbWVudGF0aW9uIHJhdGhlciB0aGFuIGludm9rZVxuICAgICAqIGluZGl2aWR1YWwgcmVhZGVycy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIE11bHRpRm9ybWF0VVBDRUFOUmVhZGVyIGV4dGVuZHMgT25lRFJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGhpbnRzKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgbGV0IHBvc3NpYmxlRm9ybWF0cyA9IGhpbnRzID09IG51bGwgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuUE9TU0lCTEVfRk9STUFUUyk7XG4gICAgICAgICAgICBsZXQgcmVhZGVycyA9IFtdO1xuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwb3NzaWJsZUZvcm1hdHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmRleE9mKEJhcmNvZGVGb3JtYXQkMS5FQU5fMTMpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBFQU4xM1JlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmRleE9mKEJhcmNvZGVGb3JtYXQkMS5VUENfQSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IFVQQ0FSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5kZXhPZihCYXJjb2RlRm9ybWF0JDEuRUFOXzgpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBFQU44UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluZGV4T2YoQmFyY29kZUZvcm1hdCQxLlVQQ19FKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgVVBDRVJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIGhpbnRzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgRUFOMTNSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBVUENBUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgRUFOOFJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IFVQQ0VSZWFkZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWRlcnMgPSByZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJlYWRlciBvZiB0aGlzLnJlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCByZXN1bHQ6IFJlc3VsdCA9IHJlYWRlci5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIHN0YXJ0R3VhcmRQYXR0ZXJuLCBoaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWRlci5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBhIDEyLWRpZ2l0IGNvZGUgZW5jb2RlZCBpbiBVUEMtQSBpcyBpZGVudGljYWwgdG8gYSBcIjBcIlxuICAgICAgICAgICAgICAgICAgICAvLyBmb2xsb3dlZCBieSB0aG9zZSAxMiBkaWdpdHMgZW5jb2RlZCBhcyBFQU4tMTMuIEVhY2ggd2lsbCByZWNvZ25pemUgc3VjaCBhIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIFVQQy1BIGFzIGEgMTItZGlnaXQgc3RyaW5nIGFuZCBFQU4tMTMgYXMgYSAxMy1kaWdpdCBzdHJpbmcgc3RhcnRpbmcgd2l0aCBcIjBcIi5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kaXZpZHVhbGx5IHRoZXNlIGFyZSBjb3JyZWN0IGFuZCB0aGVpciByZWFkZXJzIHdpbGwgYm90aCByZWFkIHN1Y2ggYSBjb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBjb3JyZWN0bHkgY2FsbCBpdCBFQU4tMTMsIG9yIFVQQy1BLCByZXNwZWN0aXZlbHkuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWYgd2UndmUgYmVlbiBsb29raW5nIGZvciBib3RoIHR5cGVzLCB3ZSdkIGxpa2UgdG8gY2FsbCBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBhIFVQQy1BIGNvZGUuIEJ1dCBmb3IgZWZmaWNpZW5jeSB3ZSBvbmx5IHJ1biB0aGUgRUFOLTEzIGRlY29kZXIgdG8gYWxzbyByZWFkXG4gICAgICAgICAgICAgICAgICAgIC8vIFVQQy1BLiBTbyB3ZSBzcGVjaWFsIGNhc2UgaXQgaGVyZSwgYW5kIGNvbnZlcnQgYW4gRUFOLTEzIHJlc3VsdCB0byBhIFVQQy1BXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdCBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0LCBkb24ndCByZXR1cm4gVVBDLUEgaWYgVVBDLUEgd2FzIG5vdCBhIHJlcXVlc3RlZCBmb3JtYXQhXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVhbjEzTWF5QmVVUENBID0gcmVzdWx0LmdldEJhcmNvZGVGb3JtYXQoKSA9PT0gQmFyY29kZUZvcm1hdCQxLkVBTl8xMyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmdldFRleHQoKS5jaGFyQXQoMCkgPT09ICcwJztcbiAgICAgICAgICAgICAgICAgICAgLy8gQFN1cHByZXNzV2FybmluZ3MoXCJ1bmNoZWNrZWRcIilcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVGb3JtYXRzID0gaGludHMgPT0gbnVsbCA/IG51bGwgOiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5QT1NTSUJMRV9GT1JNQVRTKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FuUmV0dXJuVVBDQSA9IHBvc3NpYmxlRm9ybWF0cyA9PSBudWxsIHx8IHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0JDEuVVBDX0EpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWFuMTNNYXlCZVVQQ0EgJiYgY2FuUmV0dXJuVVBDQSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3Qnl0ZXMgPSByZXN1bHQuZ2V0UmF3Qnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZmVyIHRoZSBtZXRhZGF0YSBhY3Jvc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdFVQQ0EgPSBuZXcgUmVzdWx0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5nZXRUZXh0KCkuc3Vic3RyaW5nKDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd0J5dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyYXdCeXRlcyA/IHJhd0J5dGVzLmxlbmd0aCA6IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5nZXRSZXN1bHRQb2ludHMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCYXJjb2RlRm9ybWF0JDEuVVBDX0EpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0VVBDQS5wdXRBbGxNZXRhZGF0YShyZXN1bHQuZ2V0UmVzdWx0TWV0YWRhdGEoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0VVBDQTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgZm9yIChsZXQgcmVhZGVyIG9mIHRoaXMucmVhZGVycykge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaW1wb3J0IEludGVnZXIgZnJvbSAnLi4vLi4vdXRpbC9JbnRlZ2VyJztcbiAgICAvLyBpbXBvcnQgRmxvYXQgZnJvbSAnLi4vLi4vdXRpbC9GbG9hdCc7XG4gICAgY2xhc3MgQWJzdHJhY3RSU1NSZWFkZXIgZXh0ZW5kcyBPbmVEUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVGaW5kZXJDb3VudGVycyA9IG5ldyBJbnQzMkFycmF5KDQpO1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhcmFjdGVyQ291bnRlcnMgPSBuZXcgSW50MzJBcnJheSg4KTtcbiAgICAgICAgICAgIHRoaXMub2RkUm91bmRpbmdFcnJvcnMgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgICB0aGlzLmV2ZW5Sb3VuZGluZ0Vycm9ycyA9IG5ldyBBcnJheSg0KTtcbiAgICAgICAgICAgIHRoaXMub2RkQ291bnRzID0gbmV3IEFycmF5KHRoaXMuZGF0YUNoYXJhY3RlckNvdW50ZXJzLmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgdGhpcy5ldmVuQ291bnRzID0gbmV3IEFycmF5KHRoaXMuZGF0YUNoYXJhY3RlckNvdW50ZXJzLmxlbmd0aCAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGdldERlY29kZUZpbmRlckNvdW50ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRmluZGVyQ291bnRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGF0YUNoYXJhY3RlckNvdW50ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNoYXJhY3RlckNvdW50ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGdldE9kZFJvdW5kaW5nRXJyb3JzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2RkUm91bmRpbmdFcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlblJvdW5kaW5nRXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIGdldE9kZENvdW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9kZENvdW50cztcbiAgICAgICAgfVxuICAgICAgICBnZXRFdmVuQ291bnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbkNvdW50cztcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUZpbmRlclZhbHVlKGNvdW50ZXJzLCBmaW5kZXJQYXR0ZXJucykge1xuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgPSAwOyB2YWx1ZSA8IGZpbmRlclBhdHRlcm5zLmxlbmd0aDsgdmFsdWUrKykge1xuICAgICAgICAgICAgICAgIGlmIChPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBmaW5kZXJQYXR0ZXJuc1t2YWx1ZV0sIEFic3RyYWN0UlNTUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKSA8IEFic3RyYWN0UlNTUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYXJyYXkgdmFsdWVzIHRvIHN1bVxuICAgICAgICAgKiBAcmV0dXJuIHN1bSBvZiB2YWx1ZXNcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgY2FsbCB7QGxpbmsgTWF0aFV0aWxzI3N1bShpbnRbXSl9XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY291bnQoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuc3VtKG5ldyBJbnQzMkFycmF5KGFycmF5KSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGluY3JlbWVudChhcnJheSwgZXJyb3JzKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IGJpZ2dlc3RFcnJvciA9IGVycm9yc1swXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzW2ldID4gYmlnZ2VzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpZ2dlc3RFcnJvciA9IGVycm9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFycmF5W2luZGV4XSsrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNyZW1lbnQoYXJyYXksIGVycm9ycykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBiaWdnZXN0RXJyb3IgPSBlcnJvcnNbMF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yc1tpXSA8IGJpZ2dlc3RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBiaWdnZXN0RXJyb3IgPSBlcnJvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcnJheVtpbmRleF0tLTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNGaW5kZXJQYXR0ZXJuKGNvdW50ZXJzKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3RUd29TdW0gPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgbGV0IHN1bSA9IGZpcnN0VHdvU3VtICsgY291bnRlcnNbMl0gKyBjb3VudGVyc1szXTtcbiAgICAgICAgICAgIGxldCByYXRpbyA9IGZpcnN0VHdvU3VtIC8gc3VtO1xuICAgICAgICAgICAgaWYgKHJhdGlvID49IEFic3RyYWN0UlNTUmVhZGVyLk1JTl9GSU5ERVJfUEFUVEVSTl9SQVRJTyAmJiByYXRpbyA8PSBBYnN0cmFjdFJTU1JlYWRlci5NQVhfRklOREVSX1BBVFRFUk5fUkFUSU8pIHtcbiAgICAgICAgICAgICAgICAvLyBwYXNzZXMgcmF0aW8gdGVzdCBpbiBzcGVjLCBidXQgc2VlIGlmIHRoZSBjb3VudHMgYXJlIHVucmVhc29uYWJsZVxuICAgICAgICAgICAgICAgIGxldCBtaW5Db3VudGVyID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICAgICAgbGV0IG1heENvdW50ZXIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyID4gbWF4Q291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4Q291bnRlciA9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgPCBtaW5Db3VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5Db3VudGVyID0gY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF4Q291bnRlciA8IDEwICogbWluQ291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBYnN0cmFjdFJTU1JlYWRlci5NQVhfQVZHX1ZBUklBTkNFID0gMC4yO1xuICAgIEFic3RyYWN0UlNTUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFID0gMC40NTtcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5NSU5fRklOREVSX1BBVFRFUk5fUkFUSU8gPSA5LjUgLyAxMi4wO1xuICAgIEFic3RyYWN0UlNTUmVhZGVyLk1BWF9GSU5ERVJfUEFUVEVSTl9SQVRJTyA9IDEyLjUgLyAxNC4wO1xuXG4gICAgY2xhc3MgRGF0YUNoYXJhY3RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBjaGVja3N1bVBvcnRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tzdW1Qb3J0aW9uID0gY2hlY2tzdW1Qb3J0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q2hlY2tzdW1Qb3J0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tzdW1Qb3J0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgKyAnKCcgKyB0aGlzLmNoZWNrc3VtUG9ydGlvbiArICcpJztcbiAgICAgICAgfVxuICAgICAgICBlcXVhbHMobykge1xuICAgICAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIERhdGFDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGhhdCA9IG87XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gdGhhdC52YWx1ZSAmJiB0aGlzLmNoZWNrc3VtUG9ydGlvbiA9PT0gdGhhdC5jaGVja3N1bVBvcnRpb247XG4gICAgICAgIH1cbiAgICAgICAgaGFzaENvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSBeIHRoaXMuY2hlY2tzdW1Qb3J0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgRmluZGVyUGF0dGVybiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzdGFydEVuZCwgc3RhcnQsIGVuZCwgcm93TnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RW5kID0gc3RhcnRFbmQ7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RW5kID0gc3RhcnRFbmQ7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMucHVzaChuZXcgUmVzdWx0UG9pbnQoc3RhcnQsIHJvd051bWJlcikpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMucHVzaChuZXcgUmVzdWx0UG9pbnQoZW5kLCByb3dOdW1iZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGdldFN0YXJ0RW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UmVzdWx0UG9pbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0UG9pbnRzO1xuICAgICAgICB9XG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgRmluZGVyUGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aGF0ID0gbztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSB0aGF0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGhhc2hDb2RlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSU1MgdXRpbCBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgUlNTVXRpbHMge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgICAgICBzdGF0aWMgZ2V0UlNTdmFsdWUod2lkdGhzLCBtYXhXaWR0aCwgbm9OYXJyb3cpIHtcbiAgICAgICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpZHRoIG9mIHdpZHRocykge1xuICAgICAgICAgICAgICAgIG4gKz0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsID0gMDtcbiAgICAgICAgICAgIGxldCBuYXJyb3dNYXNrID0gMDtcbiAgICAgICAgICAgIGxldCBlbGVtZW50cyA9IHdpZHRocy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBiYXIgPSAwOyBiYXIgPCBlbGVtZW50cyAtIDE7IGJhcisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVsbVdpZHRoO1xuICAgICAgICAgICAgICAgIGZvciAoZWxtV2lkdGggPSAxLCBuYXJyb3dNYXNrIHw9IDEgPDwgYmFyOyBlbG1XaWR0aCA8IHdpZHRoc1tiYXJdOyBlbG1XaWR0aCsrLCBuYXJyb3dNYXNrICY9IH4oMSA8PCBiYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWJWYWwgPSBSU1NVdGlscy5jb21iaW5zKG4gLSBlbG1XaWR0aCAtIDEsIGVsZW1lbnRzIC0gYmFyIC0gMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub05hcnJvdyAmJiAobmFycm93TWFzayA9PT0gMCkgJiYgKG4gLSBlbG1XaWR0aCAtIChlbGVtZW50cyAtIGJhciAtIDEpID49IGVsZW1lbnRzIC0gYmFyIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlZhbCAtPSBSU1NVdGlscy5jb21iaW5zKG4gLSBlbG1XaWR0aCAtIChlbGVtZW50cyAtIGJhciksIGVsZW1lbnRzIC0gYmFyIC0gMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzIC0gYmFyIC0gMSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsZXNzVmFsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG14d0VsZW1lbnQgPSBuIC0gZWxtV2lkdGggLSAoZWxlbWVudHMgLSBiYXIgLSAyKTsgbXh3RWxlbWVudCA+IG1heFdpZHRoOyBteHdFbGVtZW50LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXNzVmFsICs9IFJTU1V0aWxzLmNvbWJpbnMobiAtIGVsbVdpZHRoIC0gbXh3RWxlbWVudCAtIDEsIGVsZW1lbnRzIC0gYmFyIC0gMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJWYWwgLT0gbGVzc1ZhbCAqIChlbGVtZW50cyAtIDEgLSBiYXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG4gLSBlbG1XaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJWYWwtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gc3ViVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuIC09IGVsbVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY29tYmlucyhuLCByKSB7XG4gICAgICAgICAgICBsZXQgbWF4RGVub207XG4gICAgICAgICAgICBsZXQgbWluRGVub207XG4gICAgICAgICAgICBpZiAobiAtIHIgPiByKSB7XG4gICAgICAgICAgICAgICAgbWluRGVub20gPSByO1xuICAgICAgICAgICAgICAgIG1heERlbm9tID0gbiAtIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW5EZW5vbSA9IG4gLSByO1xuICAgICAgICAgICAgICAgIG1heERlbm9tID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2YWwgPSAxO1xuICAgICAgICAgICAgbGV0IGogPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG47IGkgPiBtYXhEZW5vbTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFsICo9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGogPD0gbWluRGVub20pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsIC89IGo7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoKGogPD0gbWluRGVub20pKSB7XG4gICAgICAgICAgICAgICAgdmFsIC89IGo7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEJpdEFycmF5QnVpbGRlciB7XG4gICAgICAgIHN0YXRpYyBidWlsZEJpdEFycmF5KHBhaXJzKSB7XG4gICAgICAgICAgICBsZXQgY2hhck51bWJlciA9IChwYWlycy5sZW5ndGggKiAyKSAtIDE7XG4gICAgICAgICAgICBpZiAocGFpcnNbcGFpcnMubGVuZ3RoIC0gMV0uZ2V0UmlnaHRDaGFyKCkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYXJOdW1iZXIgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaXplID0gMTIgKiBjaGFyTnVtYmVyO1xuICAgICAgICAgICAgbGV0IGJpbmFyeSA9IG5ldyBCaXRBcnJheShzaXplKTtcbiAgICAgICAgICAgIGxldCBhY2NQb3MgPSAwO1xuICAgICAgICAgICAgbGV0IGZpcnN0UGFpciA9IHBhaXJzWzBdO1xuICAgICAgICAgICAgbGV0IGZpcnN0VmFsdWUgPSBmaXJzdFBhaXIuZ2V0UmlnaHRDaGFyKCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGZpcnN0VmFsdWUgJiAoMSA8PCBpKSkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBiaW5hcnkuc2V0KGFjY1Bvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY1BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYWlycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50UGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0VmFsdWUgPSBjdXJyZW50UGFpci5nZXRMZWZ0Q2hhcigpLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDExOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGxlZnRWYWx1ZSAmICgxIDw8IGopKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnkuc2V0KGFjY1Bvcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWNjUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFpci5nZXRSaWdodENoYXIoKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByaWdodFZhbHVlID0gY3VycmVudFBhaXIuZ2V0UmlnaHRDaGFyKCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDExOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyaWdodFZhbHVlICYgKDEgPDwgaikpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnkuc2V0KGFjY1Bvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaW5hcnk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBCbG9ja1BhcnNlZFJlc3VsdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGZpbmlzaGVkLCBkZWNvZGVkSW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkSW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZWRJbmZvcm1hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVkSW5mb3JtYXRpb24gPSBkZWNvZGVkSW5mb3JtYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGVjb2RlZEluZm9ybWF0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlZEluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlzRmluaXNoZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIERlY29kZWRPYmplY3Qge1xuICAgICAgICBjb25zdHJ1Y3RvcihuZXdQb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5uZXdQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldE5ld1Bvc2l0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3UG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBEZWNvZGVkQ2hhciBleHRlbmRzIERlY29kZWRPYmplY3Qge1xuICAgICAgICBjb25zdHJ1Y3RvcihuZXdQb3NpdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgICAgIHN1cGVyKG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlzRk5DMSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBEZWNvZGVkQ2hhci5GTkMxO1xuICAgICAgICB9XG4gICAgfVxuICAgIERlY29kZWRDaGFyLkZOQzEgPSAnJCc7XG5cbiAgICBjbGFzcyBEZWNvZGVkSW5mb3JtYXRpb24gZXh0ZW5kcyBEZWNvZGVkT2JqZWN0IHtcbiAgICAgICAgY29uc3RydWN0b3IobmV3UG9zaXRpb24sIG5ld1N0cmluZywgcmVtYWluaW5nVmFsdWUpIHtcbiAgICAgICAgICAgIHN1cGVyKG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbWFpbmluZ1ZhbHVlID0gdGhpcy5yZW1haW5pbmdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdWYWx1ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5ld1N0cmluZyA9IG5ld1N0cmluZztcbiAgICAgICAgfVxuICAgICAgICBnZXROZXdTdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXdTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaXNSZW1haW5pbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UmVtYWluaW5nVmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1haW5pbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIERlY29kZWROdW1lcmljIGV4dGVuZHMgRGVjb2RlZE9iamVjdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG5ld1Bvc2l0aW9uLCBmaXJzdERpZ2l0LCBzZWNvbmREaWdpdCkge1xuICAgICAgICAgICAgc3VwZXIobmV3UG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpcnN0RGlnaXQgPCAwIHx8IGZpcnN0RGlnaXQgPiAxMCB8fCBzZWNvbmREaWdpdCA8IDAgfHwgc2Vjb25kRGlnaXQgPiAxMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmlyc3REaWdpdCA9IGZpcnN0RGlnaXQ7XG4gICAgICAgICAgICB0aGlzLnNlY29uZERpZ2l0ID0gc2Vjb25kRGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Rmlyc3REaWdpdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0RGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U2Vjb25kRGlnaXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmREaWdpdDtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0RGlnaXQgKiAxMCArIHRoaXMuc2Vjb25kRGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaXNGaXJzdERpZ2l0Rk5DMSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0RGlnaXQgPT09IERlY29kZWROdW1lcmljLkZOQzE7XG4gICAgICAgIH1cbiAgICAgICAgaXNTZWNvbmREaWdpdEZOQzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmREaWdpdCA9PT0gRGVjb2RlZE51bWVyaWMuRk5DMTtcbiAgICAgICAgfVxuICAgICAgICBpc0FueUZOQzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdERpZ2l0ID09PSBEZWNvZGVkTnVtZXJpYy5GTkMxIHx8IHRoaXMuc2Vjb25kRGlnaXQgPT09IERlY29kZWROdW1lcmljLkZOQzE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGVjb2RlZE51bWVyaWMuRk5DMSA9IDEwO1xuXG4gICAgY2xhc3MgRmllbGRQYXJzZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcGFyc2VGaWVsZHNJbkdlbmVyYWxQdXJwb3NlKHJhd0luZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXJhd0luZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcm9jZXNzaW5nIDItZGlnaXQgQUlzXG4gICAgICAgICAgICBpZiAocmF3SW5mb3JtYXRpb24ubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpcnN0VHdvRGlnaXRzID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIDIpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGF0YUxlbmd0aCBvZiBGaWVsZFBhcnNlci5UV09fRElHSVRfREFUQV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFswXSA9PT0gZmlyc3RUd29EaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMV0gPT09IEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NWYXJpYWJsZUFJKDIsIGRhdGFMZW5ndGhbMl0sIHJhd0luZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc0ZpeGVkQUkoMiwgZGF0YUxlbmd0aFsxXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyYXdJbmZvcm1hdGlvbi5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmlyc3RUaHJlZURpZ2l0cyA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZygwLCAzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRhdGFMZW5ndGggb2YgRmllbGRQYXJzZXIuVEhSRUVfRElHSVRfREFUQV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFswXSA9PT0gZmlyc3RUaHJlZURpZ2l0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFsxXSA9PT0gRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc1ZhcmlhYmxlQUkoMywgZGF0YUxlbmd0aFsyXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzRml4ZWRBSSgzLCBkYXRhTGVuZ3RoWzFdLCByYXdJbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZGF0YUxlbmd0aCBvZiBGaWVsZFBhcnNlci5USFJFRV9ESUdJVF9QTFVTX0RJR0lUX0RBVEFfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMF0gPT09IGZpcnN0VGhyZWVEaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMV0gPT09IEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NWYXJpYWJsZUFJKDQsIGRhdGFMZW5ndGhbMl0sIHJhd0luZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc0ZpeGVkQUkoNCwgZGF0YUxlbmd0aFsxXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyYXdJbmZvcm1hdGlvbi5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmlyc3RGb3VyRGlnaXRzID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIDQpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGF0YUxlbmd0aCBvZiBGaWVsZFBhcnNlci5GT1VSX0RJR0lUX0RBVEFfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMF0gPT09IGZpcnN0Rm91ckRpZ2l0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFsxXSA9PT0gRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc1ZhcmlhYmxlQUkoNCwgZGF0YUxlbmd0aFsyXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzRml4ZWRBSSg0LCBkYXRhTGVuZ3RoWzFdLCByYXdJbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHByb2Nlc3NGaXhlZEFJKGFpU2l6ZSwgZmllbGRTaXplLCByYXdJbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IGFpU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFpID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIGFpU2l6ZSk7XG4gICAgICAgICAgICBpZiAocmF3SW5mb3JtYXRpb24ubGVuZ3RoIDwgYWlTaXplICsgZmllbGRTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmllbGQgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoYWlTaXplLCBhaVNpemUgKyBmaWVsZFNpemUpO1xuICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZyhhaVNpemUgKyBmaWVsZFNpemUpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcoJyArIGFpICsgJyknICsgZmllbGQ7XG4gICAgICAgICAgICBsZXQgcGFyc2VkQUkgPSBGaWVsZFBhcnNlci5wYXJzZUZpZWxkc0luR2VuZXJhbFB1cnBvc2UocmVtYWluaW5nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRBSSA9PSBudWxsID8gcmVzdWx0IDogcmVzdWx0ICsgcGFyc2VkQUk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHByb2Nlc3NWYXJpYWJsZUFJKGFpU2l6ZSwgdmFyaWFibGVGaWVsZFNpemUsIHJhd0luZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBsZXQgYWkgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoMCwgYWlTaXplKTtcbiAgICAgICAgICAgIGxldCBtYXhTaXplO1xuICAgICAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IGFpU2l6ZSArIHZhcmlhYmxlRmllbGRTaXplKSB7XG4gICAgICAgICAgICAgICAgbWF4U2l6ZSA9IHJhd0luZm9ybWF0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1heFNpemUgPSBhaVNpemUgKyB2YXJpYWJsZUZpZWxkU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaWVsZCA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZyhhaVNpemUsIG1heFNpemUpO1xuICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZyhtYXhTaXplKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAnKCcgKyBhaSArICcpJyArIGZpZWxkO1xuICAgICAgICAgICAgbGV0IHBhcnNlZEFJID0gRmllbGRQYXJzZXIucGFyc2VGaWVsZHNJbkdlbmVyYWxQdXJwb3NlKHJlbWFpbmluZyk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkQUkgPT0gbnVsbCA/IHJlc3VsdCA6IHJlc3VsdCArIHBhcnNlZEFJO1xuICAgICAgICB9XG4gICAgfVxuICAgIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCA9IFtdO1xuICAgIEZpZWxkUGFyc2VyLlRXT19ESUdJVF9EQVRBX0xFTkdUSCA9IFtcbiAgICAgICAgWycwMCcsIDE4XSxcbiAgICAgICAgWycwMScsIDE0XSxcbiAgICAgICAgWycwMicsIDE0XSxcbiAgICAgICAgWycxMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMjBdLFxuICAgICAgICBbJzExJywgNl0sXG4gICAgICAgIFsnMTInLCA2XSxcbiAgICAgICAgWycxMycsIDZdLFxuICAgICAgICBbJzE1JywgNl0sXG4gICAgICAgIFsnMTcnLCA2XSxcbiAgICAgICAgWycyMCcsIDJdLFxuICAgICAgICBbJzIxJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAyMF0sXG4gICAgICAgIFsnMjInLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDI5XSxcbiAgICAgICAgWyczMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgOF0sXG4gICAgICAgIFsnMzcnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDhdLFxuICAgICAgICAvLyBpbnRlcm5hbCBjb21wYW55IGNvZGVzXG4gICAgICAgIFsnOTAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5MScsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzkyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnOTMnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5NCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzk1JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnOTYnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5NycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgM10sXG4gICAgICAgIFsnOTgnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5OScsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgIF07XG4gICAgRmllbGRQYXJzZXIuVEhSRUVfRElHSVRfREFUQV9MRU5HVEggPSBbXG4gICAgICAgIC8vIFNhbWUgZm9ybWF0IGFzIGFib3ZlXG4gICAgICAgIFsnMjQwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnMjQxJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnMjQyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCA2XSxcbiAgICAgICAgWycyNTAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWycyNTEnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWycyNTMnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE3XSxcbiAgICAgICAgWycyNTQnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDIwXSxcbiAgICAgICAgWyc0MDAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc0MDEnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc0MDInLCAxN10sXG4gICAgICAgIFsnNDAzJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnNDEwJywgMTNdLFxuICAgICAgICBbJzQxMScsIDEzXSxcbiAgICAgICAgWyc0MTInLCAxM10sXG4gICAgICAgIFsnNDEzJywgMTNdLFxuICAgICAgICBbJzQxNCcsIDEzXSxcbiAgICAgICAgWyc0MjAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDIwXSxcbiAgICAgICAgWyc0MjEnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE1XSxcbiAgICAgICAgWyc0MjInLCAzXSxcbiAgICAgICAgWyc0MjMnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE1XSxcbiAgICAgICAgWyc0MjQnLCAzXSxcbiAgICAgICAgWyc0MjUnLCAzXSxcbiAgICAgICAgWyc0MjYnLCAzXSxcbiAgICBdO1xuICAgIEZpZWxkUGFyc2VyLlRIUkVFX0RJR0lUX1BMVVNfRElHSVRfREFUQV9MRU5HVEggPSBbXG4gICAgICAgIC8vIFNhbWUgZm9ybWF0IGFzIGFib3ZlXG4gICAgICAgIFsnMzEwJywgNl0sXG4gICAgICAgIFsnMzExJywgNl0sXG4gICAgICAgIFsnMzEyJywgNl0sXG4gICAgICAgIFsnMzEzJywgNl0sXG4gICAgICAgIFsnMzE0JywgNl0sXG4gICAgICAgIFsnMzE1JywgNl0sXG4gICAgICAgIFsnMzE2JywgNl0sXG4gICAgICAgIFsnMzIwJywgNl0sXG4gICAgICAgIFsnMzIxJywgNl0sXG4gICAgICAgIFsnMzIyJywgNl0sXG4gICAgICAgIFsnMzIzJywgNl0sXG4gICAgICAgIFsnMzI0JywgNl0sXG4gICAgICAgIFsnMzI1JywgNl0sXG4gICAgICAgIFsnMzI2JywgNl0sXG4gICAgICAgIFsnMzI3JywgNl0sXG4gICAgICAgIFsnMzI4JywgNl0sXG4gICAgICAgIFsnMzI5JywgNl0sXG4gICAgICAgIFsnMzMwJywgNl0sXG4gICAgICAgIFsnMzMxJywgNl0sXG4gICAgICAgIFsnMzMyJywgNl0sXG4gICAgICAgIFsnMzMzJywgNl0sXG4gICAgICAgIFsnMzM0JywgNl0sXG4gICAgICAgIFsnMzM1JywgNl0sXG4gICAgICAgIFsnMzM2JywgNl0sXG4gICAgICAgIFsnMzQwJywgNl0sXG4gICAgICAgIFsnMzQxJywgNl0sXG4gICAgICAgIFsnMzQyJywgNl0sXG4gICAgICAgIFsnMzQzJywgNl0sXG4gICAgICAgIFsnMzQ0JywgNl0sXG4gICAgICAgIFsnMzQ1JywgNl0sXG4gICAgICAgIFsnMzQ2JywgNl0sXG4gICAgICAgIFsnMzQ3JywgNl0sXG4gICAgICAgIFsnMzQ4JywgNl0sXG4gICAgICAgIFsnMzQ5JywgNl0sXG4gICAgICAgIFsnMzUwJywgNl0sXG4gICAgICAgIFsnMzUxJywgNl0sXG4gICAgICAgIFsnMzUyJywgNl0sXG4gICAgICAgIFsnMzUzJywgNl0sXG4gICAgICAgIFsnMzU0JywgNl0sXG4gICAgICAgIFsnMzU1JywgNl0sXG4gICAgICAgIFsnMzU2JywgNl0sXG4gICAgICAgIFsnMzU3JywgNl0sXG4gICAgICAgIFsnMzYwJywgNl0sXG4gICAgICAgIFsnMzYxJywgNl0sXG4gICAgICAgIFsnMzYyJywgNl0sXG4gICAgICAgIFsnMzYzJywgNl0sXG4gICAgICAgIFsnMzY0JywgNl0sXG4gICAgICAgIFsnMzY1JywgNl0sXG4gICAgICAgIFsnMzY2JywgNl0sXG4gICAgICAgIFsnMzY3JywgNl0sXG4gICAgICAgIFsnMzY4JywgNl0sXG4gICAgICAgIFsnMzY5JywgNl0sXG4gICAgICAgIFsnMzkwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxNV0sXG4gICAgICAgIFsnMzkxJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxOF0sXG4gICAgICAgIFsnMzkyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxNV0sXG4gICAgICAgIFsnMzkzJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxOF0sXG4gICAgICAgIFsnNzAzJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgXTtcbiAgICBGaWVsZFBhcnNlci5GT1VSX0RJR0lUX0RBVEFfTEVOR1RIID0gW1xuICAgICAgICAvLyBTYW1lIGZvcm1hdCBhcyBhYm92ZVxuICAgICAgICBbJzcwMDEnLCAxM10sXG4gICAgICAgIFsnNzAwMicsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzcwMDMnLCAxMF0sXG4gICAgICAgIFsnODAwMScsIDE0XSxcbiAgICAgICAgWyc4MDAyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAyMF0sXG4gICAgICAgIFsnODAwMycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzgwMDQnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc4MDA1JywgNl0sXG4gICAgICAgIFsnODAwNicsIDE4XSxcbiAgICAgICAgWyc4MDA3JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnODAwOCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMTJdLFxuICAgICAgICBbJzgwMTgnLCAxOF0sXG4gICAgICAgIFsnODAyMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMjVdLFxuICAgICAgICBbJzgxMDAnLCA2XSxcbiAgICAgICAgWyc4MTAxJywgMTBdLFxuICAgICAgICBbJzgxMDInLCAyXSxcbiAgICAgICAgWyc4MTEwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCA3MF0sXG4gICAgICAgIFsnODIwMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgNzBdLFxuICAgIF07XG5cbiAgICBjbGFzcyBHZW5lcmFsQXBwSWREZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuaW5mb3JtYXRpb24gPSBpbmZvcm1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVBbGxDb2RlcyhidWZmLCBpbml0aWFsUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSBpbml0aWFsUG9zaXRpb247XG4gICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5mbyA9IHRoaXMuZGVjb2RlR2VuZXJhbFB1cnBvc2VGaWVsZChjdXJyZW50UG9zaXRpb24sIHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZEZpZWxkcyA9IEZpZWxkUGFyc2VyLnBhcnNlRmllbGRzSW5HZW5lcmFsUHVycG9zZShpbmZvLmdldE5ld1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkRmllbGRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZi5hcHBlbmQocGFyc2VkRmllbGRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uaXNSZW1haW5pbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmcgPSAnJyArIGluZm8uZ2V0UmVtYWluaW5nVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UG9zaXRpb24gPT09IGluZm8uZ2V0TmV3UG9zaXRpb24oKSkgeyAvLyBObyBzdGVwIGZvcndhcmQhXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gPSBpbmZvLmdldE5ld1Bvc2l0aW9uKCk7XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNTdGlsbE51bWVyaWMocG9zKSB7XG4gICAgICAgICAgICAvLyBJdCdzIG51bWVyaWMgaWYgaXQgc3RpbGwgaGFzIDcgcG9zaXRpb25zXG4gICAgICAgICAgICAvLyBhbmQgb25lIG9mIHRoZSBmaXJzdCA0IGJpdHMgaXMgXCIxXCIuXG4gICAgICAgICAgICBpZiAocG9zICsgNyA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcyArIDQgPD0gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgcG9zICsgMzsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5mb3JtYXRpb24uZ2V0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZm9ybWF0aW9uLmdldChwb3MgKyAzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVOdW1lcmljKHBvcykge1xuICAgICAgICAgICAgaWYgKHBvcyArIDcgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgIGxldCBudW1lcmljID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNCk7XG4gICAgICAgICAgICAgICAgaWYgKG51bWVyaWMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkTnVtZXJpYyh0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSwgRGVjb2RlZE51bWVyaWMuRk5DMSwgRGVjb2RlZE51bWVyaWMuRk5DMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZE51bWVyaWModGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCksIG51bWVyaWMgLSAxLCBEZWNvZGVkTnVtZXJpYy5GTkMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBudW1lcmljID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNyk7XG4gICAgICAgICAgICBsZXQgZGlnaXQxID0gKG51bWVyaWMgLSA4KSAvIDExO1xuICAgICAgICAgICAgbGV0IGRpZ2l0MiA9IChudW1lcmljIC0gOCkgJSAxMTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZE51bWVyaWMocG9zICsgNywgZGlnaXQxLCBkaWdpdDIpO1xuICAgICAgICB9XG4gICAgICAgIGV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCBiaXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gR2VuZXJhbEFwcElkRGVjb2Rlci5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHRoaXMuaW5mb3JtYXRpb24sIHBvcywgYml0cyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoaW5mb3JtYXRpb24sIHBvcywgYml0cykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYml0czsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm9ybWF0aW9uLmdldChwb3MgKyBpKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSB8PSAxIDw8IChiaXRzIC0gaSAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVHZW5lcmFsUHVycG9zZUZpZWxkKHBvcywgcmVtYWluaW5nKSB7XG4gICAgICAgICAgICAvLyB0aGlzLmJ1ZmZlci5zZXRMZW5ndGgoMCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5zZXRMZW5ndGhUb1plcm8oKTtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLmFwcGVuZChyZW1haW5pbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldFBvc2l0aW9uKHBvcyk7XG4gICAgICAgICAgICBsZXQgbGFzdERlY29kZWQgPSB0aGlzLnBhcnNlQmxvY2tzKCk7XG4gICAgICAgICAgICBpZiAobGFzdERlY29kZWQgIT0gbnVsbCAmJiBsYXN0RGVjb2RlZC5pc1JlbWFpbmluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkSW5mb3JtYXRpb24odGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCksIGxhc3REZWNvZGVkLmdldFJlbWFpbmluZ1ZhbHVlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkSW5mb3JtYXRpb24odGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlQmxvY2tzKCkge1xuICAgICAgICAgICAgbGV0IGlzRmluaXNoZWQ7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxldCBpbml0aWFsUG9zaXRpb24gPSB0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50LmlzQWxwaGEoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQWxwaGFCbG9jaygpO1xuICAgICAgICAgICAgICAgICAgICBpc0ZpbmlzaGVkID0gcmVzdWx0LmlzRmluaXNoZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJyZW50LmlzSXNvSWVjNjQ2KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUlzb0llYzY0NkJsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlzRmluaXNoZWQgPSByZXN1bHQuaXNGaW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gaXQgbXVzdCBiZSBudW1lcmljXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VOdW1lcmljQmxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgaXNGaW5pc2hlZCA9IHJlc3VsdC5pc0ZpbmlzaGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbkNoYW5nZWQgPSBpbml0aWFsUG9zaXRpb24gIT09IHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmICghcG9zaXRpb25DaGFuZ2VkICYmICFpc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKCFpc0ZpbmlzaGVkKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZ2V0RGVjb2RlZEluZm9ybWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VOdW1lcmljQmxvY2soKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc1N0aWxsTnVtZXJpYyh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbnVtZXJpYyA9IHRoaXMuZGVjb2RlTnVtZXJpYyh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldFBvc2l0aW9uKG51bWVyaWMuZ2V0TmV3UG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgaWYgKG51bWVyaWMuaXNGaXJzdERpZ2l0Rk5DMSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmZvcm1hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bWVyaWMuaXNTZWNvbmREaWdpdEZOQzEoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mb3JtYXRpb24gPSBuZXcgRGVjb2RlZEluZm9ybWF0aW9uKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpLCB0aGlzLmJ1ZmZlci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uID0gbmV3IERlY29kZWRJbmZvcm1hdGlvbih0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSwgbnVtZXJpYy5nZXRTZWNvbmREaWdpdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrUGFyc2VkUmVzdWx0KHRydWUsIGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKG51bWVyaWMuZ2V0Rmlyc3REaWdpdCgpKTtcbiAgICAgICAgICAgICAgICBpZiAobnVtZXJpYy5pc1NlY29uZERpZ2l0Rk5DMSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmZvcm1hdGlvbiA9IG5ldyBEZWNvZGVkSW5mb3JtYXRpb24odGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrUGFyc2VkUmVzdWx0KHRydWUsIGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKG51bWVyaWMuZ2V0U2Vjb25kRGlnaXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc051bWVyaWNUb0FscGhhTnVtZXJpY0xhdGNoKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRBbHBoYSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbig0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tQYXJzZWRSZXN1bHQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlSXNvSWVjNjQ2QmxvY2soKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc1N0aWxsSXNvSWVjNjQ2KHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIGxldCBpc28gPSB0aGlzLmRlY29kZUlzb0llYzY0Nih0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldFBvc2l0aW9uKGlzby5nZXROZXdQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNvLmlzRk5DMSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmZvcm1hdGlvbiA9IG5ldyBEZWNvZGVkSW5mb3JtYXRpb24odGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrUGFyc2VkUmVzdWx0KHRydWUsIGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKGlzby5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWxwaGFPcjY0NlRvTnVtZXJpY0xhdGNoKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbigzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0TnVtZXJpYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0FscGhhVG82NDZUb0FscGhhTGF0Y2godGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpICsgNSA8IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbig1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRQb3NpdGlvbih0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRBbHBoYSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VBbHBoYUJsb2NrKCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNTdGlsbEFscGhhKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIGxldCBhbHBoYSA9IHRoaXMuZGVjb2RlQWxwaGFudW1lcmljKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24oYWxwaGEuZ2V0TmV3UG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhLmlzRk5DMSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmZvcm1hdGlvbiA9IG5ldyBEZWNvZGVkSW5mb3JtYXRpb24odGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrUGFyc2VkUmVzdWx0KHRydWUsIGluZm9ybWF0aW9uKTsgLy8gZW5kIG9mIHRoZSBjaGFyIGJsb2NrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLmFwcGVuZChhbHBoYS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWxwaGFPcjY0NlRvTnVtZXJpY0xhdGNoKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbigzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0TnVtZXJpYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0FscGhhVG82NDZUb0FscGhhTGF0Y2godGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpICsgNSA8IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbig1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRQb3NpdGlvbih0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRJc29JZWM2NDYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tQYXJzZWRSZXN1bHQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlzU3RpbGxJc29JZWM2NDYocG9zKSB7XG4gICAgICAgICAgICBpZiAocG9zICsgNSA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpdmVCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDUpO1xuICAgICAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA+PSA1ICYmIGZpdmVCaXRWYWx1ZSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zICsgNyA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNldmVuQml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA3KTtcbiAgICAgICAgICAgIGlmIChzZXZlbkJpdFZhbHVlID49IDY0ICYmIHNldmVuQml0VmFsdWUgPCAxMTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgKyA4ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZWlnaHRCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDgpO1xuICAgICAgICAgICAgcmV0dXJuIGVpZ2h0Qml0VmFsdWUgPj0gMjMyICYmIGVpZ2h0Qml0VmFsdWUgPCAyNTM7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlSXNvSWVjNjQ2KHBvcykge1xuICAgICAgICAgICAgbGV0IGZpdmVCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDUpO1xuICAgICAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA9PT0gMTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyKHBvcyArIDUsIERlY29kZWRDaGFyLkZOQzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA+PSA1ICYmIGZpdmVCaXRWYWx1ZSA8IDE1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA1LCAoJzAnICsgKGZpdmVCaXRWYWx1ZSAtIDUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2V2ZW5CaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDcpO1xuICAgICAgICAgICAgaWYgKHNldmVuQml0VmFsdWUgPj0gNjQgJiYgc2V2ZW5CaXRWYWx1ZSA8IDkwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA3LCAoJycgKyAoc2V2ZW5CaXRWYWx1ZSArIDEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V2ZW5CaXRWYWx1ZSA+PSA5MCAmJiBzZXZlbkJpdFZhbHVlIDwgMTE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA3LCAoJycgKyAoc2V2ZW5CaXRWYWx1ZSArIDcpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZWlnaHRCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDgpO1xuICAgICAgICAgICAgbGV0IGM7XG4gICAgICAgICAgICBzd2l0Y2ggKGVpZ2h0Qml0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDIzMjpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICchJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzM6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnXCInO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzNDpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICclJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzU6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnJic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM2OlxuICAgICAgICAgICAgICAgICAgICBjID0gJ1xcJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM3OlxuICAgICAgICAgICAgICAgICAgICBjID0gJygnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzODpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcpJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzk6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnKic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQwOlxuICAgICAgICAgICAgICAgICAgICBjID0gJysnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0MTpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDI6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnLSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQzOlxuICAgICAgICAgICAgICAgICAgICBjID0gJy4nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0NDpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcvJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDU6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnOic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ2OlxuICAgICAgICAgICAgICAgICAgICBjID0gJzsnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0NzpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICc8JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDg6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnPSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ5OlxuICAgICAgICAgICAgICAgICAgICBjID0gJz4nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI1MDpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICc/JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNTE6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnXyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjUyOlxuICAgICAgICAgICAgICAgICAgICBjID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyKHBvcyArIDgsIGMpO1xuICAgICAgICB9XG4gICAgICAgIGlzU3RpbGxBbHBoYShwb3MpIHtcbiAgICAgICAgICAgIGlmIChwb3MgKyA1ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBub3cgY2hlY2sgaWYgaXQncyBhIHZhbGlkIDUtYml0IHZhbHVlICgwLi45IGFuZCBGTkMxKVxuICAgICAgICAgICAgbGV0IGZpdmVCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDUpO1xuICAgICAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA+PSA1ICYmIGZpdmVCaXRWYWx1ZSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zICsgNiA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNpeEJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNik7XG4gICAgICAgICAgICByZXR1cm4gc2l4Qml0VmFsdWUgPj0gMTYgJiYgc2l4Qml0VmFsdWUgPCA2MzsgLy8gNjMgbm90IGluY2x1ZGVkXG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlQWxwaGFudW1lcmljKHBvcykge1xuICAgICAgICAgICAgbGV0IGZpdmVCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDUpO1xuICAgICAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA9PT0gMTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyKHBvcyArIDUsIERlY29kZWRDaGFyLkZOQzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA+PSA1ICYmIGZpdmVCaXRWYWx1ZSA8IDE1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA1LCAoJzAnICsgKGZpdmVCaXRWYWx1ZSAtIDUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2l4Qml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA2KTtcbiAgICAgICAgICAgIGlmIChzaXhCaXRWYWx1ZSA+PSAzMiAmJiBzaXhCaXRWYWx1ZSA8IDU4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA2LCAoJycgKyAoc2l4Qml0VmFsdWUgKyAzMykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjO1xuICAgICAgICAgICAgc3dpdGNoIChzaXhCaXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgNTg6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnKic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTk6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnLCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjA6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnLSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjE6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnLic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjI6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnLyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oJ0RlY29kaW5nIGludmFsaWQgYWxwaGFudW1lcmljIHZhbHVlOiAnICsgc2l4Qml0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA2LCBjKTtcbiAgICAgICAgfVxuICAgICAgICBpc0FscGhhVG82NDZUb0FscGhhTGF0Y2gocG9zKSB7XG4gICAgICAgICAgICBpZiAocG9zICsgMSA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1ICYmIGkgKyBwb3MgPCB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluZm9ybWF0aW9uLmdldChwb3MgKyAyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5mb3JtYXRpb24uZ2V0KHBvcyArIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpc0FscGhhT3I2NDZUb051bWVyaWNMYXRjaChwb3MpIHtcbiAgICAgICAgICAgIC8vIE5leHQgaXMgYWxwaGFudW1lcmljIGlmIHRoZXJlIGFyZSAzIHBvc2l0aW9ucyBhbmQgdGhleSBhcmUgYWxsIHplcm9zXG4gICAgICAgICAgICBpZiAocG9zICsgMyA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IHBvcyArIDM7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZm9ybWF0aW9uLmdldChpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaXNOdW1lcmljVG9BbHBoYU51bWVyaWNMYXRjaChwb3MpIHtcbiAgICAgICAgICAgIC8vIE5leHQgaXMgYWxwaGFudW1lcmljIGlmIHRoZXJlIGFyZSA0IHBvc2l0aW9ucyBhbmQgdGhleSBhcmUgYWxsIHplcm9zLCBvclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzdWJzZXQgb2YgdGhpcyBqdXN0IGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBzeW1ib2xcbiAgICAgICAgICAgIGlmIChwb3MgKyAxID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQgJiYgaSArIHBvcyA8IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmZvcm1hdGlvbi5nZXQocG9zICsgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgQWJzdHJhY3RFeHBhbmRlZERlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5pbmZvcm1hdGlvbiA9IGluZm9ybWF0aW9uO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmFsRGVjb2RlciA9IG5ldyBHZW5lcmFsQXBwSWREZWNvZGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldEdlbmVyYWxEZWNvZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhbERlY29kZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBBSTAxZGVjb2RlciBleHRlbmRzIEFic3RyYWN0RXhwYW5kZWREZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVDb21wcmVzc2VkR3RpbihidWYsIGN1cnJlbnRQb3MpIHtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJygwMSknKTtcbiAgICAgICAgICAgIGxldCBpbml0aWFsUG9zaXRpb24gPSBidWYubGVuZ3RoKCk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCc5Jyk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluV2l0aG91dEFJKGJ1ZiwgY3VycmVudFBvcywgaW5pdGlhbFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVDb21wcmVzc2VkR3RpbldpdGhvdXRBSShidWYsIGN1cnJlbnRQb3MsIGluaXRpYWxCdWZmZXJQb3NpdGlvbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEJsb2NrID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoY3VycmVudFBvcyArIDEwICogaSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2sgLyAxMDAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEJsb2NrIC8gMTAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKGN1cnJlbnRCbG9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBBSTAxZGVjb2Rlci5hcHBlbmRDaGVja0RpZ2l0KGJ1ZiwgaW5pdGlhbEJ1ZmZlclBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYXBwZW5kQ2hlY2tEaWdpdChidWYsIGN1cnJlbnRQb3MpIHtcbiAgICAgICAgICAgIGxldCBjaGVja0RpZ2l0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTM7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGxldCBkaWdpdCA9IGJ1Zi5jaGFyQXQoaSArIGN1cnJlbnRQb3MpIC0gJzAnO1xuICAgICAgICAgICAgICAgIC8vIFRvIGJlIGNoZWNrZWRcbiAgICAgICAgICAgICAgICBsZXQgZGlnaXQgPSBidWYuY2hhckF0KGkgKyBjdXJyZW50UG9zKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgY2hlY2tEaWdpdCArPSAoaSAmIDB4MDEpID09PSAwID8gMyAqIGRpZ2l0IDogZGlnaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0RpZ2l0ID0gMTAgLSAoY2hlY2tEaWdpdCAlIDEwKTtcbiAgICAgICAgICAgIGlmIChjaGVja0RpZ2l0ID09PSAxMCkge1xuICAgICAgICAgICAgICAgIGNoZWNrRGlnaXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmLmFwcGVuZChjaGVja0RpZ2l0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBSTAxZGVjb2Rlci5HVElOX1NJWkUgPSA0MDtcblxuICAgIGNsYXNzIEFJMDFBbmRPdGhlckFJcyBleHRlbmRzIEFJMDFkZWNvZGVyIHtcbiAgICAgICAgLy8gdGhlIHNlY29uZCBvbmUgaXMgdGhlIGVuY29kYXRpb24gbWV0aG9kLCBhbmQgdGhlIG90aGVyIHR3byBhcmUgZm9yIHRoZSB2YXJpYWJsZSBsZW5ndGhcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUluZm9ybWF0aW9uKCkge1xuICAgICAgICAgICAgbGV0IGJ1ZmYgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgYnVmZi5hcHBlbmQoJygwMSknKTtcbiAgICAgICAgICAgIGxldCBpbml0aWFsR3RpblBvc2l0aW9uID0gYnVmZi5sZW5ndGgoKTtcbiAgICAgICAgICAgIGxldCBmaXJzdEd0aW5EaWdpdCA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KEFJMDFBbmRPdGhlckFJcy5IRUFERVJfU0laRSwgNCk7XG4gICAgICAgICAgICBidWZmLmFwcGVuZChmaXJzdEd0aW5EaWdpdCk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluV2l0aG91dEFJKGJ1ZmYsIEFJMDFBbmRPdGhlckFJcy5IRUFERVJfU0laRSArIDQsIGluaXRpYWxHdGluUG9zaXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5kZWNvZGVBbGxDb2RlcyhidWZmLCBBSTAxQW5kT3RoZXJBSXMuSEVBREVSX1NJWkUgKyA0NCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQUkwMUFuZE90aGVyQUlzLkhFQURFUl9TSVpFID0gMSArIDEgKyAyOyAvLyBmaXJzdCBiaXQgZW5jb2RlcyB0aGUgbGlua2FnZSBmbGFnLFxuXG4gICAgY2xhc3MgQW55QUlEZWNvZGVyIGV4dGVuZHMgQWJzdHJhY3RFeHBhbmRlZERlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgc3VwZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlSW5mb3JtYXRpb24oKSB7XG4gICAgICAgICAgICBsZXQgYnVmID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZGVjb2RlQWxsQ29kZXMoYnVmLCBBbnlBSURlY29kZXIuSEVBREVSX1NJWkUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFueUFJRGVjb2Rlci5IRUFERVJfU0laRSA9IDIgKyAxICsgMjtcblxuICAgIGNsYXNzIEFJMDF3ZWlnaHREZWNvZGVyIGV4dGVuZHMgQUkwMWRlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgc3VwZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZUNvbXByZXNzZWRXZWlnaHQoYnVmLCBjdXJyZW50UG9zLCB3ZWlnaHRTaXplKSB7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxXZWlnaHROdW1lcmljID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoY3VycmVudFBvcywgd2VpZ2h0U2l6ZSk7XG4gICAgICAgICAgICB0aGlzLmFkZFdlaWdodENvZGUoYnVmLCBvcmlnaW5hbFdlaWdodE51bWVyaWMpO1xuICAgICAgICAgICAgbGV0IHdlaWdodE51bWVyaWMgPSB0aGlzLmNoZWNrV2VpZ2h0KG9yaWdpbmFsV2VpZ2h0TnVtZXJpYyk7XG4gICAgICAgICAgICBsZXQgY3VycmVudERpdmlzb3IgPSAxMDAwMDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh3ZWlnaHROdW1lcmljIC8gY3VycmVudERpdmlzb3IgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50RGl2aXNvciAvPSAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQod2VpZ2h0TnVtZXJpYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBBSTAxM3gweERlY29kZXIgZXh0ZW5kcyBBSTAxd2VpZ2h0RGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBzdXBlcihpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEluZm9ybWF0aW9uKCkuZ2V0U2l6ZSgpICE9IEFJMDEzeDB4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDF3ZWlnaHREZWNvZGVyLkdUSU5fU0laRSArIEFJMDEzeDB4RGVjb2Rlci5XRUlHSFRfU0laRSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJ1ZiA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluKGJ1ZiwgQUkwMTN4MHhEZWNvZGVyLkhFQURFUl9TSVpFKTtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZFdlaWdodChidWYsIEFJMDEzeDB4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDF3ZWlnaHREZWNvZGVyLkdUSU5fU0laRSwgQUkwMTN4MHhEZWNvZGVyLldFSUdIVF9TSVpFKTtcbiAgICAgICAgICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBSTAxM3gweERlY29kZXIuSEVBREVSX1NJWkUgPSA0ICsgMTtcbiAgICBBSTAxM3gweERlY29kZXIuV0VJR0hUX1NJWkUgPSAxNTtcblxuICAgIGNsYXNzIEFJMDEzMTAzZGVjb2RlciBleHRlbmRzIEFJMDEzeDB4RGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBzdXBlcihpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgYWRkV2VpZ2h0Q29kZShidWYsIHdlaWdodCkge1xuICAgICAgICAgICAgYnVmLmFwcGVuZCgnKDMxMDMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tXZWlnaHQod2VpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gd2VpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgQUkwMTMyMHhEZWNvZGVyIGV4dGVuZHMgQUkwMTN4MHhEZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRXZWlnaHRDb2RlKGJ1Ziwgd2VpZ2h0KSB7XG4gICAgICAgICAgICBpZiAod2VpZ2h0IDwgMTAwMDApIHtcbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcoMzIwMiknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJygzMjAzKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoZWNrV2VpZ2h0KHdlaWdodCkge1xuICAgICAgICAgICAgaWYgKHdlaWdodCA8IDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3ZWlnaHQgLSAxMDAwMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEFJMDEzOTJ4RGVjb2RlciBleHRlbmRzIEFJMDFkZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUluZm9ybWF0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0SW5mb3JtYXRpb24oKS5nZXRTaXplKCkgPCBBSTAxMzkyeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlci5HVElOX1NJWkUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBidWYgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkR3RpbihidWYsIEFJMDEzOTJ4RGVjb2Rlci5IRUFERVJfU0laRSk7XG4gICAgICAgICAgICBsZXQgbGFzdEFJZGlnaXQgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShBSTAxMzkyeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlci5HVElOX1NJWkUsIEFJMDEzOTJ4RGVjb2Rlci5MQVNUX0RJR0lUX1NJWkUpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZCgnKDM5MicpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZChsYXN0QUlkaWdpdCk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcpJyk7XG4gICAgICAgICAgICBsZXQgZGVjb2RlZEluZm9ybWF0aW9uID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmRlY29kZUdlbmVyYWxQdXJwb3NlRmllbGQoQUkwMTM5MnhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMWRlY29kZXIuR1RJTl9TSVpFICsgQUkwMTM5MnhEZWNvZGVyLkxBU1RfRElHSVRfU0laRSwgbnVsbCk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKGRlY29kZWRJbmZvcm1hdGlvbi5nZXROZXdTdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQUkwMTM5MnhEZWNvZGVyLkhFQURFUl9TSVpFID0gNSArIDEgKyAyO1xuICAgIEFJMDEzOTJ4RGVjb2Rlci5MQVNUX0RJR0lUX1NJWkUgPSAyO1xuXG4gICAgY2xhc3MgQUkwMTM5M3hEZWNvZGVyIGV4dGVuZHMgQUkwMWRlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgc3VwZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlSW5mb3JtYXRpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJbmZvcm1hdGlvbigpLmdldFNpemUoKSA8IEFJMDEzOTN4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyLkdUSU5fU0laRSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJ1ZiA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluKGJ1ZiwgQUkwMTM5M3hEZWNvZGVyLkhFQURFUl9TSVpFKTtcbiAgICAgICAgICAgIGxldCBsYXN0QUlkaWdpdCA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KEFJMDEzOTN4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyLkdUSU5fU0laRSwgQUkwMTM5M3hEZWNvZGVyLkxBU1RfRElHSVRfU0laRSk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcoMzkzJyk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKGxhc3RBSWRpZ2l0KTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJyknKTtcbiAgICAgICAgICAgIGxldCBmaXJzdFRocmVlRGlnaXRzID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoQUkwMTM5M3hEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMWRlY29kZXIuR1RJTl9TSVpFICsgQUkwMTM5M3hEZWNvZGVyLkxBU1RfRElHSVRfU0laRSwgQUkwMTM5M3hEZWNvZGVyLkZJUlNUX1RIUkVFX0RJR0lUU19TSVpFKTtcbiAgICAgICAgICAgIGlmIChmaXJzdFRocmVlRGlnaXRzIC8gMTAwID09IDApIHtcbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaHJlZURpZ2l0cyAvIDEwID09IDApIHtcbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWYuYXBwZW5kKGZpcnN0VGhyZWVEaWdpdHMpO1xuICAgICAgICAgICAgbGV0IGdlbmVyYWxJbmZvcm1hdGlvbiA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5kZWNvZGVHZW5lcmFsUHVycG9zZUZpZWxkKEFJMDEzOTN4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyLkdUSU5fU0laRSArIEFJMDEzOTN4RGVjb2Rlci5MQVNUX0RJR0lUX1NJWkUgKyBBSTAxMzkzeERlY29kZXIuRklSU1RfVEhSRUVfRElHSVRTX1NJWkUsIG51bGwpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZChnZW5lcmFsSW5mb3JtYXRpb24uZ2V0TmV3U3RyaW5nKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFJMDEzOTN4RGVjb2Rlci5IRUFERVJfU0laRSA9IDUgKyAxICsgMjtcbiAgICBBSTAxMzkzeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFID0gMjtcbiAgICBBSTAxMzkzeERlY29kZXIuRklSU1RfVEhSRUVfRElHSVRTX1NJWkUgPSAxMDtcblxuICAgIGNsYXNzIEFJMDEzeDB4MXhEZWNvZGVyIGV4dGVuZHMgQUkwMXdlaWdodERlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbiwgZmlyc3RBSWRpZ2l0cywgZGF0ZUNvZGUpIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZGF0ZUNvZGUgPSBkYXRlQ29kZTtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RBSWRpZ2l0cyA9IGZpcnN0QUlkaWdpdHM7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEluZm9ybWF0aW9uKCkuZ2V0U2l6ZSgpICE9IEFJMDEzeDB4MXhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMTN4MHgxeERlY29kZXIuR1RJTl9TSVpFICsgQUkwMTN4MHgxeERlY29kZXIuV0VJR0hUX1NJWkUgKyBBSTAxM3gweDF4RGVjb2Rlci5EQVRFX1NJWkUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBidWYgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkR3RpbihidWYsIEFJMDEzeDB4MXhEZWNvZGVyLkhFQURFUl9TSVpFKTtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZFdlaWdodChidWYsIEFJMDEzeDB4MXhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMTN4MHgxeERlY29kZXIuR1RJTl9TSVpFLCBBSTAxM3gweDF4RGVjb2Rlci5XRUlHSFRfU0laRSk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWREYXRlKGJ1ZiwgQUkwMTN4MHgxeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxM3gweDF4RGVjb2Rlci5HVElOX1NJWkUgKyBBSTAxM3gweDF4RGVjb2Rlci5XRUlHSFRfU0laRSk7XG4gICAgICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlQ29tcHJlc3NlZERhdGUoYnVmLCBjdXJyZW50UG9zKSB7XG4gICAgICAgICAgICBsZXQgbnVtZXJpY0RhdGUgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShjdXJyZW50UG9zLCBBSTAxM3gweDF4RGVjb2Rlci5EQVRFX1NJWkUpO1xuICAgICAgICAgICAgaWYgKG51bWVyaWNEYXRlID09IDM4NDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmLmFwcGVuZCgnKCcpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZCh0aGlzLmRhdGVDb2RlKTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJyknKTtcbiAgICAgICAgICAgIGxldCBkYXkgPSBudW1lcmljRGF0ZSAlIDMyO1xuICAgICAgICAgICAgbnVtZXJpY0RhdGUgLz0gMzI7XG4gICAgICAgICAgICBsZXQgbW9udGggPSBudW1lcmljRGF0ZSAlIDEyICsgMTtcbiAgICAgICAgICAgIG51bWVyaWNEYXRlIC89IDEyO1xuICAgICAgICAgICAgbGV0IHllYXIgPSBudW1lcmljRGF0ZTtcbiAgICAgICAgICAgIGlmICh5ZWFyIC8gMTAgPT0gMCkge1xuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoeWVhcik7XG4gICAgICAgICAgICBpZiAobW9udGggLyAxMCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmLmFwcGVuZChtb250aCk7XG4gICAgICAgICAgICBpZiAoZGF5IC8gMTAgPT0gMCkge1xuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoZGF5KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRXZWlnaHRDb2RlKGJ1Ziwgd2VpZ2h0KSB7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcoJyk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKHRoaXMuZmlyc3RBSWRpZ2l0cyk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKHdlaWdodCAvIDEwMDAwMCk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tXZWlnaHQod2VpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gd2VpZ2h0ICUgMTAwMDAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFJMDEzeDB4MXhEZWNvZGVyLkhFQURFUl9TSVpFID0gNyArIDE7XG4gICAgQUkwMTN4MHgxeERlY29kZXIuV0VJR0hUX1NJWkUgPSAyMDtcbiAgICBBSTAxM3gweDF4RGVjb2Rlci5EQVRFX1NJWkUgPSAxNjtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURlY29kZXIoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpbmZvcm1hdGlvbi5nZXQoMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFJMDFBbmRPdGhlckFJcyhpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWluZm9ybWF0aW9uLmdldCgyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQW55QUlEZWNvZGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3VyQml0RW5jb2RhdGlvbk1ldGhvZCA9IEdlbmVyYWxBcHBJZERlY29kZXIuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShpbmZvcm1hdGlvbiwgMSwgNCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZvdXJCaXRFbmNvZGF0aW9uTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEFJMDEzMTAzZGVjb2RlcihpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEFJMDEzMjB4RGVjb2RlcihpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZml2ZUJpdEVuY29kYXRpb25NZXRob2QgPSBHZW5lcmFsQXBwSWREZWNvZGVyLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoaW5mb3JtYXRpb24sIDEsIDUpO1xuICAgICAgICAgICAgc3dpdGNoIChmaXZlQml0RW5jb2RhdGlvbk1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBuZXcgQUkwMTM5MnhEZWNvZGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gbmV3IEFJMDEzOTN4RGVjb2RlcihpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2V2ZW5CaXRFbmNvZGF0aW9uTWV0aG9kID0gR2VuZXJhbEFwcElkRGVjb2Rlci5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KGluZm9ybWF0aW9uLCAxLCA3KTtcbiAgICAgICAgICAgIHN3aXRjaCAoc2V2ZW5CaXRFbmNvZGF0aW9uTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA1NjogcmV0dXJuIG5ldyBBSTAxM3gweDF4RGVjb2RlcihpbmZvcm1hdGlvbiwgJzMxMCcsICcxMScpO1xuICAgICAgICAgICAgICAgIGNhc2UgNTc6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXIoaW5mb3JtYXRpb24sICczMjAnLCAnMTEnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDU4OiByZXR1cm4gbmV3IEFJMDEzeDB4MXhEZWNvZGVyKGluZm9ybWF0aW9uLCAnMzEwJywgJzEzJyk7XG4gICAgICAgICAgICAgICAgY2FzZSA1OTogcmV0dXJuIG5ldyBBSTAxM3gweDF4RGVjb2RlcihpbmZvcm1hdGlvbiwgJzMyMCcsICcxMycpO1xuICAgICAgICAgICAgICAgIGNhc2UgNjA6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXIoaW5mb3JtYXRpb24sICczMTAnLCAnMTUnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDYxOiByZXR1cm4gbmV3IEFJMDEzeDB4MXhEZWNvZGVyKGluZm9ybWF0aW9uLCAnMzIwJywgJzE1Jyk7XG4gICAgICAgICAgICAgICAgY2FzZSA2MjogcmV0dXJuIG5ldyBBSTAxM3gweDF4RGVjb2RlcihpbmZvcm1hdGlvbiwgJzMxMCcsICcxNycpO1xuICAgICAgICAgICAgICAgIGNhc2UgNjM6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXIoaW5mb3JtYXRpb24sICczMjAnLCAnMTcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCd1bmtub3duIGRlY29kZXI6ICcgKyBpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBFeHBhbmRlZFBhaXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihsZWZ0Q2hhciwgcmlnaHRDaGFyLCBmaW5kZXJQYXR0ZXIsIG1heUJlTGFzdCkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0Y2hhciA9IGxlZnRDaGFyO1xuICAgICAgICAgICAgdGhpcy5yaWdodGNoYXIgPSByaWdodENoYXI7XG4gICAgICAgICAgICB0aGlzLmZpbmRlcnBhdHRlcm4gPSBmaW5kZXJQYXR0ZXI7XG4gICAgICAgICAgICB0aGlzLm1heWJlTGFzdCA9IG1heUJlTGFzdDtcbiAgICAgICAgfVxuICAgICAgICBtYXlCZUxhc3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXliZUxhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TGVmdENoYXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Y2hhcjtcbiAgICAgICAgfVxuICAgICAgICBnZXRSaWdodENoYXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodGNoYXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RmluZGVyUGF0dGVybigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRlcnBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgbXVzdEJlTGFzdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Y2hhciA9PSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICdbICcgKyB0aGlzLmxlZnRjaGFyICsgJywgJyArIHRoaXMucmlnaHRjaGFyICsgJyA6ICcgKyAodGhpcy5maW5kZXJwYXR0ZXJuID09IG51bGwgPyAnbnVsbCcgOiB0aGlzLmZpbmRlcnBhdHRlcm4uZ2V0VmFsdWUoKSkgKyAnIF0nO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlcXVhbHMobzEsIG8yKSB7XG4gICAgICAgICAgICBpZiAoIShvMSBpbnN0YW5jZW9mIEV4cGFuZGVkUGFpcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRXhwYW5kZWRQYWlyLmVxdWFsc09yTnVsbChvMS5sZWZ0Y2hhciwgbzIubGVmdGNoYXIpICYmXG4gICAgICAgICAgICAgICAgRXhwYW5kZWRQYWlyLmVxdWFsc09yTnVsbChvMS5yaWdodGNoYXIsIG8yLnJpZ2h0Y2hhcikgJiZcbiAgICAgICAgICAgICAgICBFeHBhbmRlZFBhaXIuZXF1YWxzT3JOdWxsKG8xLmZpbmRlcnBhdHRlcm4sIG8yLmZpbmRlcnBhdHRlcm4pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlcXVhbHNPck51bGwobzEsIG8yKSB7XG4gICAgICAgICAgICByZXR1cm4gbzEgPT09IG51bGwgPyBvMiA9PT0gbnVsbCA6IEV4cGFuZGVkUGFpci5lcXVhbHMobzEsIG8yKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBFeHBhbmRlZFBhaXIuaGFzaE5vdE51bGwobGVmdENoYXIpIF4gaGFzaE5vdE51bGwocmlnaHRDaGFyKSBeIGhhc2hOb3ROdWxsKGZpbmRlclBhdHRlcm4pO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5sZWZ0Y2hhci5nZXRWYWx1ZSgpIF4gdGhpcy5yaWdodGNoYXIuZ2V0VmFsdWUoKSBeIHRoaXMuZmluZGVycGF0dGVybi5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgRXhwYW5kZWRSb3cge1xuICAgICAgICBjb25zdHJ1Y3RvcihwYWlycywgcm93TnVtYmVyLCB3YXNSZXZlcnNlZCkge1xuICAgICAgICAgICAgdGhpcy5wYWlycyA9IHBhaXJzO1xuICAgICAgICAgICAgdGhpcy5yb3dOdW1iZXIgPSByb3dOdW1iZXI7XG4gICAgICAgICAgICB0aGlzLndhc1JldmVyc2VkID0gd2FzUmV2ZXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UGFpcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWlycztcbiAgICAgICAgfVxuICAgICAgICBnZXRSb3dOdW1iZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgaXNSZXZlcnNlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhc1JldmVyc2VkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlzRXF1aXZhbGVudChvdGhlclBhaXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja0VxdWFsaXRpdHkodGhpcywgb3RoZXJQYWlycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICd7ICcgKyB0aGlzLnBhaXJzICsgJyB9JztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVHdvIHJvd3MgYXJlIGVxdWFsIGlmIHRoZXkgY29udGFpbiB0aGUgc2FtZSBwYWlycyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICovXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICAvLyBjaGVjayBpbXBsZW1lbnRhdGlvblxuICAgICAgICBlcXVhbHMobzEsIG8yKSB7XG4gICAgICAgICAgICBpZiAoIShvMSBpbnN0YW5jZW9mIEV4cGFuZGVkUm93KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrRXF1YWxpdGl0eShvMSwgbzIpICYmIG8xLndhc1JldmVyc2VkID09PSBvMi53YXNSZXZlcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0VxdWFsaXRpdHkocGFpcjEsIHBhaXIyKSB7XG4gICAgICAgICAgICBpZiAoIXBhaXIxIHx8ICFwYWlyMilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgcGFpcjEuZm9yRWFjaCgoZTEsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBwYWlyMi5mb3JFYWNoKGUyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUxLmdldExlZnRDaGFyKCkuZ2V0VmFsdWUoKSA9PT0gZTIuZ2V0TGVmdENoYXIoKS5nZXRWYWx1ZSgpICYmIGUxLmdldFJpZ2h0Q2hhcigpLmdldFZhbHVlKCkgPT09IGUyLmdldFJpZ2h0Q2hhcigpLmdldFZhbHVlKCkgJiYgZTEuZ2V0RmluZGVyUGF0dGVyKCkuZ2V0VmFsdWUoKSA9PT0gZTIuZ2V0RmluZGVyUGF0dGVyKCkuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5JdGVyYXRvcjtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5NYXA7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9ucztcbiAgICBjbGFzcyBSU1NFeHBhbmRlZFJlYWRlciBleHRlbmRzIEFic3RyYWN0UlNTUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IodmVyYm9zZSkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMucGFpcnMgPSBuZXcgQXJyYXkoUlNTRXhwYW5kZWRSZWFkZXIuTUFYX1BBSVJTKTtcbiAgICAgICAgICAgIHRoaXMucm93cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFydEVuZCA9IFsyXTtcbiAgICAgICAgICAgIHRoaXMudmVyYm9zZSA9ICh2ZXJib3NlID09PSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgICAgICAvLyBSb3dzIGNhbiBzdGFydCB3aXRoIGV2ZW4gcGF0dGVybiBpbiBjYXNlIGluIHByZXYgcm93cyB0aGVyZSB3aGVyZSBvZGQgbnVtYmVyIG9mIHBhdHRlcnMuXG4gICAgICAgICAgICAvLyBTbyBsZXRzIHRyeSB0d2ljZVxuICAgICAgICAgICAgLy8gdGhpcy5wYWlycy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5wYWlycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5zdGFydEZyb21FdmVuID0gZmFsc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSU1NFeHBhbmRlZFJlYWRlci5jb25zdHJ1Y3RSZXN1bHQodGhpcy5kZWNvZGVSb3cycGFpcnMocm93TnVtYmVyLCByb3cpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gT0tcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFpcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRGcm9tRXZlbiA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gUlNTRXhwYW5kZWRSZWFkZXIuY29uc3RydWN0UmVzdWx0KHRoaXMuZGVjb2RlUm93MnBhaXJzKHJvd051bWJlciwgcm93KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICB0aGlzLnBhaXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnJvd3MubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgcHJpdmF0ZSBmb3IgdGVzdGluZ1xuICAgICAgICBkZWNvZGVSb3cycGFpcnMocm93TnVtYmVyLCByb3cpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhaXJzLnB1c2godGhpcy5yZXRyaWV2ZU5leHRQYWlyKHJvdywgdGhpcy5wYWlycywgcm93TnVtYmVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhaXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhpdCB0aGlzIGxvb3Agd2hlbiByZXRyaWV2ZU5leHRQYWlyKCkgZmFpbHMgYW5kIHRocm93c1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiB2ZXJpZnkgc2VxdWVuY2Ugb2YgZmluZGVyIHBhdHRlcm5zIGFzIGluIGNoZWNrUGFpclNlcXVlbmNlKClcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrQ2hlY2tzdW0oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyeVN0YWNrZWREZWNvZGU7XG4gICAgICAgICAgICBpZiAodGhpcy5yb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRyeVN0YWNrZWREZWNvZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5U3RhY2tlZERlY29kZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGV0IHRyeVN0YWNrZWREZWNvZGUgPSAhdGhpcy5yb3dzLmlzRW1wdHkoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVSb3cocm93TnVtYmVyLCBmYWxzZSk7IC8vIFRPRE86IGRlYWwgd2l0aCByZXZlcnNlZCByb3dzXG4gICAgICAgICAgICBpZiAodHJ5U3RhY2tlZERlY29kZSkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGltYWdlIGlzIDE4MC1yb3RhdGVkLCB0aGVuIHJvd3MgYXJlIHNvcnRlZCBpbiB3cm9uZyBkaXJlY3Rpb24uXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHR3aWNlIHdpdGggYm90aCB0aGUgZGlyZWN0aW9ucy5cbiAgICAgICAgICAgICAgICBsZXQgcHMgPSB0aGlzLmNoZWNrUm93c0Jvb2xlYW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChwcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHMgPSB0aGlzLmNoZWNrUm93c0Jvb2xlYW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5lZWQgdG8gVmVyaWZ5XG4gICAgICAgIGNoZWNrUm93c0Jvb2xlYW4ocmV2ZXJzZSkge1xuICAgICAgICAgICAgLy8gTGltaXQgbnVtYmVyIG9mIHJvd3Mgd2UgYXJlIGNoZWNraW5nXG4gICAgICAgICAgICAvLyBXZSB1c2UgcmVjdXJzaXZlIGFsZ29yaXRobSB3aXRoIHB1cmUgY29tcGxleGl0eSBhbmQgZG9uJ3Qgd2FudCBpdCB0byB0YWtlIGZvcmV2ZXJcbiAgICAgICAgICAgIC8vIFN0YWNrZWQgYmFyY29kZSBjYW4gaGF2ZSB1cCB0byAxMSByb3dzLCBzbyAyNSBzZWVtcyByZWFzb25hYmxlIGVub3VnaFxuICAgICAgICAgICAgaWYgKHRoaXMucm93cy5sZW5ndGggPiAyNSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm93cy5sZW5ndGggPSAwOyAvLyBXZSB3aWxsIG5ldmVyIGhhdmUgYSBjaGFuY2UgdG8gZ2V0IHJlc3VsdCwgc28gY2xlYXIgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFpcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzID0gdGhpcy5yb3dzLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBDb2xsZWN0aW9ucy5yZXZlcnNlKHRoaXMucm93cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHMgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcyA9IHRoaXMuY2hlY2tSb3dzKG5ldyBBcnJheSgpLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gT0tcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzID0gdGhpcy5yb3dzLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBDb2xsZWN0aW9ucy5yZXZlcnNlKHRoaXMucm93cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIGNvbnN0cnVjdCBhIHZhbGlkIHJvd3Mgc2VxdWVuY2VcbiAgICAgICAgLy8gUmVjdXJzaW9uIGlzIHVzZWQgdG8gaW1wbGVtZW50IGJhY2t0cmFja2luZ1xuICAgICAgICBjaGVja1Jvd3MoY29sbGVjdGVkUm93cywgY3VycmVudFJvdykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGN1cnJlbnRSb3c7IGkgPCB0aGlzLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcm93ID0gdGhpcy5yb3dzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMucGFpcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2xsZWN0ZWRSb3cgb2YgY29sbGVjdGVkUm93cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhaXJzLnB1c2goY29sbGVjdGVkUm93LmdldFBhaXJzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhaXJzLnB1c2gocm93LmdldFBhaXJzKCkpO1xuICAgICAgICAgICAgICAgIGlmICghUlNTRXhwYW5kZWRSZWFkZXIuaXNWYWxpZFNlcXVlbmNlKHRoaXMucGFpcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0NoZWNrc3VtKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBycyA9IG5ldyBBcnJheShjb2xsZWN0ZWRSb3dzKTtcbiAgICAgICAgICAgICAgICBycy5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzaW9uOiB0cnkgdG8gYWRkIG1vcmUgcm93c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja1Jvd3MocnMsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZmFpbGVkLCB0cnkgdGhlIG5leHQgY2FuZGlkYXRlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hldGhlciB0aGUgcGFpcnMgZm9ybSBhIHZhbGlkIGZpbmQgcGF0dGVybiBzZXF1ZW5jZSxcbiAgICAgICAgLy8gZWl0aGVyIGNvbXBsZXRlIG9yIGEgcHJlZml4XG4gICAgICAgIHN0YXRpYyBpc1ZhbGlkU2VxdWVuY2UocGFpcnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNlcXVlbmNlIG9mIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRURVJOX1NFUVVFTkNFUykge1xuICAgICAgICAgICAgICAgIGlmIChwYWlycy5sZW5ndGggPiBzZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhaXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWlyc1tqXS5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0VmFsdWUoKSAhPSBzZXF1ZW5jZVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlUm93KHJvd051bWJlciwgd2FzUmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIC8vIERpc2NhcmQgaWYgZHVwbGljYXRlIGFib3ZlIG9yIGJlbG93OyBvdGhlcndpc2UgaW5zZXJ0IGluIG9yZGVyIGJ5IHJvdyBudW1iZXIuXG4gICAgICAgICAgICBsZXQgaW5zZXJ0UG9zID0gMDtcbiAgICAgICAgICAgIGxldCBwcmV2SXNTYW1lID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbmV4dElzU2FtZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKGluc2VydFBvcyA8IHRoaXMucm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXJvdyA9IHRoaXMucm93c1tpbnNlcnRQb3NdO1xuICAgICAgICAgICAgICAgIGlmIChlcm93LmdldFJvd051bWJlcigpID4gcm93TnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRJc1NhbWUgPSBlcm93LmlzRXF1aXZhbGVudCh0aGlzLnBhaXJzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZJc1NhbWUgPSBlcm93LmlzRXF1aXZhbGVudCh0aGlzLnBhaXJzKTtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0SXNTYW1lIHx8IHByZXZJc1NhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSByb3cgd2FzIHBhcnRpYWxseSBkZWNvZGVkIChlLmcuIDIgcGFpcnMgZm91bmQgaW5zdGVhZCBvZiAzKSxcbiAgICAgICAgICAgIC8vIGl0IHdpbGwgcHJldmVudCB1cyBmcm9tIGRldGVjdGluZyB0aGUgYmFyY29kZS5cbiAgICAgICAgICAgIC8vIFRyeSB0byBtZXJnZSBwYXJ0aWFsIHJvd3NcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIHJvdyBpcyBwYXJ0IG9mIGFuIGFsbHJlYWR5IGRldGVjdGVkIHJvd1xuICAgICAgICAgICAgaWYgKFJTU0V4cGFuZGVkUmVhZGVyLmlzUGFydGlhbFJvdyh0aGlzLnBhaXJzLCB0aGlzLnJvd3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb3dzLnB1c2goaW5zZXJ0UG9zLCBuZXcgRXhwYW5kZWRSb3codGhpcy5wYWlycywgcm93TnVtYmVyLCB3YXNSZXZlcnNlZCkpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQYXJ0aWFsUm93cyh0aGlzLnBhaXJzLCB0aGlzLnJvd3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgdGhlIHJvd3MgdGhhdCBjb250YWlucyBvbmx5IHNwZWNpZmllZCBwYWlyc1xuICAgICAgICByZW1vdmVQYXJ0aWFsUm93cyhwYWlycywgcm93cykge1xuICAgICAgICAgICAgLy8gZm9yIChJdGVyYXRvcjxFeHBhbmRlZFJvdz4gaXRlcmF0b3IgPSByb3dzLml0ZXJhdG9yKCk7IGl0ZXJhdG9yLmhhc05leHQoKTspIHtcbiAgICAgICAgICAgIC8vICAgRXhwYW5kZWRSb3cgciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIC8vICAgaWYgKHIuZ2V0UGFpcnMoKS5zaXplKCkgPT0gcGFpcnMuc2l6ZSgpKSB7XG4gICAgICAgICAgICAvLyAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vICAgYm9vbGVhbiBhbGxGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAvLyAgIGZvciAoRXhwYW5kZWRQYWlyIHAgOiByLmdldFBhaXJzKCkpIHtcbiAgICAgICAgICAgIC8vICAgICBib29sZWFuIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAvLyAgICAgZm9yIChFeHBhbmRlZFBhaXIgcHAgOiBwYWlycykge1xuICAgICAgICAgICAgLy8gICAgICAgaWYgKHAuZXF1YWxzKHBwKSkge1xuICAgICAgICAgICAgLy8gICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAvLyAgICAgICBhbGxGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAvLyAgIGlmIChhbGxGb3VuZCkge1xuICAgICAgICAgICAgLy8gICAgIC8vICdwYWlycycgY29udGFpbnMgYWxsIHRoZSBwYWlycyBmcm9tIHRoZSByb3cgJ3InXG4gICAgICAgICAgICAvLyAgICAgaXRlcmF0b3IucmVtb3ZlKCk7XG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGZvciAobGV0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXRQYWlycygpLmxlbmd0aCA9PT0gcGFpcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHJvdy5nZXRQYWlycygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHBwIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRXhwYW5kZWRQYWlyLmVxdWFscyhwLCBwcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm5zIHRydWUgd2hlbiBvbmUgb2YgdGhlIHJvd3MgYWxyZWFkeSBjb250YWlucyBhbGwgdGhlIHBhaXJzXG4gICAgICAgIHN0YXRpYyBpc1BhcnRpYWxSb3cocGFpcnMsIHJvd3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2Ygcm93cykge1xuICAgICAgICAgICAgICAgIGxldCBhbGxGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcHAgb2Ygci5nZXRQYWlycygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5lcXVhbHMocHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJvdyAncicgY29udGFpbiBhbGwgdGhlIHBhaXJzIGZyb20gJ3BhaXJzJ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSB1c2VkIGZvciB1bml0IHRlc3RpbmdcbiAgICAgICAgZ2V0Um93cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHByaXZhdGUgZm9yIHVuaXQgdGVzdGluZ1xuICAgICAgICBzdGF0aWMgY29uc3RydWN0UmVzdWx0KHBhaXJzKSB7XG4gICAgICAgICAgICBsZXQgYmluYXJ5ID0gQml0QXJyYXlCdWlsZGVyLmJ1aWxkQml0QXJyYXkocGFpcnMpO1xuICAgICAgICAgICAgbGV0IGRlY29kZXIgPSBjcmVhdGVEZWNvZGVyKGJpbmFyeSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0aW5nU3RyaW5nID0gZGVjb2Rlci5wYXJzZUluZm9ybWF0aW9uKCk7XG4gICAgICAgICAgICBsZXQgZmlyc3RQb2ludHMgPSBwYWlyc1swXS5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0UmVzdWx0UG9pbnRzKCk7XG4gICAgICAgICAgICBsZXQgbGFzdFBvaW50cyA9IHBhaXJzW3BhaXJzLmxlbmd0aCAtIDFdLmdldEZpbmRlclBhdHRlcm4oKS5nZXRSZXN1bHRQb2ludHMoKTtcbiAgICAgICAgICAgIGxldCBwb2ludHMgPSBbZmlyc3RQb2ludHNbMF0sIGZpcnN0UG9pbnRzWzFdLCBsYXN0UG9pbnRzWzBdLCBsYXN0UG9pbnRzWzFdXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0KHJlc3VsdGluZ1N0cmluZywgbnVsbCwgbnVsbCwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0JDEuUlNTX0VYUEFOREVELCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0NoZWNrc3VtKCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0UGFpciA9IHRoaXMucGFpcnMuZ2V0KDApO1xuICAgICAgICAgICAgbGV0IGNoZWNrQ2hhcmFjdGVyID0gZmlyc3RQYWlyLmdldExlZnRDaGFyKCk7XG4gICAgICAgICAgICBsZXQgZmlyc3RDaGFyYWN0ZXIgPSBmaXJzdFBhaXIuZ2V0UmlnaHRDaGFyKCk7XG4gICAgICAgICAgICBpZiAoZmlyc3RDaGFyYWN0ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGVja3N1bSA9IGZpcnN0Q2hhcmFjdGVyLmdldENoZWNrc3VtUG9ydGlvbigpO1xuICAgICAgICAgICAgbGV0IHMgPSAyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnBhaXJzLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRQYWlyID0gdGhpcy5wYWlycy5nZXQoaSk7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW0gKz0gY3VycmVudFBhaXIuZ2V0TGVmdENoYXIoKS5nZXRDaGVja3N1bVBvcnRpb24oKTtcbiAgICAgICAgICAgICAgICBzKys7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRSaWdodENoYXIgPSBjdXJyZW50UGFpci5nZXRSaWdodENoYXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFJpZ2h0Q2hhciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrc3VtICs9IGN1cnJlbnRSaWdodENoYXIuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja3N1bSAlPSAyMTE7XG4gICAgICAgICAgICBsZXQgY2hlY2tDaGFyYWN0ZXJWYWx1ZSA9IDIxMSAqIChzIC0gNCkgKyBjaGVja3N1bTtcbiAgICAgICAgICAgIHJldHVybiBjaGVja0NoYXJhY3RlclZhbHVlID09IGNoZWNrQ2hhcmFjdGVyLmdldFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldE5leHRTZWNvbmRCYXIocm93LCBpbml0aWFsUG9zKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFBvcztcbiAgICAgICAgICAgIGlmIChyb3cuZ2V0KGluaXRpYWxQb3MpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IHJvdy5nZXROZXh0VW5zZXQoaW5pdGlhbFBvcyk7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IHJvdy5nZXROZXh0U2V0KGN1cnJlbnRQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IHJvdy5nZXROZXh0U2V0KGluaXRpYWxQb3MpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSByb3cuZ2V0TmV4dFVuc2V0KGN1cnJlbnRQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQb3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90IHByaXZhdGUgZm9yIHRlc3RpbmdcbiAgICAgICAgcmV0cmlldmVOZXh0UGFpcihyb3csIHByZXZpb3VzUGFpcnMsIHJvd051bWJlcikge1xuICAgICAgICAgICAgbGV0IGlzT2RkUGF0dGVybiA9IHByZXZpb3VzUGFpcnMubGVuZ3RoICUgMiA9PSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRGcm9tRXZlbikge1xuICAgICAgICAgICAgICAgIGlzT2RkUGF0dGVybiA9ICFpc09kZFBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGF0dGVybjtcbiAgICAgICAgICAgIGxldCBrZWVwRmluZGluZyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZm9yY2VkT2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kTmV4dFBhaXIocm93LCBwcmV2aW91c1BhaXJzLCBmb3JjZWRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLnBhcnNlRm91bmRGaW5kZXJQYXR0ZXJuKHJvdywgcm93TnVtYmVyLCBpc09kZFBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkT2Zmc2V0ID0gUlNTRXhwYW5kZWRSZWFkZXIuZ2V0TmV4dFNlY29uZEJhcihyb3csIHRoaXMuc3RhcnRFbmRbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2VlcEZpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChrZWVwRmluZGluZyk7XG4gICAgICAgICAgICAvLyBXaGVuIHN0YWNrZWQgc3ltYm9sIGlzIHNwbGl0IG92ZXIgbXVsdGlwbGUgcm93cywgdGhlcmUncyBubyB3YXkgdG8gZ3Vlc3MgaWYgdGhpcyBwYWlyIGNhbiBiZSBsYXN0IG9yIG5vdC5cbiAgICAgICAgICAgIC8vIGJvb2xlYW4gbWF5QmVMYXN0ID0gY2hlY2tQYWlyU2VxdWVuY2UocHJldmlvdXNQYWlycywgcGF0dGVybik7XG4gICAgICAgICAgICBsZXQgbGVmdENoYXIgPSB0aGlzLmRlY29kZURhdGFDaGFyYWN0ZXIocm93LCBwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIHRydWUpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRW1wdHlQYWlyKHByZXZpb3VzUGFpcnMpICYmIHByZXZpb3VzUGFpcnNbcHJldmlvdXNQYWlycy5sZW5ndGggLSAxXS5tdXN0QmVMYXN0KCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByaWdodENoYXI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJpZ2h0Q2hhciA9IHRoaXMuZGVjb2RlRGF0YUNoYXJhY3Rlcihyb3csIHBhdHRlcm4sIGlzT2RkUGF0dGVybiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByaWdodENoYXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHBhbmRlZFBhaXIobGVmdENoYXIsIHJpZ2h0Q2hhciwgcGF0dGVybiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaXNFbXB0eVBhaXIocGFpcnMpIHtcbiAgICAgICAgICAgIGlmIChwYWlycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5kTmV4dFBhaXIocm93LCBwcmV2aW91c1BhaXJzLCBmb3JjZWRPZmZzZXQpIHtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IHRoaXMuZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKTtcbiAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgcm93T2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGZvcmNlZE9mZnNldCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gZm9yY2VkT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0VtcHR5UGFpcihwcmV2aW91c1BhaXJzKSkge1xuICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdFBhaXIgPSBwcmV2aW91c1BhaXJzW3ByZXZpb3VzUGFpcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gbGFzdFBhaXIuZ2V0RmluZGVyUGF0dGVybigpLmdldFN0YXJ0RW5kKClbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2VhcmNoaW5nRXZlblBhaXIgPSBwcmV2aW91c1BhaXJzLmxlbmd0aCAlIDIgIT0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0RnJvbUV2ZW4pIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hpbmdFdmVuUGFpciA9ICFzZWFyY2hpbmdFdmVuUGFpcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAocm93T2Zmc2V0IDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIXJvdy5nZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvd09mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvdW50ZXJQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IHJvd09mZnNldDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmdldCh4KSAhPSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaGluZ0V2ZW5QYWlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIucmV2ZXJzZUNvdW50ZXJzKGNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSU1NFeHBhbmRlZFJlYWRlci5pc0ZpbmRlclBhdHRlcm4oY291bnRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydEVuZFswXSA9IHBhdHRlcm5TdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RW5kWzFdID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoaW5nRXZlblBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5yZXZlcnNlQ291bnRlcnMoY291bnRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJzWzBdICsgY291bnRlcnNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1swXSA9IGNvdW50ZXJzWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbMV0gPSBjb3VudGVyc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcmV2ZXJzZUNvdW50ZXJzKGNvdW50ZXJzKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGggLyAyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgY291bnRlcnNbaV0gPSBjb3VudGVyc1tsZW5ndGggLSBpIC0gMV07XG4gICAgICAgICAgICAgICAgY291bnRlcnNbbGVuZ3RoIC0gaSAtIDFdID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcnNlRm91bmRGaW5kZXJQYXR0ZXJuKHJvdywgcm93TnVtYmVyLCBvZGRQYXR0ZXJuKSB7XG4gICAgICAgICAgICAvLyBBY3R1YWxseSB3ZSBmb3VuZCBlbGVtZW50cyAyLTUuXG4gICAgICAgICAgICBsZXQgZmlyc3RDb3VudGVyO1xuICAgICAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgICAgIGlmIChvZGRQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGF0dGVybiBudW1iZXIgaXMgb2RkLCB3ZSBuZWVkIHRvIGxvY2F0ZSBlbGVtZW50IDEgKmJlZm9yZSogdGhlIGN1cnJlbnQgYmxvY2suXG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0RWxlbWVudFN0YXJ0ID0gdGhpcy5zdGFydEVuZFswXSAtIDE7XG4gICAgICAgICAgICAgICAgLy8gTG9jYXRlIGVsZW1lbnQgMVxuICAgICAgICAgICAgICAgIHdoaWxlIChmaXJzdEVsZW1lbnRTdGFydCA+PSAwICYmICFyb3cuZ2V0KGZpcnN0RWxlbWVudFN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVsZW1lbnRTdGFydC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaXJzdEVsZW1lbnRTdGFydCsrO1xuICAgICAgICAgICAgICAgIGZpcnN0Q291bnRlciA9IHRoaXMuc3RhcnRFbmRbMF0gLSBmaXJzdEVsZW1lbnRTdGFydDtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGZpcnN0RWxlbWVudFN0YXJ0O1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuc3RhcnRFbmRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXR0ZXJuIG51bWJlciBpcyBldmVuLCB0aGUgcGF0dGVybiBpcyByZXZlcnNlZCwgc28gd2UgbmVlZCB0byBsb2NhdGUgZWxlbWVudCAxICphZnRlciogdGhlIGN1cnJlbnQgYmxvY2suXG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnN0YXJ0RW5kWzBdO1xuICAgICAgICAgICAgICAgIGVuZCA9IHJvdy5nZXROZXh0VW5zZXQodGhpcy5zdGFydEVuZFsxXSArIDEpO1xuICAgICAgICAgICAgICAgIGZpcnN0Q291bnRlciA9IGVuZCAtIHRoaXMuc3RhcnRFbmRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlICdjb3VudGVycycgaG9sZCAxLTRcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IHRoaXMuZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKTtcbiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoY291bnRlcnMsIDAsIGNvdW50ZXJzLCAxLCBjb3VudGVycy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gZmlyc3RDb3VudGVyO1xuICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VGaW5kZXJWYWx1ZShjb3VudGVycywgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVFRFUk5TKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gbmV3IEZpbmRlclBhdHRlcm4odmFsdWUsIG5ldyBpbnRbXSB7IHN0YXJ0LCBlbmQgfSwgc3RhcnQsIGVuZCwgcm93TnVtYmVyfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbmRlclBhdHRlcm4odmFsdWUsIFtzdGFydCwgZW5kXSwgc3RhcnQsIGVuZCwgcm93TnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVEYXRhQ2hhcmFjdGVyKHJvdywgcGF0dGVybiwgaXNPZGRQYXR0ZXJuLCBsZWZ0Q2hhcikge1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gdGhpcy5nZXREYXRhQ2hhcmFjdGVyQ291bnRlcnMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgY291bnRlcnMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1t4XSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdENoYXIpIHtcbiAgICAgICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5yZWNvcmRQYXR0ZXJuSW5SZXZlcnNlKHJvdywgcGF0dGVybi5nZXRTdGFydEVuZCgpWzBdLCBjb3VudGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5yZWNvcmRQYXR0ZXJuKHJvdywgcGF0dGVybi5nZXRTdGFydEVuZCgpWzFdLCBjb3VudGVycyk7XG4gICAgICAgICAgICAgICAgLy8gcmV2ZXJzZSBpdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gY291bnRlcnMubGVuZ3RoIC0gMTsgaSA8IGo7IGkrKywgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2ldID0gY291bnRlcnNbal07XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2pdID0gdGVtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGNvdW50ZXJzW10gaGFzIHRoZSBwaXhlbHMgb2YgdGhlIG1vZHVsZVxuICAgICAgICAgICAgbGV0IG51bU1vZHVsZXMgPSAxNzsgLy8gbGVmdCBhbmQgcmlnaHQgZGF0YSBjaGFyYWN0ZXJzIGhhdmUgYWxsIHRoZSBzYW1lIGxlbmd0aFxuICAgICAgICAgICAgbGV0IGVsZW1lbnRXaWR0aCA9IE1hdGhVdGlscy5zdW0obmV3IEludDMyQXJyYXkoY291bnRlcnMpKSAvIG51bU1vZHVsZXM7XG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2s6IGVsZW1lbnQgd2lkdGggZm9yIHBhdHRlcm4gYW5kIHRoZSBjaGFyYWN0ZXIgc2hvdWxkIG1hdGNoXG4gICAgICAgICAgICBsZXQgZXhwZWN0ZWRFbGVtZW50V2lkdGggPSAocGF0dGVybi5nZXRTdGFydEVuZCgpWzFdIC0gcGF0dGVybi5nZXRTdGFydEVuZCgpWzBdKSAvIDE1LjA7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZWxlbWVudFdpZHRoIC0gZXhwZWN0ZWRFbGVtZW50V2lkdGgpIC8gZXhwZWN0ZWRFbGVtZW50V2lkdGggPiAwLjMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvZGRDb3VudHMgPSB0aGlzLmdldE9kZENvdW50cygpO1xuICAgICAgICAgICAgbGV0IGV2ZW5Db3VudHMgPSB0aGlzLmdldEV2ZW5Db3VudHMoKTtcbiAgICAgICAgICAgIGxldCBvZGRSb3VuZGluZ0Vycm9ycyA9IHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKTtcbiAgICAgICAgICAgIGxldCBldmVuUm91bmRpbmdFcnJvcnMgPSB0aGlzLmdldEV2ZW5Sb3VuZGluZ0Vycm9ycygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IDEuMCAqIGNvdW50ZXJzW2ldIC8gZWxlbWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IHZhbHVlICsgMC41OyAvLyBSb3VuZFxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMC4zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50ID4gOCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiA4LjcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGkgLyAyO1xuICAgICAgICAgICAgICAgIGlmICgoaSAmIDB4MDEpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2RkQ291bnRzW29mZnNldF0gPSBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgb2RkUm91bmRpbmdFcnJvcnNbb2Zmc2V0XSA9IHZhbHVlIC0gY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmVuQ291bnRzW29mZnNldF0gPSBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgZXZlblJvdW5kaW5nRXJyb3JzW29mZnNldF0gPSB2YWx1ZSAtIGNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRqdXN0T2RkRXZlbkNvdW50cyhudW1Nb2R1bGVzKTtcbiAgICAgICAgICAgIGxldCB3ZWlnaHRSb3dOdW1iZXIgPSA0ICogcGF0dGVybi5nZXRWYWx1ZSgpICsgKGlzT2RkUGF0dGVybiA/IDAgOiAyKSArIChsZWZ0Q2hhciA/IDAgOiAxKSAtIDE7XG4gICAgICAgICAgICBsZXQgb2RkU3VtID0gMDtcbiAgICAgICAgICAgIGxldCBvZGRDaGVja3N1bVBvcnRpb24gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG9kZENvdW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChSU1NFeHBhbmRlZFJlYWRlci5pc05vdEExbGVmdChwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIGxlZnRDaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2VpZ2h0ID0gUlNTRXhwYW5kZWRSZWFkZXIuV0VJR0hUU1t3ZWlnaHRSb3dOdW1iZXJdWzIgKiBpXTtcbiAgICAgICAgICAgICAgICAgICAgb2RkQ2hlY2tzdW1Qb3J0aW9uICs9IG9kZENvdW50c1tpXSAqIHdlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2RkU3VtICs9IG9kZENvdW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBldmVuQ2hlY2tzdW1Qb3J0aW9uID0gMDtcbiAgICAgICAgICAgIC8vIGludCBldmVuU3VtID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBldmVuQ291bnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKFJTU0V4cGFuZGVkUmVhZGVyLmlzTm90QTFsZWZ0KHBhdHRlcm4sIGlzT2RkUGF0dGVybiwgbGVmdENoYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3ZWlnaHQgPSBSU1NFeHBhbmRlZFJlYWRlci5XRUlHSFRTW3dlaWdodFJvd051bWJlcl1bMiAqIGkgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbkNoZWNrc3VtUG9ydGlvbiArPSBldmVuQ291bnRzW2ldICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBldmVuU3VtICs9IGV2ZW5Db3VudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hlY2tzdW1Qb3J0aW9uID0gb2RkQ2hlY2tzdW1Qb3J0aW9uICsgZXZlbkNoZWNrc3VtUG9ydGlvbjtcbiAgICAgICAgICAgIGlmICgob2RkU3VtICYgMHgwMSkgIT0gMCB8fCBvZGRTdW0gPiAxMyB8fCBvZGRTdW0gPCA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSAoMTMgLSBvZGRTdW0pIC8gMjtcbiAgICAgICAgICAgIGxldCBvZGRXaWRlc3QgPSBSU1NFeHBhbmRlZFJlYWRlci5TWU1CT0xfV0lERVNUW2dyb3VwXTtcbiAgICAgICAgICAgIGxldCBldmVuV2lkZXN0ID0gOSAtIG9kZFdpZGVzdDtcbiAgICAgICAgICAgIGxldCB2T2RkID0gUlNTVXRpbHMuZ2V0UlNTdmFsdWUob2RkQ291bnRzLCBvZGRXaWRlc3QsIHRydWUpO1xuICAgICAgICAgICAgbGV0IHZFdmVuID0gUlNTVXRpbHMuZ2V0UlNTdmFsdWUoZXZlbkNvdW50cywgZXZlbldpZGVzdCwgZmFsc2UpO1xuICAgICAgICAgICAgbGV0IHRFdmVuID0gUlNTRXhwYW5kZWRSZWFkZXIuRVZFTl9UT1RBTF9TVUJTRVRbZ3JvdXBdO1xuICAgICAgICAgICAgbGV0IGdTdW0gPSBSU1NFeHBhbmRlZFJlYWRlci5HU1VNW2dyb3VwXTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHZPZGQgKiB0RXZlbiArIHZFdmVuICsgZ1N1bTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YUNoYXJhY3Rlcih2YWx1ZSwgY2hlY2tzdW1Qb3J0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNOb3RBMWxlZnQocGF0dGVybiwgaXNPZGRQYXR0ZXJuLCBsZWZ0Q2hhcikge1xuICAgICAgICAgICAgLy8gQTE6IHBhdHRlcm4uZ2V0VmFsdWUgaXMgMCAoQSksIGFuZCBpdCdzIGFuIG9kZFBhdHRlcm4sIGFuZCBpdCBpcyBhIGxlZnQgY2hhclxuICAgICAgICAgICAgcmV0dXJuICEocGF0dGVybi5nZXRWYWx1ZSgpID09IDAgJiYgaXNPZGRQYXR0ZXJuICYmIGxlZnRDaGFyKTtcbiAgICAgICAgfVxuICAgICAgICBhZGp1c3RPZGRFdmVuQ291bnRzKG51bU1vZHVsZXMpIHtcbiAgICAgICAgICAgIGxldCBvZGRTdW0gPSBNYXRoVXRpbHMuc3VtKG5ldyBJbnQzMkFycmF5KHRoaXMuZ2V0T2RkQ291bnRzKCkpKTtcbiAgICAgICAgICAgIGxldCBldmVuU3VtID0gTWF0aFV0aWxzLnN1bShuZXcgSW50MzJBcnJheSh0aGlzLmdldEV2ZW5Db3VudHMoKSkpO1xuICAgICAgICAgICAgbGV0IGluY3JlbWVudE9kZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGRlY3JlbWVudE9kZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG9kZFN1bSA+IDEzKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9kZFN1bSA8IDQpIHtcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGluY3JlbWVudEV2ZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBkZWNyZW1lbnRFdmVuID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXZlblN1bSA+IDEzKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVuU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1pc21hdGNoID0gb2RkU3VtICsgZXZlblN1bSAtIG51bU1vZHVsZXM7XG4gICAgICAgICAgICBsZXQgb2RkUGFyaXR5QmFkID0gKG9kZFN1bSAmIDB4MDEpID09IDE7XG4gICAgICAgICAgICBsZXQgZXZlblBhcml0eUJhZCA9IChldmVuU3VtICYgMHgwMSkgPT0gMDtcbiAgICAgICAgICAgIGlmIChtaXNtYXRjaCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9kZFBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWlzbWF0Y2ggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAob2RkUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtaXNtYXRjaCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9kZFBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEJvdGggYmFkXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZGRTdW0gPCBldmVuU3VtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY3JlbWVudE9kZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWNyZW1lbnRPZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLmluY3JlbWVudCh0aGlzLmdldE9kZENvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY3JlbWVudE9kZCkge1xuICAgICAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLmRlY3JlbWVudCh0aGlzLmdldE9kZENvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY3JlbWVudEV2ZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVjcmVtZW50RXZlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuaW5jcmVtZW50KHRoaXMuZ2V0RXZlbkNvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY3JlbWVudEV2ZW4pIHtcbiAgICAgICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5kZWNyZW1lbnQodGhpcy5nZXRFdmVuQ291bnRzKCksIHRoaXMuZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFJTU0V4cGFuZGVkUmVhZGVyLlNZTUJPTF9XSURFU1QgPSBbNywgNSwgNCwgMywgMV07XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRVZFTl9UT1RBTF9TVUJTRVQgPSBbNCwgMjAsIDUyLCAxMDQsIDIwNF07XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuR1NVTSA9IFswLCAzNDgsIDEzODgsIDI5NDgsIDM5ODhdO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRURVJOUyA9IFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA4LCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgNiwgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDQsIDYsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAyLCA4LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgNiwgNSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDksIDFdKSAvLyBGXG4gICAgXTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5XRUlHSFRTID0gW1xuICAgICAgICBbMSwgMywgOSwgMjcsIDgxLCAzMiwgOTYsIDc3XSxcbiAgICAgICAgWzIwLCA2MCwgMTgwLCAxMTgsIDE0MywgNywgMjEsIDYzXSxcbiAgICAgICAgWzE4OSwgMTQ1LCAxMywgMzksIDExNywgMTQwLCAyMDksIDIwNV0sXG4gICAgICAgIFsxOTMsIDE1NywgNDksIDE0NywgMTksIDU3LCAxNzEsIDkxXSxcbiAgICAgICAgWzYyLCAxODYsIDEzNiwgMTk3LCAxNjksIDg1LCA0NCwgMTMyXSxcbiAgICAgICAgWzE4NSwgMTMzLCAxODgsIDE0MiwgNCwgMTIsIDM2LCAxMDhdLFxuICAgICAgICBbMTEzLCAxMjgsIDE3MywgOTcsIDgwLCAyOSwgODcsIDUwXSxcbiAgICAgICAgWzE1MCwgMjgsIDg0LCA0MSwgMTIzLCAxNTgsIDUyLCAxNTZdLFxuICAgICAgICBbNDYsIDEzOCwgMjAzLCAxODcsIDEzOSwgMjA2LCAxOTYsIDE2Nl0sXG4gICAgICAgIFs3NiwgMTcsIDUxLCAxNTMsIDM3LCAxMTEsIDEyMiwgMTU1XSxcbiAgICAgICAgWzQzLCAxMjksIDE3NiwgMTA2LCAxMDcsIDExMCwgMTE5LCAxNDZdLFxuICAgICAgICBbMTYsIDQ4LCAxNDQsIDEwLCAzMCwgOTAsIDU5LCAxNzddLFxuICAgICAgICBbMTA5LCAxMTYsIDEzNywgMjAwLCAxNzgsIDExMiwgMTI1LCAxNjRdLFxuICAgICAgICBbNzAsIDIxMCwgMjA4LCAyMDIsIDE4NCwgMTMwLCAxNzksIDExNV0sXG4gICAgICAgIFsxMzQsIDE5MSwgMTUxLCAzMSwgOTMsIDY4LCAyMDQsIDE5MF0sXG4gICAgICAgIFsxNDgsIDIyLCA2NiwgMTk4LCAxNzIsIDk0LCA3MSwgMl0sXG4gICAgICAgIFs2LCAxOCwgNTQsIDE2MiwgNjQsIDE5MiwgMTU0LCA0MF0sXG4gICAgICAgIFsxMjAsIDE0OSwgMjUsIDc1LCAxNCwgNDIsIDEyNiwgMTY3XSxcbiAgICAgICAgWzc5LCAyNiwgNzgsIDIzLCA2OSwgMjA3LCAxOTksIDE3NV0sXG4gICAgICAgIFsxMDMsIDk4LCA4MywgMzgsIDExNCwgMTMxLCAxODIsIDEyNF0sXG4gICAgICAgIFsxNjEsIDYxLCAxODMsIDEyNywgMTcwLCA4OCwgNTMsIDE1OV0sXG4gICAgICAgIFs1NSwgMTY1LCA3MywgOCwgMjQsIDcyLCA1LCAxNV0sXG4gICAgICAgIFs0NSwgMTM1LCAxOTQsIDE2MCwgNTgsIDE3NCwgMTAwLCA4OV1cbiAgICBdO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSA9IDA7XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CID0gMTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MgPSAyO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCA9IDM7XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FID0gNDtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0YgPSA1O1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRURVJOX1NFUVVFTkNFUyA9IFtcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0JdLFxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9EXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0ZdLFxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9EXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0VdLFxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQywgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GXSxcbiAgICBdO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLk1BWF9QQUlSUyA9IDExO1xuXG4gICAgY2xhc3MgUGFpciBleHRlbmRzIERhdGFDaGFyYWN0ZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgY2hlY2tzdW1Qb3J0aW9uLCBmaW5kZXJQYXR0ZXJuKSB7XG4gICAgICAgICAgICBzdXBlcih2YWx1ZSwgY2hlY2tzdW1Qb3J0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5maW5kZXJQYXR0ZXJuID0gZmluZGVyUGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICBnZXRGaW5kZXJQYXR0ZXJuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZGVyUGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICBnZXRDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGluY3JlbWVudENvdW50KCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgUlNTMTRSZWFkZXIgZXh0ZW5kcyBBYnN0cmFjdFJTU1JlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVMZWZ0UGFpcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVSaWdodFBhaXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICAgICAgY29uc3QgbGVmdFBhaXIgPSB0aGlzLmRlY29kZVBhaXIocm93LCBmYWxzZSwgcm93TnVtYmVyLCBoaW50cyk7XG4gICAgICAgICAgICBSU1MxNFJlYWRlci5hZGRPclRhbGx5KHRoaXMucG9zc2libGVMZWZ0UGFpcnMsIGxlZnRQYWlyKTtcbiAgICAgICAgICAgIHJvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsZXQgcmlnaHRQYWlyID0gdGhpcy5kZWNvZGVQYWlyKHJvdywgdHJ1ZSwgcm93TnVtYmVyLCBoaW50cyk7XG4gICAgICAgICAgICBSU1MxNFJlYWRlci5hZGRPclRhbGx5KHRoaXMucG9zc2libGVSaWdodFBhaXJzLCByaWdodFBhaXIpO1xuICAgICAgICAgICAgcm93LnJldmVyc2UoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGxlZnQgb2YgdGhpcy5wb3NzaWJsZUxlZnRQYWlycykge1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0LmdldENvdW50KCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHJpZ2h0IG9mIHRoaXMucG9zc2libGVSaWdodFBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHQuZ2V0Q291bnQoKSA+IDEgJiYgUlNTMTRSZWFkZXIuY2hlY2tDaGVja3N1bShsZWZ0LCByaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUlNTMTRSZWFkZXIuY29uc3RydWN0UmVzdWx0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhZGRPclRhbGx5KHBvc3NpYmxlUGFpcnMsIHBhaXIpIHtcbiAgICAgICAgICAgIGlmIChwYWlyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IG90aGVyIG9mIHBvc3NpYmxlUGFpcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3RoZXIuZ2V0VmFsdWUoKSA9PT0gcGFpci5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyLmluY3JlbWVudENvdW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlUGFpcnMucHVzaChwYWlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVMZWZ0UGFpcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVSaWdodFBhaXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNvbnN0cnVjdFJlc3VsdChsZWZ0UGFpciwgcmlnaHRQYWlyKSB7XG4gICAgICAgICAgICBsZXQgc3ltYm9sVmFsdWUgPSA0NTM3MDc3ICogbGVmdFBhaXIuZ2V0VmFsdWUoKSArIHJpZ2h0UGFpci5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgbGV0IHRleHQgPSBuZXcgU3RyaW5nKHN5bWJvbFZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTMgLSB0ZXh0Lmxlbmd0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQodGV4dCk7XG4gICAgICAgICAgICBsZXQgY2hlY2tEaWdpdCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlnaXQgPSBidWZmZXIuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBjaGVja0RpZ2l0ICs9ICgoaSAmIDB4MDEpID09PSAwKSA/IDMgKiBkaWdpdCA6IGRpZ2l0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tEaWdpdCA9IDEwIC0gKGNoZWNrRGlnaXQgJSAxMCk7XG4gICAgICAgICAgICBpZiAoY2hlY2tEaWdpdCA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICBjaGVja0RpZ2l0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoY2hlY2tEaWdpdC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGxldCBsZWZ0UG9pbnRzID0gbGVmdFBhaXIuZ2V0RmluZGVyUGF0dGVybigpLmdldFJlc3VsdFBvaW50cygpO1xuICAgICAgICAgICAgbGV0IHJpZ2h0UG9pbnRzID0gcmlnaHRQYWlyLmdldEZpbmRlclBhdHRlcm4oKS5nZXRSZXN1bHRQb2ludHMoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0KGJ1ZmZlci50b1N0cmluZygpLCBudWxsLCAwLCBbbGVmdFBvaW50c1swXSwgbGVmdFBvaW50c1sxXSwgcmlnaHRQb2ludHNbMF0sIHJpZ2h0UG9pbnRzWzFdXSwgQmFyY29kZUZvcm1hdCQxLlJTU18xNCwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaGVja0NoZWNrc3VtKGxlZnRQYWlyLCByaWdodFBhaXIpIHtcbiAgICAgICAgICAgIGxldCBjaGVja1ZhbHVlID0gKGxlZnRQYWlyLmdldENoZWNrc3VtUG9ydGlvbigpICsgMTYgKiByaWdodFBhaXIuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCkpICUgNzk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0Q2hlY2tWYWx1ZSA9IDkgKiBsZWZ0UGFpci5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0VmFsdWUoKSArIHJpZ2h0UGFpci5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRDaGVja1ZhbHVlID4gNzIpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRDaGVja1ZhbHVlLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0Q2hlY2tWYWx1ZSA+IDgpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRDaGVja1ZhbHVlLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tWYWx1ZSA9PT0gdGFyZ2V0Q2hlY2tWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVQYWlyKHJvdywgcmlnaHQsIHJvd051bWJlciwgaGludHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0RW5kID0gdGhpcy5maW5kRmluZGVyUGF0dGVybihyb3csIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IHRoaXMucGFyc2VGb3VuZEZpbmRlclBhdHRlcm4ocm93LCByb3dOdW1iZXIsIHJpZ2h0LCBzdGFydEVuZCk7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdFBvaW50Q2FsbGJhY2sgPSBoaW50cyA9PSBudWxsID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLk5FRURfUkVTVUxUX1BPSU5UX0NBTExCQUNLKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0UG9pbnRDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjZW50ZXIgPSAoc3RhcnRFbmRbMF0gKyBzdGFydEVuZFsxXSkgLyAyLjA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm93IGlzIGFjdHVhbGx5IHJldmVyc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXIgPSByb3cuZ2V0U2l6ZSgpIC0gMSAtIGNlbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRQb2ludENhbGxiYWNrLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChuZXcgUmVzdWx0UG9pbnQoY2VudGVyLCByb3dOdW1iZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG91dHNpZGUgPSB0aGlzLmRlY29kZURhdGFDaGFyYWN0ZXIocm93LCBwYXR0ZXJuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zaWRlID0gdGhpcy5kZWNvZGVEYXRhQ2hhcmFjdGVyKHJvdywgcGF0dGVybiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGFpcigxNTk3ICogb3V0c2lkZS5nZXRWYWx1ZSgpICsgaW5zaWRlLmdldFZhbHVlKCksIG91dHNpZGUuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCkgKyA0ICogaW5zaWRlLmdldENoZWNrc3VtUG9ydGlvbigpLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVEYXRhQ2hhcmFjdGVyKHJvdywgcGF0dGVybiwgb3V0c2lkZUNoYXIpIHtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IHRoaXMuZ2V0RGF0YUNoYXJhY3RlckNvdW50ZXJzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNvdW50ZXJzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcnNbeF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dHNpZGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgT25lRFJlYWRlci5yZWNvcmRQYXR0ZXJuSW5SZXZlcnNlKHJvdywgcGF0dGVybi5nZXRTdGFydEVuZCgpWzBdLCBjb3VudGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBPbmVEUmVhZGVyLnJlY29yZFBhdHRlcm4ocm93LCBwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMV0gKyAxLCBjb3VudGVycyk7XG4gICAgICAgICAgICAgICAgLy8gcmV2ZXJzZSBpdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gY291bnRlcnMubGVuZ3RoIC0gMTsgaSA8IGo7IGkrKywgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2ldID0gY291bnRlcnNbal07XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2pdID0gdGVtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbnVtTW9kdWxlcyA9IG91dHNpZGVDaGFyID8gMTYgOiAxNTtcbiAgICAgICAgICAgIGxldCBlbGVtZW50V2lkdGggPSBNYXRoVXRpbHMuc3VtKG5ldyBJbnQzMkFycmF5KGNvdW50ZXJzKSkgLyBudW1Nb2R1bGVzO1xuICAgICAgICAgICAgbGV0IG9kZENvdW50cyA9IHRoaXMuZ2V0T2RkQ291bnRzKCk7XG4gICAgICAgICAgICBsZXQgZXZlbkNvdW50cyA9IHRoaXMuZ2V0RXZlbkNvdW50cygpO1xuICAgICAgICAgICAgbGV0IG9kZFJvdW5kaW5nRXJyb3JzID0gdGhpcy5nZXRPZGRSb3VuZGluZ0Vycm9ycygpO1xuICAgICAgICAgICAgbGV0IGV2ZW5Sb3VuZGluZ0Vycm9ycyA9IHRoaXMuZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gY291bnRlcnNbaV0gLyBlbGVtZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gTWF0aC5mbG9vcih2YWx1ZSArIDAuNSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50ID4gOCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBNYXRoLmZsb29yKGkgLyAyKTtcbiAgICAgICAgICAgICAgICBpZiAoKGkgJiAweDAxKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZGRDb3VudHNbb2Zmc2V0XSA9IGNvdW50O1xuICAgICAgICAgICAgICAgICAgICBvZGRSb3VuZGluZ0Vycm9yc1tvZmZzZXRdID0gdmFsdWUgLSBjb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW5Db3VudHNbb2Zmc2V0XSA9IGNvdW50O1xuICAgICAgICAgICAgICAgICAgICBldmVuUm91bmRpbmdFcnJvcnNbb2Zmc2V0XSA9IHZhbHVlIC0gY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGp1c3RPZGRFdmVuQ291bnRzKG91dHNpZGVDaGFyLCBudW1Nb2R1bGVzKTtcbiAgICAgICAgICAgIGxldCBvZGRTdW0gPSAwO1xuICAgICAgICAgICAgbGV0IG9kZENoZWNrc3VtUG9ydGlvbiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gb2RkQ291bnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgb2RkQ2hlY2tzdW1Qb3J0aW9uICo9IDk7XG4gICAgICAgICAgICAgICAgb2RkQ2hlY2tzdW1Qb3J0aW9uICs9IG9kZENvdW50c1tpXTtcbiAgICAgICAgICAgICAgICBvZGRTdW0gKz0gb2RkQ291bnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV2ZW5DaGVja3N1bVBvcnRpb24gPSAwO1xuICAgICAgICAgICAgbGV0IGV2ZW5TdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGV2ZW5Db3VudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBldmVuQ2hlY2tzdW1Qb3J0aW9uICo9IDk7XG4gICAgICAgICAgICAgICAgZXZlbkNoZWNrc3VtUG9ydGlvbiArPSBldmVuQ291bnRzW2ldO1xuICAgICAgICAgICAgICAgIGV2ZW5TdW0gKz0gZXZlbkNvdW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGVja3N1bVBvcnRpb24gPSBvZGRDaGVja3N1bVBvcnRpb24gKyAzICogZXZlbkNoZWNrc3VtUG9ydGlvbjtcbiAgICAgICAgICAgIGlmIChvdXRzaWRlQ2hhcikge1xuICAgICAgICAgICAgICAgIGlmICgob2RkU3VtICYgMHgwMSkgIT09IDAgfHwgb2RkU3VtID4gMTIgfHwgb2RkU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gKDEyIC0gb2RkU3VtKSAvIDI7XG4gICAgICAgICAgICAgICAgbGV0IG9kZFdpZGVzdCA9IFJTUzE0UmVhZGVyLk9VVFNJREVfT0REX1dJREVTVFtncm91cF07XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW5XaWRlc3QgPSA5IC0gb2RkV2lkZXN0O1xuICAgICAgICAgICAgICAgIGxldCB2T2RkID0gUlNTVXRpbHMuZ2V0UlNTdmFsdWUob2RkQ291bnRzLCBvZGRXaWRlc3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBsZXQgdkV2ZW4gPSBSU1NVdGlscy5nZXRSU1N2YWx1ZShldmVuQ291bnRzLCBldmVuV2lkZXN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBsZXQgdEV2ZW4gPSBSU1MxNFJlYWRlci5PVVRTSURFX0VWRU5fVE9UQUxfU1VCU0VUW2dyb3VwXTtcbiAgICAgICAgICAgICAgICBsZXQgZ1N1bSA9IFJTUzE0UmVhZGVyLk9VVFNJREVfR1NVTVtncm91cF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhQ2hhcmFjdGVyKHZPZGQgKiB0RXZlbiArIHZFdmVuICsgZ1N1bSwgY2hlY2tzdW1Qb3J0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgoZXZlblN1bSAmIDB4MDEpICE9PSAwIHx8IGV2ZW5TdW0gPiAxMCB8fCBldmVuU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gKDEwIC0gZXZlblN1bSkgLyAyO1xuICAgICAgICAgICAgICAgIGxldCBvZGRXaWRlc3QgPSBSU1MxNFJlYWRlci5JTlNJREVfT0REX1dJREVTVFtncm91cF07XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW5XaWRlc3QgPSA5IC0gb2RkV2lkZXN0O1xuICAgICAgICAgICAgICAgIGxldCB2T2RkID0gUlNTVXRpbHMuZ2V0UlNTdmFsdWUob2RkQ291bnRzLCBvZGRXaWRlc3QsIHRydWUpO1xuICAgICAgICAgICAgICAgIGxldCB2RXZlbiA9IFJTU1V0aWxzLmdldFJTU3ZhbHVlKGV2ZW5Db3VudHMsIGV2ZW5XaWRlc3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBsZXQgdE9kZCA9IFJTUzE0UmVhZGVyLklOU0lERV9PRERfVE9UQUxfU1VCU0VUW2dyb3VwXTtcbiAgICAgICAgICAgICAgICBsZXQgZ1N1bSA9IFJTUzE0UmVhZGVyLklOU0lERV9HU1VNW2dyb3VwXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGFDaGFyYWN0ZXIodkV2ZW4gKiB0T2RkICsgdk9kZCArIGdTdW0sIGNoZWNrc3VtUG9ydGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluZEZpbmRlclBhdHRlcm4ocm93LCByaWdodEZpbmRlclBhdHRlcm4pIHtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IHRoaXMuZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKTtcbiAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHJvd09mZnNldCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocm93T2Zmc2V0IDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIXJvdy5nZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRGaW5kZXJQYXR0ZXJuID09PSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdpbGwgZW5jb3VudGVyIHdoaXRlIGZpcnN0IHdoZW4gc2VhcmNoaW5nIGZvciByaWdodCBmaW5kZXIgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSByb3dPZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gcm93T2Zmc2V0OyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuZ2V0KHgpICE9PSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBYnN0cmFjdFJTU1JlYWRlci5pc0ZpbmRlclBhdHRlcm4oY291bnRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwYXR0ZXJuU3RhcnQsIHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJzWzBdICsgY291bnRlcnNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1swXSA9IGNvdW50ZXJzWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbMV0gPSBjb3VudGVyc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUZvdW5kRmluZGVyUGF0dGVybihyb3csIHJvd051bWJlciwgcmlnaHQsIHN0YXJ0RW5kKSB7XG4gICAgICAgICAgICAvLyBBY3R1YWxseSB3ZSBmb3VuZCBlbGVtZW50cyAyLTVcbiAgICAgICAgICAgIGxldCBmaXJzdElzQmxhY2sgPSByb3cuZ2V0KHN0YXJ0RW5kWzBdKTtcbiAgICAgICAgICAgIGxldCBmaXJzdEVsZW1lbnRTdGFydCA9IHN0YXJ0RW5kWzBdIC0gMTtcbiAgICAgICAgICAgIC8vIExvY2F0ZSBlbGVtZW50IDFcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdEVsZW1lbnRTdGFydCA+PSAwICYmIGZpcnN0SXNCbGFjayAhPT0gcm93LmdldChmaXJzdEVsZW1lbnRTdGFydCkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEVsZW1lbnRTdGFydC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3RFbGVtZW50U3RhcnQrKztcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q291bnRlciA9IHN0YXJ0RW5kWzBdIC0gZmlyc3RFbGVtZW50U3RhcnQ7XG4gICAgICAgICAgICAvLyBNYWtlICdjb3VudGVycycgaG9sZCAxLTRcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5nZXREZWNvZGVGaW5kZXJDb3VudGVycygpO1xuICAgICAgICAgICAgY29uc3QgY29weSA9IG5ldyBJbnQzMkFycmF5KGNvdW50ZXJzLmxlbmd0aCk7XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvdW50ZXJzLCAwLCBjb3B5LCAxLCBjb3VudGVycy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNvcHlbMF0gPSBmaXJzdENvdW50ZXI7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucGFyc2VGaW5kZXJWYWx1ZShjb3B5LCBSU1MxNFJlYWRlci5GSU5ERVJfUEFUVEVSTlMpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gZmlyc3RFbGVtZW50U3RhcnQ7XG4gICAgICAgICAgICBsZXQgZW5kID0gc3RhcnRFbmRbMV07XG4gICAgICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyByb3cgaXMgYWN0dWFsbHkgcmV2ZXJzZWRcbiAgICAgICAgICAgICAgICBzdGFydCA9IHJvdy5nZXRTaXplKCkgLSAxIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgZW5kID0gcm93LmdldFNpemUoKSAtIDEgLSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbmRlclBhdHRlcm4odmFsdWUsIFtmaXJzdEVsZW1lbnRTdGFydCwgc3RhcnRFbmRbMV1dLCBzdGFydCwgZW5kLCByb3dOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGFkanVzdE9kZEV2ZW5Db3VudHMob3V0c2lkZUNoYXIsIG51bU1vZHVsZXMpIHtcbiAgICAgICAgICAgIGxldCBvZGRTdW0gPSBNYXRoVXRpbHMuc3VtKG5ldyBJbnQzMkFycmF5KHRoaXMuZ2V0T2RkQ291bnRzKCkpKTtcbiAgICAgICAgICAgIGxldCBldmVuU3VtID0gTWF0aFV0aWxzLnN1bShuZXcgSW50MzJBcnJheSh0aGlzLmdldEV2ZW5Db3VudHMoKSkpO1xuICAgICAgICAgICAgbGV0IGluY3JlbWVudE9kZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGRlY3JlbWVudE9kZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGluY3JlbWVudEV2ZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBkZWNyZW1lbnRFdmVuID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAob3V0c2lkZUNoYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAob2RkU3VtID4gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2RkU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlblN1bSA+IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVuU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2RkU3VtID4gMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2RkU3VtIDwgNSkge1xuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlblN1bSA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVuU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWlzbWF0Y2ggPSBvZGRTdW0gKyBldmVuU3VtIC0gbnVtTW9kdWxlcztcbiAgICAgICAgICAgIGxldCBvZGRQYXJpdHlCYWQgPSAob2RkU3VtICYgMHgwMSkgPT09IChvdXRzaWRlQ2hhciA/IDEgOiAwKTtcbiAgICAgICAgICAgIGxldCBldmVuUGFyaXR5QmFkID0gKGV2ZW5TdW0gJiAweDAxKSA9PT0gMTtcbiAgICAgICAgICAgIGlmIChtaXNtYXRjaCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChvZGRQYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1pc21hdGNoID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChvZGRQYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1pc21hdGNoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9kZFBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEJvdGggYmFkXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZGRTdW0gPCBldmVuU3VtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY3JlbWVudE9kZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWNyZW1lbnRPZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEFic3RyYWN0UlNTUmVhZGVyLmluY3JlbWVudCh0aGlzLmdldE9kZENvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY3JlbWVudE9kZCkge1xuICAgICAgICAgICAgICAgIEFic3RyYWN0UlNTUmVhZGVyLmRlY3JlbWVudCh0aGlzLmdldE9kZENvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY3JlbWVudEV2ZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVjcmVtZW50RXZlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQWJzdHJhY3RSU1NSZWFkZXIuaW5jcmVtZW50KHRoaXMuZ2V0RXZlbkNvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY3JlbWVudEV2ZW4pIHtcbiAgICAgICAgICAgICAgICBBYnN0cmFjdFJTU1JlYWRlci5kZWNyZW1lbnQodGhpcy5nZXRFdmVuQ291bnRzKCksIHRoaXMuZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFJTUzE0UmVhZGVyLk9VVFNJREVfRVZFTl9UT1RBTF9TVUJTRVQgPSBbMSwgMTAsIDM0LCA3MCwgMTI2XTtcbiAgICBSU1MxNFJlYWRlci5JTlNJREVfT0REX1RPVEFMX1NVQlNFVCA9IFs0LCAyMCwgNDgsIDgxXTtcbiAgICBSU1MxNFJlYWRlci5PVVRTSURFX0dTVU0gPSBbMCwgMTYxLCA5NjEsIDIwMTUsIDI3MTVdO1xuICAgIFJTUzE0UmVhZGVyLklOU0lERV9HU1VNID0gWzAsIDMzNiwgMTAzNiwgMTUxNl07XG4gICAgUlNTMTRSZWFkZXIuT1VUU0lERV9PRERfV0lERVNUID0gWzgsIDYsIDQsIDMsIDFdO1xuICAgIFJTUzE0UmVhZGVyLklOU0lERV9PRERfV0lERVNUID0gWzIsIDQsIDYsIDhdO1xuICAgIFJTUzE0UmVhZGVyLkZJTkRFUl9QQVRURVJOUyA9IFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCA4LCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgNSwgNSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDMsIDcsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCA5LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgNywgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDUsIDYsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCA4LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgNSwgNywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDksIDFdKSxcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBEYW5pZWwgU3dpdGtpbiA8ZHN3aXRraW5AZ29vZ2xlLmNvbT5cbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIE11bHRpRm9ybWF0T25lRFJlYWRlciBleHRlbmRzIE9uZURSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihoaW50cywgdmVyYm9zZSkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMucmVhZGVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy52ZXJib3NlID0gKHZlcmJvc2UgPT09IHRydWUpO1xuICAgICAgICAgICAgY29uc3QgcG9zc2libGVGb3JtYXRzID0gIWhpbnRzID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlBPU1NJQkxFX0ZPUk1BVFMpO1xuICAgICAgICAgICAgY29uc3QgdXNlQ29kZTM5Q2hlY2tEaWdpdCA9IGhpbnRzICYmIGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLkFTU1VNRV9DT0RFXzM5X0NIRUNLX0RJR0lUKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cykge1xuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLkVBTl8xMykgfHxcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5VUENfQSkgfHxcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5FQU5fOCkgfHxcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5VUENfRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IE11bHRpRm9ybWF0VVBDRUFOUmVhZGVyKGhpbnRzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLkNPREVfMzkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RlMzlSZWFkZXIodXNlQ29kZTM5Q2hlY2tEaWdpdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiAocG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQuQ09ERV85MykpIHtcbiAgICAgICAgICAgICAgICAvLyAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kZTkzUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5DT0RFXzEyOCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGUxMjhSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLklURikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IElURlJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0LkNPREFCQVIpKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGFCYXJSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLlJTU18xNCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IFJTUzE0UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5SU1NfRVhQQU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBSU1NFeHBhbmRlZFJlYWRlcih0aGlzLnZlcmJvc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENhc2Ugd2hlbiBubyBoaW50cyB3ZXJlIHByb3ZpZGVkIC0+IGFkZCBhbGwuXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IE11bHRpRm9ybWF0VVBDRUFOUmVhZGVyKGhpbnRzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGUzOVJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kYUJhclJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kZTkzUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlcihoaW50cykpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RlMTI4UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBJVEZSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IFJTUzE0UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBSU1NFeHBhbmRlZFJlYWRlcih0aGlzLnZlcmJvc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkZXJzW2ldLmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAocmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlcnMuZm9yRWFjaChyZWFkZXIgPT4gcmVhZGVyLnJlc2V0KCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICpcbiAgICAgKiBCYXJjb2RlIHJlYWRlciByZWFkZXIgdG8gdXNlIGZyb20gYnJvd3Nlci5cbiAgICAgKi9cbiAgICBjbGFzcyBCcm93c2VyQmFyY29kZVJlYWRlciBleHRlbmRzIEJyb3dzZXJDb2RlUmVhZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlckJhcmNvZGVSZWFkZXIuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZUJldHdlZW5TY2Fuc01pbGxpcz01MDBdIHRoZSB0aW1lIGRlbGF5IGJldHdlZW4gc3Vic2VxdWVudCBkZWNvZGUgdHJpZXNcbiAgICAgICAgICogQHBhcmFtIHtNYXA8RGVjb2RlSGludFR5cGUsIGFueT59IGhpbnRzXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcih0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwLCBoaW50cykge1xuICAgICAgICAgICAgc3VwZXIobmV3IE11bHRpRm9ybWF0T25lRFJlYWRlcihoaW50cyksIHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMsIGhpbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGEgc2V0IG9mIGVycm9yLWNvcnJlY3Rpb24gYmxvY2tzIGluIG9uZSBzeW1ib2wgdmVyc2lvbi4gTW9zdCB2ZXJzaW9ucyB3aWxsXG4gICAgICogdXNlIGJsb2NrcyBvZiBkaWZmZXJpbmcgc2l6ZXMgd2l0aGluIG9uZSB2ZXJzaW9uLCBzbywgdGhpcyBlbmNhcHN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgZm9yXG4gICAgICogZWFjaCBzZXQgb2YgYmxvY2tzLiBJdCBhbHNvIGhvbGRzIHRoZSBudW1iZXIgb2YgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMgcGVyIGJsb2NrIHNpbmNlIGl0XG4gICAgICogd2lsbCBiZSB0aGUgc2FtZSBhY3Jvc3MgYWxsIGJsb2NrcyB3aXRoaW4gb25lIHZlcnNpb24uPC9wPlxuICAgICAqL1xuICAgIGNsYXNzIEVDQmxvY2tzIHtcbiAgICAgICAgY29uc3RydWN0b3IoZWNDb2Rld29yZHMsIGVjQmxvY2tzMSwgZWNCbG9ja3MyKSB7XG4gICAgICAgICAgICB0aGlzLmVjQ29kZXdvcmRzID0gZWNDb2Rld29yZHM7XG4gICAgICAgICAgICB0aGlzLmVjQmxvY2tzID0gW2VjQmxvY2tzMV07XG4gICAgICAgICAgICBlY0Jsb2NrczIgJiYgdGhpcy5lY0Jsb2Nrcy5wdXNoKGVjQmxvY2tzMik7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RUNDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lY0NvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICBnZXRFQ0Jsb2NrcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjQmxvY2tzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyB0aGUgcGFyYW1ldGVycyBmb3Igb25lIGVycm9yLWNvcnJlY3Rpb24gYmxvY2sgaW4gb25lIHN5bWJvbCB2ZXJzaW9uLlxuICAgICAqIFRoaXMgaW5jbHVkZXMgdGhlIG51bWJlciBvZiBkYXRhIGNvZGV3b3JkcywgYW5kIHRoZSBudW1iZXIgb2YgdGltZXMgYSBibG9jayB3aXRoIHRoZXNlXG4gICAgICogcGFyYW1ldGVycyBpcyB1c2VkIGNvbnNlY3V0aXZlbHkgaW4gdGhlIERhdGEgTWF0cml4IGNvZGUgdmVyc2lvbidzIGZvcm1hdC48L3A+XG4gICAgICovXG4gICAgY2xhc3MgRUNCIHtcbiAgICAgICAgY29uc3RydWN0b3IoY291bnQsIGRhdGFDb2Rld29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNvZGV3b3JkcyA9IGRhdGFDb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXREYXRhQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgVmVyc2lvbiBvYmplY3QgZW5jYXBzdWxhdGVzIGF0dHJpYnV0ZXMgYWJvdXQgYSBwYXJ0aWN1bGFyXG4gICAgICogc2l6ZSBEYXRhIE1hdHJpeCBDb2RlLlxuICAgICAqXG4gICAgICogQGF1dGhvciBiYnJvd25AZ29vZ2xlLmNvbSAoQnJpYW4gQnJvd24pXG4gICAgICovXG4gICAgY2xhc3MgVmVyc2lvbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZlcnNpb25OdW1iZXIsIHN5bWJvbFNpemVSb3dzLCBzeW1ib2xTaXplQ29sdW1ucywgZGF0YVJlZ2lvblNpemVSb3dzLCBkYXRhUmVnaW9uU2l6ZUNvbHVtbnMsIGVjQmxvY2tzKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb25OdW1iZXIgPSB2ZXJzaW9uTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5zeW1ib2xTaXplUm93cyA9IHN5bWJvbFNpemVSb3dzO1xuICAgICAgICAgICAgdGhpcy5zeW1ib2xTaXplQ29sdW1ucyA9IHN5bWJvbFNpemVDb2x1bW5zO1xuICAgICAgICAgICAgdGhpcy5kYXRhUmVnaW9uU2l6ZVJvd3MgPSBkYXRhUmVnaW9uU2l6ZVJvd3M7XG4gICAgICAgICAgICB0aGlzLmRhdGFSZWdpb25TaXplQ29sdW1ucyA9IGRhdGFSZWdpb25TaXplQ29sdW1ucztcbiAgICAgICAgICAgIHRoaXMuZWNCbG9ja3MgPSBlY0Jsb2NrcztcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbnVtYmVyIG9mIGNvZGV3b3Jkc1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVjQ29kZXdvcmRzID0gZWNCbG9ja3MuZ2V0RUNDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGVjYkFycmF5ID0gZWNCbG9ja3MuZ2V0RUNCbG9ja3MoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGVjQmxvY2sgb2YgZWNiQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBlY0Jsb2NrLmdldENvdW50KCkgKiAoZWNCbG9jay5nZXREYXRhQ29kZXdvcmRzKCkgKyBlY0NvZGV3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRvdGFsQ29kZXdvcmRzID0gdG90YWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmVyc2lvbk51bWJlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnNpb25OdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U3ltYm9sU2l6ZVJvd3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xTaXplUm93cztcbiAgICAgICAgfVxuICAgICAgICBnZXRTeW1ib2xTaXplQ29sdW1ucygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFNpemVDb2x1bW5zO1xuICAgICAgICB9XG4gICAgICAgIGdldERhdGFSZWdpb25TaXplUm93cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFSZWdpb25TaXplUm93cztcbiAgICAgICAgfVxuICAgICAgICBnZXREYXRhUmVnaW9uU2l6ZUNvbHVtbnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhUmVnaW9uU2l6ZUNvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VG90YWxDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbENvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICBnZXRFQ0Jsb2NrcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjQmxvY2tzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5EZWR1Y2VzIHZlcnNpb24gaW5mb3JtYXRpb24gZnJvbSBEYXRhIE1hdHJpeCBkaW1lbnNpb25zLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gbW9kdWxlc1xuICAgICAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiBtb2R1bGVzXG4gICAgICAgICAqIEByZXR1cm4gVmVyc2lvbiBmb3IgYSBEYXRhIE1hdHJpeCBDb2RlIG9mIHRob3NlIGRpbWVuc2lvbnNcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgZGltZW5zaW9ucyBkbyBjb3JyZXNwb25kIHRvIGEgdmFsaWQgRGF0YSBNYXRyaXggc2l6ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldFZlcnNpb25Gb3JEaW1lbnNpb25zKG51bVJvd3MsIG51bUNvbHVtbnMpIHtcbiAgICAgICAgICAgIGlmICgobnVtUm93cyAmIDB4MDEpICE9PSAwIHx8IChudW1Db2x1bW5zICYgMHgwMSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCB2ZXJzaW9uIG9mIFZlcnNpb24uVkVSU0lPTlMpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbi5zeW1ib2xTaXplUm93cyA9PT0gbnVtUm93cyAmJiB2ZXJzaW9uLnN5bWJvbFNpemVDb2x1bW5zID09PSBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAgQE92ZXJyaWRlXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgdGhpcy52ZXJzaW9uTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYgNS41LjEgVGFibGUgN1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGJ1aWxkVmVyc2lvbnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDEsIDEwLCAxMCwgOCwgOCwgbmV3IEVDQmxvY2tzKDUsIG5ldyBFQ0IoMSwgMykpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyLCAxMiwgMTIsIDEwLCAxMCwgbmV3IEVDQmxvY2tzKDcsIG5ldyBFQ0IoMSwgNSkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigzLCAxNCwgMTQsIDEyLCAxMiwgbmV3IEVDQmxvY2tzKDEwLCBuZXcgRUNCKDEsIDgpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oNCwgMTYsIDE2LCAxNCwgMTQsIG5ldyBFQ0Jsb2NrcygxMiwgbmV3IEVDQigxLCAxMikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbig1LCAxOCwgMTgsIDE2LCAxNiwgbmV3IEVDQmxvY2tzKDE0LCBuZXcgRUNCKDEsIDE4KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDYsIDIwLCAyMCwgMTgsIDE4LCBuZXcgRUNCbG9ja3MoMTgsIG5ldyBFQ0IoMSwgMjIpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oNywgMjIsIDIyLCAyMCwgMjAsIG5ldyBFQ0Jsb2NrcygyMCwgbmV3IEVDQigxLCAzMCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbig4LCAyNCwgMjQsIDIyLCAyMiwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDEsIDM2KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDksIDI2LCAyNiwgMjQsIDI0LCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMSwgNDQpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTAsIDMyLCAzMiwgMTQsIDE0LCBuZXcgRUNCbG9ja3MoMzYsIG5ldyBFQ0IoMSwgNjIpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTEsIDM2LCAzNiwgMTYsIDE2LCBuZXcgRUNCbG9ja3MoNDIsIG5ldyBFQ0IoMSwgODYpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTIsIDQwLCA0MCwgMTgsIDE4LCBuZXcgRUNCbG9ja3MoNDgsIG5ldyBFQ0IoMSwgMTE0KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDEzLCA0NCwgNDQsIDIwLCAyMCwgbmV3IEVDQmxvY2tzKDU2LCBuZXcgRUNCKDEsIDE0NCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxNCwgNDgsIDQ4LCAyMiwgMjIsIG5ldyBFQ0Jsb2Nrcyg2OCwgbmV3IEVDQigxLCAxNzQpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTUsIDUyLCA1MiwgMjQsIDI0LCBuZXcgRUNCbG9ja3MoNDIsIG5ldyBFQ0IoMiwgMTAyKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDE2LCA2NCwgNjQsIDE0LCAxNCwgbmV3IEVDQmxvY2tzKDU2LCBuZXcgRUNCKDIsIDE0MCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxNywgNzIsIDcyLCAxNiwgMTYsIG5ldyBFQ0Jsb2NrcygzNiwgbmV3IEVDQig0LCA5MikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxOCwgODAsIDgwLCAxOCwgMTgsIG5ldyBFQ0Jsb2Nrcyg0OCwgbmV3IEVDQig0LCAxMTQpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTksIDg4LCA4OCwgMjAsIDIwLCBuZXcgRUNCbG9ja3MoNTYsIG5ldyBFQ0IoNCwgMTQ0KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDIwLCA5NiwgOTYsIDIyLCAyMiwgbmV3IEVDQmxvY2tzKDY4LCBuZXcgRUNCKDQsIDE3NCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyMSwgMTA0LCAxMDQsIDI0LCAyNCwgbmV3IEVDQmxvY2tzKDU2LCBuZXcgRUNCKDYsIDEzNikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyMiwgMTIwLCAxMjAsIDE4LCAxOCwgbmV3IEVDQmxvY2tzKDY4LCBuZXcgRUNCKDYsIDE3NSkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyMywgMTMyLCAxMzIsIDIwLCAyMCwgbmV3IEVDQmxvY2tzKDYyLCBuZXcgRUNCKDgsIDE2MykpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyNCwgMTQ0LCAxNDQsIDIyLCAyMiwgbmV3IEVDQmxvY2tzKDYyLCBuZXcgRUNCKDgsIDE1NiksIG5ldyBFQ0IoMiwgMTU1KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDI1LCA4LCAxOCwgNiwgMTYsIG5ldyBFQ0Jsb2Nrcyg3LCBuZXcgRUNCKDEsIDUpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMjYsIDgsIDMyLCA2LCAxNCwgbmV3IEVDQmxvY2tzKDExLCBuZXcgRUNCKDEsIDEwKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDI3LCAxMiwgMjYsIDEwLCAyNCwgbmV3IEVDQmxvY2tzKDE0LCBuZXcgRUNCKDEsIDE2KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDI4LCAxMiwgMzYsIDEwLCAxNiwgbmV3IEVDQmxvY2tzKDE4LCBuZXcgRUNCKDEsIDIyKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDI5LCAxNiwgMzYsIDE0LCAxNiwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDEsIDMyKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDMwLCAxNiwgNDgsIDE0LCAyMiwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDEsIDQ5KSkpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIFZlcnNpb24uVkVSU0lPTlMgPSBWZXJzaW9uLmJ1aWxkVmVyc2lvbnMoKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBiYnJvd25AZ29vZ2xlLmNvbSAoQnJpYW4gQnJvd24pXG4gICAgICovXG4gICAgY2xhc3MgQml0TWF0cml4UGFyc2VyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBiaXRNYXRyaXgge0BsaW5rIEJpdE1hdHJpeH0gdG8gcGFyc2VcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgZGltZW5zaW9uIGlzIDwgOCBvciA+IDE0NCBvciBub3QgMCBtb2QgMlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoYml0TWF0cml4KSB7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSBiaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uIDwgOCB8fCBkaW1lbnNpb24gPiAxNDQgfHwgKGRpbWVuc2lvbiAmIDB4MDEpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uID0gQml0TWF0cml4UGFyc2VyLnJlYWRWZXJzaW9uKGJpdE1hdHJpeCk7XG4gICAgICAgICAgICB0aGlzLm1hcHBpbmdCaXRNYXRyaXggPSB0aGlzLmV4dHJhY3REYXRhUmVnaW9uKGJpdE1hdHJpeCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRNYXBwaW5nTWF0cml4ID0gbmV3IEJpdE1hdHJpeCh0aGlzLm1hcHBpbmdCaXRNYXRyaXguZ2V0V2lkdGgoKSwgdGhpcy5tYXBwaW5nQml0TWF0cml4LmdldEhlaWdodCgpKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWZXJzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+Q3JlYXRlcyB0aGUgdmVyc2lvbiBvYmplY3QgYmFzZWQgb24gdGhlIGRpbWVuc2lvbiBvZiB0aGUgb3JpZ2luYWwgYml0IG1hdHJpeCBmcm9tXG4gICAgICAgICAqIHRoZSBkYXRhbWF0cml4IGNvZGUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYgVGFibGUgNyAtIEVDQyAyMDAgc3ltYm9sIGF0dHJpYnV0ZXM8L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBiaXRNYXRyaXggT3JpZ2luYWwge0BsaW5rIEJpdE1hdHJpeH0gaW5jbHVkaW5nIGFsaWdubWVudCBwYXR0ZXJuc1xuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBWZXJzaW9ufSBlbmNhcHN1bGF0aW5nIHRoZSBEYXRhIE1hdHJpeCBDb2RlJ3MgXCJ2ZXJzaW9uXCJcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG1hcHBpbmcgbWF0cml4IGFyZSBub3QgdmFsaWRcbiAgICAgICAgICogRGF0YSBNYXRyaXggZGltZW5zaW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyByZWFkVmVyc2lvbihiaXRNYXRyaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bVJvd3MgPSBiaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBudW1Db2x1bW5zID0gYml0TWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgICAgICByZXR1cm4gVmVyc2lvbi5nZXRWZXJzaW9uRm9yRGltZW5zaW9ucyhudW1Sb3dzLCBudW1Db2x1bW5zKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgdGhlIGJpdHMgaW4gdGhlIHtAbGluayBCaXRNYXRyaXh9IHJlcHJlc2VudGluZyB0aGUgbWFwcGluZyBtYXRyaXggKE5vIGFsaWdubWVudCBwYXR0ZXJucylcbiAgICAgICAgICogaW4gdGhlIGNvcnJlY3Qgb3JkZXIgaW4gb3JkZXIgdG8gcmVjb25zdGl0dXRlIHRoZSBjb2Rld29yZHMgYnl0ZXMgY29udGFpbmVkIHdpdGhpbiB0aGVcbiAgICAgICAgICogRGF0YSBNYXRyaXggQ29kZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gYnl0ZXMgZW5jb2RlZCB3aXRoaW4gdGhlIERhdGEgTWF0cml4IENvZGVcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyBleHBlY3RlZCBpcyBub3QgcmVhZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZENvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBJbnQ4QXJyYXkodGhpcy52ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdE9mZnNldCA9IDA7XG4gICAgICAgICAgICBsZXQgcm93ID0gNDtcbiAgICAgICAgICAgIGxldCBjb2x1bW4gPSAwO1xuICAgICAgICAgICAgY29uc3QgbnVtUm93cyA9IHRoaXMubWFwcGluZ0JpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IG51bUNvbHVtbnMgPSB0aGlzLm1hcHBpbmdCaXRNYXRyaXguZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGxldCBjb3JuZXIxUmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNvcm5lcjJSZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgY29ybmVyM1JlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjb3JuZXI0UmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gUmVhZCBhbGwgb2YgdGhlIGNvZGV3b3Jkc1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBmb3VyIGNvcm5lciBjYXNlc1xuICAgICAgICAgICAgICAgIGlmICgocm93ID09PSBudW1Sb3dzKSAmJiAoY29sdW1uID09PSAwKSAmJiAhY29ybmVyMVJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IHRoaXMucmVhZENvcm5lcjEobnVtUm93cywgbnVtQ29sdW1ucykgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvcm5lcjFSZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHJvdyA9PT0gbnVtUm93cyAtIDIpICYmIChjb2x1bW4gPT09IDApICYmICgobnVtQ29sdW1ucyAmIDB4MDMpICE9PSAwKSAmJiAhY29ybmVyMlJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IHRoaXMucmVhZENvcm5lcjIobnVtUm93cywgbnVtQ29sdW1ucykgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvcm5lcjJSZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHJvdyA9PT0gbnVtUm93cyArIDQpICYmIChjb2x1bW4gPT09IDIpICYmICgobnVtQ29sdW1ucyAmIDB4MDcpID09PSAwKSAmJiAhY29ybmVyM1JlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IHRoaXMucmVhZENvcm5lcjMobnVtUm93cywgbnVtQ29sdW1ucykgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvcm5lcjNSZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHJvdyA9PT0gbnVtUm93cyAtIDIpICYmIChjb2x1bW4gPT09IDApICYmICgobnVtQ29sdW1ucyAmIDB4MDcpID09PSA0KSAmJiAhY29ybmVyNFJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IHRoaXMucmVhZENvcm5lcjQobnVtUm93cywgbnVtQ29sdW1ucykgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvcm5lcjRSZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN3ZWVwIHVwd2FyZCBkaWFnb25hbGx5IHRvIHRoZSByaWdodFxuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJvdyA8IG51bVJvd3MpICYmIChjb2x1bW4gPj0gMCkgJiYgIXRoaXMucmVhZE1hcHBpbmdNYXRyaXguZ2V0KGNvbHVtbiwgcm93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRVdGFoKHJvdywgY29sdW1uLCBudW1Sb3dzLCBudW1Db2x1bW5zKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiArPSAyO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgocm93ID49IDApICYmIChjb2x1bW4gPCBudW1Db2x1bW5zKSk7XG4gICAgICAgICAgICAgICAgICAgIHJvdyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMztcbiAgICAgICAgICAgICAgICAgICAgLy8gU3dlZXAgZG93bndhcmQgZGlhZ29uYWxseSB0byB0aGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJvdyA+PSAwKSAmJiAoY29sdW1uIDwgbnVtQ29sdW1ucykgJiYgIXRoaXMucmVhZE1hcHBpbmdNYXRyaXguZ2V0KGNvbHVtbiwgcm93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRVdGFoKHJvdywgY29sdW1uLCBudW1Sb3dzLCBudW1Db2x1bW5zKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiAtPSAyO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgocm93IDwgbnVtUm93cykgJiYgKGNvbHVtbiA+PSAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJvdyArPSAzO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgocm93IDwgbnVtUm93cykgfHwgKGNvbHVtbiA8IG51bUNvbHVtbnMpKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRPZmZzZXQgIT09IHRoaXMudmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgYSBiaXQgb2YgdGhlIG1hcHBpbmcgbWF0cml4IGFjY291bnRpbmcgZm9yIGJvdW5kYXJ5IHdyYXBwaW5nLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvdyBSb3cgdG8gcmVhZCBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIGNvbHVtbiBDb2x1bW4gdG8gcmVhZCBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSBudW1Db2x1bW5zIE51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcmV0dXJuIHZhbHVlIG9mIHRoZSBnaXZlbiBiaXQgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqL1xuICAgICAgICByZWFkTW9kdWxlKHJvdywgY29sdW1uLCBudW1Sb3dzLCBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICAvLyBBZGp1c3QgdGhlIHJvdyBhbmQgY29sdW1uIGluZGljZXMgYmFzZWQgb24gYm91bmRhcnkgd3JhcHBpbmdcbiAgICAgICAgICAgIGlmIChyb3cgPCAwKSB7XG4gICAgICAgICAgICAgICAgcm93ICs9IG51bVJvd3M7XG4gICAgICAgICAgICAgICAgY29sdW1uICs9IDQgLSAoKG51bVJvd3MgKyA0KSAmIDB4MDcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbHVtbiA8IDApIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gbnVtQ29sdW1ucztcbiAgICAgICAgICAgICAgICByb3cgKz0gNCAtICgobnVtQ29sdW1ucyArIDQpICYgMHgwNyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWRNYXBwaW5nTWF0cml4LnNldChjb2x1bW4sIHJvdyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBwaW5nQml0TWF0cml4LmdldChjb2x1bW4sIHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIHRoZSA4IGJpdHMgb2YgdGhlIHN0YW5kYXJkIFV0YWgtc2hhcGVkIHBhdHRlcm4uPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYsIDUuOC4xIEZpZ3VyZSA2PC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcm93IEN1cnJlbnQgcm93IGluIHRoZSBtYXBwaW5nIG1hdHJpeCwgYW5jaG9yZWQgYXQgdGhlIDh0aCBiaXQgKExTQikgb2YgdGhlIHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIGNvbHVtbiBDdXJyZW50IGNvbHVtbiBpbiB0aGUgbWFwcGluZyBtYXRyaXgsIGFuY2hvcmVkIGF0IHRoZSA4dGggYml0IChMU0IpIG9mIHRoZSBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBudW1Sb3dzIE51bWJlciBvZiByb3dzIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHJldHVybiBieXRlIGZyb20gdGhlIHV0YWggc2hhcGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRVdGFoKHJvdywgY29sdW1uLCBudW1Sb3dzLCBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAyLCBjb2x1bW4gLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93IC0gMiwgY29sdW1uIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKHJvdyAtIDEsIGNvbHVtbiAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAxLCBjb2x1bW4gLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93IC0gMSwgY29sdW1uLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93LCBjb2x1bW4gLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93LCBjb2x1bW4gLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93LCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgdGhlIDggYml0cyBvZiB0aGUgc3BlY2lhbCBjb3JuZXIgY29uZGl0aW9uIDEuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYsIEZpZ3VyZSBGLjM8L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBudW1Sb3dzIE51bWJlciBvZiByb3dzIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHJldHVybiBieXRlIGZyb20gdGhlIENvcm5lciBjb25kaXRpb24gMVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZENvcm5lcjEobnVtUm93cywgbnVtQ29sdW1ucykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRCeXRlID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMSwgMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDEsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMiwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgzLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRCeXRlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5SZWFkcyB0aGUgOCBiaXRzIG9mIHRoZSBzcGVjaWFsIGNvcm5lciBjb25kaXRpb24gMi48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlNlZSBJU08gMTYwMjI6MjAwNiwgRmlndXJlIEYuNDwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSBudW1Db2x1bW5zIE51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcmV0dXJuIGJ5dGUgZnJvbSB0aGUgQ29ybmVyIGNvbmRpdGlvbiAyXG4gICAgICAgICAqL1xuICAgICAgICByZWFkQ29ybmVyMihudW1Sb3dzLCBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMywgMCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAyLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gNCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAzLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDEsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIHRoZSA4IGJpdHMgb2YgdGhlIHNwZWNpYWwgY29ybmVyIGNvbmRpdGlvbiAzLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCBGaWd1cmUgRi41PC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4gYnl0ZSBmcm9tIHRoZSBDb3JuZXIgY29uZGl0aW9uIDNcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRDb3JuZXIzKG51bVJvd3MsIG51bUNvbHVtbnMpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qnl0ZSA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDMsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMSwgbnVtQ29sdW1ucyAtIDMsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgxLCBudW1Db2x1bW5zIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDEsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIHRoZSA4IGJpdHMgb2YgdGhlIHNwZWNpYWwgY29ybmVyIGNvbmRpdGlvbiA0LjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCBGaWd1cmUgRi42PC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4gYnl0ZSBmcm9tIHRoZSBDb3JuZXIgY29uZGl0aW9uIDRcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRDb3JuZXI0KG51bVJvd3MsIG51bUNvbHVtbnMpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qnl0ZSA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAzLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDIsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMSwgMCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgxLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDIsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMywgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RXh0cmFjdHMgdGhlIGRhdGEgcmVnaW9uIGZyb20gYSB7QGxpbmsgQml0TWF0cml4fSB0aGF0IGNvbnRhaW5zXG4gICAgICAgICAqIGFsaWdubWVudCBwYXR0ZXJucy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBiaXRNYXRyaXggT3JpZ2luYWwge0BsaW5rIEJpdE1hdHJpeH0gd2l0aCBhbGlnbm1lbnQgcGF0dGVybnNcbiAgICAgICAgICogQHJldHVybiBCaXRNYXRyaXggdGhhdCBoYXMgdGhlIGFsaWdubWVudCBwYXR0ZXJucyByZW1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICBleHRyYWN0RGF0YVJlZ2lvbihiaXRNYXRyaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbFNpemVSb3dzID0gdGhpcy52ZXJzaW9uLmdldFN5bWJvbFNpemVSb3dzKCk7XG4gICAgICAgICAgICBjb25zdCBzeW1ib2xTaXplQ29sdW1ucyA9IHRoaXMudmVyc2lvbi5nZXRTeW1ib2xTaXplQ29sdW1ucygpO1xuICAgICAgICAgICAgaWYgKGJpdE1hdHJpeC5nZXRIZWlnaHQoKSAhPT0gc3ltYm9sU2l6ZVJvd3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdEaW1lbnNpb24gb2YgYml0TWF0cml4IG11c3QgbWF0Y2ggdGhlIHZlcnNpb24gc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YVJlZ2lvblNpemVSb3dzID0gdGhpcy52ZXJzaW9uLmdldERhdGFSZWdpb25TaXplUm93cygpO1xuICAgICAgICAgICAgY29uc3QgZGF0YVJlZ2lvblNpemVDb2x1bW5zID0gdGhpcy52ZXJzaW9uLmdldERhdGFSZWdpb25TaXplQ29sdW1ucygpO1xuICAgICAgICAgICAgY29uc3QgbnVtRGF0YVJlZ2lvbnNSb3cgPSBzeW1ib2xTaXplUm93cyAvIGRhdGFSZWdpb25TaXplUm93cyB8IDA7XG4gICAgICAgICAgICBjb25zdCBudW1EYXRhUmVnaW9uc0NvbHVtbiA9IHN5bWJvbFNpemVDb2x1bW5zIC8gZGF0YVJlZ2lvblNpemVDb2x1bW5zIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpemVEYXRhUmVnaW9uUm93ID0gbnVtRGF0YVJlZ2lvbnNSb3cgKiBkYXRhUmVnaW9uU2l6ZVJvd3M7XG4gICAgICAgICAgICBjb25zdCBzaXplRGF0YVJlZ2lvbkNvbHVtbiA9IG51bURhdGFSZWdpb25zQ29sdW1uICogZGF0YVJlZ2lvblNpemVDb2x1bW5zO1xuICAgICAgICAgICAgY29uc3QgYml0TWF0cml4V2l0aG91dEFsaWdubWVudCA9IG5ldyBCaXRNYXRyaXgoc2l6ZURhdGFSZWdpb25Db2x1bW4sIHNpemVEYXRhUmVnaW9uUm93KTtcbiAgICAgICAgICAgIGZvciAobGV0IGRhdGFSZWdpb25Sb3cgPSAwOyBkYXRhUmVnaW9uUm93IDwgbnVtRGF0YVJlZ2lvbnNSb3c7ICsrZGF0YVJlZ2lvblJvdykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFSZWdpb25Sb3dPZmZzZXQgPSBkYXRhUmVnaW9uUm93ICogZGF0YVJlZ2lvblNpemVSb3dzO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGRhdGFSZWdpb25Db2x1bW4gPSAwOyBkYXRhUmVnaW9uQ29sdW1uIDwgbnVtRGF0YVJlZ2lvbnNDb2x1bW47ICsrZGF0YVJlZ2lvbkNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhUmVnaW9uQ29sdW1uT2Zmc2V0ID0gZGF0YVJlZ2lvbkNvbHVtbiAqIGRhdGFSZWdpb25TaXplQ29sdW1ucztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhUmVnaW9uU2l6ZVJvd3M7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZFJvd09mZnNldCA9IGRhdGFSZWdpb25Sb3cgKiAoZGF0YVJlZ2lvblNpemVSb3dzICsgMikgKyAxICsgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlUm93T2Zmc2V0ID0gZGF0YVJlZ2lvblJvd09mZnNldCArIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRhdGFSZWdpb25TaXplQ29sdW1uczsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZENvbHVtbk9mZnNldCA9IGRhdGFSZWdpb25Db2x1bW4gKiAoZGF0YVJlZ2lvblNpemVDb2x1bW5zICsgMikgKyAxICsgajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0TWF0cml4LmdldChyZWFkQ29sdW1uT2Zmc2V0LCByZWFkUm93T2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3cml0ZUNvbHVtbk9mZnNldCA9IGRhdGFSZWdpb25Db2x1bW5PZmZzZXQgKyBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRNYXRyaXhXaXRob3V0QWxpZ25tZW50LnNldCh3cml0ZUNvbHVtbk9mZnNldCwgd3JpdGVSb3dPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaXRNYXRyaXhXaXRob3V0QWxpZ25tZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGEgYmxvY2sgb2YgZGF0YSB3aXRoaW4gYSBEYXRhIE1hdHJpeCBDb2RlLiBEYXRhIE1hdHJpeCBDb2RlcyBtYXkgc3BsaXQgdGhlaXIgZGF0YSBpbnRvXG4gICAgICogbXVsdGlwbGUgYmxvY2tzLCBlYWNoIG9mIHdoaWNoIGlzIGEgdW5pdCBvZiBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkcy4gRWFjaFxuICAgICAqIGlzIHJlcHJlc2VudGVkIGJ5IGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBiYnJvd25AZ29vZ2xlLmNvbSAoQnJpYW4gQnJvd24pXG4gICAgICovXG4gICAgY2xhc3MgRGF0YUJsb2NrIHtcbiAgICAgICAgY29uc3RydWN0b3IobnVtRGF0YUNvZGV3b3JkcywgY29kZXdvcmRzKSB7XG4gICAgICAgICAgICB0aGlzLm51bURhdGFDb2Rld29yZHMgPSBudW1EYXRhQ29kZXdvcmRzO1xuICAgICAgICAgICAgdGhpcy5jb2Rld29yZHMgPSBjb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPldoZW4gRGF0YSBNYXRyaXggQ29kZXMgdXNlIG11bHRpcGxlIGRhdGEgYmxvY2tzLCB0aGV5IGFjdHVhbGx5IGludGVybGVhdmUgdGhlIGJ5dGVzIG9mIGVhY2ggb2YgdGhlbS5cbiAgICAgICAgICogVGhhdCBpcywgdGhlIGZpcnN0IGJ5dGUgb2YgZGF0YSBibG9jayAxIHRvIG4gaXMgd3JpdHRlbiwgdGhlbiB0aGUgc2Vjb25kIGJ5dGVzLCBhbmQgc28gb24uIFRoaXNcbiAgICAgICAgICogbWV0aG9kIHdpbGwgc2VwYXJhdGUgdGhlIGRhdGEgaW50byBvcmlnaW5hbCBibG9ja3MuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcmF3Q29kZXdvcmRzIGJ5dGVzIGFzIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgRGF0YSBNYXRyaXggQ29kZVxuICAgICAgICAgKiBAcGFyYW0gdmVyc2lvbiB2ZXJzaW9uIG9mIHRoZSBEYXRhIE1hdHJpeCBDb2RlXG4gICAgICAgICAqIEByZXR1cm4gRGF0YUJsb2NrcyBjb250YWluaW5nIG9yaWdpbmFsIGJ5dGVzLCBcImRlLWludGVybGVhdmVkXCIgZnJvbSByZXByZXNlbnRhdGlvbiBpbiB0aGVcbiAgICAgICAgICogICAgICAgICBEYXRhIE1hdHJpeCBDb2RlXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0RGF0YUJsb2NrcyhyYXdDb2Rld29yZHMsIHZlcnNpb24pIHtcbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIG51bWJlciBhbmQgc2l6ZSBvZiBkYXRhIGJsb2NrcyB1c2VkIGJ5IHRoaXMgdmVyc2lvblxuICAgICAgICAgICAgY29uc3QgZWNCbG9ja3MgPSB2ZXJzaW9uLmdldEVDQmxvY2tzKCk7XG4gICAgICAgICAgICAvLyBGaXJzdCBjb3VudCB0aGUgdG90YWwgbnVtYmVyIG9mIGRhdGEgYmxvY2tzXG4gICAgICAgICAgICBsZXQgdG90YWxCbG9ja3MgPSAwO1xuICAgICAgICAgICAgY29uc3QgZWNCbG9ja0FycmF5ID0gZWNCbG9ja3MuZ2V0RUNCbG9ja3MoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGVjQmxvY2sgb2YgZWNCbG9ja0FycmF5KSB7XG4gICAgICAgICAgICAgICAgdG90YWxCbG9ja3MgKz0gZWNCbG9jay5nZXRDb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IGVzdGFibGlzaCBEYXRhQmxvY2tzIG9mIHRoZSBhcHByb3ByaWF0ZSBzaXplIGFuZCBudW1iZXIgb2YgZGF0YSBjb2Rld29yZHNcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSh0b3RhbEJsb2Nrcyk7XG4gICAgICAgICAgICBsZXQgbnVtUmVzdWx0QmxvY2tzID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGVjQmxvY2sgb2YgZWNCbG9ja0FycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlY0Jsb2NrLmdldENvdW50KCk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1EYXRhQ29kZXdvcmRzID0gZWNCbG9jay5nZXREYXRhQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bUJsb2NrQ29kZXdvcmRzID0gZWNCbG9ja3MuZ2V0RUNDb2Rld29yZHMoKSArIG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtudW1SZXN1bHRCbG9ja3MrK10gPSBuZXcgRGF0YUJsb2NrKG51bURhdGFDb2Rld29yZHMsIG5ldyBVaW50OEFycmF5KG51bUJsb2NrQ29kZXdvcmRzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWxsIGJsb2NrcyBoYXZlIHRoZSBzYW1lIGFtb3VudCBvZiBkYXRhLCBleGNlcHQgdGhhdCB0aGUgbGFzdCBuXG4gICAgICAgICAgICAvLyAod2hlcmUgbiBtYXkgYmUgMCkgaGF2ZSAxIGxlc3MgYnl0ZS4gRmlndXJlIG91dCB3aGVyZSB0aGVzZSBzdGFydC5cbiAgICAgICAgICAgIC8vIFRPRE8oYmJyb3duKTogVGhlcmUgaXMgb25seSBvbmUgY2FzZSB3aGVyZSB0aGVyZSBpcyBhIGRpZmZlcmVuY2UgZm9yIERhdGEgTWF0cml4IGZvciBzaXplIDE0NFxuICAgICAgICAgICAgY29uc3QgbG9uZ2VyQmxvY2tzVG90YWxDb2Rld29yZHMgPSByZXN1bHRbMF0uY29kZXdvcmRzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGludCBzaG9ydGVyQmxvY2tzVG90YWxDb2Rld29yZHMgPSBsb25nZXJCbG9ja3NUb3RhbENvZGV3b3JkcyAtIDE7XG4gICAgICAgICAgICBjb25zdCBsb25nZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzID0gbG9uZ2VyQmxvY2tzVG90YWxDb2Rld29yZHMgLSBlY0Jsb2Nrcy5nZXRFQ0NvZGV3b3JkcygpO1xuICAgICAgICAgICAgY29uc3Qgc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHMgPSBsb25nZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzIC0gMTtcbiAgICAgICAgICAgIC8vIFRoZSBsYXN0IGVsZW1lbnRzIG9mIHJlc3VsdCBtYXkgYmUgMSBlbGVtZW50IHNob3J0ZXIgZm9yIDE0NCBtYXRyaXhcbiAgICAgICAgICAgIC8vIGZpcnN0IGZpbGwgb3V0IGFzIG1hbnkgZWxlbWVudHMgYXMgYWxsIG9mIHRoZW0gaGF2ZSBtaW51cyAxXG4gICAgICAgICAgICBsZXQgcmF3Q29kZXdvcmRzT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2pdLmNvZGV3b3Jkc1tpXSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlsbCBvdXQgdGhlIGxhc3QgZGF0YSBibG9jayBpbiB0aGUgbG9uZ2VyIG9uZXNcbiAgICAgICAgICAgIGNvbnN0IHNwZWNpYWxWZXJzaW9uID0gdmVyc2lvbi5nZXRWZXJzaW9uTnVtYmVyKCkgPT09IDI0O1xuICAgICAgICAgICAgY29uc3QgbnVtTG9uZ2VyQmxvY2tzID0gc3BlY2lhbFZlcnNpb24gPyA4IDogbnVtUmVzdWx0QmxvY2tzO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1Mb25nZXJCbG9ja3M7IGorKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbbG9uZ2VyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyAtIDFdID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBhZGQgaW4gZXJyb3IgY29ycmVjdGlvbiBibG9ja3NcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHJlc3VsdFswXS5jb2Rld29yZHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxvbmdlckJsb2Nrc051bURhdGFDb2Rld29yZHM7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgak9mZnNldCA9IHNwZWNpYWxWZXJzaW9uID8gKGogKyA4KSAlIG51bVJlc3VsdEJsb2NrcyA6IGo7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlPZmZzZXQgPSBzcGVjaWFsVmVyc2lvbiAmJiBqT2Zmc2V0ID4gNyA/IGkgLSAxIDogaTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2pPZmZzZXRdLmNvZGV3b3Jkc1tpT2Zmc2V0XSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJhd0NvZGV3b3Jkc09mZnNldCAhPT0gcmF3Q29kZXdvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TnVtRGF0YUNvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bURhdGFDb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5UaGlzIHByb3ZpZGVzIGFuIGVhc3kgYWJzdHJhY3Rpb24gdG8gcmVhZCBiaXRzIGF0IGEgdGltZSBmcm9tIGEgc2VxdWVuY2Ugb2YgYnl0ZXMsIHdoZXJlIHRoZVxuICAgICAqIG51bWJlciBvZiBiaXRzIHJlYWQgaXMgbm90IG9mdGVuIGEgbXVsdGlwbGUgb2YgOC48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGlzIGNsYXNzIGlzIHRocmVhZC1zYWZlIGJ1dCBub3QgcmVlbnRyYW50IC0tIHVubGVzcyB0aGUgY2FsbGVyIG1vZGlmaWVzIHRoZSBieXRlcyBhcnJheVxuICAgICAqIGl0IHBhc3NlZCBpbiwgaW4gd2hpY2ggY2FzZSBhbGwgYmV0cyBhcmUgb2ZmLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgQml0U291cmNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBieXRlcyBieXRlcyBmcm9tIHdoaWNoIHRoaXMgd2lsbCByZWFkIGJpdHMuIEJpdHMgd2lsbCBiZSByZWFkIGZyb20gdGhlIGZpcnN0IGJ5dGUgZmlyc3QuXG4gICAgICAgICAqIEJpdHMgYXJlIHJlYWQgd2l0aGluIGEgYnl0ZSBmcm9tIG1vc3Qtc2lnbmlmaWNhbnQgdG8gbGVhc3Qtc2lnbmlmaWNhbnQgYml0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICAgICAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IDA7XG4gICAgICAgICAgICB0aGlzLmJpdE9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gaW5kZXggb2YgbmV4dCBiaXQgaW4gY3VycmVudCBieXRlIHdoaWNoIHdvdWxkIGJlIHJlYWQgYnkgdGhlIG5leHQgY2FsbCB0byB7QGxpbmsgI3JlYWRCaXRzKGludCl9LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Qml0T2Zmc2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGluZGV4IG9mIG5leHQgYnl0ZSBpbiBpbnB1dCBieXRlIGFycmF5IHdoaWNoIHdvdWxkIGJlIHJlYWQgYnkgdGhlIG5leHQgY2FsbCB0byB7QGxpbmsgI3JlYWRCaXRzKGludCl9LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Qnl0ZU9mZnNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBudW1CaXRzIG51bWJlciBvZiBiaXRzIHRvIHJlYWRcbiAgICAgICAgICogQHJldHVybiBpbnQgcmVwcmVzZW50aW5nIHRoZSBiaXRzIHJlYWQuIFRoZSBiaXRzIHdpbGwgYXBwZWFyIGFzIHRoZSBsZWFzdC1zaWduaWZpY2FudFxuICAgICAgICAgKiAgICAgICAgIGJpdHMgb2YgdGhlIGludFxuICAgICAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBudW1CaXRzIGlzbid0IGluIFsxLDMyXSBvciBtb3JlIHRoYW4gaXMgYXZhaWxhYmxlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkQml0cyhudW1CaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChudW1CaXRzIDwgMSB8fCBudW1CaXRzID4gMzIgfHwgbnVtQml0cyA+IHRoaXMuYXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCcnICsgbnVtQml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgIGxldCBiaXRPZmZzZXQgPSB0aGlzLmJpdE9mZnNldDtcbiAgICAgICAgICAgIGxldCBieXRlT2Zmc2V0ID0gdGhpcy5ieXRlT2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLmJ5dGVzO1xuICAgICAgICAgICAgLy8gRmlyc3QsIHJlYWQgcmVtYWluZGVyIGZyb20gY3VycmVudCBieXRlXG4gICAgICAgICAgICBpZiAoYml0T2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpdHNMZWZ0ID0gOCAtIGJpdE9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCB0b1JlYWQgPSBudW1CaXRzIDwgYml0c0xlZnQgPyBudW1CaXRzIDogYml0c0xlZnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0c1RvTm90UmVhZCA9IGJpdHNMZWZ0IC0gdG9SZWFkO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hc2sgPSAoMHhGRiA+PiAoOCAtIHRvUmVhZCkpIDw8IGJpdHNUb05vdFJlYWQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKGJ5dGVzW2J5dGVPZmZzZXRdICYgbWFzaykgPj4gYml0c1RvTm90UmVhZDtcbiAgICAgICAgICAgICAgICBudW1CaXRzIC09IHRvUmVhZDtcbiAgICAgICAgICAgICAgICBiaXRPZmZzZXQgKz0gdG9SZWFkO1xuICAgICAgICAgICAgICAgIGlmIChiaXRPZmZzZXQgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgYml0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5leHQgcmVhZCB3aG9sZSBieXRlc1xuICAgICAgICAgICAgaWYgKG51bUJpdHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG51bUJpdHMgPj0gOCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDgpIHwgKGJ5dGVzW2J5dGVPZmZzZXRdICYgMHhGRik7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgbnVtQml0cyAtPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5IHJlYWQgYSBwYXJ0aWFsIGJ5dGVcbiAgICAgICAgICAgICAgICBpZiAobnVtQml0cyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYml0c1RvTm90UmVhZCA9IDggLSBudW1CaXRzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gKDB4RkYgPj4gYml0c1RvTm90UmVhZCkgPDwgYml0c1RvTm90UmVhZDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCBudW1CaXRzKSB8ICgoYnl0ZXNbYnl0ZU9mZnNldF0gJiBtYXNrKSA+PiBiaXRzVG9Ob3RSZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgYml0T2Zmc2V0ICs9IG51bUJpdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iaXRPZmZzZXQgPSBiaXRPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgPSBieXRlT2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBudW1iZXIgb2YgYml0cyB0aGF0IGNhbiBiZSByZWFkIHN1Y2Nlc3NmdWxseVxuICAgICAgICAgKi9cbiAgICAgICAgYXZhaWxhYmxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIDggKiAodGhpcy5ieXRlcy5sZW5ndGggLSB0aGlzLmJ5dGVPZmZzZXQpIC0gdGhpcy5iaXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgTW9kZTtcbiAgICAoZnVuY3Rpb24gKE1vZGUpIHtcbiAgICAgICAgTW9kZVtNb2RlW1wiUEFEX0VOQ09ERVwiXSA9IDBdID0gXCJQQURfRU5DT0RFXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIkFTQ0lJX0VOQ09ERVwiXSA9IDFdID0gXCJBU0NJSV9FTkNPREVcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiQzQwX0VOQ09ERVwiXSA9IDJdID0gXCJDNDBfRU5DT0RFXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIlRFWFRfRU5DT0RFXCJdID0gM10gPSBcIlRFWFRfRU5DT0RFXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIkFOU0lYMTJfRU5DT0RFXCJdID0gNF0gPSBcIkFOU0lYMTJfRU5DT0RFXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIkVESUZBQ1RfRU5DT0RFXCJdID0gNV0gPSBcIkVESUZBQ1RfRU5DT0RFXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIkJBU0UyNTZfRU5DT0RFXCJdID0gNl0gPSBcIkJBU0UyNTZfRU5DT0RFXCI7XG4gICAgfSkoTW9kZSB8fCAoTW9kZSA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogPHA+RGF0YSBNYXRyaXggQ29kZXMgY2FuIGVuY29kZSB0ZXh0IGFzIGJpdHMgaW4gb25lIG9mIHNldmVyYWwgbW9kZXMsIGFuZCBjYW4gdXNlIG11bHRpcGxlIG1vZGVzXG4gICAgICogaW4gb25lIERhdGEgTWF0cml4IENvZGUuIFRoaXMgY2xhc3MgZGVjb2RlcyB0aGUgYml0cyBiYWNrIGludG8gdGV4dC48L3A+XG4gICAgICpcbiAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi4xIC0gNS4yLjkuMjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciB7XG4gICAgICAgIHN0YXRpYyBkZWNvZGUoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBuZXcgQml0U291cmNlKGJ5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRUcmFpbGVyID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVTZWdtZW50cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgbGV0IG1vZGUgPSBNb2RlLkFTQ0lJX0VOQ09ERTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gTW9kZS5BU0NJSV9FTkNPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IHRoaXMuZGVjb2RlQXNjaWlTZWdtZW50KGJpdHMsIHJlc3VsdCwgcmVzdWx0VHJhaWxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5DNDBfRU5DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQzQwU2VnbWVudChiaXRzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLlRFWFRfRU5DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlVGV4dFNlZ21lbnQoYml0cywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5BTlNJWDEyX0VOQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZUFuc2lYMTJTZWdtZW50KGJpdHMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuRURJRkFDVF9FTkNPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVFZGlmYWN0U2VnbWVudChiaXRzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLkJBU0UyNTZfRU5DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQmFzZTI1NlNlZ21lbnQoYml0cywgcmVzdWx0LCBieXRlU2VnbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IE1vZGUuQVNDSUlfRU5DT0RFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKG1vZGUgIT09IE1vZGUuUEFEX0VOQ09ERSAmJiBiaXRzLmF2YWlsYWJsZSgpID4gMCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0VHJhaWxlci5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHJlc3VsdFRyYWlsZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZXJSZXN1bHQoYnl0ZXMsIHJlc3VsdC50b1N0cmluZygpLCBieXRlU2VnbWVudHMubGVuZ3RoID09PSAwID8gbnVsbCA6IGJ5dGVTZWdtZW50cywgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgNS4yLjMgYW5kIEFubmV4IEMsIFRhYmxlIEMuMlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUFzY2lpU2VnbWVudChiaXRzLCByZXN1bHQsIHJlc3VsdFRyYWlsZXIpIHtcbiAgICAgICAgICAgIGxldCB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IG9uZUJ5dGUgPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICAgICAgICAgIGlmIChvbmVCeXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob25lQnl0ZSA8PSAxMjgpIHsgLy8gQVNDSUkgZGF0YSAoQVNDSUkgdmFsdWUgKyAxKVxuICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lQnl0ZSArPSAxMjg7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKG9uZUJ5dGUgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLkFTQ0lJX0VOQ09ERTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob25lQnl0ZSA9PT0gMTI5KSB7IC8vIFBhZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW9kZS5QQURfRU5DT0RFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbmVCeXRlIDw9IDIyOSkgeyAvLyAyLWRpZ2l0IGRhdGEgMDAtOTkgKE51bWVyaWMgVmFsdWUgKyAxMzApXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb25lQnl0ZSAtIDEzMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMTApIHsgLy8gcGFkIHdpdGggJzAnIGZvciBzaW5nbGUgZGlnaXQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcwJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnJyArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob25lQnl0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzA6IC8vIExhdGNoIHRvIEM0MCBlbmNvZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuQzQwX0VOQ09ERTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjMxOiAvLyBMYXRjaCB0byBCYXNlIDI1NiBlbmNvZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuQkFTRTI1Nl9FTkNPREU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzMjogLy8gRk5DMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSgyOSkpOyAvLyB0cmFuc2xhdGUgYXMgQVNDSUkgMjlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjMzOiAvLyBTdHJ1Y3R1cmVkIEFwcGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzQ6IC8vIFJlYWRlciBQcm9ncmFtbWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGVzZSBzeW1ib2xzIGZvciBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyBSZWFkZXJFeGNlcHRpb24uZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjM1OiAvLyBVcHBlciBTaGlmdCAoc2hpZnQgdG8gRXh0ZW5kZWQgQVNDSUkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzNjogLy8gMDUgTWFjcm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdbKT5cXHUwMDFFMDVcXHUwMDFEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0VHJhaWxlci5pbnNlcnQoMCwgJ1xcdTAwMUVcXHUwMDA0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzNzogLy8gMDYgTWFjcm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdbKT5cXHUwMDFFMDZcXHUwMDFEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0VHJhaWxlci5pbnNlcnQoMCwgJ1xcdTAwMUVcXHUwMDA0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzODogLy8gTGF0Y2ggdG8gQU5TSSBYMTIgZW5jb2RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLkFOU0lYMTJfRU5DT0RFO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzk6IC8vIExhdGNoIHRvIFRleHQgZW5jb2RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLlRFWFRfRU5DT0RFO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDA6IC8vIExhdGNoIHRvIEVESUZBQ1QgZW5jb2RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLkVESUZBQ1RfRU5DT0RFO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDE6IC8vIEVDSSBDaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGJicm93bik6IEkgdGhpbmsgd2UgbmVlZCB0byBzdXBwb3J0IEVDSVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm93IFJlYWRlckV4Y2VwdGlvbi5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGlzIHN5bWJvbCBmb3Igbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCB0byBiZSB1c2VkIGluIEFTQ0lJIGVuY29kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgd29yayBhcm91bmQgZW5jb2RlcnMgdGhhdCBlbmQgd2l0aCAyNTQsIGxhdGNoIGJhY2sgdG8gQVNDSUlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25lQnl0ZSAhPT0gMjU0IHx8IGJpdHMuYXZhaWxhYmxlKCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcbiAgICAgICAgICAgIHJldHVybiBNb2RlLkFTQ0lJX0VOQ09ERTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCA1LjIuNSBhbmQgQW5uZXggQywgVGFibGUgQy4xXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlQzQwU2VnbWVudChiaXRzLCByZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIFRocmVlIEM0MCB2YWx1ZXMgYXJlIGVuY29kZWQgaW4gYSAxNi1iaXQgdmFsdWUgYXNcbiAgICAgICAgICAgIC8vICgxNjAwICogQzEpICsgKDQwICogQzIpICsgQzMgKyAxXG4gICAgICAgICAgICAvLyBUT0RPKGJicm93bik6IFRoZSBVcHBlciBTaGlmdCB3aXRoIEM0MCBkb2Vzbid0IHdvcmsgaW4gdGhlIDQgdmFsdWUgc2NlbmFyaW8gYWxsIHRoZSB0aW1lXG4gICAgICAgICAgICBsZXQgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY1ZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IHNoaWZ0ID0gMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSBieXRlIGxlZnQgdGhlbiBpdCB3aWxsIGJlIGVuY29kZWQgYXMgQVNDSUlcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMjU0KSB7IC8vIFVubGF0Y2ggY29kZXdvcmRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVHdvQnl0ZXMoZmlyc3RCeXRlLCBiaXRzLnJlYWRCaXRzKDgpLCBjVmFsdWVzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjVmFsdWUgPSBjVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNWYWx1ZSA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBjVmFsdWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjVmFsdWUgPCB0aGlzLkM0MF9CQVNJQ19TRVRfQ0hBUlMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGM0MGNoYXIgPSB0aGlzLkM0MF9CQVNJQ19TRVRfQ0hBUlNbY1ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjNDBjaGFyLmNoYXJDb2RlQXQoMCkgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoYzQwY2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY1ZhbHVlIDwgdGhpcy5DNDBfU0hJRlQyX1NFVF9DSEFSUy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYzQwY2hhciA9IHRoaXMuQzQwX1NISUZUMl9TRVRfQ0hBUlNbY1ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjNDBjaGFyLmNoYXJDb2RlQXQoMCkgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoYzQwY2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI3OiAvLyBGTkMxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KSk7IC8vIHRyYW5zbGF0ZSBhcyBBU0NJSSAyOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzMDogLy8gVXBwZXIgU2hpZnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlICsgMjI0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyA5NikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCA1LjIuNiBhbmQgQW5uZXggQywgVGFibGUgQy4yXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlVGV4dFNlZ21lbnQoYml0cywgcmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBUaHJlZSBUZXh0IHZhbHVlcyBhcmUgZW5jb2RlZCBpbiBhIDE2LWJpdCB2YWx1ZSBhc1xuICAgICAgICAgICAgLy8gKDE2MDAgKiBDMSkgKyAoNDAgKiBDMikgKyBDMyArIDFcbiAgICAgICAgICAgIC8vIFRPRE8oYmJyb3duKTogVGhlIFVwcGVyIFNoaWZ0IHdpdGggVGV4dCBkb2Vzbid0IHdvcmsgaW4gdGhlIDQgdmFsdWUgc2NlbmFyaW8gYWxsIHRoZSB0aW1lXG4gICAgICAgICAgICBsZXQgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGxldCBzaGlmdCA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgYnl0ZSBsZWZ0IHRoZW4gaXQgd2lsbCBiZSBlbmNvZGVkIGFzIEFTQ0lJXG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDI1NCkgeyAvLyBVbmxhdGNoIGNvZGV3b3JkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVR3b0J5dGVzKGZpcnN0Qnl0ZSwgYml0cy5yZWFkQml0cyg4KSwgY1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY1ZhbHVlID0gY1ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gY1ZhbHVlICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY1ZhbHVlIDwgdGhpcy5URVhUX0JBU0lDX1NFVF9DSEFSUy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dENoYXIgPSB0aGlzLlRFWFRfQkFTSUNfU0VUX0NIQVJTW2NWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUodGV4dENoYXIuY2hhckNvZGVBdCgwKSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0ZXh0Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGlmdCAyIGZvciBUZXh0IGlzIHRoZSBzYW1lIGVuY29kaW5nIGFzIEM0MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCB0aGlzLlRFWFRfU0hJRlQyX1NFVF9DSEFSUy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dENoYXIgPSB0aGlzLlRFWFRfU0hJRlQyX1NFVF9DSEFSU1tjVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKHRleHRDaGFyLmNoYXJDb2RlQXQoMCkgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGV4dENoYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gRk5DMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSgyOSkpOyAvLyB0cmFuc2xhdGUgYXMgQVNDSUkgMjlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzA6IC8vIFVwcGVyIFNoaWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNWYWx1ZSA8IHRoaXMuVEVYVF9TSElGVDNfU0VUX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0Q2hhciA9IHRoaXMuVEVYVF9TSElGVDNfU0VUX0NIQVJTW2NWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUodGV4dENoYXIuY2hhckNvZGVBdCgwKSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0ZXh0Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoYml0cy5hdmFpbGFibGUoKSA+IDApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi43XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlQW5zaVgxMlNlZ21lbnQoYml0cywgcmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBUaHJlZSBBTlNJIFgxMiB2YWx1ZXMgYXJlIGVuY29kZWQgaW4gYSAxNi1iaXQgdmFsdWUgYXNcbiAgICAgICAgICAgIC8vICgxNjAwICogQzEpICsgKDQwICogQzIpICsgQzMgKyAxXG4gICAgICAgICAgICBjb25zdCBjVmFsdWVzID0gW107XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgYnl0ZSBsZWZ0IHRoZW4gaXQgd2lsbCBiZSBlbmNvZGVkIGFzIEFTQ0lJXG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDI1NCkgeyAvLyBVbmxhdGNoIGNvZGV3b3JkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVR3b0J5dGVzKGZpcnN0Qnl0ZSwgYml0cy5yZWFkQml0cyg4KSwgY1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY1ZhbHVlID0gY1ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogLy8gWDEyIHNlZ21lbnQgdGVybWluYXRvciA8Q1I+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIFgxMiBzZWdtZW50IHNlcGFyYXRvciAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnKicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiAvLyBYMTIgc3ViLWVsZW1lbnQgc2VwYXJhdG9yID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCc+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY1ZhbHVlIDwgMTQpIHsgLy8gMCAtIDlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSArIDQ0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNWYWx1ZSA8IDQwKSB7IC8vIEEgLSBaXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyA1MSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcGFyc2VUd29CeXRlcyhmaXJzdEJ5dGUsIHNlY29uZEJ5dGUsIHJlc3VsdCkge1xuICAgICAgICAgICAgbGV0IGZ1bGxCaXRWYWx1ZSA9IChmaXJzdEJ5dGUgPDwgOCkgKyBzZWNvbmRCeXRlIC0gMTtcbiAgICAgICAgICAgIGxldCB0ZW1wID0gTWF0aC5mbG9vcihmdWxsQml0VmFsdWUgLyAxNjAwKTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXA7XG4gICAgICAgICAgICBmdWxsQml0VmFsdWUgLT0gdGVtcCAqIDE2MDA7XG4gICAgICAgICAgICB0ZW1wID0gTWF0aC5mbG9vcihmdWxsQml0VmFsdWUgLyA0MCk7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gZnVsbEJpdFZhbHVlIC0gdGVtcCAqIDQwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi44IGFuZCBBbm5leCBDIFRhYmxlIEMuM1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUVkaWZhY3RTZWdtZW50KGJpdHMsIHJlc3VsdCkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgdHdvIG9yIGxlc3MgYnl0ZXMgbGVmdCB0aGVuIGl0IHdpbGwgYmUgZW5jb2RlZCBhcyBBU0NJSVxuICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDw9IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVkaWZhY3RWYWx1ZSA9IGJpdHMucmVhZEJpdHMoNik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgdW5sYXRjaCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVkaWZhY3RWYWx1ZSA9PT0gMHgxRikgeyAvLyAwMTExMTFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgcmVzdCBvZiBieXRlLCB3aGljaCBzaG91bGQgYmUgMCwgYW5kIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdHNMZWZ0ID0gOCAtIGJpdHMuZ2V0Qml0T2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0c0xlZnQgIT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzLnJlYWRCaXRzKGJpdHNMZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKGVkaWZhY3RWYWx1ZSAmIDB4MjApID09PSAwKSB7IC8vIG5vIDEgaW4gdGhlIGxlYWRpbmcgKDZ0aCkgYml0XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGlmYWN0VmFsdWUgfD0gMHg0MDsgLy8gQWRkIGEgbGVhZGluZyAwMSB0byB0aGUgNiBiaXQgYmluYXJ5IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGVkaWZhY3RWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCA1LjIuOSBhbmQgQW5uZXggQiwgQi4yXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlQmFzZTI1NlNlZ21lbnQoYml0cywgcmVzdWx0LCBieXRlU2VnbWVudHMpIHtcbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgaG93IGxvbmcgdGhlIEJhc2UgMjU2IFNlZ21lbnQgaXMuXG4gICAgICAgICAgICBsZXQgY29kZXdvcmRQb3NpdGlvbiA9IDEgKyBiaXRzLmdldEJ5dGVPZmZzZXQoKTsgLy8gcG9zaXRpb24gaXMgMS1pbmRleGVkXG4gICAgICAgICAgICBjb25zdCBkMSA9IHRoaXMudW5yYW5kb21pemUyNTVTdGF0ZShiaXRzLnJlYWRCaXRzKDgpLCBjb2Rld29yZFBvc2l0aW9uKyspO1xuICAgICAgICAgICAgbGV0IGNvdW50O1xuICAgICAgICAgICAgaWYgKGQxID09PSAwKSB7IC8vIFJlYWQgdGhlIHJlbWFpbmRlciBvZiB0aGUgc3ltYm9sXG4gICAgICAgICAgICAgICAgY291bnQgPSBiaXRzLmF2YWlsYWJsZSgpIC8gOCB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkMSA8IDI1MCkge1xuICAgICAgICAgICAgICAgIGNvdW50ID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudCA9IDI1MCAqIChkMSAtIDI0OSkgKyB0aGlzLnVucmFuZG9taXplMjU1U3RhdGUoYml0cy5yZWFkQml0cyg4KSwgY29kZXdvcmRQb3NpdGlvbisrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlJ3JlIHNlZWluZyBOZWdhdGl2ZUFycmF5U2l6ZUV4Y2VwdGlvbiBlcnJvcnMgZnJvbSB1c2Vycy5cbiAgICAgICAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGNvdW50KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIEhhdmUgc2VlbiB0aGlzIHBhcnRpY3VsYXIgZXJyb3IgaW4gdGhlIHdpbGQsIHN1Y2ggYXMgYXRcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LmJjZ2VuLmNvbS9kZW1vL0lEQXV0b21hdGlvblN0cmVhbWluZ0RhdGFNYXRyaXguYXNweD9NT0RFPTMmRD1GcmVkJlBGTVQ9MyZQVD1GJlg9MC4zJk89MCZMTT0wLjJcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieXRlc1tpXSA9IHRoaXMudW5yYW5kb21pemUyNTVTdGF0ZShiaXRzLnJlYWRCaXRzKDgpLCBjb2Rld29yZFBvc2l0aW9uKyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnl0ZVNlZ21lbnRzLnB1c2goYnl0ZXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZ0VuY29kaW5nLmRlY29kZShieXRlcywgU3RyaW5nVXRpbHMuSVNPODg1OTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoICh1ZWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCdQbGF0Zm9ybSBkb2VzIG5vdCBzdXBwb3J0IHJlcXVpcmVkIGVuY29kaW5nOiAnICsgdWVlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIEFubmV4IEIsIEIuMlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHVucmFuZG9taXplMjU1U3RhdGUocmFuZG9taXplZEJhc2UyNTZDb2Rld29yZCwgYmFzZTI1NkNvZGV3b3JkUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBzZXVkb1JhbmRvbU51bWJlciA9ICgoMTQ5ICogYmFzZTI1NkNvZGV3b3JkUG9zaXRpb24pICUgMjU1KSArIDE7XG4gICAgICAgICAgICBjb25zdCB0ZW1wVmFyaWFibGUgPSByYW5kb21pemVkQmFzZTI1NkNvZGV3b3JkIC0gcHNldWRvUmFuZG9tTnVtYmVyO1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBWYXJpYWJsZSA+PSAwID8gdGVtcFZhcmlhYmxlIDogdGVtcFZhcmlhYmxlICsgMjU2O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgQW5uZXggQyBUYWJsZSBDLjFcbiAgICAgKiBUaGUgQzQwIEJhc2ljIENoYXJhY3RlciBTZXQgKConcyB1c2VkIGZvciBwbGFjZWhvbGRlcnMgZm9yIHRoZSBzaGlmdCB2YWx1ZXMpXG4gICAgICovXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5DNDBfQkFTSUNfU0VUX0NIQVJTID0gW1xuICAgICAgICAnKicsICcqJywgJyonLCAnICcsICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JyxcbiAgICAgICAgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsXG4gICAgICAgICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWidcbiAgICBdO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQzQwX1NISUZUMl9TRVRfQ0hBUlMgPSBbXG4gICAgICAgICchJywgJ1wiJywgJyMnLCAnJCcsICclJywgJyYnLCAnXFwnJywgJygnLCAnKScsICcqJywgJysnLCAnLCcsICctJywgJy4nLFxuICAgICAgICAnLycsICc6JywgJzsnLCAnPCcsICc9JywgJz4nLCAnPycsICdAJywgJ1snLCAnXFxcXCcsICddJywgJ14nLCAnXydcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgQW5uZXggQyBUYWJsZSBDLjJcbiAgICAgKiBUaGUgVGV4dCBCYXNpYyBDaGFyYWN0ZXIgU2V0ICgqJ3MgdXNlZCBmb3IgcGxhY2Vob2xkZXJzIGZvciB0aGUgc2hpZnQgdmFsdWVzKVxuICAgICAqL1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9CQVNJQ19TRVRfQ0hBUlMgPSBbXG4gICAgICAgICcqJywgJyonLCAnKicsICcgJywgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxuICAgICAgICAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJyxcbiAgICAgICAgJ28nLCAncCcsICdxJywgJ3InLCAncycsICd0JywgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6J1xuICAgIF07XG4gICAgLy8gU2hpZnQgMiBmb3IgVGV4dCBpcyB0aGUgc2FtZSBlbmNvZGluZyBhcyBDNDBcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfU0hJRlQyX1NFVF9DSEFSUyA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQzQwX1NISUZUMl9TRVRfQ0hBUlM7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX1NISUZUM19TRVRfQ0hBUlMgPSBbXG4gICAgICAgICdgJywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsXG4gICAgICAgICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICd7JywgJ3wnLCAnfScsICd+JywgU3RyaW5nLmZyb21DaGFyQ29kZSgxMjcpXG4gICAgXTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+VGhlIG1haW4gY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyBEYXRhIE1hdHJpeCBDb2RlIGRlY29kaW5nIC0tIGFzIG9wcG9zZWQgdG8gbG9jYXRpbmcgYW5kIGV4dHJhY3RpbmdcbiAgICAgKiB0aGUgRGF0YSBNYXRyaXggQ29kZSBmcm9tIGFuIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxuICAgICAqL1xuICAgIGNsYXNzIERlY29kZXIkMSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5yc0RlY29kZXIgPSBuZXcgUmVlZFNvbG9tb25EZWNvZGVyKEdlbmVyaWNHRi5EQVRBX01BVFJJWF9GSUVMRF8yNTYpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5EZWNvZGVzIGEgRGF0YSBNYXRyaXggQ29kZSByZXByZXNlbnRlZCBhcyBhIHtAbGluayBCaXRNYXRyaXh9LiBBIDEgb3IgXCJ0cnVlXCIgaXMgdGFrZW5cbiAgICAgICAgICogdG8gbWVhbiBhIGJsYWNrIG1vZHVsZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBiaXRzIGJvb2xlYW5zIHJlcHJlc2VudGluZyB3aGl0ZS9ibGFjayBEYXRhIE1hdHJpeCBDb2RlIG1vZHVsZXNcbiAgICAgICAgICogQHJldHVybiB0ZXh0IGFuZCBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgRGF0YSBNYXRyaXggQ29kZVxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiB0aGUgRGF0YSBNYXRyaXggQ29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZShiaXRzKSB7XG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgYSBwYXJzZXIgYW5kIHJlYWQgdmVyc2lvbiwgZXJyb3ItY29ycmVjdGlvbiBsZXZlbFxuICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IEJpdE1hdHJpeFBhcnNlcihiaXRzKTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBwYXJzZXIuZ2V0VmVyc2lvbigpO1xuICAgICAgICAgICAgLy8gUmVhZCBjb2Rld29yZHNcbiAgICAgICAgICAgIGNvbnN0IGNvZGV3b3JkcyA9IHBhcnNlci5yZWFkQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAvLyBTZXBhcmF0ZSBpbnRvIGRhdGEgYmxvY2tzXG4gICAgICAgICAgICBjb25zdCBkYXRhQmxvY2tzID0gRGF0YUJsb2NrLmdldERhdGFCbG9ja3MoY29kZXdvcmRzLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgIC8vIENvdW50IHRvdGFsIG51bWJlciBvZiBkYXRhIGJ5dGVzXG4gICAgICAgICAgICBsZXQgdG90YWxCeXRlcyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBkYiBvZiBkYXRhQmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgdG90YWxCeXRlcyArPSBkYi5nZXROdW1EYXRhQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsQnl0ZXMpO1xuICAgICAgICAgICAgY29uc3QgZGF0YUJsb2Nrc0NvdW50ID0gZGF0YUJsb2Nrcy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBFcnJvci1jb3JyZWN0IGFuZCBjb3B5IGRhdGEgYmxvY2tzIHRvZ2V0aGVyIGludG8gYSBzdHJlYW0gb2YgYnl0ZXNcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGF0YUJsb2Nrc0NvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhQmxvY2sgPSBkYXRhQmxvY2tzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGV3b3JkQnl0ZXMgPSBkYXRhQmxvY2suZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtRGF0YUNvZGV3b3JkcyA9IGRhdGFCbG9jay5nZXROdW1EYXRhQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JyZWN0RXJyb3JzKGNvZGV3b3JkQnl0ZXMsIG51bURhdGFDb2Rld29yZHMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlLWludGVybGFjZSBkYXRhIGJsb2Nrcy5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Qnl0ZXNbaSAqIGRhdGFCbG9ja3NDb3VudCArIGpdID0gY29kZXdvcmRCeXRlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWNvZGUgdGhlIGNvbnRlbnRzIG9mIHRoYXQgc3RyZWFtIG9mIGJ5dGVzXG4gICAgICAgICAgICByZXR1cm4gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGUocmVzdWx0Qnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5HaXZlbiBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyByZWNlaXZlZCwgcG9zc2libHkgY29ycnVwdGVkIGJ5IGVycm9ycywgYXR0ZW1wdHMgdG9cbiAgICAgICAgICogY29ycmVjdCB0aGUgZXJyb3JzIGluLXBsYWNlIHVzaW5nIFJlZWQtU29sb21vbiBlcnJvciBjb3JyZWN0aW9uLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3JkQnl0ZXMgZGF0YSBhbmQgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHNcbiAgICAgICAgICogQHBhcmFtIG51bURhdGFDb2Rld29yZHMgbnVtYmVyIG9mIGNvZGV3b3JkcyB0aGF0IGFyZSBkYXRhIGJ5dGVzXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgY29ycmVjdEVycm9ycyhjb2Rld29yZEJ5dGVzLCBudW1EYXRhQ29kZXdvcmRzKSB7XG4gICAgICAgICAgICAvLyBjb25zdCBudW1Db2Rld29yZHMgPSBjb2Rld29yZEJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIEZpcnN0IHJlYWQgaW50byBhbiBhcnJheSBvZiBpbnRzXG4gICAgICAgICAgICBjb25zdCBjb2Rld29yZHNJbnRzID0gbmV3IEludDMyQXJyYXkoY29kZXdvcmRCeXRlcyk7XG4gICAgICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAvLyAgIGNvZGV3b3Jkc0ludHNbaV0gPSBjb2Rld29yZEJ5dGVzW2ldICYgMHhGRjtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yc0RlY29kZXIuZGVjb2RlKGNvZGV3b3Jkc0ludHMsIGNvZGV3b3JkQnl0ZXMubGVuZ3RoIC0gbnVtRGF0YUNvZGV3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCAvKiBSZWVkU29sb21vbkV4Y2VwdGlvbiAqLykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDaGVja3N1bUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29weSBiYWNrIGludG8gYXJyYXkgb2YgYnl0ZXMgLS0gb25seSBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZSBieXRlcyB0aGF0IHdlcmUgZGF0YVxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgY2FyZSBhYm91dCBlcnJvcnMgaW4gdGhlIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkQnl0ZXNbaV0gPSBjb2Rld29yZHNJbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGxvZ2ljIHRoYXQgY2FuIGRldGVjdCBhIERhdGEgTWF0cml4IENvZGUgaW4gYW4gaW1hZ2UsIGV2ZW4gaWYgdGhlIERhdGEgTWF0cml4IENvZGVcbiAgICAgKiBpcyByb3RhdGVkIG9yIHNrZXdlZCwgb3IgcGFydGlhbGx5IG9ic2N1cmVkLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGV0ZWN0b3IkMSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGltYWdlKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLnJlY3RhbmdsZURldGVjdG9yID0gbmV3IFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IodGhpcy5pbWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRldGVjdHMgYSBEYXRhIE1hdHJpeCBDb2RlIGluIGFuIGltYWdlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgRGV0ZWN0b3JSZXN1bHR9IGVuY2Fwc3VsYXRpbmcgcmVzdWx0cyBvZiBkZXRlY3RpbmcgYSBEYXRhIE1hdHJpeCBDb2RlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgbm8gRGF0YSBNYXRyaXggQ29kZSBjYW4gYmUgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGRldGVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcm5lclBvaW50cyA9IHRoaXMucmVjdGFuZ2xlRGV0ZWN0b3IuZGV0ZWN0KCk7XG4gICAgICAgICAgICBsZXQgcG9pbnRzID0gdGhpcy5kZXRlY3RTb2xpZDEoY29ybmVyUG9pbnRzKTtcbiAgICAgICAgICAgIHBvaW50cyA9IHRoaXMuZGV0ZWN0U29saWQyKHBvaW50cyk7XG4gICAgICAgICAgICBwb2ludHNbM10gPSB0aGlzLmNvcnJlY3RUb3BSaWdodChwb2ludHMpO1xuICAgICAgICAgICAgaWYgKCFwb2ludHNbM10pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cyA9IHRoaXMuc2hpZnRUb01vZHVsZUNlbnRlcihwb2ludHMpO1xuICAgICAgICAgICAgY29uc3QgdG9wTGVmdCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbUxlZnQgPSBwb2ludHNbMV07XG4gICAgICAgICAgICBjb25zdCBib3R0b21SaWdodCA9IHBvaW50c1syXTtcbiAgICAgICAgICAgIGNvbnN0IHRvcFJpZ2h0ID0gcG9pbnRzWzNdO1xuICAgICAgICAgICAgbGV0IGRpbWVuc2lvblRvcCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHRvcExlZnQsIHRvcFJpZ2h0KSArIDE7XG4gICAgICAgICAgICBsZXQgZGltZW5zaW9uUmlnaHQgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihib3R0b21SaWdodCwgdG9wUmlnaHQpICsgMTtcbiAgICAgICAgICAgIGlmICgoZGltZW5zaW9uVG9wICYgMHgwMSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25Ub3AgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZGltZW5zaW9uUmlnaHQgJiAweDAxKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvblJpZ2h0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoNCAqIGRpbWVuc2lvblRvcCA8IDcgKiBkaW1lbnNpb25SaWdodCAmJiA0ICogZGltZW5zaW9uUmlnaHQgPCA3ICogZGltZW5zaW9uVG9wKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG1hdHJpeCBpcyBzcXVhcmVcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25Ub3AgPSBkaW1lbnNpb25SaWdodCA9IE1hdGgubWF4KGRpbWVuc2lvblRvcCwgZGltZW5zaW9uUmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJpdHMgPSBEZXRlY3RvciQxLnNhbXBsZUdyaWQodGhpcy5pbWFnZSwgdG9wTGVmdCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIHRvcFJpZ2h0LCBkaW1lbnNpb25Ub3AsIGRpbWVuc2lvblJpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGV0ZWN0b3JSZXN1bHQoYml0cywgW3RvcExlZnQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCB0b3BSaWdodF0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBzaGlmdFBvaW50KHBvaW50LCB0bywgZGl2KSB7XG4gICAgICAgICAgICBsZXQgeCA9ICh0by5nZXRYKCkgLSBwb2ludC5nZXRYKCkpIC8gKGRpdiArIDEpO1xuICAgICAgICAgICAgbGV0IHkgPSAodG8uZ2V0WSgpIC0gcG9pbnQuZ2V0WSgpKSAvIChkaXYgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0UG9pbnQocG9pbnQuZ2V0WCgpICsgeCwgcG9pbnQuZ2V0WSgpICsgeSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG1vdmVBd2F5KHBvaW50LCBmcm9tWCwgZnJvbVkpIHtcbiAgICAgICAgICAgIGxldCB4ID0gcG9pbnQuZ2V0WCgpO1xuICAgICAgICAgICAgbGV0IHkgPSBwb2ludC5nZXRZKCk7XG4gICAgICAgICAgICBpZiAoeCA8IGZyb21YKSB7XG4gICAgICAgICAgICAgICAgeCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPCBmcm9tWSkge1xuICAgICAgICAgICAgICAgIHkgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHkgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0UG9pbnQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdCBhIHNvbGlkIHNpZGUgd2hpY2ggaGFzIG1pbmltdW0gdHJhbnNpdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGRldGVjdFNvbGlkMShjb3JuZXJQb2ludHMpIHtcbiAgICAgICAgICAgIC8vIDAgIDJcbiAgICAgICAgICAgIC8vIDEgIDNcbiAgICAgICAgICAgIGxldCBwb2ludEEgPSBjb3JuZXJQb2ludHNbMF07XG4gICAgICAgICAgICBsZXQgcG9pbnRCID0gY29ybmVyUG9pbnRzWzFdO1xuICAgICAgICAgICAgbGV0IHBvaW50QyA9IGNvcm5lclBvaW50c1szXTtcbiAgICAgICAgICAgIGxldCBwb2ludEQgPSBjb3JuZXJQb2ludHNbMl07XG4gICAgICAgICAgICBsZXQgdHJBQiA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QSwgcG9pbnRCKTtcbiAgICAgICAgICAgIGxldCB0ckJDID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRCLCBwb2ludEMpO1xuICAgICAgICAgICAgbGV0IHRyQ0QgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEMsIHBvaW50RCk7XG4gICAgICAgICAgICBsZXQgdHJEQSA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50RCwgcG9pbnRBKTtcbiAgICAgICAgICAgIC8vIDAuLjNcbiAgICAgICAgICAgIC8vIDogIDpcbiAgICAgICAgICAgIC8vIDEtLTJcbiAgICAgICAgICAgIGxldCBtaW4gPSB0ckFCO1xuICAgICAgICAgICAgbGV0IHBvaW50cyA9IFtwb2ludEQsIHBvaW50QSwgcG9pbnRCLCBwb2ludENdO1xuICAgICAgICAgICAgaWYgKG1pbiA+IHRyQkMpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSB0ckJDO1xuICAgICAgICAgICAgICAgIHBvaW50c1swXSA9IHBvaW50QTtcbiAgICAgICAgICAgICAgICBwb2ludHNbMV0gPSBwb2ludEI7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzJdID0gcG9pbnRDO1xuICAgICAgICAgICAgICAgIHBvaW50c1szXSA9IHBvaW50RDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaW4gPiB0ckNEKSB7XG4gICAgICAgICAgICAgICAgbWluID0gdHJDRDtcbiAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBwb2ludEI7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzFdID0gcG9pbnRDO1xuICAgICAgICAgICAgICAgIHBvaW50c1syXSA9IHBvaW50RDtcbiAgICAgICAgICAgICAgICBwb2ludHNbM10gPSBwb2ludEE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWluID4gdHJEQSkge1xuICAgICAgICAgICAgICAgIHBvaW50c1swXSA9IHBvaW50QztcbiAgICAgICAgICAgICAgICBwb2ludHNbMV0gPSBwb2ludEQ7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzJdID0gcG9pbnRBO1xuICAgICAgICAgICAgICAgIHBvaW50c1szXSA9IHBvaW50QjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdCBhIHNlY29uZCBzb2xpZCBzaWRlIG5leHQgdG8gZmlyc3Qgc29saWQgc2lkZS5cbiAgICAgICAgICovXG4gICAgICAgIGRldGVjdFNvbGlkMihwb2ludHMpIHtcbiAgICAgICAgICAgIC8vIEEuLkRcbiAgICAgICAgICAgIC8vIDogIDpcbiAgICAgICAgICAgIC8vIEItLUNcbiAgICAgICAgICAgIGxldCBwb2ludEEgPSBwb2ludHNbMF07XG4gICAgICAgICAgICBsZXQgcG9pbnRCID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgbGV0IHBvaW50QyA9IHBvaW50c1syXTtcbiAgICAgICAgICAgIGxldCBwb2ludEQgPSBwb2ludHNbM107XG4gICAgICAgICAgICAvLyBUcmFuc2l0aW9uIGRldGVjdGlvbiBvbiB0aGUgZWRnZSBpcyBub3Qgc3RhYmxlLlxuICAgICAgICAgICAgLy8gVG8gc2FmZWx5IGRldGVjdCwgc2hpZnQgdGhlIHBvaW50cyB0byB0aGUgbW9kdWxlIGNlbnRlci5cbiAgICAgICAgICAgIGxldCB0ciA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QSwgcG9pbnREKTtcbiAgICAgICAgICAgIGxldCBwb2ludEJzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QiwgcG9pbnRDLCAodHIgKyAxKSAqIDQpO1xuICAgICAgICAgICAgbGV0IHBvaW50Q3MgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRDLCBwb2ludEIsICh0ciArIDEpICogNCk7XG4gICAgICAgICAgICBsZXQgdHJCQSA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QnMsIHBvaW50QSk7XG4gICAgICAgICAgICBsZXQgdHJDRCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50Q3MsIHBvaW50RCk7XG4gICAgICAgICAgICAvLyAwLi4zXG4gICAgICAgICAgICAvLyB8ICA6XG4gICAgICAgICAgICAvLyAxLS0yXG4gICAgICAgICAgICBpZiAodHJCQSA8IHRyQ0QpIHtcbiAgICAgICAgICAgICAgICAvLyBzb2xpZCBzaWRlczogQS1CLUNcbiAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBwb2ludEE7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzFdID0gcG9pbnRCO1xuICAgICAgICAgICAgICAgIHBvaW50c1syXSA9IHBvaW50QztcbiAgICAgICAgICAgICAgICBwb2ludHNbM10gPSBwb2ludEQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzb2xpZCBzaWRlczogQi1DLURcbiAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBwb2ludEI7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzFdID0gcG9pbnRDO1xuICAgICAgICAgICAgICAgIHBvaW50c1syXSA9IHBvaW50RDtcbiAgICAgICAgICAgICAgICBwb2ludHNbM10gPSBwb2ludEE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBjb3JuZXIgcG9zaXRpb24gb2YgdGhlIHdoaXRlIHRvcCByaWdodCBtb2R1bGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb3JyZWN0VG9wUmlnaHQocG9pbnRzKSB7XG4gICAgICAgICAgICAvLyBBLi5EXG4gICAgICAgICAgICAvLyB8ICA6XG4gICAgICAgICAgICAvLyBCLS1DXG4gICAgICAgICAgICBsZXQgcG9pbnRBID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgbGV0IHBvaW50QiA9IHBvaW50c1sxXTtcbiAgICAgICAgICAgIGxldCBwb2ludEMgPSBwb2ludHNbMl07XG4gICAgICAgICAgICBsZXQgcG9pbnREID0gcG9pbnRzWzNdO1xuICAgICAgICAgICAgLy8gc2hpZnQgcG9pbnRzIGZvciBzYWZlIHRyYW5zaXRpb24gZGV0ZWN0aW9uLlxuICAgICAgICAgICAgbGV0IHRyVG9wID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBLCBwb2ludEQpO1xuICAgICAgICAgICAgbGV0IHRyUmlnaHQgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEIsIHBvaW50RCk7XG4gICAgICAgICAgICBsZXQgcG9pbnRBcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEEsIHBvaW50QiwgKHRyUmlnaHQgKyAxKSAqIDQpO1xuICAgICAgICAgICAgbGV0IHBvaW50Q3MgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRDLCBwb2ludEIsICh0clRvcCArIDEpICogNCk7XG4gICAgICAgICAgICB0clRvcCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QXMsIHBvaW50RCk7XG4gICAgICAgICAgICB0clJpZ2h0ID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDcywgcG9pbnREKTtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUxID0gbmV3IFJlc3VsdFBvaW50KHBvaW50RC5nZXRYKCkgKyAocG9pbnRDLmdldFgoKSAtIHBvaW50Qi5nZXRYKCkpIC8gKHRyVG9wICsgMSksIHBvaW50RC5nZXRZKCkgKyAocG9pbnRDLmdldFkoKSAtIHBvaW50Qi5nZXRZKCkpIC8gKHRyVG9wICsgMSkpO1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZTIgPSBuZXcgUmVzdWx0UG9pbnQocG9pbnRELmdldFgoKSArIChwb2ludEEuZ2V0WCgpIC0gcG9pbnRCLmdldFgoKSkgLyAodHJSaWdodCArIDEpLCBwb2ludEQuZ2V0WSgpICsgKHBvaW50QS5nZXRZKCkgLSBwb2ludEIuZ2V0WSgpKSAvICh0clJpZ2h0ICsgMSkpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoY2FuZGlkYXRlMSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKGNhbmRpZGF0ZTIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKGNhbmRpZGF0ZTIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3VtYzEgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEFzLCBjYW5kaWRhdGUxKSArIHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50Q3MsIGNhbmRpZGF0ZTEpO1xuICAgICAgICAgICAgbGV0IHN1bWMyID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBcywgY2FuZGlkYXRlMikgKyB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludENzLCBjYW5kaWRhdGUyKTtcbiAgICAgICAgICAgIGlmIChzdW1jMSA+IHN1bWMyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2hpZnQgdGhlIGVkZ2UgcG9pbnRzIHRvIHRoZSBtb2R1bGUgY2VudGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2hpZnRUb01vZHVsZUNlbnRlcihwb2ludHMpIHtcbiAgICAgICAgICAgIC8vIEEuLkRcbiAgICAgICAgICAgIC8vIHwgIDpcbiAgICAgICAgICAgIC8vIEItLUNcbiAgICAgICAgICAgIGxldCBwb2ludEEgPSBwb2ludHNbMF07XG4gICAgICAgICAgICBsZXQgcG9pbnRCID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgbGV0IHBvaW50QyA9IHBvaW50c1syXTtcbiAgICAgICAgICAgIGxldCBwb2ludEQgPSBwb2ludHNbM107XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgcHNldWRvIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIGxldCBkaW1IID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBLCBwb2ludEQpICsgMTtcbiAgICAgICAgICAgIGxldCBkaW1WID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDLCBwb2ludEQpICsgMTtcbiAgICAgICAgICAgIC8vIHNoaWZ0IHBvaW50cyBmb3Igc2FmZSBkaW1lbnNpb24gZGV0ZWN0aW9uXG4gICAgICAgICAgICBsZXQgcG9pbnRBcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEEsIHBvaW50QiwgZGltViAqIDQpO1xuICAgICAgICAgICAgbGV0IHBvaW50Q3MgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRDLCBwb2ludEIsIGRpbUggKiA0KTtcbiAgICAgICAgICAgIC8vICBjYWxjdWxhdGUgbW9yZSBwcmVjaXNlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIGRpbUggPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEFzLCBwb2ludEQpICsgMTtcbiAgICAgICAgICAgIGRpbVYgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludENzLCBwb2ludEQpICsgMTtcbiAgICAgICAgICAgIGlmICgoZGltSCAmIDB4MDEpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGltSCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChkaW1WICYgMHgwMSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkaW1WICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaGl0ZVJlY3RhbmdsZURldGVjdG9yIHJldHVybnMgcG9pbnRzIGluc2lkZSBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAgICAgICAgLy8gSSB3YW50IHBvaW50cyBvbiB0aGUgZWRnZXMuXG4gICAgICAgICAgICBsZXQgY2VudGVyWCA9IChwb2ludEEuZ2V0WCgpICsgcG9pbnRCLmdldFgoKSArIHBvaW50Qy5nZXRYKCkgKyBwb2ludEQuZ2V0WCgpKSAvIDQ7XG4gICAgICAgICAgICBsZXQgY2VudGVyWSA9IChwb2ludEEuZ2V0WSgpICsgcG9pbnRCLmdldFkoKSArIHBvaW50Qy5nZXRZKCkgKyBwb2ludEQuZ2V0WSgpKSAvIDQ7XG4gICAgICAgICAgICBwb2ludEEgPSBEZXRlY3RvciQxLm1vdmVBd2F5KHBvaW50QSwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgICAgICBwb2ludEIgPSBEZXRlY3RvciQxLm1vdmVBd2F5KHBvaW50QiwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgICAgICBwb2ludEMgPSBEZXRlY3RvciQxLm1vdmVBd2F5KHBvaW50QywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgICAgICBwb2ludEQgPSBEZXRlY3RvciQxLm1vdmVBd2F5KHBvaW50RCwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgICAgICBsZXQgcG9pbnRCcztcbiAgICAgICAgICAgIGxldCBwb2ludERzO1xuICAgICAgICAgICAgLy8gc2hpZnQgcG9pbnRzIHRvIHRoZSBjZW50ZXIgb2YgZWFjaCBtb2R1bGVzXG4gICAgICAgICAgICBwb2ludEFzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QSwgcG9pbnRCLCBkaW1WICogNCk7XG4gICAgICAgICAgICBwb2ludEFzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QXMsIHBvaW50RCwgZGltSCAqIDQpO1xuICAgICAgICAgICAgcG9pbnRCcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEIsIHBvaW50QSwgZGltViAqIDQpO1xuICAgICAgICAgICAgcG9pbnRCcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEJzLCBwb2ludEMsIGRpbUggKiA0KTtcbiAgICAgICAgICAgIHBvaW50Q3MgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRDLCBwb2ludEQsIGRpbVYgKiA0KTtcbiAgICAgICAgICAgIHBvaW50Q3MgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRDcywgcG9pbnRCLCBkaW1IICogNCk7XG4gICAgICAgICAgICBwb2ludERzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50RCwgcG9pbnRDLCBkaW1WICogNCk7XG4gICAgICAgICAgICBwb2ludERzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50RHMsIHBvaW50QSwgZGltSCAqIDQpO1xuICAgICAgICAgICAgcmV0dXJuIFtwb2ludEFzLCBwb2ludEJzLCBwb2ludENzLCBwb2ludERzXTtcbiAgICAgICAgfVxuICAgICAgICBpc1ZhbGlkKHApIHtcbiAgICAgICAgICAgIHJldHVybiBwLmdldFgoKSA+PSAwICYmIHAuZ2V0WCgpIDwgdGhpcy5pbWFnZS5nZXRXaWR0aCgpICYmIHAuZ2V0WSgpID4gMCAmJiBwLmdldFkoKSA8IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHNhbXBsZUdyaWQoaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCB0b3BSaWdodCwgZGltZW5zaW9uWCwgZGltZW5zaW9uWSkge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlciA9IEdyaWRTYW1wbGVySW5zdGFuY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVyLnNhbXBsZUdyaWQoaW1hZ2UsIGRpbWVuc2lvblgsIGRpbWVuc2lvblksIDAuNSwgMC41LCBkaW1lbnNpb25YIC0gMC41LCAwLjUsIGRpbWVuc2lvblggLSAwLjUsIGRpbWVuc2lvblkgLSAwLjUsIDAuNSwgZGltZW5zaW9uWSAtIDAuNSwgdG9wTGVmdC5nZXRYKCksIHRvcExlZnQuZ2V0WSgpLCB0b3BSaWdodC5nZXRYKCksIHRvcFJpZ2h0LmdldFkoKSwgYm90dG9tUmlnaHQuZ2V0WCgpLCBib3R0b21SaWdodC5nZXRZKCksIGJvdHRvbUxlZnQuZ2V0WCgpLCBib3R0b21MZWZ0LmdldFkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGJsYWNrL3doaXRlIHRyYW5zaXRpb25zIGJldHdlZW4gdHdvIHBvaW50cywgdXNpbmcgc29tZXRoaW5nIGxpa2UgQnJlc2VuaGFtJ3MgYWxnb3JpdGhtLlxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNpdGlvbnNCZXR3ZWVuKGZyb20sIHRvKSB7XG4gICAgICAgICAgICAvLyBTZWUgUVIgQ29kZSBEZXRlY3Rvciwgc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKClcbiAgICAgICAgICAgIGxldCBmcm9tWCA9IE1hdGgudHJ1bmMoZnJvbS5nZXRYKCkpO1xuICAgICAgICAgICAgbGV0IGZyb21ZID0gTWF0aC50cnVuYyhmcm9tLmdldFkoKSk7XG4gICAgICAgICAgICBsZXQgdG9YID0gTWF0aC50cnVuYyh0by5nZXRYKCkpO1xuICAgICAgICAgICAgbGV0IHRvWSA9IE1hdGgudHJ1bmModG8uZ2V0WSgpKTtcbiAgICAgICAgICAgIGxldCBzdGVlcCA9IE1hdGguYWJzKHRvWSAtIGZyb21ZKSA+IE1hdGguYWJzKHRvWCAtIGZyb21YKTtcbiAgICAgICAgICAgIGlmIChzdGVlcCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gZnJvbVg7XG4gICAgICAgICAgICAgICAgZnJvbVggPSBmcm9tWTtcbiAgICAgICAgICAgICAgICBmcm9tWSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgdGVtcCA9IHRvWDtcbiAgICAgICAgICAgICAgICB0b1ggPSB0b1k7XG4gICAgICAgICAgICAgICAgdG9ZID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkeCA9IE1hdGguYWJzKHRvWCAtIGZyb21YKTtcbiAgICAgICAgICAgIGxldCBkeSA9IE1hdGguYWJzKHRvWSAtIGZyb21ZKTtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IC1keCAvIDI7XG4gICAgICAgICAgICBsZXQgeXN0ZXAgPSBmcm9tWSA8IHRvWSA/IDEgOiAtMTtcbiAgICAgICAgICAgIGxldCB4c3RlcCA9IGZyb21YIDwgdG9YID8gMSA6IC0xO1xuICAgICAgICAgICAgbGV0IHRyYW5zaXRpb25zID0gMDtcbiAgICAgICAgICAgIGxldCBpbkJsYWNrID0gdGhpcy5pbWFnZS5nZXQoc3RlZXAgPyBmcm9tWSA6IGZyb21YLCBzdGVlcCA/IGZyb21YIDogZnJvbVkpO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IGZyb21YLCB5ID0gZnJvbVk7IHggIT09IHRvWDsgeCArPSB4c3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBpc0JsYWNrID0gdGhpcy5pbWFnZS5nZXQoc3RlZXAgPyB5IDogeCwgc3RlZXAgPyB4IDogeSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQmxhY2sgIT09IGluQmxhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbnMrKztcbiAgICAgICAgICAgICAgICAgICAgaW5CbGFjayA9IGlzQmxhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9yICs9IGR5O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPT09IHRvWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeSArPSB5c3RlcDtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgLT0gZHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zaXRpb25zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGNhbiBkZXRlY3QgYW5kIGRlY29kZSBEYXRhIE1hdHJpeCBjb2RlcyBpbiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxuICAgICAqL1xuICAgIGNsYXNzIERhdGFNYXRyaXhSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBEZWNvZGVyJDEoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTG9jYXRlcyBhbmQgZGVjb2RlcyBhIERhdGEgTWF0cml4IGNvZGUgaW4gYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gYSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb250ZW50IGVuY29kZWQgYnkgdGhlIERhdGEgTWF0cml4IGNvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhIERhdGEgTWF0cml4IGNvZGUgY2Fubm90IGJlIGZvdW5kXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgRGF0YSBNYXRyaXggY29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcbiAgICAgICAgICovXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICAvLyBwdWJsaWMgUmVzdWx0IGRlY29kZShCaW5hcnlCaXRtYXAgaW1hZ2UpIHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiwgQ2hlY2tzdW1FeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiB7XG4gICAgICAgIC8vICAgcmV0dXJuIGRlY29kZShpbWFnZSwgbnVsbCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZShpbWFnZSwgaGludHMgPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgZGVjb2RlclJlc3VsdDtcbiAgICAgICAgICAgIGxldCBwb2ludHM7XG4gICAgICAgICAgICBpZiAoaGludHMgIT0gbnVsbCAmJiBoaW50cy5oYXMoRGVjb2RlSGludFR5cGUkMS5QVVJFX0JBUkNPREUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0cyA9IERhdGFNYXRyaXhSZWFkZXIuZXh0cmFjdFB1cmVCaXRzKGltYWdlLmdldEJsYWNrTWF0cml4KCkpO1xuICAgICAgICAgICAgICAgIGRlY29kZXJSZXN1bHQgPSB0aGlzLmRlY29kZXIuZGVjb2RlKGJpdHMpO1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IERhdGFNYXRyaXhSZWFkZXIuTk9fUE9JTlRTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV0ZWN0b3JSZXN1bHQgPSBuZXcgRGV0ZWN0b3IkMShpbWFnZS5nZXRCbGFja01hdHJpeCgpKS5kZXRlY3QoKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gdGhpcy5kZWNvZGVyLmRlY29kZShkZXRlY3RvclJlc3VsdC5nZXRCaXRzKCkpO1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IGRldGVjdG9yUmVzdWx0LmdldFBvaW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3Qnl0ZXMgPSBkZWNvZGVyUmVzdWx0LmdldFJhd0J5dGVzKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUmVzdWx0KGRlY29kZXJSZXN1bHQuZ2V0VGV4dCgpLCByYXdCeXRlcywgOCAqIHJhd0J5dGVzLmxlbmd0aCwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0JDEuREFUQV9NQVRSSVgsIFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVTZWdtZW50cyA9IGRlY29kZXJSZXN1bHQuZ2V0Qnl0ZVNlZ21lbnRzKCk7XG4gICAgICAgICAgICBpZiAoYnl0ZVNlZ21lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuQllURV9TRUdNRU5UUywgYnl0ZVNlZ21lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVjTGV2ZWwgPSBkZWNvZGVyUmVzdWx0LmdldEVDTGV2ZWwoKTtcbiAgICAgICAgICAgIGlmIChlY0xldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuRVJST1JfQ09SUkVDVElPTl9MRVZFTCwgZWNMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgZGV0ZWN0cyBhIGNvZGUgaW4gYSBcInB1cmVcIiBpbWFnZSAtLSB0aGF0IGlzLCBwdXJlIG1vbm9jaHJvbWUgaW1hZ2VcbiAgICAgICAgICogd2hpY2ggY29udGFpbnMgb25seSBhbiB1bnJvdGF0ZWQsIHVuc2tld2VkLCBpbWFnZSBvZiBhIGNvZGUsIHdpdGggc29tZSB3aGl0ZSBib3JkZXJcbiAgICAgICAgICogYXJvdW5kIGl0LiBUaGlzIGlzIGEgc3BlY2lhbGl6ZWQgbWV0aG9kIHRoYXQgd29ya3MgZXhjZXB0aW9uYWxseSBmYXN0IGluIHRoaXMgc3BlY2lhbFxuICAgICAgICAgKiBjYXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2VlIGNvbS5nb29nbGUuenhpbmcucXJjb2RlLlFSQ29kZVJlYWRlciNleHRyYWN0UHVyZUJpdHMoQml0TWF0cml4KVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGV4dHJhY3RQdXJlQml0cyhpbWFnZSkge1xuICAgICAgICAgICAgY29uc3QgbGVmdFRvcEJsYWNrID0gaW1hZ2UuZ2V0VG9wTGVmdE9uQml0KCk7XG4gICAgICAgICAgICBjb25zdCByaWdodEJvdHRvbUJsYWNrID0gaW1hZ2UuZ2V0Qm90dG9tUmlnaHRPbkJpdCgpO1xuICAgICAgICAgICAgaWYgKGxlZnRUb3BCbGFjayA9PSBudWxsIHx8IHJpZ2h0Qm90dG9tQmxhY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kdWxlU2l6ZSA9IHRoaXMubW9kdWxlU2l6ZShsZWZ0VG9wQmxhY2ssIGltYWdlKTtcbiAgICAgICAgICAgIGxldCB0b3AgPSBsZWZ0VG9wQmxhY2tbMV07XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSByaWdodEJvdHRvbUJsYWNrWzFdO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSBsZWZ0VG9wQmxhY2tbMF07XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHJpZ2h0Qm90dG9tQmxhY2tbMF07XG4gICAgICAgICAgICBjb25zdCBtYXRyaXhXaWR0aCA9IChyaWdodCAtIGxlZnQgKyAxKSAvIG1vZHVsZVNpemU7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXhIZWlnaHQgPSAoYm90dG9tIC0gdG9wICsgMSkgLyBtb2R1bGVTaXplO1xuICAgICAgICAgICAgaWYgKG1hdHJpeFdpZHRoIDw9IDAgfHwgbWF0cml4SGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFB1c2ggaW4gdGhlIFwiYm9yZGVyXCIgYnkgaGFsZiB0aGUgbW9kdWxlIHdpZHRoIHNvIHRoYXQgd2Ugc3RhcnRcbiAgICAgICAgICAgIC8vIHNhbXBsaW5nIGluIHRoZSBtaWRkbGUgb2YgdGhlIG1vZHVsZS4gSnVzdCBpbiBjYXNlIHRoZSBpbWFnZSBpcyBhXG4gICAgICAgICAgICAvLyBsaXR0bGUgb2ZmLCB0aGlzIHdpbGwgaGVscCByZWNvdmVyLlxuICAgICAgICAgICAgY29uc3QgbnVkZ2UgPSBtb2R1bGVTaXplIC8gMjtcbiAgICAgICAgICAgIHRvcCArPSBudWRnZTtcbiAgICAgICAgICAgIGxlZnQgKz0gbnVkZ2U7XG4gICAgICAgICAgICAvLyBOb3cganVzdCByZWFkIG9mZiB0aGUgYml0c1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IG5ldyBCaXRNYXRyaXgobWF0cml4V2lkdGgsIG1hdHJpeEhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG1hdHJpeEhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaU9mZnNldCA9IHRvcCArIHkgKiBtb2R1bGVTaXplO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbWF0cml4V2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGxlZnQgKyB4ICogbW9kdWxlU2l6ZSwgaU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMuc2V0KHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG1vZHVsZVNpemUobGVmdFRvcEJsYWNrLCBpbWFnZSkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgbGV0IHggPSBsZWZ0VG9wQmxhY2tbMF07XG4gICAgICAgICAgICBjb25zdCB5ID0gbGVmdFRvcEJsYWNrWzFdO1xuICAgICAgICAgICAgd2hpbGUgKHggPCB3aWR0aCAmJiBpbWFnZS5nZXQoeCwgeSkpIHtcbiAgICAgICAgICAgICAgICB4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA9PT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemUgPSB4IC0gbGVmdFRvcEJsYWNrWzBdO1xuICAgICAgICAgICAgaWYgKG1vZHVsZVNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIERhdGFNYXRyaXhSZWFkZXIuTk9fUE9JTlRTID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBNb3ZpbmcgdG8gQHp4aW5nL2Jyb3dzZXJcbiAgICAgKlxuICAgICAqIFFSIENvZGUgcmVhZGVyIHRvIHVzZSBmcm9tIGJyb3dzZXIuXG4gICAgICovXG4gICAgY2xhc3MgQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyIGV4dGVuZHMgQnJvd3NlckNvZGVSZWFkZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCcm93c2VyUVJDb2RlUmVhZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVCZXR3ZWVuU2NhbnNNaWxsaXM9NTAwXSB0aGUgdGltZSBkZWxheSBiZXR3ZWVuIHN1YnNlcXVlbnQgZGVjb2RlIHRyaWVzXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcih0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwKSB7XG4gICAgICAgICAgICBzdXBlcihuZXcgRGF0YU1hdHJpeFJlYWRlcigpLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgdmFyIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzO1xuICAgIChmdW5jdGlvbiAoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMpIHtcbiAgICAgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbXCJMXCJdID0gMF0gPSBcIkxcIjtcbiAgICAgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbXCJNXCJdID0gMV0gPSBcIk1cIjtcbiAgICAgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbXCJRXCJdID0gMl0gPSBcIlFcIjtcbiAgICAgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbXCJIXCJdID0gM10gPSBcIkhcIjtcbiAgICB9KShFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcyB8fCAoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIDxwPlNlZSBJU08gMTgwMDQ6MjAwNiwgNi41LjEuIFRoaXMgZW51bSBlbmNhcHN1bGF0ZXMgdGhlIGZvdXIgZXJyb3IgY29ycmVjdGlvbiBsZXZlbHNcbiAgICAgKiBkZWZpbmVkIGJ5IHRoZSBRUiBjb2RlIHN0YW5kYXJkLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRXJyb3JDb3JyZWN0aW9uTGV2ZWwge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc3RyaW5nVmFsdWUsIGJpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9CSVRTLnNldChiaXRzLCB0aGlzKTtcbiAgICAgICAgICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9WQUxVRS5zZXQodmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qml0cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21TdHJpbmcocykge1xuICAgICAgICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTCc6IHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbC5MO1xuICAgICAgICAgICAgICAgIGNhc2UgJ00nOiByZXR1cm4gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuTTtcbiAgICAgICAgICAgICAgICBjYXNlICdRJzogcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLlE7XG4gICAgICAgICAgICAgICAgY2FzZSAnSCc6IHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbC5IO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihzICsgJ25vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgRXJyb3JDb3JyZWN0aW9uTGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IG90aGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYml0cyBpbnQgY29udGFpbmluZyB0aGUgdHdvIGJpdHMgZW5jb2RpbmcgYSBRUiBDb2RlJ3MgZXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICAgICAgICAgKiBAcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsIHJlcHJlc2VudGluZyB0aGUgZW5jb2RlZCBlcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZm9yQml0cyhiaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChiaXRzIDwgMCB8fCBiaXRzID49IEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9CSVRTLnNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuRk9SX0JJVFMuZ2V0KGJpdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9CSVRTID0gbmV3IE1hcCgpO1xuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9WQUxVRSA9IG5ldyBNYXAoKTtcbiAgICAvKiogTCA9IH43JSBjb3JyZWN0aW9uICovXG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuTCA9IG5ldyBFcnJvckNvcnJlY3Rpb25MZXZlbChFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcy5MLCAnTCcsIDB4MDEpO1xuICAgIC8qKiBNID0gfjE1JSBjb3JyZWN0aW9uICovXG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuTSA9IG5ldyBFcnJvckNvcnJlY3Rpb25MZXZlbChFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcy5NLCAnTScsIDB4MDApO1xuICAgIC8qKiBRID0gfjI1JSBjb3JyZWN0aW9uICovXG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuUSA9IG5ldyBFcnJvckNvcnJlY3Rpb25MZXZlbChFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcy5RLCAnUScsIDB4MDMpO1xuICAgIC8qKiBIID0gfjMwJSBjb3JyZWN0aW9uICovXG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuSCA9IG5ldyBFcnJvckNvcnJlY3Rpb25MZXZlbChFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcy5ILCAnSCcsIDB4MDIpO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgYSBRUiBDb2RlJ3MgZm9ybWF0IGluZm9ybWF0aW9uLCBpbmNsdWRpbmcgdGhlIGRhdGEgbWFzayB1c2VkIGFuZFxuICAgICAqIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAc2VlIERhdGFNYXNrXG4gICAgICogQHNlZSBFcnJvckNvcnJlY3Rpb25MZXZlbFxuICAgICAqL1xuICAgIGNsYXNzIEZvcm1hdEluZm9ybWF0aW9uIHtcbiAgICAgICAgY29uc3RydWN0b3IoZm9ybWF0SW5mbyAvKmludCovKSB7XG4gICAgICAgICAgICAvLyBCaXRzIDMsNFxuICAgICAgICAgICAgdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsLmZvckJpdHMoKGZvcm1hdEluZm8gPj4gMykgJiAweDAzKTtcbiAgICAgICAgICAgIC8vIEJvdHRvbSAzIGJpdHNcbiAgICAgICAgICAgIHRoaXMuZGF0YU1hc2sgPSAvKihieXRlKSAqLyAoZm9ybWF0SW5mbyAmIDB4MDcpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBudW1CaXRzRGlmZmVyaW5nKGEgLyppbnQqLywgYiAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlci5iaXRDb3VudChhIF4gYik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBtYXNrZWRGb3JtYXRJbmZvMSBmb3JtYXQgaW5mbyBpbmRpY2F0b3IsIHdpdGggbWFzayBzdGlsbCBhcHBsaWVkXG4gICAgICAgICAqIEBwYXJhbSBtYXNrZWRGb3JtYXRJbmZvMiBzZWNvbmQgY29weSBvZiBzYW1lIGluZm87IGJvdGggYXJlIGNoZWNrZWQgYXQgdGhlIHNhbWUgdGltZVxuICAgICAgICAgKiAgdG8gZXN0YWJsaXNoIGJlc3QgbWF0Y2hcbiAgICAgICAgICogQHJldHVybiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZm9ybWF0IGl0IHNwZWNpZmllcywgb3Ige0Bjb2RlIG51bGx9XG4gICAgICAgICAqICBpZiBkb2Vzbid0IHNlZW0gdG8gbWF0Y2ggYW55IGtub3duIHBhdHRlcm5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihtYXNrZWRGb3JtYXRJbmZvMSAvKmludCovLCBtYXNrZWRGb3JtYXRJbmZvMiAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRJbmZvID0gRm9ybWF0SW5mb3JtYXRpb24uZG9EZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihtYXNrZWRGb3JtYXRJbmZvMSwgbWFza2VkRm9ybWF0SW5mbzIpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdEluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0SW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNob3VsZCByZXR1cm4gbnVsbCwgYnV0LCBzb21lIFFSIGNvZGVzIGFwcGFyZW50bHlcbiAgICAgICAgICAgIC8vIGRvIG5vdCBtYXNrIHRoaXMgaW5mby4gVHJ5IGFnYWluIGJ5IGFjdHVhbGx5IG1hc2tpbmcgdGhlIHBhdHRlcm5cbiAgICAgICAgICAgIC8vIGZpcnN0XG4gICAgICAgICAgICByZXR1cm4gRm9ybWF0SW5mb3JtYXRpb24uZG9EZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihtYXNrZWRGb3JtYXRJbmZvMSBeIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX01BU0tfUVIsIG1hc2tlZEZvcm1hdEluZm8yIF4gRm9ybWF0SW5mb3JtYXRpb24uRk9STUFUX0lORk9fTUFTS19RUik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRvRGVjb2RlRm9ybWF0SW5mb3JtYXRpb24obWFza2VkRm9ybWF0SW5mbzEgLyppbnQqLywgbWFza2VkRm9ybWF0SW5mbzIgLyppbnQqLykge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgaW50IGluIEZPUk1BVF9JTkZPX0RFQ09ERV9MT09LVVAgd2l0aCBmZXdlc3QgYml0cyBkaWZmZXJpbmdcbiAgICAgICAgICAgIGxldCBiZXN0RGlmZmVyZW5jZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgbGV0IGJlc3RGb3JtYXRJbmZvID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVjb2RlSW5mbyBvZiBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19ERUNPREVfTE9PS1VQKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0SW5mbyA9IGRlY29kZUluZm9bMF07XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEluZm8gPT09IG1hc2tlZEZvcm1hdEluZm8xIHx8IHRhcmdldEluZm8gPT09IG1hc2tlZEZvcm1hdEluZm8yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGFuIGV4YWN0IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0SW5mb3JtYXRpb24oZGVjb2RlSW5mb1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBiaXRzRGlmZmVyZW5jZSA9IEZvcm1hdEluZm9ybWF0aW9uLm51bUJpdHNEaWZmZXJpbmcobWFza2VkRm9ybWF0SW5mbzEsIHRhcmdldEluZm8pO1xuICAgICAgICAgICAgICAgIGlmIChiaXRzRGlmZmVyZW5jZSA8IGJlc3REaWZmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RGb3JtYXRJbmZvID0gZGVjb2RlSW5mb1sxXTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdERpZmZlcmVuY2UgPSBiaXRzRGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hc2tlZEZvcm1hdEluZm8xICE9PSBtYXNrZWRGb3JtYXRJbmZvMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIHRyeSB0aGUgb3RoZXIgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGJpdHNEaWZmZXJlbmNlID0gRm9ybWF0SW5mb3JtYXRpb24ubnVtQml0c0RpZmZlcmluZyhtYXNrZWRGb3JtYXRJbmZvMiwgdGFyZ2V0SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXRzRGlmZmVyZW5jZSA8IGJlc3REaWZmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0Rm9ybWF0SW5mbyA9IGRlY29kZUluZm9bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0RGlmZmVyZW5jZSA9IGJpdHNEaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFtbWluZyBkaXN0YW5jZSBvZiB0aGUgMzIgbWFza2VkIGNvZGVzIGlzIDcsIGJ5IGNvbnN0cnVjdGlvbiwgc28gPD0gMyBiaXRzXG4gICAgICAgICAgICAvLyBkaWZmZXJpbmcgbWVhbnMgd2UgZm91bmQgYSBtYXRjaFxuICAgICAgICAgICAgaWYgKGJlc3REaWZmZXJlbmNlIDw9IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEluZm9ybWF0aW9uKGJlc3RGb3JtYXRJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGdldEVycm9yQ29ycmVjdGlvbkxldmVsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGF0YU1hc2soKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhTWFzaztcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGhhc2hDb2RlKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsLmdldEJpdHMoKSA8PCAzKSB8IHRoaXMuZGF0YU1hc2s7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBlcXVhbHMobykge1xuICAgICAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIEZvcm1hdEluZm9ybWF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0gbztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsID09PSBvdGhlci5lcnJvckNvcnJlY3Rpb25MZXZlbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YU1hc2sgPT09IG90aGVyLmRhdGFNYXNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX01BU0tfUVIgPSAweDU0MTI7XG4gICAgLyoqXG4gICAgICogU2VlIElTTyAxODAwNDoyMDA2LCBBbm5leCBDLCBUYWJsZSBDLjFcbiAgICAgKi9cbiAgICBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19ERUNPREVfTE9PS1VQID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NTQxMiwgMHgwMF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NTEyNSwgMHgwMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NUU3QywgMHgwMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NUI0QiwgMHgwM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NDVGOSwgMHgwNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NDBDRSwgMHgwNV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NEY5NywgMHgwNl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NEFBMCwgMHgwN10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NzdDNCwgMHgwOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NzJGMywgMHgwOV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4N0RBQSwgMHgwQV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4Nzg5RCwgMHgwQl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NjYyRiwgMHgwQ10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NjMxOCwgMHgwRF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NkM0MSwgMHgwRV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4Njk3NiwgMHgwRl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MTY4OSwgMHgxMF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MTNCRSwgMHgxMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MUNFNywgMHgxMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MTlEMCwgMHgxM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MDc2MiwgMHgxNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MDI1NSwgMHgxNV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MEQwQywgMHgxNl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MDgzQiwgMHgxN10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MzU1RiwgMHgxOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MzA2OCwgMHgxOV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4M0YzMSwgMHgxQV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4M0EwNiwgMHgxQl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MjRCNCwgMHgxQ10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MjE4MywgMHgxRF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MkVEQSwgMHgxRV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MkJFRCwgMHgxRl0pLFxuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgYSBzZXQgb2YgZXJyb3ItY29ycmVjdGlvbiBibG9ja3MgaW4gb25lIHN5bWJvbCB2ZXJzaW9uLiBNb3N0IHZlcnNpb25zIHdpbGxcbiAgICAgKiB1c2UgYmxvY2tzIG9mIGRpZmZlcmluZyBzaXplcyB3aXRoaW4gb25lIHZlcnNpb24sIHNvLCB0aGlzIGVuY2Fwc3VsYXRlcyB0aGUgcGFyYW1ldGVycyBmb3JcbiAgICAgKiBlYWNoIHNldCBvZiBibG9ja3MuIEl0IGFsc28gaG9sZHMgdGhlIG51bWJlciBvZiBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyBwZXIgYmxvY2sgc2luY2UgaXRcbiAgICAgKiB3aWxsIGJlIHRoZSBzYW1lIGFjcm9zcyBhbGwgYmxvY2tzIHdpdGhpbiBvbmUgdmVyc2lvbi48L3A+XG4gICAgICovXG4gICAgY2xhc3MgRUNCbG9ja3MkMSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGVjQ29kZXdvcmRzUGVyQmxvY2sgLyppbnQqLywgLi4uZWNCbG9ja3MpIHtcbiAgICAgICAgICAgIHRoaXMuZWNDb2Rld29yZHNQZXJCbG9jayA9IGVjQ29kZXdvcmRzUGVyQmxvY2s7XG4gICAgICAgICAgICB0aGlzLmVjQmxvY2tzID0gZWNCbG9ja3M7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RUNDb2Rld29yZHNQZXJCbG9jaygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjQ29kZXdvcmRzUGVyQmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TnVtQmxvY2tzKCkge1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVjQmxvY2tzID0gdGhpcy5lY0Jsb2NrcztcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWNCbG9jayBvZiBlY0Jsb2Nrcykge1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGVjQmxvY2suZ2V0Q291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgICBnZXRUb3RhbEVDQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNDb2Rld29yZHNQZXJCbG9jayAqIHRoaXMuZ2V0TnVtQmxvY2tzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RUNCbG9ja3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lY0Jsb2NrcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyB0aGUgcGFyYW1ldGVycyBmb3Igb25lIGVycm9yLWNvcnJlY3Rpb24gYmxvY2sgaW4gb25lIHN5bWJvbCB2ZXJzaW9uLlxuICAgICAqIFRoaXMgaW5jbHVkZXMgdGhlIG51bWJlciBvZiBkYXRhIGNvZGV3b3JkcywgYW5kIHRoZSBudW1iZXIgb2YgdGltZXMgYSBibG9jayB3aXRoIHRoZXNlXG4gICAgICogcGFyYW1ldGVycyBpcyB1c2VkIGNvbnNlY3V0aXZlbHkgaW4gdGhlIFFSIGNvZGUgdmVyc2lvbidzIGZvcm1hdC48L3A+XG4gICAgICovXG4gICAgY2xhc3MgRUNCJDEge1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb3VudCAvKmludCovLCBkYXRhQ29kZXdvcmRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNvZGV3b3JkcyA9IGRhdGFDb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXREYXRhQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU2VlIElTTyAxODAwNDoyMDA2IEFubmV4IERcbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgVmVyc2lvbiQxIHtcbiAgICAgICAgY29uc3RydWN0b3IodmVyc2lvbk51bWJlciAvKmludCovLCBhbGlnbm1lbnRQYXR0ZXJuQ2VudGVycywgLi4uZWNCbG9ja3MpIHtcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbk51bWJlciA9IHZlcnNpb25OdW1iZXI7XG4gICAgICAgICAgICB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzID0gYWxpZ25tZW50UGF0dGVybkNlbnRlcnM7XG4gICAgICAgICAgICB0aGlzLmVjQmxvY2tzID0gZWNCbG9ja3M7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICAgICAgY29uc3QgZWNDb2Rld29yZHMgPSBlY0Jsb2Nrc1swXS5nZXRFQ0NvZGV3b3Jkc1BlckJsb2NrKCk7XG4gICAgICAgICAgICBjb25zdCBlY2JBcnJheSA9IGVjQmxvY2tzWzBdLmdldEVDQmxvY2tzKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVjQmxvY2sgb2YgZWNiQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBlY0Jsb2NrLmdldENvdW50KCkgKiAoZWNCbG9jay5nZXREYXRhQ29kZXdvcmRzKCkgKyBlY0NvZGV3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRvdGFsQ29kZXdvcmRzID0gdG90YWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmVyc2lvbk51bWJlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnNpb25OdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QWxpZ25tZW50UGF0dGVybkNlbnRlcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVycztcbiAgICAgICAgfVxuICAgICAgICBnZXRUb3RhbENvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsQ29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIGdldERpbWVuc2lvbkZvclZlcnNpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gMTcgKyA0ICogdGhpcy52ZXJzaW9uTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGdldEVDQmxvY2tzRm9yTGV2ZWwoZWNMZXZlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNCbG9ja3NbZWNMZXZlbC5nZXRWYWx1ZSgpXTtcbiAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBvcmlnaW5hbCB3YXMgdXNpbmcgb3JkaW5hbCwgYW5kIHVzaW5nIHRoZSBvcmRlciBvZiBsZXZlbHMgYXMgZGVmaW5lZCBpbiBFcnJvckNvcnJlY3Rpb25MZXZlbCBlbnVtIChMTVFIKVxuICAgICAgICAgICAgLy8gSSB3aWxsIHVzZSB0aGUgZGlyZWN0IHZhbHVlIGZyb20gRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMgZW51bSB3aGljaCBpbiB0eXBlc2NyaXB0IGdvZXMgdG8gYSBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGVkdWNlcyB2ZXJzaW9uIGluZm9ybWF0aW9uIHB1cmVseSBmcm9tIFFSIENvZGUgZGltZW5zaW9ucy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkaW1lbnNpb24gZGltZW5zaW9uIGluIG1vZHVsZXNcbiAgICAgICAgICogQHJldHVybiBWZXJzaW9uIGZvciBhIFFSIENvZGUgb2YgdGhhdCBkaW1lbnNpb25cbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgZGltZW5zaW9uIGlzIG5vdCAxIG1vZCA0XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0UHJvdmlzaW9uYWxWZXJzaW9uRm9yRGltZW5zaW9uKGRpbWVuc2lvbiAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uICUgNCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmVyc2lvbkZvck51bWJlcigoZGltZW5zaW9uIC0gMTcpIC8gNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldFZlcnNpb25Gb3JOdW1iZXIodmVyc2lvbk51bWJlciAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAodmVyc2lvbk51bWJlciA8IDEgfHwgdmVyc2lvbk51bWJlciA+IDQwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFZlcnNpb24kMS5WRVJTSU9OU1t2ZXJzaW9uTnVtYmVyIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlY29kZVZlcnNpb25JbmZvcm1hdGlvbih2ZXJzaW9uQml0cyAvKmludCovKSB7XG4gICAgICAgICAgICBsZXQgYmVzdERpZmZlcmVuY2UgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgIGxldCBiZXN0VmVyc2lvbiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFZlcnNpb24kMS5WRVJTSU9OX0RFQ09ERV9JTkZPLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmVyc2lvbiA9IFZlcnNpb24kMS5WRVJTSU9OX0RFQ09ERV9JTkZPW2ldO1xuICAgICAgICAgICAgICAgIC8vIERvIHRoZSB2ZXJzaW9uIGluZm8gYml0cyBtYXRjaCBleGFjdGx5PyBkb25lLlxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRWZXJzaW9uID09PSB2ZXJzaW9uQml0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmVyc2lvbiQxLmdldFZlcnNpb25Gb3JOdW1iZXIoaSArIDcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugc2VlIGlmIHRoaXMgaXMgdGhlIGNsb3Nlc3QgdG8gYSByZWFsIHZlcnNpb24gaW5mbyBiaXQgc3RyaW5nXG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBzZWVuIHNvIGZhclxuICAgICAgICAgICAgICAgIGNvbnN0IGJpdHNEaWZmZXJlbmNlID0gRm9ybWF0SW5mb3JtYXRpb24ubnVtQml0c0RpZmZlcmluZyh2ZXJzaW9uQml0cywgdGFyZ2V0VmVyc2lvbik7XG4gICAgICAgICAgICAgICAgaWYgKGJpdHNEaWZmZXJlbmNlIDwgYmVzdERpZmZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFZlcnNpb24gPSBpICsgNztcbiAgICAgICAgICAgICAgICAgICAgYmVzdERpZmZlcmVuY2UgPSBiaXRzRGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBjYW4gdG9sZXJhdGUgdXAgdG8gMyBiaXRzIG9mIGVycm9yIHNpbmNlIG5vIHR3byB2ZXJzaW9uIGluZm8gY29kZXdvcmRzIHdpbGxcbiAgICAgICAgICAgIC8vIGRpZmZlciBpbiBsZXNzIHRoYW4gOCBiaXRzLlxuICAgICAgICAgICAgaWYgKGJlc3REaWZmZXJlbmNlIDw9IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVyc2lvbiQxLmdldFZlcnNpb25Gb3JOdW1iZXIoYmVzdFZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYSBjbG9zZSBlbm91Z2ggbWF0Y2gsIGZhaWxcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYgQW5uZXggRVxuICAgICAgICAgKi9cbiAgICAgICAgYnVpbGRGdW5jdGlvblBhdHRlcm4oKSB7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmdldERpbWVuc2lvbkZvclZlcnNpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGJpdE1hdHJpeCA9IG5ldyBCaXRNYXRyaXgoZGltZW5zaW9uKTtcbiAgICAgICAgICAgIC8vIFRvcCBsZWZ0IGZpbmRlciBwYXR0ZXJuICsgc2VwYXJhdG9yICsgZm9ybWF0XG4gICAgICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKDAsIDAsIDksIDkpO1xuICAgICAgICAgICAgLy8gVG9wIHJpZ2h0IGZpbmRlciBwYXR0ZXJuICsgc2VwYXJhdG9yICsgZm9ybWF0XG4gICAgICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKGRpbWVuc2lvbiAtIDgsIDAsIDgsIDkpO1xuICAgICAgICAgICAgLy8gQm90dG9tIGxlZnQgZmluZGVyIHBhdHRlcm4gKyBzZXBhcmF0b3IgKyBmb3JtYXRcbiAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oMCwgZGltZW5zaW9uIC0gOCwgOSwgOCk7XG4gICAgICAgICAgICAvLyBBbGlnbm1lbnQgcGF0dGVybnNcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHRoaXMuYWxpZ25tZW50UGF0dGVybkNlbnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBtYXg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzW3hdIC0gMjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG1heDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoeCA9PT0gMCAmJiAoeSA9PT0gMCB8fCB5ID09PSBtYXggLSAxKSkgfHwgKHggPT09IG1heCAtIDEgJiYgeSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGFsaWdubWVudCBwYXR0ZXJucyBuZWFyIHRoZSB0aHJlZSBmaW5kZXIgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24odGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVyc1t5XSAtIDIsIGksIDUsIDUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZlcnRpY2FsIHRpbWluZyBwYXR0ZXJuXG4gICAgICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKDYsIDksIDEsIGRpbWVuc2lvbiAtIDE3KTtcbiAgICAgICAgICAgIC8vIEhvcml6b250YWwgdGltaW5nIHBhdHRlcm5cbiAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oOSwgNiwgZGltZW5zaW9uIC0gMTcsIDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMudmVyc2lvbk51bWJlciA+IDYpIHtcbiAgICAgICAgICAgICAgICAvLyBWZXJzaW9uIGluZm8sIHRvcCByaWdodFxuICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oZGltZW5zaW9uIC0gMTEsIDAsIDMsIDYpO1xuICAgICAgICAgICAgICAgIC8vIFZlcnNpb24gaW5mbywgYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKDAsIGRpbWVuc2lvbiAtIDExLCA2LCAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaXRNYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIHRoaXMudmVyc2lvbk51bWJlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgICAqIFNlZSBJU08gMTgwMDQ6MjAwNiBBbm5leCBELlxuICAgICAgICogRWxlbWVudCBpIHJlcHJlc2VudHMgdGhlIHJhdyB2ZXJzaW9uIGJpdHMgdGhhdCBzcGVjaWZ5IHZlcnNpb24gaSArIDdcbiAgICAgICAqL1xuICAgIFZlcnNpb24kMS5WRVJTSU9OX0RFQ09ERV9JTkZPID0gSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgMHgwN0M5NCwgMHgwODVCQywgMHgwOUE5OSwgMHgwQTREMywgMHgwQkJGNixcbiAgICAgICAgMHgwQzc2MiwgMHgwRDg0NywgMHgwRTYwRCwgMHgwRjkyOCwgMHgxMEI3OCxcbiAgICAgICAgMHgxMTQ1RCwgMHgxMkExNywgMHgxMzUzMiwgMHgxNDlBNiwgMHgxNTY4MyxcbiAgICAgICAgMHgxNjhDOSwgMHgxNzdFQywgMHgxOEVDNCwgMHgxOTFFMSwgMHgxQUZBQixcbiAgICAgICAgMHgxQjA4RSwgMHgxQ0MxQSwgMHgxRDMzRiwgMHgxRUQ3NSwgMHgxRjI1MCxcbiAgICAgICAgMHgyMDlENSwgMHgyMTZGMCwgMHgyMjhCQSwgMHgyMzc5RiwgMHgyNEIwQixcbiAgICAgICAgMHgyNTQyRSwgMHgyNkE2NCwgMHgyNzU0MSwgMHgyOEM2OVxuICAgIF0pO1xuICAgIC8qKlxuICAgICAgICogU2VlIElTTyAxODAwNDoyMDA2IDYuNS4xIFRhYmxlIDlcbiAgICAgICAqL1xuICAgIFZlcnNpb24kMS5WRVJTSU9OUyA9IFtcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxLCBuZXcgSW50MzJBcnJheSgwKSwgbmV3IEVDQmxvY2tzJDEoNywgbmV3IEVDQiQxKDEsIDE5KSksIG5ldyBFQ0Jsb2NrcyQxKDEwLCBuZXcgRUNCJDEoMSwgMTYpKSwgbmV3IEVDQmxvY2tzJDEoMTMsIG5ldyBFQ0IkMSgxLCAxMykpLCBuZXcgRUNCbG9ja3MkMSgxNywgbmV3IEVDQiQxKDEsIDkpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMiwgSW50MzJBcnJheS5mcm9tKFs2LCAxOF0pLCBuZXcgRUNCbG9ja3MkMSgxMCwgbmV3IEVDQiQxKDEsIDM0KSksIG5ldyBFQ0Jsb2NrcyQxKDE2LCBuZXcgRUNCJDEoMSwgMjgpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSgxLCAyMikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDEsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDMsIEludDMyQXJyYXkuZnJvbShbNiwgMjJdKSwgbmV3IEVDQmxvY2tzJDEoMTUsIG5ldyBFQ0IkMSgxLCA1NSkpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDEsIDQ0KSksIG5ldyBFQ0Jsb2NrcyQxKDE4LCBuZXcgRUNCJDEoMiwgMTcpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSgyLCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSg0LCBJbnQzMkFycmF5LmZyb20oWzYsIDI2XSksIG5ldyBFQ0Jsb2NrcyQxKDIwLCBuZXcgRUNCJDEoMSwgODApKSwgbmV3IEVDQmxvY2tzJDEoMTgsIG5ldyBFQ0IkMSgyLCAzMikpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDIsIDI0KSksIG5ldyBFQ0Jsb2NrcyQxKDE2LCBuZXcgRUNCJDEoNCwgOSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSg1LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwXSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoMSwgMTA4KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoMiwgNDMpKSwgbmV3IEVDQmxvY2tzJDEoMTgsIG5ldyBFQ0IkMSgyLCAxNSksIG5ldyBFQ0IkMSgyLCAxNikpLCBuZXcgRUNCbG9ja3MkMSgyMiwgbmV3IEVDQiQxKDIsIDExKSwgbmV3IEVDQiQxKDIsIDEyKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDYsIEludDMyQXJyYXkuZnJvbShbNiwgMzRdKSwgbmV3IEVDQmxvY2tzJDEoMTgsIG5ldyBFQ0IkMSgyLCA2OCkpLCBuZXcgRUNCbG9ja3MkMSgxNiwgbmV3IEVDQiQxKDQsIDI3KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoNCwgMTkpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg0LCAxNSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSg3LCBJbnQzMkFycmF5LmZyb20oWzYsIDIyLCAzOF0pLCBuZXcgRUNCbG9ja3MkMSgyMCwgbmV3IEVDQiQxKDIsIDc4KSksIG5ldyBFQ0Jsb2NrcyQxKDE4LCBuZXcgRUNCJDEoNCwgMzEpKSwgbmV3IEVDQmxvY2tzJDEoMTgsIG5ldyBFQ0IkMSgyLCAxNCksIG5ldyBFQ0IkMSg0LCAxNSkpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDQsIDEzKSwgbmV3IEVDQiQxKDEsIDE0KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDgsIEludDMyQXJyYXkuZnJvbShbNiwgMjQsIDQyXSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoMiwgOTcpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSgyLCAzOCksIG5ldyBFQ0IkMSgyLCAzOSkpLCBuZXcgRUNCbG9ja3MkMSgyMiwgbmV3IEVDQiQxKDQsIDE4KSwgbmV3IEVDQiQxKDIsIDE5KSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoNCwgMTQpLCBuZXcgRUNCJDEoMiwgMTUpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoOSwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNDZdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyLCAxMTYpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSgzLCAzNiksIG5ldyBFQ0IkMSgyLCAzNykpLCBuZXcgRUNCbG9ja3MkMSgyMCwgbmV3IEVDQiQxKDQsIDE2KSwgbmV3IEVDQiQxKDQsIDE3KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoNCwgMTIpLCBuZXcgRUNCJDEoNCwgMTMpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTAsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDUwXSksIG5ldyBFQ0Jsb2NrcyQxKDE4LCBuZXcgRUNCJDEoMiwgNjgpLCBuZXcgRUNCJDEoMiwgNjkpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSg0LCA0MyksIG5ldyBFQ0IkMSgxLCA0NCkpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDYsIDE5KSwgbmV3IEVDQiQxKDIsIDIwKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNiwgMTUpLCBuZXcgRUNCJDEoMiwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTEsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0XSksIG5ldyBFQ0Jsb2NrcyQxKDIwLCBuZXcgRUNCJDEoNCwgODEpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxLCA1MCksIG5ldyBFQ0IkMSg0LCA1MSkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDQsIDIyKSwgbmV3IEVDQiQxKDQsIDIzKSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoMywgMTIpLCBuZXcgRUNCJDEoOCwgMTMpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTIsIEludDMyQXJyYXkuZnJvbShbNiwgMzIsIDU4XSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoMiwgOTIpLCBuZXcgRUNCJDEoMiwgOTMpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSg2LCAzNiksIG5ldyBFQ0IkMSgyLCAzNykpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDQsIDIwKSwgbmV3IEVDQiQxKDYsIDIxKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNywgMTQpLCBuZXcgRUNCJDEoNCwgMTUpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTMsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyXSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoNCwgMTA3KSksIG5ldyBFQ0Jsb2NrcyQxKDIyLCBuZXcgRUNCJDEoOCwgMzcpLCBuZXcgRUNCJDEoMSwgMzgpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSg4LCAyMCksIG5ldyBFQ0IkMSg0LCAyMSkpLCBuZXcgRUNCbG9ja3MkMSgyMiwgbmV3IEVDQiQxKDEyLCAxMSksIG5ldyBFQ0IkMSg0LCAxMikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxNCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNDYsIDY2XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMywgMTE1KSwgbmV3IEVDQiQxKDEsIDExNikpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDQsIDQwKSwgbmV3IEVDQiQxKDUsIDQxKSksIG5ldyBFQ0Jsb2NrcyQxKDIwLCBuZXcgRUNCJDEoMTEsIDE2KSwgbmV3IEVDQiQxKDUsIDE3KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoMTEsIDEyKSwgbmV3IEVDQiQxKDUsIDEzKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDE1LCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0OCwgNzBdKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSg1LCA4NyksIG5ldyBFQ0IkMSgxLCA4OCkpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDUsIDQxKSwgbmV3IEVDQiQxKDUsIDQyKSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNSwgMjQpLCBuZXcgRUNCJDEoNywgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSgxMSwgMTIpLCBuZXcgRUNCJDEoNywgMTMpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTYsIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUwLCA3NF0pLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDUsIDk4KSwgbmV3IEVDQiQxKDEsIDk5KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNywgNDUpLCBuZXcgRUNCJDEoMywgNDYpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSgxNSwgMTkpLCBuZXcgRUNCJDEoMiwgMjApKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgzLCAxNSksIG5ldyBFQ0IkMSgxMywgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTcsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OF0pLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDEsIDEwNyksIG5ldyBFQ0IkMSg1LCAxMDgpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxMCwgNDYpLCBuZXcgRUNCJDEoMSwgNDcpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxLCAyMiksIG5ldyBFQ0IkMSgxNSwgMjMpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgyLCAxNCksIG5ldyBFQ0IkMSgxNywgMTUpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTgsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU2LCA4Ml0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDUsIDEyMCksIG5ldyBFQ0IkMSgxLCAxMjEpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSg5LCA0MyksIG5ldyBFQ0IkMSg0LCA0NCkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDE3LCAyMiksIG5ldyBFQ0IkMSgxLCAyMykpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDIsIDE0KSwgbmV3IEVDQiQxKDE5LCAxNSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxOSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2XSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMywgMTEzKSwgbmV3IEVDQiQxKDQsIDExNCkpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDMsIDQ0KSwgbmV3IEVDQiQxKDExLCA0NSkpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDE3LCAyMSksIG5ldyBFQ0IkMSg0LCAyMikpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDksIDEzKSwgbmV3IEVDQiQxKDE2LCAxNCkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyMCwgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIDkwXSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMywgMTA3KSwgbmV3IEVDQiQxKDUsIDEwOCkpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDMsIDQxKSwgbmV3IEVDQiQxKDEzLCA0MikpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDE1LCAyNCksIG5ldyBFQ0IkMSg1LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDE1LCAxNSksIG5ldyBFQ0IkMSgxMCwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjEsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDUwLCA3MiwgOTRdKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg0LCAxMTYpLCBuZXcgRUNCJDEoNCwgMTE3KSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoMTcsIDQyKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTcsIDIyKSwgbmV3IEVDQiQxKDYsIDIzKSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTksIDE2KSwgbmV3IEVDQiQxKDYsIDE3KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDIyLCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MCwgNzQsIDk4XSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMiwgMTExKSwgbmV3IEVDQiQxKDcsIDExMikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDE3LCA0NikpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDcsIDI0KSwgbmV3IEVDQiQxKDE2LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDM0LCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyMywgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTQsIDc4LCAxMDJdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0LCAxMjEpLCBuZXcgRUNCJDEoNSwgMTIyKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNCwgNDcpLCBuZXcgRUNCJDEoMTQsIDQ4KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTEsIDI0KSwgbmV3IEVDQiQxKDE0LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDE2LCAxNSksIG5ldyBFQ0IkMSgxNCwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjQsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDU0LCA4MCwgMTA2XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNiwgMTE3KSwgbmV3IEVDQiQxKDQsIDExOCkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDYsIDQ1KSwgbmV3IEVDQiQxKDE0LCA0NikpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDExLCAyNCksIG5ldyBFQ0IkMSgxNiwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgzMCwgMTYpLCBuZXcgRUNCJDEoMiwgMTcpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjUsIEludDMyQXJyYXkuZnJvbShbNiwgMzIsIDU4LCA4NCwgMTEwXSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoOCwgMTA2KSwgbmV3IEVDQiQxKDQsIDEwNykpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDgsIDQ3KSwgbmV3IEVDQiQxKDEzLCA0OCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDcsIDI0KSwgbmV3IEVDQiQxKDIyLCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDIyLCAxNSksIG5ldyBFQ0IkMSgxMywgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjYsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0XSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTAsIDExNCksIG5ldyBFQ0IkMSgyLCAxMTUpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxOSwgNDYpLCBuZXcgRUNCJDEoNCwgNDcpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgyOCwgMjIpLCBuZXcgRUNCJDEoNiwgMjMpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgzMywgMTYpLCBuZXcgRUNCJDEoNCwgMTcpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjcsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgMTE4XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoOCwgMTIyKSwgbmV3IEVDQiQxKDQsIDEyMykpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDIyLCA0NSksIG5ldyBFQ0IkMSgzLCA0NikpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDgsIDIzKSwgbmV3IEVDQiQxKDI2LCAyNCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDEyLCAxNSksIG5ldyBFQ0IkMSgyOCwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjgsIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUwLCA3NCwgOTgsIDEyMl0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDMsIDExNyksIG5ldyBFQ0IkMSgxMCwgMTE4KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMywgNDUpLCBuZXcgRUNCJDEoMjMsIDQ2KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNCwgMjQpLCBuZXcgRUNCJDEoMzEsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTEsIDE1KSwgbmV3IEVDQiQxKDMxLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyOSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNl0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDcsIDExNiksIG5ldyBFQ0IkMSg3LCAxMTcpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgyMSwgNDUpLCBuZXcgRUNCJDEoNywgNDYpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxLCAyMyksIG5ldyBFQ0IkMSgzNywgMjQpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxOSwgMTUpLCBuZXcgRUNCJDEoMjYsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDMwLCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MiwgNzgsIDEwNCwgMTMwXSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNSwgMTE1KSwgbmV3IEVDQiQxKDEwLCAxMTYpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxOSwgNDcpLCBuZXcgRUNCJDEoMTAsIDQ4KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTUsIDI0KSwgbmV3IEVDQiQxKDI1LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDIzLCAxNSksIG5ldyBFQ0IkMSgyNSwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzEsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU2LCA4MiwgMTA4LCAxMzRdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxMywgMTE1KSwgbmV3IEVDQiQxKDMsIDExNikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDIsIDQ2KSwgbmV3IEVDQiQxKDI5LCA0NykpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDQyLCAyNCksIG5ldyBFQ0IkMSgxLCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDIzLCAxNSksIG5ldyBFQ0IkMSgyOCwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzIsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzhdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxNywgMTE1KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTAsIDQ2KSwgbmV3IEVDQiQxKDIzLCA0NykpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDEwLCAyNCksIG5ldyBFQ0IkMSgzNSwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxOSwgMTUpLCBuZXcgRUNCJDEoMzUsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDMzLCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1OCwgODYsIDExNCwgMTQyXSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTcsIDExNSksIG5ldyBFQ0IkMSgxLCAxMTYpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxNCwgNDYpLCBuZXcgRUNCJDEoMjEsIDQ3KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMjksIDI0KSwgbmV3IEVDQiQxKDE5LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDExLCAxNSksIG5ldyBFQ0IkMSg0NiwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzQsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgMTE4LCAxNDZdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxMywgMTE1KSwgbmV3IEVDQiQxKDYsIDExNikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDE0LCA0NiksIG5ldyBFQ0IkMSgyMywgNDcpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0NCwgMjQpLCBuZXcgRUNCJDEoNywgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg1OSwgMTYpLCBuZXcgRUNCJDEoMSwgMTcpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzUsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDEyLCAxMjEpLCBuZXcgRUNCJDEoNywgMTIyKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTIsIDQ3KSwgbmV3IEVDQiQxKDI2LCA0OCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDM5LCAyNCksIG5ldyBFQ0IkMSgxNCwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyMiwgMTUpLCBuZXcgRUNCJDEoNDEsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDM2LCBJbnQzMkFycmF5LmZyb20oWzYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTRdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg2LCAxMjEpLCBuZXcgRUNCJDEoMTQsIDEyMikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDYsIDQ3KSwgbmV3IEVDQiQxKDM0LCA0OCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDQ2LCAyNCksIG5ldyBFQ0IkMSgxMCwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyLCAxNSksIG5ldyBFQ0IkMSg2NCwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzcsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDU0LCA4MCwgMTA2LCAxMzIsIDE1OF0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDE3LCAxMjIpLCBuZXcgRUNCJDEoNCwgMTIzKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMjksIDQ2KSwgbmV3IEVDQiQxKDE0LCA0NykpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDQ5LCAyNCksIG5ldyBFQ0IkMSgxMCwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyNCwgMTUpLCBuZXcgRUNCJDEoNDYsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDM4LCBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OCwgODQsIDExMCwgMTM2LCAxNjJdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0LCAxMjIpLCBuZXcgRUNCJDEoMTgsIDEyMykpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDEzLCA0NiksIG5ldyBFQ0IkMSgzMiwgNDcpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0OCwgMjQpLCBuZXcgRUNCJDEoMTQsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNDIsIDE1KSwgbmV3IEVDQiQxKDMyLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgzOSwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMjAsIDExNyksIG5ldyBFQ0IkMSg0LCAxMTgpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg0MCwgNDcpLCBuZXcgRUNCJDEoNywgNDgpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0MywgMjQpLCBuZXcgRUNCJDEoMjIsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTAsIDE1KSwgbmV3IEVDQiQxKDY3LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSg0MCwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTksIDExOCksIG5ldyBFQ0IkMSg2LCAxMTkpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxOCwgNDcpLCBuZXcgRUNCJDEoMzEsIDQ4KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMzQsIDI0KSwgbmV3IEVDQiQxKDM0LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDIwLCAxNSksIG5ldyBFQ0IkMSg2MSwgMTYpKSlcbiAgICBdO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICB2YXIgRGF0YU1hc2tWYWx1ZXM7XG4gICAgKGZ1bmN0aW9uIChEYXRhTWFza1ZhbHVlcykge1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18wMDBcIl0gPSAwXSA9IFwiREFUQV9NQVNLXzAwMFwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18wMDFcIl0gPSAxXSA9IFwiREFUQV9NQVNLXzAwMVwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18wMTBcIl0gPSAyXSA9IFwiREFUQV9NQVNLXzAxMFwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18wMTFcIl0gPSAzXSA9IFwiREFUQV9NQVNLXzAxMVwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18xMDBcIl0gPSA0XSA9IFwiREFUQV9NQVNLXzEwMFwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18xMDFcIl0gPSA1XSA9IFwiREFUQV9NQVNLXzEwMVwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18xMTBcIl0gPSA2XSA9IFwiREFUQV9NQVNLXzExMFwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18xMTFcIl0gPSA3XSA9IFwiREFUQV9NQVNLXzExMVwiO1xuICAgIH0pKERhdGFNYXNrVmFsdWVzIHx8IChEYXRhTWFza1ZhbHVlcyA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGRhdGEgbWFza3MgZm9yIHRoZSBkYXRhIGJpdHMgaW4gYSBRUiBjb2RlLCBwZXIgSVNPIDE4MDA0OjIwMDYgNi44LiBJbXBsZW1lbnRhdGlvbnNcbiAgICAgKiBvZiB0aGlzIGNsYXNzIGNhbiB1bi1tYXNrIGEgcmF3IEJpdE1hdHJpeC4gRm9yIHNpbXBsaWNpdHksIHRoZXkgd2lsbCB1bm1hc2sgdGhlIGVudGlyZSBCaXRNYXRyaXgsXG4gICAgICogaW5jbHVkaW5nIGFyZWFzIHVzZWQgZm9yIGZpbmRlciBwYXR0ZXJucywgdGltaW5nIHBhdHRlcm5zLCBldGMuIFRoZXNlIGFyZWFzIHNob3VsZCBiZSB1bnVzZWRcbiAgICAgKiBhZnRlciB0aGUgcG9pbnQgdGhleSBhcmUgdW5tYXNrZWQgYW55d2F5LjwvcD5cbiAgICAgKlxuICAgICAqIDxwPk5vdGUgdGhhdCB0aGUgZGlhZ3JhbSBpbiBzZWN0aW9uIDYuOC4xIGlzIG1pc2xlYWRpbmcgc2luY2UgaXQgaW5kaWNhdGVzIHRoYXQgaSBpcyBjb2x1bW4gcG9zaXRpb25cbiAgICAgKiBhbmQgaiBpcyByb3cgcG9zaXRpb24uIEluIGZhY3QsIGFzIHRoZSB0ZXh0IHNheXMsIGkgaXMgcm93IHBvc2l0aW9uIGFuZCBqIGlzIGNvbHVtbiBwb3NpdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIERhdGFNYXNrIHtcbiAgICAgICAgLy8gU2VlIElTTyAxODAwNDoyMDA2IDYuOC4xXG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBpc01hc2tlZCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5pc01hc2tlZCA9IGlzTWFza2VkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuZCBvZiBlbnVtIGNvbnN0YW50cy5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkltcGxlbWVudGF0aW9ucyBvZiB0aGlzIG1ldGhvZCByZXZlcnNlIHRoZSBkYXRhIG1hc2tpbmcgcHJvY2VzcyBhcHBsaWVkIHRvIGEgUVIgQ29kZSBhbmRcbiAgICAgICAgICogbWFrZSBpdHMgYml0cyByZWFkeSB0byByZWFkLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJpdHMgcmVwcmVzZW50YXRpb24gb2YgUVIgQ29kZSBiaXRzXG4gICAgICAgICAqIEBwYXJhbSBkaW1lbnNpb24gZGltZW5zaW9uIG9mIFFSIENvZGUsIHJlcHJlc2VudGVkIGJ5IGJpdHMsIGJlaW5nIHVubWFza2VkXG4gICAgICAgICAqL1xuICAgICAgICB1bm1hc2tCaXRNYXRyaXgoYml0cywgZGltZW5zaW9uIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltZW5zaW9uOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRpbWVuc2lvbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTWFza2VkKGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRzLmZsaXAoaiwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGF0YU1hc2sudmFsdWVzID0gbmV3IE1hcChbXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAwMDA6IG1hc2sgYml0cyBmb3Igd2hpY2ggKHggKyB5KSBtb2QgMiA9PSAwXG4gICAgICAgICAqL1xuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAwMCwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMDAsIChpIC8qaW50Ki8sIGogLyppbnQqLykgPT4geyByZXR1cm4gKChpICsgaikgJiAweDAxKSA9PT0gMDsgfSldLFxuICAgICAgICAvKipcbiAgICAgICAgICogMDAxOiBtYXNrIGJpdHMgZm9yIHdoaWNoIHggbW9kIDIgPT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMDEsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDAxLCAoaSAvKmludCovLCBqIC8qaW50Ki8pID0+IHsgcmV0dXJuIChpICYgMHgwMSkgPT09IDA7IH0pXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDAxMDogbWFzayBiaXRzIGZvciB3aGljaCB5IG1vZCAzID09IDBcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDEwLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAxMCwgKGkgLyppbnQqLywgaiAvKmludCovKSA9PiB7IHJldHVybiBqICUgMyA9PT0gMDsgfSldLFxuICAgICAgICAvKipcbiAgICAgICAgICogMDExOiBtYXNrIGJpdHMgZm9yIHdoaWNoICh4ICsgeSkgbW9kIDMgPT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMTEsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDExLCAoaSAvKmludCovLCBqIC8qaW50Ki8pID0+IHsgcmV0dXJuIChpICsgaikgJSAzID09PSAwOyB9KV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAxMDA6IG1hc2sgYml0cyBmb3Igd2hpY2ggKHgvMiArIHkvMykgbW9kIDIgPT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMDAsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTAwLCAoaSAvKmludCovLCBqIC8qaW50Ki8pID0+IHsgcmV0dXJuICgoTWF0aC5mbG9vcihpIC8gMikgKyBNYXRoLmZsb29yKGogLyAzKSkgJiAweDAxKSA9PT0gMDsgfSldLFxuICAgICAgICAvKipcbiAgICAgICAgICogMTAxOiBtYXNrIGJpdHMgZm9yIHdoaWNoIHh5IG1vZCAyICsgeHkgbW9kIDMgPT0gMFxuICAgICAgICAgKiBlcXVpdmFsZW50bHksIHN1Y2ggdGhhdCB4eSBtb2QgNiA9PSAwXG4gICAgICAgICAqL1xuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzEwMSwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMDEsIChpIC8qaW50Ki8sIGogLyppbnQqLykgPT4geyByZXR1cm4gKGkgKiBqKSAlIDYgPT09IDA7IH0pXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDExMDogbWFzayBiaXRzIGZvciB3aGljaCAoeHkgbW9kIDIgKyB4eSBtb2QgMykgbW9kIDIgPT0gMFxuICAgICAgICAgKiBlcXVpdmFsZW50bHksIHN1Y2ggdGhhdCB4eSBtb2QgNiA8IDNcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTEwLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzExMCwgKGkgLyppbnQqLywgaiAvKmludCovKSA9PiB7IHJldHVybiAoKGkgKiBqKSAlIDYpIDwgMzsgfSldLFxuICAgICAgICAvKipcbiAgICAgICAgICogMTExOiBtYXNrIGJpdHMgZm9yIHdoaWNoICgoeCt5KW1vZCAyICsgeHkgbW9kIDMpIG1vZCAyID09IDBcbiAgICAgICAgICogZXF1aXZhbGVudGx5LCBzdWNoIHRoYXQgKHggKyB5ICsgeHkgbW9kIDMpIG1vZCAyID09IDBcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTExLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzExMSwgKGkgLyppbnQqLywgaiAvKmludCovKSA9PiB7IHJldHVybiAoKGkgKyBqICsgKChpICogaikgJSAzKSkgJiAweDAxKSA9PT0gMDsgfSldLFxuICAgIF0pO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEJpdE1hdHJpeFBhcnNlciQxIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBiaXRNYXRyaXgge0BsaW5rIEJpdE1hdHJpeH0gdG8gcGFyc2VcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgZGltZW5zaW9uIGlzIG5vdCA+PSAyMSBhbmQgMSBtb2QgNFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoYml0TWF0cml4KSB7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSBiaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uIDwgMjEgfHwgKGRpbWVuc2lvbiAmIDB4MDMpICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iaXRNYXRyaXggPSBiaXRNYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIGZvcm1hdCBpbmZvcm1hdGlvbiBmcm9tIG9uZSBvZiBpdHMgdHdvIGxvY2F0aW9ucyB3aXRoaW4gdGhlIFFSIENvZGUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBGb3JtYXRJbmZvcm1hdGlvbn0gZW5jYXBzdWxhdGluZyB0aGUgUVIgQ29kZSdzIGZvcm1hdCBpbmZvXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGJvdGggZm9ybWF0IGluZm9ybWF0aW9uIGxvY2F0aW9ucyBjYW5ub3QgYmUgcGFyc2VkIGFzXG4gICAgICAgICAqIHRoZSB2YWxpZCBlbmNvZGluZyBvZiBmb3JtYXQgaW5mb3JtYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHJlYWRGb3JtYXRJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlZEZvcm1hdEluZm8gIT09IG51bGwgJiYgdGhpcy5wYXJzZWRGb3JtYXRJbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRGb3JtYXRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVhZCB0b3AtbGVmdCBmb3JtYXQgaW5mbyBiaXRzXG4gICAgICAgICAgICBsZXQgZm9ybWF0SW5mb0JpdHMxID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMxID0gdGhpcy5jb3B5Qml0KGksIDgsIGZvcm1hdEluZm9CaXRzMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAuLiBhbmQgc2tpcCBhIGJpdCBpbiB0aGUgdGltaW5nIHBhdHRlcm4gLi4uXG4gICAgICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoNywgOCwgZm9ybWF0SW5mb0JpdHMxKTtcbiAgICAgICAgICAgIGZvcm1hdEluZm9CaXRzMSA9IHRoaXMuY29weUJpdCg4LCA4LCBmb3JtYXRJbmZvQml0czEpO1xuICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMxID0gdGhpcy5jb3B5Qml0KDgsIDcsIGZvcm1hdEluZm9CaXRzMSk7XG4gICAgICAgICAgICAvLyAuLiBhbmQgc2tpcCBhIGJpdCBpbiB0aGUgdGltaW5nIHBhdHRlcm4gLi4uXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoOCwgaiwgZm9ybWF0SW5mb0JpdHMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlYWQgdGhlIHRvcC1yaWdodC9ib3R0b20tbGVmdCBwYXR0ZXJuIHRvb1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5iaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBsZXQgZm9ybWF0SW5mb0JpdHMyID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGpNaW4gPSBkaW1lbnNpb24gLSA3O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGRpbWVuc2lvbiAtIDE7IGogPj0gak1pbjsgai0tKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMyID0gdGhpcy5jb3B5Qml0KDgsIGosIGZvcm1hdEluZm9CaXRzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZGltZW5zaW9uIC0gODsgaSA8IGRpbWVuc2lvbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMyID0gdGhpcy5jb3B5Qml0KGksIDgsIGZvcm1hdEluZm9CaXRzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcnNlZEZvcm1hdEluZm8gPSBGb3JtYXRJbmZvcm1hdGlvbi5kZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihmb3JtYXRJbmZvQml0czEsIGZvcm1hdEluZm9CaXRzMik7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZWRGb3JtYXRJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkRm9ybWF0SW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgdmVyc2lvbiBpbmZvcm1hdGlvbiBmcm9tIG9uZSBvZiBpdHMgdHdvIGxvY2F0aW9ucyB3aXRoaW4gdGhlIFFSIENvZGUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBWZXJzaW9ufSBlbmNhcHN1bGF0aW5nIHRoZSBRUiBDb2RlJ3MgdmVyc2lvblxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBib3RoIHZlcnNpb24gaW5mb3JtYXRpb24gbG9jYXRpb25zIGNhbm5vdCBiZSBwYXJzZWQgYXNcbiAgICAgICAgICogdGhlIHZhbGlkIGVuY29kaW5nIG9mIHZlcnNpb24gaW5mb3JtYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHJlYWRWZXJzaW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VkVmVyc2lvbiAhPT0gbnVsbCAmJiB0aGlzLnBhcnNlZFZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlZFZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3Zpc2lvbmFsVmVyc2lvbiA9IE1hdGguZmxvb3IoKGRpbWVuc2lvbiAtIDE3KSAvIDQpO1xuICAgICAgICAgICAgaWYgKHByb3Zpc2lvbmFsVmVyc2lvbiA8PSA2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlcnNpb24kMS5nZXRWZXJzaW9uRm9yTnVtYmVyKHByb3Zpc2lvbmFsVmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZWFkIHRvcC1yaWdodCB2ZXJzaW9uIGluZm86IDMgd2lkZSBieSA2IHRhbGxcbiAgICAgICAgICAgIGxldCB2ZXJzaW9uQml0cyA9IDA7XG4gICAgICAgICAgICBjb25zdCBpak1pbiA9IGRpbWVuc2lvbiAtIDExO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDU7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGRpbWVuc2lvbiAtIDk7IGkgPj0gaWpNaW47IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uQml0cyA9IHRoaXMuY29weUJpdChpLCBqLCB2ZXJzaW9uQml0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRoZVBhcnNlZFZlcnNpb24gPSBWZXJzaW9uJDEuZGVjb2RlVmVyc2lvbkluZm9ybWF0aW9uKHZlcnNpb25CaXRzKTtcbiAgICAgICAgICAgIGlmICh0aGVQYXJzZWRWZXJzaW9uICE9PSBudWxsICYmIHRoZVBhcnNlZFZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpID09PSBkaW1lbnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlZFZlcnNpb24gPSB0aGVQYXJzZWRWZXJzaW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGVQYXJzZWRWZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSG1tLCBmYWlsZWQuIFRyeSBib3R0b20gbGVmdDogNiB3aWRlIGJ5IDMgdGFsbFxuICAgICAgICAgICAgdmVyc2lvbkJpdHMgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDU7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGRpbWVuc2lvbiAtIDk7IGogPj0gaWpNaW47IGotLSkge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uQml0cyA9IHRoaXMuY29weUJpdChpLCBqLCB2ZXJzaW9uQml0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhlUGFyc2VkVmVyc2lvbiA9IFZlcnNpb24kMS5kZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24odmVyc2lvbkJpdHMpO1xuICAgICAgICAgICAgaWYgKHRoZVBhcnNlZFZlcnNpb24gIT09IG51bGwgJiYgdGhlUGFyc2VkVmVyc2lvbi5nZXREaW1lbnNpb25Gb3JWZXJzaW9uKCkgPT09IGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VkVmVyc2lvbiA9IHRoZVBhcnNlZFZlcnNpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoZVBhcnNlZFZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29weUJpdChpIC8qaW50Ki8sIGogLyppbnQqLywgdmVyc2lvbkJpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgYml0ID0gdGhpcy5pc01pcnJvciA/IHRoaXMuYml0TWF0cml4LmdldChqLCBpKSA6IHRoaXMuYml0TWF0cml4LmdldChpLCBqKTtcbiAgICAgICAgICAgIHJldHVybiBiaXQgPyAodmVyc2lvbkJpdHMgPDwgMSkgfCAweDEgOiB2ZXJzaW9uQml0cyA8PCAxO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5SZWFkcyB0aGUgYml0cyBpbiB0aGUge0BsaW5rIEJpdE1hdHJpeH0gcmVwcmVzZW50aW5nIHRoZSBmaW5kZXIgcGF0dGVybiBpbiB0aGVcbiAgICAgICAgICogY29ycmVjdCBvcmRlciBpbiBvcmRlciB0byByZWNvbnN0cnVjdCB0aGUgY29kZXdvcmRzIGJ5dGVzIGNvbnRhaW5lZCB3aXRoaW4gdGhlXG4gICAgICAgICAqIFFSIENvZGUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIGJ5dGVzIGVuY29kZWQgd2l0aGluIHRoZSBRUiBDb2RlXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBleGFjdCBudW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgaXMgbm90IHJlYWRcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRJbmZvID0gdGhpcy5yZWFkRm9ybWF0SW5mb3JtYXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnJlYWRWZXJzaW9uKCk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGRhdGEgbWFzayBmb3IgdGhlIGZvcm1hdCB1c2VkIGluIHRoaXMgUVIgQ29kZS4gVGhpcyB3aWxsIGV4Y2x1ZGVcbiAgICAgICAgICAgIC8vIHNvbWUgYml0cyBmcm9tIHJlYWRpbmcgYXMgd2Ugd2luZCB0aHJvdWdoIHRoZSBiaXQgbWF0cml4LlxuICAgICAgICAgICAgY29uc3QgZGF0YU1hc2sgPSBEYXRhTWFzay52YWx1ZXMuZ2V0KGZvcm1hdEluZm8uZ2V0RGF0YU1hc2soKSk7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGRhdGFNYXNrLnVubWFza0JpdE1hdHJpeCh0aGlzLmJpdE1hdHJpeCwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUGF0dGVybiA9IHZlcnNpb24uYnVpbGRGdW5jdGlvblBhdHRlcm4oKTtcbiAgICAgICAgICAgIGxldCByZWFkaW5nVXAgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKTtcbiAgICAgICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRCeXRlID0gMDtcbiAgICAgICAgICAgIGxldCBiaXRzUmVhZCA9IDA7XG4gICAgICAgICAgICAvLyBSZWFkIGNvbHVtbnMgaW4gcGFpcnMsIGZyb20gcmlnaHQgdG8gbGVmdFxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGRpbWVuc2lvbiAtIDE7IGogPiAwOyBqIC09IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHdob2xlIGNvbHVtbiB3aXRoIHZlcnRpY2FsIGFsaWdubWVudCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNhdmVzIHRpbWUgYW5kIG1ha2VzIHRoZSBvdGhlciBjb2RlIHByb2NlZWQgbW9yZSBjbGVhbmx5XG4gICAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVhZCBhbHRlcm5hdGluZ2x5IGZyb20gYm90dG9tIHRvIHRvcCB0aGVuIHRvcCB0byBib3R0b21cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudCA9IDA7IGNvdW50IDwgZGltZW5zaW9uOyBjb3VudCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSByZWFkaW5nVXAgPyBkaW1lbnNpb24gLSAxIC0gY291bnQgOiBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgMjsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBiaXRzIGNvdmVyZWQgYnkgdGhlIGZ1bmN0aW9uIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZnVuY3Rpb25QYXR0ZXJuLmdldChqIC0gY29sLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgYSBiaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzUmVhZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJpdE1hdHJpeC5nZXQoaiAtIGNvbCwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgbWFkZSBhIHdob2xlIGJ5dGUsIHNhdmUgaXQgb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHNSZWFkID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSAvKihieXRlKSAqLyBjdXJyZW50Qnl0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0c1JlYWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlYWRpbmdVcCA9ICFyZWFkaW5nVXA7IC8vIHJlYWRpbmdVcCBePSB0cnVlOyAvLyByZWFkaW5nVXAgPSAhcmVhZGluZ1VwOyAvLyBzd2l0Y2ggZGlyZWN0aW9uc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdE9mZnNldCAhPT0gdmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV2ZXJ0IHRoZSBtYXNrIHJlbW92YWwgZG9uZSB3aGlsZSByZWFkaW5nIHRoZSBjb2RlIHdvcmRzLiBUaGUgYml0IG1hdHJpeCBzaG91bGQgcmV2ZXJ0IHRvIGl0cyBvcmlnaW5hbCBzdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHJlbWFzaygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlZEZvcm1hdEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFdlIGhhdmUgbm8gZm9ybWF0IGluZm9ybWF0aW9uLCBhbmQgaGF2ZSBubyBkYXRhIG1hc2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGFNYXNrID0gRGF0YU1hc2sudmFsdWVzW3RoaXMucGFyc2VkRm9ybWF0SW5mby5nZXREYXRhTWFzaygpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuYml0TWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgZGF0YU1hc2sudW5tYXNrQml0TWF0cml4KHRoaXMuYml0TWF0cml4LCBkaW1lbnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmVwYXJlIHRoZSBwYXJzZXIgZm9yIGEgbWlycm9yZWQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBUaGlzIGZsYWcgaGFzIGVmZmVjdCBvbmx5IG9uIHRoZSB7QGxpbmsgI3JlYWRGb3JtYXRJbmZvcm1hdGlvbigpfSBhbmQgdGhlXG4gICAgICAgICAqIHtAbGluayAjcmVhZFZlcnNpb24oKX0uIEJlZm9yZSBwcm9jZWVkaW5nIHdpdGgge0BsaW5rICNyZWFkQ29kZXdvcmRzKCl9IHRoZVxuICAgICAgICAgKiB7QGxpbmsgI21pcnJvcigpfSBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1pcnJvciBXaGV0aGVyIHRvIHJlYWQgdmVyc2lvbiBhbmQgZm9ybWF0IGluZm9ybWF0aW9uIG1pcnJvcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TWlycm9yKGlzTWlycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFZlcnNpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRGb3JtYXRJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaXNNaXJyb3IgPSBpc01pcnJvcjtcbiAgICAgICAgfVxuICAgICAgICAvKiogTWlycm9yIHRoZSBiaXQgbWF0cml4IGluIG9yZGVyIHRvIGF0dGVtcHQgYSBzZWNvbmQgcmVhZGluZy4gKi9cbiAgICAgICAgbWlycm9yKCkge1xuICAgICAgICAgICAgY29uc3QgYml0TWF0cml4ID0gdGhpcy5iaXRNYXRyaXg7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMCwgd2lkdGggPSBiaXRNYXRyaXguZ2V0V2lkdGgoKTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0geCArIDEsIGhlaWdodCA9IGJpdE1hdHJpeC5nZXRIZWlnaHQoKTsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXRNYXRyaXguZ2V0KHgsIHkpICE9PSBiaXRNYXRyaXguZ2V0KHksIHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRNYXRyaXguZmxpcCh5LCB4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5mbGlwKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgYSBibG9jayBvZiBkYXRhIHdpdGhpbiBhIFFSIENvZGUuIFFSIENvZGVzIG1heSBzcGxpdCB0aGVpciBkYXRhIGludG9cbiAgICAgKiBtdWx0aXBsZSBibG9ja3MsIGVhY2ggb2Ygd2hpY2ggaXMgYSB1bml0IG9mIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzLiBFYWNoXG4gICAgICogaXMgcmVwcmVzZW50ZWQgYnkgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIERhdGFCbG9jayQxIHtcbiAgICAgICAgY29uc3RydWN0b3IobnVtRGF0YUNvZGV3b3JkcyAvKmludCovLCBjb2Rld29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMubnVtRGF0YUNvZGV3b3JkcyA9IG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgICAgICB0aGlzLmNvZGV3b3JkcyA9IGNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+V2hlbiBRUiBDb2RlcyB1c2UgbXVsdGlwbGUgZGF0YSBibG9ja3MsIHRoZXkgYXJlIGFjdHVhbGx5IGludGVybGVhdmVkLlxuICAgICAgICAgKiBUaGF0IGlzLCB0aGUgZmlyc3QgYnl0ZSBvZiBkYXRhIGJsb2NrIDEgdG8gbiBpcyB3cml0dGVuLCB0aGVuIHRoZSBzZWNvbmQgYnl0ZXMsIGFuZCBzbyBvbi4gVGhpc1xuICAgICAgICAgKiBtZXRob2Qgd2lsbCBzZXBhcmF0ZSB0aGUgZGF0YSBpbnRvIG9yaWdpbmFsIGJsb2Nrcy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByYXdDb2Rld29yZHMgYnl0ZXMgYXMgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBRUiBDb2RlXG4gICAgICAgICAqIEBwYXJhbSB2ZXJzaW9uIHZlcnNpb24gb2YgdGhlIFFSIENvZGVcbiAgICAgICAgICogQHBhcmFtIGVjTGV2ZWwgZXJyb3ItY29ycmVjdGlvbiBsZXZlbCBvZiB0aGUgUVIgQ29kZVxuICAgICAgICAgKiBAcmV0dXJuIERhdGFCbG9ja3MgY29udGFpbmluZyBvcmlnaW5hbCBieXRlcywgXCJkZS1pbnRlcmxlYXZlZFwiIGZyb20gcmVwcmVzZW50YXRpb24gaW4gdGhlXG4gICAgICAgICAqICAgICAgICAgUVIgQ29kZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldERhdGFCbG9ja3MocmF3Q29kZXdvcmRzLCB2ZXJzaW9uLCBlY0xldmVsKSB7XG4gICAgICAgICAgICBpZiAocmF3Q29kZXdvcmRzLmxlbmd0aCAhPT0gdmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgbnVtYmVyIGFuZCBzaXplIG9mIGRhdGEgYmxvY2tzIHVzZWQgYnkgdGhpcyB2ZXJzaW9uIGFuZFxuICAgICAgICAgICAgLy8gZXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICAgICAgICAgICAgY29uc3QgZWNCbG9ja3MgPSB2ZXJzaW9uLmdldEVDQmxvY2tzRm9yTGV2ZWwoZWNMZXZlbCk7XG4gICAgICAgICAgICAvLyBGaXJzdCBjb3VudCB0aGUgdG90YWwgbnVtYmVyIG9mIGRhdGEgYmxvY2tzXG4gICAgICAgICAgICBsZXQgdG90YWxCbG9ja3MgPSAwO1xuICAgICAgICAgICAgY29uc3QgZWNCbG9ja0FycmF5ID0gZWNCbG9ja3MuZ2V0RUNCbG9ja3MoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWNCbG9jayBvZiBlY0Jsb2NrQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0b3RhbEJsb2NrcyArPSBlY0Jsb2NrLmdldENvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgZXN0YWJsaXNoIERhdGFCbG9ja3Mgb2YgdGhlIGFwcHJvcHJpYXRlIHNpemUgYW5kIG51bWJlciBvZiBkYXRhIGNvZGV3b3Jkc1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KHRvdGFsQmxvY2tzKTtcbiAgICAgICAgICAgIGxldCBudW1SZXN1bHRCbG9ja3MgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlY0Jsb2NrIG9mIGVjQmxvY2tBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWNCbG9jay5nZXRDb3VudCgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtRGF0YUNvZGV3b3JkcyA9IGVjQmxvY2suZ2V0RGF0YUNvZGV3b3JkcygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1CbG9ja0NvZGV3b3JkcyA9IGVjQmxvY2tzLmdldEVDQ29kZXdvcmRzUGVyQmxvY2soKSArIG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtudW1SZXN1bHRCbG9ja3MrK10gPSBuZXcgRGF0YUJsb2NrJDEobnVtRGF0YUNvZGV3b3JkcywgbmV3IFVpbnQ4QXJyYXkobnVtQmxvY2tDb2Rld29yZHMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbGwgYmxvY2tzIGhhdmUgdGhlIHNhbWUgYW1vdW50IG9mIGRhdGEsIGV4Y2VwdCB0aGF0IHRoZSBsYXN0IG5cbiAgICAgICAgICAgIC8vICh3aGVyZSBuIG1heSBiZSAwKSBoYXZlIDEgbW9yZSBieXRlLiBGaWd1cmUgb3V0IHdoZXJlIHRoZXNlIHN0YXJ0LlxuICAgICAgICAgICAgY29uc3Qgc2hvcnRlckJsb2Nrc1RvdGFsQ29kZXdvcmRzID0gcmVzdWx0WzBdLmNvZGV3b3Jkcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbG9uZ2VyQmxvY2tzU3RhcnRBdCA9IHJlc3VsdC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IGNoZWNrIGxlbmd0aCBpcyBjb3JyZWN0IGhlcmVcbiAgICAgICAgICAgIHdoaWxlIChsb25nZXJCbG9ja3NTdGFydEF0ID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1Db2Rld29yZHMgPSByZXN1bHRbbG9uZ2VyQmxvY2tzU3RhcnRBdF0uY29kZXdvcmRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobnVtQ29kZXdvcmRzID09PSBzaG9ydGVyQmxvY2tzVG90YWxDb2Rld29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvbmdlckJsb2Nrc1N0YXJ0QXQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvbmdlckJsb2Nrc1N0YXJ0QXQrKztcbiAgICAgICAgICAgIGNvbnN0IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzID0gc2hvcnRlckJsb2Nrc1RvdGFsQ29kZXdvcmRzIC0gZWNCbG9ja3MuZ2V0RUNDb2Rld29yZHNQZXJCbG9jaygpO1xuICAgICAgICAgICAgLy8gVGhlIGxhc3QgZWxlbWVudHMgb2YgcmVzdWx0IG1heSBiZSAxIGVsZW1lbnQgbG9uZ2VyXG4gICAgICAgICAgICAvLyBmaXJzdCBmaWxsIG91dCBhcyBtYW55IGVsZW1lbnRzIGFzIGFsbCBvZiB0aGVtIGhhdmVcbiAgICAgICAgICAgIGxldCByYXdDb2Rld29yZHNPZmZzZXQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbal0uY29kZXdvcmRzW2ldID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaWxsIG91dCB0aGUgbGFzdCBkYXRhIGJsb2NrIGluIHRoZSBsb25nZXIgb25lc1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGxvbmdlckJsb2Nrc1N0YXJ0QXQ7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHNdID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBhZGQgaW4gZXJyb3IgY29ycmVjdGlvbiBibG9ja3NcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHJlc3VsdFswXS5jb2Rld29yZHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVJlc3VsdEJsb2NrczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlPZmZzZXQgPSBqIDwgbG9uZ2VyQmxvY2tzU3RhcnRBdCA/IGkgOiBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2pdLmNvZGV3b3Jkc1tpT2Zmc2V0XSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBnZXROdW1EYXRhQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtRGF0YUNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICBnZXRDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIHZhciBNb2RlVmFsdWVzO1xuICAgIChmdW5jdGlvbiAoTW9kZVZhbHVlcykge1xuICAgICAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJURVJNSU5BVE9SXCJdID0gMF0gPSBcIlRFUk1JTkFUT1JcIjtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiTlVNRVJJQ1wiXSA9IDFdID0gXCJOVU1FUklDXCI7XG4gICAgICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkFMUEhBTlVNRVJJQ1wiXSA9IDJdID0gXCJBTFBIQU5VTUVSSUNcIjtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiU1RSVUNUVVJFRF9BUFBFTkRcIl0gPSAzXSA9IFwiU1RSVUNUVVJFRF9BUFBFTkRcIjtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiQllURVwiXSA9IDRdID0gXCJCWVRFXCI7XG4gICAgICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkVDSVwiXSA9IDVdID0gXCJFQ0lcIjtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiS0FOSklcIl0gPSA2XSA9IFwiS0FOSklcIjtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiRk5DMV9GSVJTVF9QT1NJVElPTlwiXSA9IDddID0gXCJGTkMxX0ZJUlNUX1BPU0lUSU9OXCI7XG4gICAgICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkZOQzFfU0VDT05EX1BPU0lUSU9OXCJdID0gOF0gPSBcIkZOQzFfU0VDT05EX1BPU0lUSU9OXCI7XG4gICAgICAgIC8qKiBTZWUgR0JUIDE4Mjg0LTIwMDA7IFwiSGFuemlcIiBpcyBhIHRyYW5zbGl0ZXJhdGlvbiBvZiB0aGlzIG1vZGUgbmFtZS4gKi9cbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiSEFOWklcIl0gPSA5XSA9IFwiSEFOWklcIjtcbiAgICB9KShNb2RlVmFsdWVzIHx8IChNb2RlVmFsdWVzID0ge30pKTtcbiAgICAvKipcbiAgICAgKiA8cD5TZWUgSVNPIDE4MDA0OjIwMDYsIDYuNC4xLCBUYWJsZXMgMiBhbmQgMy4gVGhpcyBlbnVtIGVuY2Fwc3VsYXRlcyB0aGUgdmFyaW91cyBtb2RlcyBpbiB3aGljaFxuICAgICAqIGRhdGEgY2FuIGJlIGVuY29kZWQgdG8gYml0cyBpbiB0aGUgUVIgY29kZSBzdGFuZGFyZC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIE1vZGUkMSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzdHJpbmdWYWx1ZSwgY2hhcmFjdGVyQ291bnRCaXRzRm9yVmVyc2lvbnMsIGJpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jaGFyYWN0ZXJDb3VudEJpdHNGb3JWZXJzaW9ucyA9IGNoYXJhY3RlckNvdW50Qml0c0ZvclZlcnNpb25zO1xuICAgICAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgICAgIE1vZGUkMS5GT1JfQklUUy5zZXQoYml0cywgdGhpcyk7XG4gICAgICAgICAgICBNb2RlJDEuRk9SX1ZBTFVFLnNldCh2YWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBiaXRzIGZvdXIgYml0cyBlbmNvZGluZyBhIFFSIENvZGUgZGF0YSBtb2RlXG4gICAgICAgICAqIEByZXR1cm4gTW9kZSBlbmNvZGVkIGJ5IHRoZXNlIGJpdHNcbiAgICAgICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgYml0cyBkbyBub3QgY29ycmVzcG9uZCB0byBhIGtub3duIG1vZGVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmb3JCaXRzKGJpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgbW9kZSA9IE1vZGUkMS5GT1JfQklUUy5nZXQoYml0cyk7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBtb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB2ZXJzaW9uIHZlcnNpb24gaW4gcXVlc3Rpb25cbiAgICAgICAgICogQHJldHVybiBudW1iZXIgb2YgYml0cyB1c2VkLCBpbiB0aGlzIFFSIENvZGUgc3ltYm9sIHtAbGluayBWZXJzaW9ufSwgdG8gZW5jb2RlIHRoZVxuICAgICAgICAgKiAgICAgICAgIGNvdW50IG9mIGNoYXJhY3RlcnMgdGhhdCB3aWxsIGZvbGxvdyBlbmNvZGVkIGluIHRoaXMgTW9kZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2hhcmFjdGVyQ291bnRCaXRzKHZlcnNpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSB2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAodmVyc2lvbk51bWJlciA8PSA5KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZlcnNpb25OdW1iZXIgPD0gMjYpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJhY3RlckNvdW50Qml0c0ZvclZlcnNpb25zW29mZnNldF07XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRCaXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0cztcbiAgICAgICAgfVxuICAgICAgICBlcXVhbHMobykge1xuICAgICAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIE1vZGUkMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvdGhlciA9IG87XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNb2RlJDEuRk9SX0JJVFMgPSBuZXcgTWFwKCk7XG4gICAgTW9kZSQxLkZPUl9WQUxVRSA9IG5ldyBNYXAoKTtcbiAgICBNb2RlJDEuVEVSTUlOQVRPUiA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5URVJNSU5BVE9SLCAnVEVSTUlOQVRPUicsIEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pLCAweDAwKTsgLy8gTm90IHJlYWxseSBhIG1vZGUuLi5cbiAgICBNb2RlJDEuTlVNRVJJQyA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5OVU1FUklDLCAnTlVNRVJJQycsIEludDMyQXJyYXkuZnJvbShbMTAsIDEyLCAxNF0pLCAweDAxKTtcbiAgICBNb2RlJDEuQUxQSEFOVU1FUklDID0gbmV3IE1vZGUkMShNb2RlVmFsdWVzLkFMUEhBTlVNRVJJQywgJ0FMUEhBTlVNRVJJQycsIEludDMyQXJyYXkuZnJvbShbOSwgMTEsIDEzXSksIDB4MDIpO1xuICAgIE1vZGUkMS5TVFJVQ1RVUkVEX0FQUEVORCA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5TVFJVQ1RVUkVEX0FQUEVORCwgJ1NUUlVDVFVSRURfQVBQRU5EJywgSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSksIDB4MDMpOyAvLyBOb3Qgc3VwcG9ydGVkXG4gICAgTW9kZSQxLkJZVEUgPSBuZXcgTW9kZSQxKE1vZGVWYWx1ZXMuQllURSwgJ0JZVEUnLCBJbnQzMkFycmF5LmZyb20oWzgsIDE2LCAxNl0pLCAweDA0KTtcbiAgICBNb2RlJDEuRUNJID0gbmV3IE1vZGUkMShNb2RlVmFsdWVzLkVDSSwgJ0VDSScsIEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pLCAweDA3KTsgLy8gY2hhcmFjdGVyIGNvdW50cyBkb24ndCBhcHBseVxuICAgIE1vZGUkMS5LQU5KSSA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5LQU5KSSwgJ0tBTkpJJywgSW50MzJBcnJheS5mcm9tKFs4LCAxMCwgMTJdKSwgMHgwOCk7XG4gICAgTW9kZSQxLkZOQzFfRklSU1RfUE9TSVRJT04gPSBuZXcgTW9kZSQxKE1vZGVWYWx1ZXMuRk5DMV9GSVJTVF9QT1NJVElPTiwgJ0ZOQzFfRklSU1RfUE9TSVRJT04nLCBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKSwgMHgwNSk7XG4gICAgTW9kZSQxLkZOQzFfU0VDT05EX1BPU0lUSU9OID0gbmV3IE1vZGUkMShNb2RlVmFsdWVzLkZOQzFfU0VDT05EX1BPU0lUSU9OLCAnRk5DMV9TRUNPTkRfUE9TSVRJT04nLCBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKSwgMHgwOSk7XG4gICAgLyoqIFNlZSBHQlQgMTgyODQtMjAwMDsgXCJIYW56aVwiIGlzIGEgdHJhbnNsaXRlcmF0aW9uIG9mIHRoaXMgbW9kZSBuYW1lLiAqL1xuICAgIE1vZGUkMS5IQU5aSSA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5IQU5aSSwgJ0hBTlpJJywgSW50MzJBcnJheS5mcm9tKFs4LCAxMCwgMTJdKSwgMHgwRCk7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qaW1wb3J0IGphdmEuaW8uVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbjsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbjsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5MaXN0OyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuICAgIC8qKlxuICAgICAqIDxwPlFSIENvZGVzIGNhbiBlbmNvZGUgdGV4dCBhcyBiaXRzIGluIG9uZSBvZiBzZXZlcmFsIG1vZGVzLCBhbmQgY2FuIHVzZSBtdWx0aXBsZSBtb2Rlc1xuICAgICAqIGluIG9uZSBRUiBDb2RlLiBUaGlzIGNsYXNzIGRlY29kZXMgdGhlIGJpdHMgYmFjayBpbnRvIHRleHQuPC9wPlxuICAgICAqXG4gICAgICogPHA+U2VlIElTTyAxODAwNDoyMDA2LCA2LjQuMyAtIDYuNC43PC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEge1xuICAgICAgICBzdGF0aWMgZGVjb2RlKGJ5dGVzLCB2ZXJzaW9uLCBlY0xldmVsLCBoaW50cykge1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IG5ldyBCaXRTb3VyY2UoYnl0ZXMpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBieXRlU2VnbWVudHMgPSBuZXcgQXJyYXkoKTsgLy8gMVxuICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IEkgZG8gbm90IHVzZSBjb25zdHJ1Y3RvciB3aXRoIHNpemUgMSBhcyBpbiBvcmlnaW5hbCBKYXZhIG1lYW5zIGNhcGFjaXR5IGFuZCB0aGUgYXJyYXkgbGVuZ3RoIGlzIGNoZWNrZWQgYmVsb3dcbiAgICAgICAgICAgIGxldCBzeW1ib2xTZXF1ZW5jZSA9IC0xO1xuICAgICAgICAgICAgbGV0IHBhcml0eURhdGEgPSAtMTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0kgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBmYzFJbkVmZmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBtb2RlO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hpbGUgc3RpbGwgYW5vdGhlciBzZWdtZW50IHRvIHJlYWQuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPSywgYXNzdW1lIHdlJ3JlIGRvbmUuIFJlYWxseSwgYSBURVJNSU5BVE9SIG1vZGUgc2hvdWxkIGhhdmUgYmVlbiByZWNvcmRlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gTW9kZSQxLlRFUk1JTkFUT1I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RlQml0cyA9IGJpdHMucmVhZEJpdHMoNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gTW9kZSQxLmZvckJpdHMobW9kZUJpdHMpOyAvLyBtb2RlIGlzIGVuY29kZWQgYnkgNCBiaXRzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5URVJNSU5BVE9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuRk5DMV9GSVJTVF9QT1NJVElPTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLkZOQzFfU0VDT05EX1BPU0lUSU9OOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIGxpdHRsZSB3aXRoIEZOQzEgZXhjZXB0IGFsdGVyIHRoZSBwYXJzZWQgcmVzdWx0IGEgYml0IGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjMUluRWZmZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLlNUUlVDVFVSRURfQVBQRU5EOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXF1ZW5jZSBudW1iZXIgYW5kIHBhcml0eSBpcyBhZGRlZCBsYXRlciB0byB0aGUgcmVzdWx0IG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBuZXh0IDggYml0cyAoc3ltYm9sIHNlcXVlbmNlICMpIGFuZCA4IGJpdHMgKGRhdGE6IHBhcml0eSksIHRoZW4gY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xTZXF1ZW5jZSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyaXR5RGF0YSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5FQ0k6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgZG9lc24ndCBhcHBseSB0byBFQ0lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5wYXJzZUVDSVZhbHVlKGJpdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0kgPSBDaGFyYWN0ZXJTZXRFQ0kuZ2V0Q2hhcmFjdGVyU2V0RUNJQnlWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0kgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLkhBTlpJOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGhhbmRsZSBIYW56aSBtb2RlIHdoaWNoIGRvZXMgbm90IHN0YXJ0IHdpdGggY2hhcmFjdGVyIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hpbmVzZSBtb2RlIGNvbnRhaW5zIGEgc3ViIHNldCBpbmRpY2F0b3IgcmlnaHQgYWZ0ZXIgbW9kZSBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJzZXQgPSBiaXRzLnJlYWRCaXRzKDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50SGFuemkgPSBiaXRzLnJlYWRCaXRzKG1vZGUuZ2V0Q2hhcmFjdGVyQ291bnRCaXRzKHZlcnNpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2V0ID09PSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuR0IyMzEyX1NVQlNFVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuZGVjb2RlSGFuemlTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnRIYW56aSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcIk5vcm1hbFwiIFFSIGNvZGUgbW9kZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG93IG1hbnkgY2hhcmFjdGVycyB3aWxsIGZvbGxvdywgZW5jb2RlZCBpbiB0aGlzIG1vZGU/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBiaXRzLnJlYWRCaXRzKG1vZGUuZ2V0Q2hhcmFjdGVyQ291bnRCaXRzKHZlcnNpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuTlVNRVJJQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5kZWNvZGVOdW1lcmljU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5BTFBIQU5VTUVSSUM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuZGVjb2RlQWxwaGFudW1lcmljU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50LCBmYzFJbkVmZmVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuQllURTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5kZWNvZGVCeXRlU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50LCBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJLCBieXRlU2VnbWVudHMsIGhpbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5LQU5KSTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5kZWNvZGVLYW5qaVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChtb2RlICE9PSBNb2RlJDEuVEVSTUlOQVRPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWFlIC8qOiBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIC8vIGZyb20gcmVhZEJpdHMoKSBjYWxsc1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlclJlc3VsdChieXRlcywgcmVzdWx0LnRvU3RyaW5nKCksIGJ5dGVTZWdtZW50cy5sZW5ndGggPT09IDAgPyBudWxsIDogYnl0ZVNlZ21lbnRzLCBlY0xldmVsID09PSBudWxsID8gbnVsbCA6IGVjTGV2ZWwudG9TdHJpbmcoKSwgc3ltYm9sU2VxdWVuY2UsIHBhcml0eURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgc3BlY2lmaWNhdGlvbiBHQlQgMTgyODQtMjAwMFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUhhbnppU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIC8vIERvbid0IGNyYXNoIHRyeWluZyB0byByZWFkIG1vcmUgYml0cyB0aGFuIHdlIGhhdmUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgaWYgKGNvdW50ICogMTMgPiBiaXRzLmF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRWFjaCBjaGFyYWN0ZXIgd2lsbCByZXF1aXJlIDIgYnl0ZXMuIFJlYWQgdGhlIGNoYXJhY3RlcnMgYXMgMi1ieXRlIHBhaXJzXG4gICAgICAgICAgICAvLyBhbmQgZGVjb2RlIGFzIEdCMjMxMiBhZnRlcndhcmRzXG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheSgyICogY291bnQpO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRWFjaCAxMyBiaXRzIGVuY29kZXMgYSAyLWJ5dGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgY29uc3QgdHdvQnl0ZXMgPSBiaXRzLnJlYWRCaXRzKDEzKTtcbiAgICAgICAgICAgICAgICBsZXQgYXNzZW1ibGVkVHdvQnl0ZXMgPSAoKCh0d29CeXRlcyAvIDB4MDYwKSA8PCA4KSAmIDB4RkZGRkZGRkYpIHwgKHR3b0J5dGVzICUgMHgwNjApO1xuICAgICAgICAgICAgICAgIGlmIChhc3NlbWJsZWRUd29CeXRlcyA8IDB4MDAzQkYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIDB4QTFBMSB0byAweEFBRkUgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgYXNzZW1ibGVkVHdvQnl0ZXMgKz0gMHgwQTFBMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHRoZSAweEIwQTEgdG8gMHhGQUZFIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGFzc2VtYmxlZFR3b0J5dGVzICs9IDB4MEE2QTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gLyooYnl0ZSkgKi8gKChhc3NlbWJsZWRUd29CeXRlcyA+PiA4KSAmIDB4RkYpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAxXSA9IC8qKGJ5dGUpICovIChhc3NlbWJsZWRUd29CeXRlcyAmIDB4RkYpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmcuZGVjb2RlKGJ1ZmZlciwgU3RyaW5nVXRpbHMuR0IyMzEyKSk7XG4gICAgICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IFRPRE86IGltcGxlbWVudCBHQjIzMTIgZGVjb2RlLiBTdHJpbmdWaWV3IGZyb20gTUROIGNvdWxkIGJlIGEgc3RhcnRpbmcgcG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkIC8qOiBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKGlnbm9yZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNvZGVLYW5qaVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCAvKmludCovKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBjcmFzaCB0cnlpbmcgdG8gcmVhZCBtb3JlIGJpdHMgdGhhbiB3ZSBoYXZlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIGlmIChjb3VudCAqIDEzID4gYml0cy5hdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVhY2ggY2hhcmFjdGVyIHdpbGwgcmVxdWlyZSAyIGJ5dGVzLiBSZWFkIHRoZSBjaGFyYWN0ZXJzIGFzIDItYnl0ZSBwYWlyc1xuICAgICAgICAgICAgLy8gYW5kIGRlY29kZSBhcyBTaGlmdF9KSVMgYWZ0ZXJ3YXJkc1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMiAqIGNvdW50KTtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggMTMgYml0cyBlbmNvZGVzIGEgMi1ieXRlIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGNvbnN0IHR3b0J5dGVzID0gYml0cy5yZWFkQml0cygxMyk7XG4gICAgICAgICAgICAgICAgbGV0IGFzc2VtYmxlZFR3b0J5dGVzID0gKCgodHdvQnl0ZXMgLyAweDBDMCkgPDwgOCkgJiAweEZGRkZGRkZGKSB8ICh0d29CeXRlcyAlIDB4MEMwKTtcbiAgICAgICAgICAgICAgICBpZiAoYXNzZW1ibGVkVHdvQnl0ZXMgPCAweDAxRjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHRoZSAweDgxNDAgdG8gMHg5RkZDIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGFzc2VtYmxlZFR3b0J5dGVzICs9IDB4MDgxNDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgMHhFMDQwIHRvIDB4RUJCRiByYW5nZVxuICAgICAgICAgICAgICAgICAgICBhc3NlbWJsZWRUd29CeXRlcyArPSAweDBDMTQwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IC8qKGJ5dGUpICovIChhc3NlbWJsZWRUd29CeXRlcyA+PiA4KTtcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAvKihieXRlKSAqLyBhc3NlbWJsZWRUd29CeXRlcztcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2hpZnRfSklTIG1heSBub3QgYmUgc3VwcG9ydGVkIGluIHNvbWUgZW52aXJvbm1lbnRzOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZ0VuY29kaW5nLmRlY29kZShidWZmZXIsIFN0cmluZ1V0aWxzLlNISUZUX0pJUykpO1xuICAgICAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBUT0RPOiBpbXBsZW1lbnQgU0hJRlRfSklTIGRlY29kZS4gU3RyaW5nVmlldyBmcm9tIE1ETiBjb3VsZCBiZSBhIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbihpZ25vcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjb2RlQnl0ZVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCAvKmludCovLCBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJLCBieXRlU2VnbWVudHMsIGhpbnRzKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBjcmFzaCB0cnlpbmcgdG8gcmVhZCBtb3JlIGJpdHMgdGhhbiB3ZSBoYXZlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIGlmICg4ICogY291bnQgPiBiaXRzLmF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVhZEJ5dGVzW2ldID0gLyooYnl0ZSkgKi8gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbmNvZGluZztcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVyU2V0RUNJID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNwZWMgaXNuJ3QgY2xlYXIgb24gdGhpcyBtb2RlOyBzZWVcbiAgICAgICAgICAgICAgICAvLyBzZWN0aW9uIDYuNC41OiB0IGRvZXMgbm90IHNheSB3aGljaCBlbmNvZGluZyB0byBhc3N1bWluZ1xuICAgICAgICAgICAgICAgIC8vIHVwb24gZGVjb2RpbmcuIEkgaGF2ZSBzZWVuIElTTy04ODU5LTEgdXNlZCBhcyB3ZWxsIGFzXG4gICAgICAgICAgICAgICAgLy8gU2hpZnRfSklTIC0tIHdpdGhvdXQgYW55dGhpbmcgbGlrZSBhbiBFQ0kgZGVzaWduYXRvciB0b1xuICAgICAgICAgICAgICAgIC8vIGdpdmUgYSBoaW50LlxuICAgICAgICAgICAgICAgIGVuY29kaW5nID0gU3RyaW5nVXRpbHMuZ3Vlc3NFbmNvZGluZyhyZWFkQnl0ZXMsIGhpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nID0gY3VycmVudENoYXJhY3RlclNldEVDSS5nZXROYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmcuZGVjb2RlKHJlYWRCeXRlcywgZW5jb2RpbmcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkIC8qOiBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKGlnbm9yZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnl0ZVNlZ21lbnRzLnB1c2gocmVhZEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgdG9BbHBoYU51bWVyaWNDaGFyKHZhbHVlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuQUxQSEFOVU1FUklDX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuQUxQSEFOVU1FUklDX0NIQVJTW3ZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjb2RlQWxwaGFudW1lcmljU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50IC8qaW50Ki8sIGZjMUluRWZmZWN0KSB7XG4gICAgICAgICAgICAvLyBSZWFkIHR3byBjaGFyYWN0ZXJzIGF0IGEgdGltZVxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSByZXN1bHQubGVuZ3RoKCk7XG4gICAgICAgICAgICB3aGlsZSAoY291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCAxMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUd29DaGFyc0JpdHMgPSBiaXRzLnJlYWRCaXRzKDExKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIoTWF0aC5mbG9vcihuZXh0VHdvQ2hhcnNCaXRzIC8gNDUpKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEudG9BbHBoYU51bWVyaWNDaGFyKG5leHRUd29DaGFyc0JpdHMgJSA0NSkpO1xuICAgICAgICAgICAgICAgIGNvdW50IC09IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IG9uZSBjaGFyYWN0ZXIgbGVmdFxuICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgNikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLnRvQWxwaGFOdW1lcmljQ2hhcihiaXRzLnJlYWRCaXRzKDYpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZWUgc2VjdGlvbiA2LjQuOC4xLCA2LjQuOC4yXG4gICAgICAgICAgICBpZiAoZmMxSW5FZmZlY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIG1hc3NhZ2UgdGhlIHJlc3VsdCBhIGJpdCBpZiBpbiBhbiBGTkMxIG1vZGU6XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgcmVzdWx0Lmxlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5jaGFyQXQoaSkgPT09ICclJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCByZXN1bHQubGVuZ3RoKCkgLSAxICYmIHJlc3VsdC5jaGFyQXQoaSArIDEpID09PSAnJScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAlJSBpcyByZW5kZXJlZCBhcyAlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRlbGV0ZUNoYXJBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBhbHBoYSBtb2RlLCAlIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gRk5DMSBzZXBhcmF0b3IgMHgxRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRDaGFyQXQoaSwgU3RyaW5nLmZyb21DaGFyQ29kZSgweDFEKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlY29kZU51bWVyaWNTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQgLyppbnQqLykge1xuICAgICAgICAgICAgLy8gUmVhZCB0aHJlZSBkaWdpdHMgYXQgYSB0aW1lXG4gICAgICAgICAgICB3aGlsZSAoY291bnQgPj0gMykge1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggMTAgYml0cyBlbmNvZGVzIHRocmVlIGRpZ2l0c1xuICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0aHJlZURpZ2l0c0JpdHMgPSBiaXRzLnJlYWRCaXRzKDEwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhyZWVEaWdpdHNCaXRzID49IDEwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIoTWF0aC5mbG9vcih0aHJlZURpZ2l0c0JpdHMgLyAxMDApKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEudG9BbHBoYU51bWVyaWNDaGFyKE1hdGguZmxvb3IodGhyZWVEaWdpdHNCaXRzIC8gMTApICUgMTApKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIodGhyZWVEaWdpdHNCaXRzICUgMTApKTtcbiAgICAgICAgICAgICAgICBjb3VudCAtPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gVHdvIGRpZ2l0cyBsZWZ0IG92ZXIgdG8gcmVhZCwgZW5jb2RlZCBpbiA3IGJpdHNcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0d29EaWdpdHNCaXRzID0gYml0cy5yZWFkQml0cyg3KTtcbiAgICAgICAgICAgICAgICBpZiAodHdvRGlnaXRzQml0cyA+PSAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIoTWF0aC5mbG9vcih0d29EaWdpdHNCaXRzIC8gMTApKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEudG9BbHBoYU51bWVyaWNDaGFyKHR3b0RpZ2l0c0JpdHMgJSAxMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmUgZGlnaXQgbGVmdCBvdmVyIHRvIHJlYWRcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkaWdpdEJpdHMgPSBiaXRzLnJlYWRCaXRzKDQpO1xuICAgICAgICAgICAgICAgIGlmIChkaWdpdEJpdHMgPj0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIoZGlnaXRCaXRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHBhcnNlRUNJVmFsdWUoYml0cykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgIGlmICgoZmlyc3RCeXRlICYgMHg4MCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBqdXN0IG9uZSBieXRlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0Qnl0ZSAmIDB4N0Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZpcnN0Qnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgLy8gdHdvIGJ5dGVzXG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vjb25kQnl0ZSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoKGZpcnN0Qnl0ZSAmIDB4M0YpIDw8IDgpICYgMHhGRkZGRkZGRikgfCBzZWNvbmRCeXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChmaXJzdEJ5dGUgJiAweEUwKSA9PT0gMHhDMCkge1xuICAgICAgICAgICAgICAgIC8vIHRocmVlIGJ5dGVzXG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vjb25kVGhpcmRCeXRlcyA9IGJpdHMucmVhZEJpdHMoMTYpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKChmaXJzdEJ5dGUgJiAweDFGKSA8PCAxNikgJiAweEZGRkZGRkZGKSB8IHNlY29uZFRoaXJkQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VlIElTTyAxODAwNDoyMDA2LCA2LjQuNCBUYWJsZSA1XG4gICAgICovXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLkFMUEhBTlVNRVJJQ19DSEFSUyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogJCUqKy0uLzonO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5HQjIzMTJfU1VCU0VUID0gMTtcbiAgICAvLyBmdW5jdGlvbiBVaW50OEFycmF5VG9TdHJpbmcoYTogVWludDhBcnJheSk6IHN0cmluZyB7XG4gICAgLy8gICAgIGNvbnN0IENIVU5LX1NaID0gMHg4MDAwO1xuICAgIC8vICAgICBjb25zdCBjID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAvLyAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGEubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IENIVU5LX1NaKSB7XG4gICAgLy8gICAgICAgICBjLmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGEuc3ViYXJyYXkoaSwgaSArIENIVU5LX1NaKSkpO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHJldHVybiBjLnRvU3RyaW5nKCk7XG4gICAgLy8gfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBNZXRhLWRhdGEgY29udGFpbmVyIGZvciBRUiBDb2RlIGRlY29kaW5nLiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBtYXkgYmUgdXNlZCB0byBjb252ZXkgaW5mb3JtYXRpb24gYmFjayB0byB0aGVcbiAgICAgKiBkZWNvZGluZyBjYWxsZXIuIENhbGxlcnMgYXJlIGV4cGVjdGVkIHRvIHByb2Nlc3MgdGhpcy5cbiAgICAgKlxuICAgICAqIEBzZWUgY29tLmdvb2dsZS56eGluZy5jb21tb24uRGVjb2RlclJlc3VsdCNnZXRPdGhlcigpXG4gICAgICovXG4gICAgY2xhc3MgUVJDb2RlRGVjb2Rlck1ldGFEYXRhIHtcbiAgICAgICAgY29uc3RydWN0b3IobWlycm9yZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWlycm9yZWQgPSBtaXJyb3JlZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBRUiBDb2RlIHdhcyBtaXJyb3JlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlzTWlycm9yZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taXJyb3JlZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgdGhlIHJlc3VsdCBwb2ludHMnIG9yZGVyIGNvcnJlY3Rpb24gZHVlIHRvIG1pcnJvcmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBvaW50cyBBcnJheSBvZiBwb2ludHMgdG8gYXBwbHkgbWlycm9yIGNvcnJlY3Rpb24gdG8uXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseU1pcnJvcmVkQ29ycmVjdGlvbihwb2ludHMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5taXJyb3JlZCB8fCBwb2ludHMgPT09IG51bGwgfHwgcG9pbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib3R0b21MZWZ0ID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRzWzJdO1xuICAgICAgICAgICAgcG9pbnRzWzJdID0gYm90dG9tTGVmdDtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gJ2ZpeCcgdG9wLWxlZnQgYW5kIGFsaWdubWVudCBwYXR0ZXJuLlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgLyoqXG4gICAgICogPHA+VGhlIG1haW4gY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyBRUiBDb2RlIGRlY29kaW5nIC0tIGFzIG9wcG9zZWQgdG8gbG9jYXRpbmcgYW5kIGV4dHJhY3RpbmdcbiAgICAgKiB0aGUgUVIgQ29kZSBmcm9tIGFuIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGVjb2RlciQyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLnJzRGVjb2RlciA9IG5ldyBSZWVkU29sb21vbkRlY29kZXIoR2VuZXJpY0dGLlFSX0NPREVfRklFTERfMjU2KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwdWJsaWMgZGVjb2RlKGltYWdlOiBib29sZWFuW11bXSk6IERlY29kZXJSZXN1bHQgLyp0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiovIHtcbiAgICAgICAgLy8gICByZXR1cm4gZGVjb2RlKGltYWdlLCBudWxsKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5Db252ZW5pZW5jZSBtZXRob2QgdGhhdCBjYW4gZGVjb2RlIGEgUVIgQ29kZSByZXByZXNlbnRlZCBhcyBhIDJEIGFycmF5IG9mIGJvb2xlYW5zLlxuICAgICAgICAgKiBcInRydWVcIiBpcyB0YWtlbiB0byBtZWFuIGEgYmxhY2sgbW9kdWxlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlIGJvb2xlYW5zIHJlcHJlc2VudGluZyB3aGl0ZS9ibGFjayBRUiBDb2RlIG1vZHVsZXNcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIGRlY29kaW5nIGhpbnRzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gaW5mbHVlbmNlIGRlY29kaW5nXG4gICAgICAgICAqIEByZXR1cm4gdGV4dCBhbmQgYnl0ZXMgZW5jb2RlZCB3aXRoaW4gdGhlIFFSIENvZGVcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIFFSIENvZGUgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVCb29sZWFuQXJyYXkoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVCaXRNYXRyaXgoQml0TWF0cml4LnBhcnNlRnJvbUJvb2xlYW5BcnJheShpbWFnZSksIGhpbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwdWJsaWMgZGVjb2RlQml0TWF0cml4KGJpdHM6IEJpdE1hdHJpeCk6IERlY29kZXJSZXN1bHQgLyp0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiovIHtcbiAgICAgICAgLy8gICByZXR1cm4gZGVjb2RlKGJpdHMsIG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRlY29kZXMgYSBRUiBDb2RlIHJlcHJlc2VudGVkIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0uIEEgMSBvciBcInRydWVcIiBpcyB0YWtlbiB0byBtZWFuIGEgYmxhY2sgbW9kdWxlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJpdHMgYm9vbGVhbnMgcmVwcmVzZW50aW5nIHdoaXRlL2JsYWNrIFFSIENvZGUgbW9kdWxlc1xuICAgICAgICAgKiBAcGFyYW0gaGludHMgZGVjb2RpbmcgaGludHMgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBpbmZsdWVuY2UgZGVjb2RpbmdcbiAgICAgICAgICogQHJldHVybiB0ZXh0IGFuZCBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgUVIgQ29kZVxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiB0aGUgUVIgQ29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUJpdE1hdHJpeChiaXRzLCBoaW50cykge1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IGEgcGFyc2VyIGFuZCByZWFkIHZlcnNpb24sIGVycm9yLWNvcnJlY3Rpb24gbGV2ZWxcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBCaXRNYXRyaXhQYXJzZXIkMShiaXRzKTtcbiAgICAgICAgICAgIGxldCBleCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUJpdE1hdHJpeFBhcnNlcihwYXJzZXIsIGhpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlIC8qOiBGb3JtYXRFeGNlcHRpb24sIENoZWNrc3VtRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICBleCA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgYml0IG1hdHJpeFxuICAgICAgICAgICAgICAgIHBhcnNlci5yZW1hc2soKTtcbiAgICAgICAgICAgICAgICAvLyBXaWxsIGJlIGF0dGVtcHRpbmcgYSBtaXJyb3JlZCByZWFkaW5nIG9mIHRoZSB2ZXJzaW9uIGFuZCBmb3JtYXQgaW5mby5cbiAgICAgICAgICAgICAgICBwYXJzZXIuc2V0TWlycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIFByZWVtcHRpdmVseSByZWFkIHRoZSB2ZXJzaW9uLlxuICAgICAgICAgICAgICAgIHBhcnNlci5yZWFkVmVyc2lvbigpO1xuICAgICAgICAgICAgICAgIC8vIFByZWVtcHRpdmVseSByZWFkIHRoZSBmb3JtYXQgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgcGFyc2VyLnJlYWRGb3JtYXRJbmZvcm1hdGlvbigpO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogU2luY2Ugd2UncmUgaGVyZSwgdGhpcyBtZWFucyB3ZSBoYXZlIHN1Y2Nlc3NmdWxseSBkZXRlY3RlZCBzb21lIGtpbmRcbiAgICAgICAgICAgICAgICAgKiBvZiB2ZXJzaW9uIGFuZCBmb3JtYXQgaW5mb3JtYXRpb24gd2hlbiBtaXJyb3JlZC4gVGhpcyBpcyBhIGdvb2Qgc2lnbixcbiAgICAgICAgICAgICAgICAgKiB0aGF0IHRoZSBRUiBjb2RlIG1heSBiZSBtaXJyb3JlZCwgYW5kIHdlIHNob3VsZCB0cnkgb25jZSBtb3JlIHdpdGggYVxuICAgICAgICAgICAgICAgICAqIG1pcnJvcmVkIGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLy8gUHJlcGFyZSBmb3IgYSBtaXJyb3JlZCByZWFkaW5nLlxuICAgICAgICAgICAgICAgIHBhcnNlci5taXJyb3IoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRlY29kZUJpdE1hdHJpeFBhcnNlcihwYXJzZXIsIGhpbnRzKTtcbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzISBOb3RpZnkgdGhlIGNhbGxlciB0aGF0IHRoZSBjb2RlIHdhcyBtaXJyb3JlZC5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0T3RoZXIobmV3IFFSQ29kZURlY29kZXJNZXRhRGF0YSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlIC8qRm9ybWF0RXhjZXB0aW9uIHwgQ2hlY2tzdW1FeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIC8vIFRocm93IHRoZSBleGNlcHRpb24gZnJvbSB0aGUgb3JpZ2luYWwgcmVhZGluZ1xuICAgICAgICAgICAgICAgIGlmIChleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVCaXRNYXRyaXhQYXJzZXIocGFyc2VyLCBoaW50cykge1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHBhcnNlci5yZWFkVmVyc2lvbigpO1xuICAgICAgICAgICAgY29uc3QgZWNMZXZlbCA9IHBhcnNlci5yZWFkRm9ybWF0SW5mb3JtYXRpb24oKS5nZXRFcnJvckNvcnJlY3Rpb25MZXZlbCgpO1xuICAgICAgICAgICAgLy8gUmVhZCBjb2Rld29yZHNcbiAgICAgICAgICAgIGNvbnN0IGNvZGV3b3JkcyA9IHBhcnNlci5yZWFkQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAvLyBTZXBhcmF0ZSBpbnRvIGRhdGEgYmxvY2tzXG4gICAgICAgICAgICBjb25zdCBkYXRhQmxvY2tzID0gRGF0YUJsb2NrJDEuZ2V0RGF0YUJsb2Nrcyhjb2Rld29yZHMsIHZlcnNpb24sIGVjTGV2ZWwpO1xuICAgICAgICAgICAgLy8gQ291bnQgdG90YWwgbnVtYmVyIG9mIGRhdGEgYnl0ZXNcbiAgICAgICAgICAgIGxldCB0b3RhbEJ5dGVzID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGF0YUJsb2NrIG9mIGRhdGFCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICB0b3RhbEJ5dGVzICs9IGRhdGFCbG9jay5nZXROdW1EYXRhQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsQnl0ZXMpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdE9mZnNldCA9IDA7XG4gICAgICAgICAgICAvLyBFcnJvci1jb3JyZWN0IGFuZCBjb3B5IGRhdGEgYmxvY2tzIHRvZ2V0aGVyIGludG8gYSBzdHJlYW0gb2YgYnl0ZXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGF0YUJsb2NrIG9mIGRhdGFCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2Rld29yZEJ5dGVzID0gZGF0YUJsb2NrLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bURhdGFDb2Rld29yZHMgPSBkYXRhQmxvY2suZ2V0TnVtRGF0YUNvZGV3b3JkcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ycmVjdEVycm9ycyhjb2Rld29yZEJ5dGVzLCBudW1EYXRhQ29kZXdvcmRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRCeXRlc1tyZXN1bHRPZmZzZXQrK10gPSBjb2Rld29yZEJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlY29kZSB0aGUgY29udGVudHMgb2YgdGhhdCBzdHJlYW0gb2YgYnl0ZXNcbiAgICAgICAgICAgIHJldHVybiBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuZGVjb2RlKHJlc3VsdEJ5dGVzLCB2ZXJzaW9uLCBlY0xldmVsLCBoaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkdpdmVuIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIHJlY2VpdmVkLCBwb3NzaWJseSBjb3JydXB0ZWQgYnkgZXJyb3JzLCBhdHRlbXB0cyB0b1xuICAgICAgICAgKiBjb3JyZWN0IHRoZSBlcnJvcnMgaW4tcGxhY2UgdXNpbmcgUmVlZC1Tb2xvbW9uIGVycm9yIGNvcnJlY3Rpb24uPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29kZXdvcmRCeXRlcyBkYXRhIGFuZCBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcGFyYW0gbnVtRGF0YUNvZGV3b3JkcyBudW1iZXIgb2YgY29kZXdvcmRzIHRoYXQgYXJlIGRhdGEgYnl0ZXNcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBjb3JyZWN0RXJyb3JzKGNvZGV3b3JkQnl0ZXMsIG51bURhdGFDb2Rld29yZHMgLyppbnQqLykge1xuICAgICAgICAgICAgLy8gY29uc3QgbnVtQ29kZXdvcmRzID0gY29kZXdvcmRCeXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBGaXJzdCByZWFkIGludG8gYW4gYXJyYXkgb2YgaW50c1xuICAgICAgICAgICAgY29uc3QgY29kZXdvcmRzSW50cyA9IG5ldyBJbnQzMkFycmF5KGNvZGV3b3JkQnl0ZXMpO1xuICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IG5vdCByZWFseSBuZWNlc3NhcnkgdG8gdHJhbnNmb3JtIHRvIGludHM/IGNvdWxkIHJlZGVzaWduIGV2ZXJ5dGhpbmcgdG8gd29yayB3aXRoIHVuc2lnbmVkIGJ5dGVzP1xuICAgICAgICAgICAgLy8gY29uc3QgY29kZXdvcmRzSW50cyA9IG5ldyBJbnQzMkFycmF5KG51bUNvZGV3b3JkcylcbiAgICAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgIC8vICAgY29kZXdvcmRzSW50c1tpXSA9IGNvZGV3b3JkQnl0ZXNbaV0gJiAweEZGXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMucnNEZWNvZGVyLmRlY29kZShjb2Rld29yZHNJbnRzLCBjb2Rld29yZEJ5dGVzLmxlbmd0aCAtIG51bURhdGFDb2Rld29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IFJlZWRTb2xvbW9uRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2hlY2tzdW1FeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvcHkgYmFjayBpbnRvIGFycmF5IG9mIGJ5dGVzIC0tIG9ubHkgbmVlZCB0byB3b3JyeSBhYm91dCB0aGUgYnl0ZXMgdGhhdCB3ZXJlIGRhdGFcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgZXJyb3JzIGluIHRoZSBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZEJ5dGVzW2ldID0gLyooYnl0ZSkgKi8gY29kZXdvcmRzSW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGFuIGFsaWdubWVudCBwYXR0ZXJuLCB3aGljaCBhcmUgdGhlIHNtYWxsZXIgc3F1YXJlIHBhdHRlcm5zIGZvdW5kIGluXG4gICAgICogYWxsIGJ1dCB0aGUgc2ltcGxlc3QgUVIgQ29kZXMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBBbGlnbm1lbnRQYXR0ZXJuIGV4dGVuZHMgUmVzdWx0UG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwb3NYIC8qZmxvYXQqLywgcG9zWSAvKmZsb2F0Ki8sIGVzdGltYXRlZE1vZHVsZVNpemUgLypmbG9hdCovKSB7XG4gICAgICAgICAgICBzdXBlcihwb3NYLCBwb3NZKTtcbiAgICAgICAgICAgIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IGVzdGltYXRlZE1vZHVsZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRldGVybWluZXMgaWYgdGhpcyBhbGlnbm1lbnQgcGF0dGVybiBcImFib3V0IGVxdWFsc1wiIGFuIGFsaWdubWVudCBwYXR0ZXJuIGF0IHRoZSBzdGF0ZWRcbiAgICAgICAgICogcG9zaXRpb24gYW5kIHNpemUgLS0gbWVhbmluZywgaXQgaXMgYXQgbmVhcmx5IHRoZSBzYW1lIGNlbnRlciB3aXRoIG5lYXJseSB0aGUgc2FtZSBzaXplLjwvcD5cbiAgICAgICAgICovXG4gICAgICAgIGFib3V0RXF1YWxzKG1vZHVsZVNpemUgLypmbG9hdCovLCBpIC8qZmxvYXQqLywgaiAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhpIC0gdGhpcy5nZXRZKCkpIDw9IG1vZHVsZVNpemUgJiYgTWF0aC5hYnMoaiAtIHRoaXMuZ2V0WCgpKSA8PSBtb2R1bGVTaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlU2l6ZURpZmYgPSBNYXRoLmFicyhtb2R1bGVTaXplIC0gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZURpZmYgPD0gMS4wIHx8IG1vZHVsZVNpemVEaWZmIDw9IHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tYmluZXMgdGhpcyBvYmplY3QncyBjdXJyZW50IGVzdGltYXRlIG9mIGEgZmluZGVyIHBhdHRlcm4gcG9zaXRpb24gYW5kIG1vZHVsZSBzaXplXG4gICAgICAgICAqIHdpdGggYSBuZXcgZXN0aW1hdGUuIEl0IHJldHVybnMgYSBuZXcge0Bjb2RlIEZpbmRlclBhdHRlcm59IGNvbnRhaW5pbmcgYW4gYXZlcmFnZSBvZiB0aGUgdHdvLlxuICAgICAgICAgKi9cbiAgICAgICAgY29tYmluZUVzdGltYXRlKGkgLypmbG9hdCovLCBqIC8qZmxvYXQqLywgbmV3TW9kdWxlU2l6ZSAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkWCA9ICh0aGlzLmdldFgoKSArIGopIC8gMi4wO1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRZID0gKHRoaXMuZ2V0WSgpICsgaSkgLyAyLjA7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZE1vZHVsZVNpemUgPSAodGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplICsgbmV3TW9kdWxlU2l6ZSkgLyAyLjA7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsaWdubWVudFBhdHRlcm4oY29tYmluZWRYLCBjb21iaW5lZFksIGNvbWJpbmVkTW9kdWxlU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTGlzdDsqL1xuICAgIC8qKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgYXR0ZW1wdHMgdG8gZmluZCBhbGlnbm1lbnQgcGF0dGVybnMgaW4gYSBRUiBDb2RlLiBBbGlnbm1lbnQgcGF0dGVybnMgbG9vayBsaWtlIGZpbmRlclxuICAgICAqIHBhdHRlcm5zIGJ1dCBhcmUgc21hbGxlciBhbmQgYXBwZWFyIGF0IHJlZ3VsYXIgaW50ZXJ2YWxzIHRocm91Z2hvdXQgdGhlIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPkF0IHRoZSBtb21lbnQgdGhpcyBvbmx5IGxvb2tzIGZvciB0aGUgYm90dG9tLXJpZ2h0IGFsaWdubWVudCBwYXR0ZXJuLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRoaXMgaXMgbW9zdGx5IGEgc2ltcGxpZmllZCBjb3B5IG9mIHtAbGluayBGaW5kZXJQYXR0ZXJuRmluZGVyfS4gSXQgaXMgY29waWVkLFxuICAgICAqIHBhc3RlZCBhbmQgc3RyaXBwZWQgZG93biBoZXJlIGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlIGJ1dCBkb2VzIHVuZm9ydHVuYXRlbHkgZHVwbGljYXRlXG4gICAgICogc29tZSBjb2RlLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgaXMgdGhyZWFkLXNhZmUgYnV0IG5vdCByZWVudHJhbnQuIEVhY2ggdGhyZWFkIG11c3QgYWxsb2NhdGUgaXRzIG93biBvYmplY3QuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkNyZWF0ZXMgYSBmaW5kZXIgdGhhdCB3aWxsIGxvb2sgaW4gYSBwb3J0aW9uIG9mIHRoZSB3aG9sZSBpbWFnZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBpbWFnZSB0byBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIHN0YXJ0WCBsZWZ0IGNvbHVtbiBmcm9tIHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICAgICAgICAgKiBAcGFyYW0gc3RhcnRZIHRvcCByb3cgZnJvbSB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAgICAgICAgICogQHBhcmFtIHdpZHRoIHdpZHRoIG9mIHJlZ2lvbiB0byBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIGhlaWdodCBoZWlnaHQgb2YgcmVnaW9uIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gbW9kdWxlU2l6ZSBlc3RpbWF0ZWQgbW9kdWxlIHNpemUgc28gZmFyXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihpbWFnZSwgc3RhcnRYIC8qaW50Ki8sIHN0YXJ0WSAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgbW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIHJlc3VsdFBvaW50Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRYID0gc3RhcnRYO1xuICAgICAgICAgICAgdGhpcy5zdGFydFkgPSBzdGFydFk7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMubW9kdWxlU2l6ZSA9IG1vZHVsZVNpemU7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgPSByZXN1bHRQb2ludENhbGxiYWNrO1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJsZUNlbnRlcnMgPSBbXTsgLy8gbmV3IEFycmF5PGFueT4oNSkpXG4gICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogYXJyYXkgaW5pdGlhbGl6YXRpb24gd2l0aG91dCBzaXplIGFzIHRoZSBsZW5ndGggaXMgY2hlY2tlZCBiZWxvd1xuICAgICAgICAgICAgdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudCA9IG5ldyBJbnQzMkFycmF5KDMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5UaGlzIG1ldGhvZCBhdHRlbXB0cyB0byBmaW5kIHRoZSBib3R0b20tcmlnaHQgYWxpZ25tZW50IHBhdHRlcm4gaW4gdGhlIGltYWdlLiBJdCBpcyBhIGJpdCBtZXNzeSBzaW5jZVxuICAgICAgICAgKiBpdCdzIHByZXR0eSBwZXJmb3JtYW5jZS1jcml0aWNhbCBhbmQgc28gaXMgd3JpdHRlbiB0byBiZSBmYXN0IGZvcmVtb3N0LjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0gaWYgZm91bmRcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBub3QgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGZpbmQoKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFggPSB0aGlzLnN0YXJ0WDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgbWF4SiA9IHN0YXJ0WCArIHdpZHRoO1xuICAgICAgICAgICAgY29uc3QgbWlkZGxlSSA9IHRoaXMuc3RhcnRZICsgKGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgLy8gV2UgYXJlIGxvb2tpbmcgZm9yIGJsYWNrL3doaXRlL2JsYWNrIG1vZHVsZXMgaW4gMToxOjEgcmF0aW9cbiAgICAgICAgICAgIC8vIHRoaXMgdHJhY2tzIHRoZSBudW1iZXIgb2YgYmxhY2svd2hpdGUvYmxhY2sgbW9kdWxlcyBzZWVuIHNvIGZhclxuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudCA9IG5ldyBJbnQzMkFycmF5KDMpO1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICAgICAgZm9yIChsZXQgaUdlbiA9IDA7IGlHZW4gPCBoZWlnaHQ7IGlHZW4rKykge1xuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmcm9tIG1pZGRsZSBvdXR3YXJkc1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBtaWRkbGVJICsgKChpR2VuICYgMHgwMSkgPT09IDAgPyBNYXRoLmZsb29yKChpR2VuICsgMSkgLyAyKSA6IC1NYXRoLmZsb29yKChpR2VuICsgMSkgLyAyKSk7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IDA7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGogPSBzdGFydFg7XG4gICAgICAgICAgICAgICAgLy8gQnVybiBvZmYgbGVhZGluZyB3aGl0ZSBwaXhlbHMgYmVmb3JlIGFueXRoaW5nIGVsc2U7IGlmIHdlIHN0YXJ0IGluIHRoZSBtaWRkbGUgb2ZcbiAgICAgICAgICAgICAgICAvLyBhIHdoaXRlIHJ1biwgaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIGNvdW50IGl0cyBsZW5ndGgsIHNpbmNlIHdlIGRvbid0IGtub3cgaWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gd2hpdGUgcnVuIGNvbnRpbnVlZCB0byB0aGUgbGVmdCBvZiB0aGUgc3RhcnQgcG9pbnRcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IG1heEogJiYgIWltYWdlLmdldChqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbWF4Sikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFjayBwaXhlbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gMSkgeyAvLyBDb3VudGluZyBibGFjayBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gQ291bnRpbmcgd2hpdGUgcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gMikgeyAvLyBBIHdpbm5lcj9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHsgLy8gWWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maXJtZWQgPSB0aGlzLmhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGksIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maXJtZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IHN0YXRlQ291bnRbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbKytjdXJyZW50U3RhdGVdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBXaGl0ZSBwaXhlbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gMSkgeyAvLyBDb3VudGluZyBibGFjayBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbY3VycmVudFN0YXRlXSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlybWVkID0gdGhpcy5oYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpLCBtYXhKKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhtbSwgbm90aGluZyB3ZSBzYXcgd2FzIG9ic2VydmVkIGFuZCBjb25maXJtZWQgdHdpY2UuIElmIHdlIGhhZFxuICAgICAgICAgICAgLy8gYW55IGd1ZXNzIGF0IGFsbCwgcmV0dXJuIGl0LlxuICAgICAgICAgICAgaWYgKHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3NpYmxlQ2VudGVyc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIGNvdW50IG9mIGJsYWNrL3doaXRlL2JsYWNrIHBpeGVscyBqdXN0IHNlZW4gYW5kIGFuIGVuZCBwb3NpdGlvbixcbiAgICAgICAgICogZmlndXJlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGlzIGJsYWNrL3doaXRlL2JsYWNrIHJ1bi5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGVuZCAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gKGVuZCAtIHN0YXRlQ291bnRbMl0pIC0gc3RhdGVDb3VudFsxXSAvIDIuMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHN0YXRlQ291bnQgY291bnQgb2YgYmxhY2svd2hpdGUvYmxhY2sgcGl4ZWxzIGp1c3QgcmVhZFxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWZmIHRoZSBwcm9wb3J0aW9ucyBvZiB0aGUgY291bnRzIGlzIGNsb3NlIGVub3VnaCB0byB0aGUgMS8xLzEgcmF0aW9zXG4gICAgICAgICAqICAgICAgICAgdXNlZCBieSBhbGlnbm1lbnQgcGF0dGVybnMgdG8gYmUgY29uc2lkZXJlZCBhIG1hdGNoXG4gICAgICAgICAqL1xuICAgICAgICBmb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVTaXplID0gdGhpcy5tb2R1bGVTaXplO1xuICAgICAgICAgICAgY29uc3QgbWF4VmFyaWFuY2UgPSBtb2R1bGVTaXplIC8gMi4wO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbaV0pID49IG1heFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+QWZ0ZXIgYSBob3Jpem9udGFsIHNjYW4gZmluZHMgYSBwb3RlbnRpYWwgYWxpZ25tZW50IHBhdHRlcm4sIHRoaXMgbWV0aG9kXG4gICAgICAgICAqIFwiY3Jvc3MtY2hlY2tzXCIgYnkgc2Nhbm5pbmcgZG93biB2ZXJ0aWNhbGx5IHRocm91Z2ggdGhlIGNlbnRlciBvZiB0aGUgcG9zc2libGVcbiAgICAgICAgICogYWxpZ25tZW50IHBhdHRlcm4gdG8gc2VlIGlmIHRoZSBzYW1lIHByb3BvcnRpb24gaXMgZGV0ZWN0ZWQuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3RhcnRJIHJvdyB3aGVyZSBhbiBhbGlnbm1lbnQgcGF0dGVybiB3YXMgZGV0ZWN0ZWRcbiAgICAgICAgICogQHBhcmFtIGNlbnRlckogY2VudGVyIG9mIHRoZSBzZWN0aW9uIHRoYXQgYXBwZWFycyB0byBjcm9zcyBhbiBhbGlnbm1lbnQgcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0gbWF4Q291bnQgbWF4aW11bSByZWFzb25hYmxlIG51bWJlciBvZiBtb2R1bGVzIHRoYXQgc2hvdWxkIGJlXG4gICAgICAgICAqIG9ic2VydmVkIGluIGFueSByZWFkaW5nIHN0YXRlLCBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGUgaG9yaXpvbnRhbCBzY2FuXG4gICAgICAgICAqIEByZXR1cm4gdmVydGljYWwgY2VudGVyIG9mIGFsaWdubWVudCBwYXR0ZXJuLCBvciB7QGxpbmsgRmxvYXQjTmFOfSBpZiBub3QgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGNyb3NzQ2hlY2tWZXJ0aWNhbChzdGFydEkgLyppbnQqLywgY2VudGVySiAvKmludCovLCBtYXhDb3VudCAvKmludCovLCBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICAgICAgICBjb25zdCBtYXhJID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50ID0gdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudDtcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSAwO1xuICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgICAgIC8vIFN0YXJ0IGNvdW50aW5nIHVwIGZyb20gY2VudGVyXG4gICAgICAgICAgICBsZXQgaSA9IHN0YXJ0STtcbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbMV0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYWxyZWFkeSB0b28gbWFueSBtb2R1bGVzIGluIHRoaXMgc3RhdGUgb3IgcmFuIG9mZiB0aGUgZWRnZTpcbiAgICAgICAgICAgIGlmIChpIDwgMCB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiAhaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbMF0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgYWxzbyBjb3VudCBkb3duIGZyb20gY2VudGVyXG4gICAgICAgICAgICBpID0gc3RhcnRJICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbWF4SSAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gbWF4SSB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmICFpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFsyXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGVDb3VudFsyXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXTtcbiAgICAgICAgICAgIGlmICg1ICogTWF0aC5hYnMoc3RhdGVDb3VudFRvdGFsIC0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpID49IDIgKiBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSA/IEFsaWdubWVudFBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBpKSA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+VGhpcyBpcyBjYWxsZWQgd2hlbiBhIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvc3NpYmxlIGFsaWdubWVudCBwYXR0ZXJuLiBJdCB3aWxsXG4gICAgICAgICAqIGNyb3NzIGNoZWNrIHdpdGggYSB2ZXJ0aWNhbCBzY2FuLCBhbmQgaWYgc3VjY2Vzc2Z1bCwgd2lsbCBzZWUgaWYgdGhpcyBwYXR0ZXJuIGhhZCBiZWVuXG4gICAgICAgICAqIGZvdW5kIG9uIGEgcHJldmlvdXMgaG9yaXpvbnRhbCBzY2FuLiBJZiBzbywgd2UgY29uc2lkZXIgaXQgY29uZmlybWVkIGFuZCBjb25jbHVkZSB3ZSBoYXZlXG4gICAgICAgICAqIGZvdW5kIHRoZSBhbGlnbm1lbnQgcGF0dGVybi48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdGF0ZUNvdW50IHJlYWRpbmcgc3RhdGUgbW9kdWxlIGNvdW50cyBmcm9tIGhvcml6b250YWwgc2NhblxuICAgICAgICAgKiBAcGFyYW0gaSByb3cgd2hlcmUgYWxpZ25tZW50IHBhdHRlcm4gbWF5IGJlIGZvdW5kXG4gICAgICAgICAqIEBwYXJhbSBqIGVuZCBvZiBwb3NzaWJsZSBhbGlnbm1lbnQgcGF0dGVybiBpbiByb3dcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0gaWYgd2UgaGF2ZSBmb3VuZCB0aGUgc2FtZSBwYXR0ZXJuIHR3aWNlLCBvciBudWxsIGlmIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSAvKmludCovLCBqIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXTtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlckogPSBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaik7XG4gICAgICAgICAgICBjb25zdCBjZW50ZXJJID0gdGhpcy5jcm9zc0NoZWNrVmVydGljYWwoaSwgLyooaW50KSAqLyBjZW50ZXJKLCAyICogc3RhdGVDb3VudFsxXSwgc3RhdGVDb3VudFRvdGFsKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oY2VudGVySSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlc3RpbWF0ZWRNb2R1bGVTaXplID0gKHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXSkgLyAzLjA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjZW50ZXIgb2YgdGhpcy5wb3NzaWJsZUNlbnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYWJvdXQgdGhlIHNhbWUgY2VudGVyIGFuZCBtb2R1bGUgc2l6ZTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbnRlci5hYm91dEVxdWFscyhlc3RpbWF0ZWRNb2R1bGVTaXplLCBjZW50ZXJJLCBjZW50ZXJKKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbnRlci5jb21iaW5lRXN0aW1hdGUoY2VudGVySSwgY2VudGVySiwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFkbid0IGZvdW5kIHRoaXMgYmVmb3JlOyBzYXZlIGl0XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgQWxpZ25tZW50UGF0dGVybihjZW50ZXJKLCBjZW50ZXJJLCBlc3RpbWF0ZWRNb2R1bGVTaXplKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3NpYmxlQ2VudGVycy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHRQb2ludENhbGxiYWNrICE9PSBudWxsICYmIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgYSBmaW5kZXIgcGF0dGVybiwgd2hpY2ggYXJlIHRoZSB0aHJlZSBzcXVhcmUgcGF0dGVybnMgZm91bmQgaW5cbiAgICAgKiB0aGUgY29ybmVycyBvZiBRUiBDb2Rlcy4gSXQgYWxzbyBlbmNhcHN1bGF0ZXMgYSBjb3VudCBvZiBzaW1pbGFyIGZpbmRlciBwYXR0ZXJucyxcbiAgICAgKiBhcyBhIGNvbnZlbmllbmNlIHRvIHRoZSBmaW5kZXIncyBib29ra2VlcGluZy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEZpbmRlclBhdHRlcm4kMSBleHRlbmRzIFJlc3VsdFBvaW50IHtcbiAgICAgICAgLy8gRmluZGVyUGF0dGVybihwb3NYOiBudW1iZXIvKmZsb2F0Ki8sIHBvc1k6IG51bWJlci8qZmxvYXQqLywgZXN0aW1hdGVkTW9kdWxlU2l6ZTogbnVtYmVyLypmbG9hdCovKSB7XG4gICAgICAgIC8vICAgdGhpcyhwb3NYLCBwb3NZLCBlc3RpbWF0ZWRNb2R1bGVTaXplLCAxKVxuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0cnVjdG9yKHBvc1ggLypmbG9hdCovLCBwb3NZIC8qZmxvYXQqLywgZXN0aW1hdGVkTW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIGNvdW50IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHN1cGVyKHBvc1gsIHBvc1kpO1xuICAgICAgICAgICAgdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplID0gZXN0aW1hdGVkTW9kdWxlU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICB2b2lkIGluY3JlbWVudENvdW50KCkge1xuICAgICAgICAgIHRoaXMuY291bnQrK1xuICAgICAgICB9XG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGV0ZXJtaW5lcyBpZiB0aGlzIGZpbmRlciBwYXR0ZXJuIFwiYWJvdXQgZXF1YWxzXCIgYSBmaW5kZXIgcGF0dGVybiBhdCB0aGUgc3RhdGVkXG4gICAgICAgICAqIHBvc2l0aW9uIGFuZCBzaXplIC0tIG1lYW5pbmcsIGl0IGlzIGF0IG5lYXJseSB0aGUgc2FtZSBjZW50ZXIgd2l0aCBuZWFybHkgdGhlIHNhbWUgc2l6ZS48L3A+XG4gICAgICAgICAqL1xuICAgICAgICBhYm91dEVxdWFscyhtb2R1bGVTaXplIC8qZmxvYXQqLywgaSAvKmZsb2F0Ki8sIGogLypmbG9hdCovKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoaSAtIHRoaXMuZ2V0WSgpKSA8PSBtb2R1bGVTaXplICYmIE1hdGguYWJzKGogLSB0aGlzLmdldFgoKSkgPD0gbW9kdWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemVEaWZmID0gTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVNpemVEaWZmIDw9IDEuMCB8fCBtb2R1bGVTaXplRGlmZiA8PSB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbWJpbmVzIHRoaXMgb2JqZWN0J3MgY3VycmVudCBlc3RpbWF0ZSBvZiBhIGZpbmRlciBwYXR0ZXJuIHBvc2l0aW9uIGFuZCBtb2R1bGUgc2l6ZVxuICAgICAgICAgKiB3aXRoIGEgbmV3IGVzdGltYXRlLiBJdCByZXR1cm5zIGEgbmV3IHtAY29kZSBGaW5kZXJQYXR0ZXJufSBjb250YWluaW5nIGEgd2VpZ2h0ZWQgYXZlcmFnZVxuICAgICAgICAgKiBiYXNlZCBvbiBjb3VudC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbWJpbmVFc3RpbWF0ZShpIC8qZmxvYXQqLywgaiAvKmZsb2F0Ki8sIG5ld01vZHVsZVNpemUgLypmbG9hdCovKSB7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZENvdW50ID0gdGhpcy5jb3VudCArIDE7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZFggPSAodGhpcy5jb3VudCAqIHRoaXMuZ2V0WCgpICsgaikgLyBjb21iaW5lZENvdW50O1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRZID0gKHRoaXMuY291bnQgKiB0aGlzLmdldFkoKSArIGkpIC8gY29tYmluZWRDb3VudDtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkTW9kdWxlU2l6ZSA9ICh0aGlzLmNvdW50ICogdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplICsgbmV3TW9kdWxlU2l6ZSkgLyBjb21iaW5lZENvdW50O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaW5kZXJQYXR0ZXJuJDEoY29tYmluZWRYLCBjb21iaW5lZFksIGNvbWJpbmVkTW9kdWxlU2l6ZSwgY29tYmluZWRDb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBpbmZvcm1hdGlvbiBhYm91dCBmaW5kZXIgcGF0dGVybnMgaW4gYW4gaW1hZ2UsIGluY2x1ZGluZyB0aGUgbG9jYXRpb24gb2ZcbiAgICAgKiB0aGUgdGhyZWUgZmluZGVyIHBhdHRlcm5zLCBhbmQgdGhlaXIgZXN0aW1hdGVkIG1vZHVsZSBzaXplLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRmluZGVyUGF0dGVybkluZm8ge1xuICAgICAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuQ2VudGVycykge1xuICAgICAgICAgICAgdGhpcy5ib3R0b21MZWZ0ID0gcGF0dGVybkNlbnRlcnNbMF07XG4gICAgICAgICAgICB0aGlzLnRvcExlZnQgPSBwYXR0ZXJuQ2VudGVyc1sxXTtcbiAgICAgICAgICAgIHRoaXMudG9wUmlnaHQgPSBwYXR0ZXJuQ2VudGVyc1syXTtcbiAgICAgICAgfVxuICAgICAgICBnZXRCb3R0b21MZWZ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBnZXRUb3BMZWZ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9wTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBnZXRUb3BSaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcFJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKmltcG9ydCBqYXZhLmlvLlNlcmlhbGl6YWJsZTsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbnM7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuQ29tcGFyYXRvcjsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5MaXN0OyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuICAgIC8qKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgYXR0ZW1wdHMgdG8gZmluZCBmaW5kZXIgcGF0dGVybnMgaW4gYSBRUiBDb2RlLiBGaW5kZXIgcGF0dGVybnMgYXJlIHRoZSBzcXVhcmVcbiAgICAgKiBtYXJrZXJzIGF0IHRocmVlIGNvcm5lcnMgb2YgYSBRUiBDb2RlLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgaXMgdGhyZWFkLXNhZmUgYnV0IG5vdCByZWVudHJhbnQuIEVhY2ggdGhyZWFkIG11c3QgYWxsb2NhdGUgaXRzIG93biBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEZpbmRlclBhdHRlcm5GaW5kZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogPHA+Q3JlYXRlcyBhIGZpbmRlciB0aGF0IHdpbGwgc2VhcmNoIHRoZSBpbWFnZSBmb3IgdGhyZWUgZmluZGVyIHBhdHRlcm5zLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlIGltYWdlIHRvIHNlYXJjaFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKGltYWdlOiBCaXRNYXRyaXgpIHtcbiAgICAgICAgLy8gICB0aGlzKGltYWdlLCBudWxsKVxuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0cnVjdG9yKGltYWdlLCByZXN1bHRQb2ludENhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgPSByZXN1bHRQb2ludENhbGxiYWNrO1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJsZUNlbnRlcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnQgPSBuZXcgSW50MzJBcnJheSg1KTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayA9IHJlc3VsdFBvaW50Q2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0SW1hZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRQb3NzaWJsZUNlbnRlcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NzaWJsZUNlbnRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZmluZChoaW50cykge1xuICAgICAgICAgICAgY29uc3QgdHJ5SGFyZGVyID0gKGhpbnRzICE9PSBudWxsICYmIGhpbnRzICE9PSB1bmRlZmluZWQpICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuVFJZX0hBUkRFUik7XG4gICAgICAgICAgICBjb25zdCBwdXJlQmFyY29kZSA9IChoaW50cyAhPT0gbnVsbCAmJiBoaW50cyAhPT0gdW5kZWZpbmVkKSAmJiB1bmRlZmluZWQgIT09IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlBVUkVfQkFSQ09ERSk7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICAgICAgICBjb25zdCBtYXhJID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBtYXhKID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBsb29raW5nIGZvciBibGFjay93aGl0ZS9ibGFjay93aGl0ZS9ibGFjayBtb2R1bGVzIGluXG4gICAgICAgICAgICAvLyAxOjE6MzoxOjEgcmF0aW87IHRoaXMgdHJhY2tzIHRoZSBudW1iZXIgb2Ygc3VjaCBtb2R1bGVzIHNlZW4gc28gZmFyXG4gICAgICAgICAgICAvLyBMZXQncyBhc3N1bWUgdGhhdCB0aGUgbWF4aW11bSB2ZXJzaW9uIFFSIENvZGUgd2Ugc3VwcG9ydCB0YWtlcyB1cCAxLzQgdGhlIGhlaWdodCBvZiB0aGVcbiAgICAgICAgICAgIC8vIGltYWdlLCBhbmQgdGhlbiBhY2NvdW50IGZvciB0aGUgY2VudGVyIGJlaW5nIDMgbW9kdWxlcyBpbiBzaXplLiBUaGlzIGdpdmVzIHRoZSBzbWFsbGVzdFxuICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHBpeGVscyB0aGUgY2VudGVyIGNvdWxkIGJlLCBzbyBza2lwIHRoaXMgb2Z0ZW4uIFdoZW4gdHJ5aW5nIGhhcmRlciwgbG9vayBmb3IgYWxsXG4gICAgICAgICAgICAvLyBRUiB2ZXJzaW9ucyByZWdhcmRsZXNzIG9mIGhvdyBkZW5zZSB0aGV5IGFyZS5cbiAgICAgICAgICAgIGxldCBpU2tpcCA9IE1hdGguZmxvb3IoKDMgKiBtYXhJKSAvICg0ICogRmluZGVyUGF0dGVybkZpbmRlci5NQVhfTU9EVUxFUykpO1xuICAgICAgICAgICAgaWYgKGlTa2lwIDwgRmluZGVyUGF0dGVybkZpbmRlci5NSU5fU0tJUCB8fCB0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICBpU2tpcCA9IEZpbmRlclBhdHRlcm5GaW5kZXIuTUlOX1NLSVA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudCA9IG5ldyBJbnQzMkFycmF5KDUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGlTa2lwIC0gMTsgaSA8IG1heEkgJiYgIWRvbmU7IGkgKz0gaVNraXApIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IDA7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSA9IDA7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXhKOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldChqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2sgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFN0YXRlICYgMSkgPT09IDEpIHsgLy8gQ291bnRpbmcgd2hpdGUgcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50W2N1cnJlbnRTdGF0ZV0rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gV2hpdGUgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFN0YXRlICYgMSkgPT09IDApIHsgLy8gQ291bnRpbmcgYmxhY2sgcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gNCkgeyAvLyBBIHdpbm5lcj9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHsgLy8gWWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maXJtZWQgPSB0aGlzLmhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGksIGosIHB1cmVCYXJjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBleGFtaW5pbmcgZXZlcnkgb3RoZXIgbGluZS4gQ2hlY2tpbmcgZWFjaCBsaW5lIHR1cm5lZCBvdXQgdG8gYmUgdG9vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwZW5zaXZlIGFuZCBkaWRuJ3QgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpU2tpcCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzU2tpcHBlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdGhpcy5oYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dTa2lwID0gdGhpcy5maW5kUm93U2tpcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93U2tpcCA+IHN0YXRlQ291bnRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcm93cyBiZXR3ZWVuIHJvdyBvZiBsb3dlciBjb25maXJtZWQgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdG9wIG9mIHByZXN1bWVkIHRoaXJkIGNvbmZpcm1lZCBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBiYWNrIHVwIGEgYml0IHRvIGdldCBhIGZ1bGwgY2hhbmNlIG9mIGRldGVjdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQsIGVudGlyZSB3aWR0aCBvZiBjZW50ZXIgb2YgZmluZGVyIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgYnkgcm93U2tpcCwgYnV0IGJhY2sgb2ZmIGJ5IHN0YXRlQ291bnRbMl0gKHNpemUgb2YgbGFzdCBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHBhdHRlcm4gd2Ugc2F3KSB0byBiZSBjb25zZXJ2YXRpdmUsIGFuZCBhbHNvIGJhY2sgb2ZmIGJ5IGlTa2lwIHdoaWNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBhYm91dCB0byBiZSByZS1hZGRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSByb3dTa2lwIC0gc3RhdGVDb3VudFsyXSAtIGlTa2lwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IG1heEogLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IHN0YXRlQ291bnRbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IHN0YXRlQ291bnRbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IHN0YXRlQ291bnRbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHN0YXRlIHRvIHN0YXJ0IGxvb2tpbmcgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBObywgc2hpZnQgY291bnRzIGJhY2sgYnkgdHdvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gc3RhdGVDb3VudFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSBzdGF0ZUNvdW50WzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IHN0YXRlQ291bnRbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsrK2N1cnJlbnRTdGF0ZV0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gQ291bnRpbmcgd2hpdGUgcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFtjdXJyZW50U3RhdGVdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlybWVkID0gdGhpcy5oYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpLCBtYXhKLCBwdXJlQmFyY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlTa2lwID0gc3RhdGVDb3VudFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1NraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIHRoaXJkIG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0aGlzLmhhdmVNdWx0aXBseUNvbmZpcm1lZENlbnRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5JbmZvID0gdGhpcy5zZWxlY3RCZXN0UGF0dGVybnMoKTtcbiAgICAgICAgICAgIFJlc3VsdFBvaW50Lm9yZGVyQmVzdFBhdHRlcm5zKHBhdHRlcm5JbmZvKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmluZGVyUGF0dGVybkluZm8ocGF0dGVybkluZm8pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIGNvdW50IG9mIGJsYWNrL3doaXRlL2JsYWNrL3doaXRlL2JsYWNrIHBpeGVscyBqdXN0IHNlZW4gYW5kIGFuIGVuZCBwb3NpdGlvbixcbiAgICAgICAgICogZmlndXJlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGlzIHJ1bi5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGVuZCAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gKGVuZCAtIHN0YXRlQ291bnRbNF0gLSBzdGF0ZUNvdW50WzNdKSAtIHN0YXRlQ291bnRbMl0gLyAyLjA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBzdGF0ZUNvdW50IGNvdW50IG9mIGJsYWNrL3doaXRlL2JsYWNrL3doaXRlL2JsYWNrIHBpeGVscyBqdXN0IHJlYWRcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmZiB0aGUgcHJvcG9ydGlvbnMgb2YgdGhlIGNvdW50cyBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIDEvMS8zLzEvMSByYXRpb3NcbiAgICAgICAgICogICAgICAgICB1c2VkIGJ5IGZpbmRlciBwYXR0ZXJucyB0byBiZSBjb25zaWRlcmVkIGEgbWF0Y2hcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSB7XG4gICAgICAgICAgICBsZXQgdG90YWxNb2R1bGVTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBzdGF0ZUNvdW50W2ldO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvdGFsTW9kdWxlU2l6ZSArPSBjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3RhbE1vZHVsZVNpemUgPCA3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kdWxlU2l6ZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIDcuMDtcbiAgICAgICAgICAgIGNvbnN0IG1heFZhcmlhbmNlID0gbW9kdWxlU2l6ZSAvIDIuMDtcbiAgICAgICAgICAgIC8vIEFsbG93IGxlc3MgdGhhbiA1MCUgdmFyaWFuY2UgZnJvbSAxLTEtMy0xLTEgcHJvcG9ydGlvbnNcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFswXSkgPCBtYXhWYXJpYW5jZSAmJlxuICAgICAgICAgICAgICAgIE1hdGguYWJzKG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50WzFdKSA8IG1heFZhcmlhbmNlICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoMy4wICogbW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbMl0pIDwgMyAqIG1heFZhcmlhbmNlICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbM10pIDwgbWF4VmFyaWFuY2UgJiZcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFs0XSkgPCBtYXhWYXJpYW5jZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRDcm9zc0NoZWNrU3RhdGVDb3VudCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNyb3NzQ2hlY2tTdGF0ZUNvdW50ID0gdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudDtcbiAgICAgICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzBdID0gMDtcbiAgICAgICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzFdID0gMDtcbiAgICAgICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzNdID0gMDtcbiAgICAgICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzRdID0gMDtcbiAgICAgICAgICAgIHJldHVybiBjcm9zc0NoZWNrU3RhdGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQWZ0ZXIgYSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBzY2FuIGZpbmRzIGEgcG90ZW50aWFsIGZpbmRlciBwYXR0ZXJuLCB0aGlzIG1ldGhvZFxuICAgICAgICAgKiBcImNyb3NzLWNyb3NzLWNyb3NzLWNoZWNrc1wiIGJ5IHNjYW5uaW5nIGRvd24gZGlhZ29uYWxseSB0aHJvdWdoIHRoZSBjZW50ZXIgb2YgdGhlIHBvc3NpYmxlXG4gICAgICAgICAqIGZpbmRlciBwYXR0ZXJuIHRvIHNlZSBpZiB0aGUgc2FtZSBwcm9wb3J0aW9uIGlzIGRldGVjdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3RhcnRJIHJvdyB3aGVyZSBhIGZpbmRlciBwYXR0ZXJuIHdhcyBkZXRlY3RlZFxuICAgICAgICAgKiBAcGFyYW0gY2VudGVySiBjZW50ZXIgb2YgdGhlIHNlY3Rpb24gdGhhdCBhcHBlYXJzIHRvIGNyb3NzIGEgZmluZGVyIHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIG1heENvdW50IG1heGltdW0gcmVhc29uYWJsZSBudW1iZXIgb2YgbW9kdWxlcyB0aGF0IHNob3VsZCBiZVxuICAgICAgICAgKiAgb2JzZXJ2ZWQgaW4gYW55IHJlYWRpbmcgc3RhdGUsIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZSBob3Jpem9udGFsIHNjYW5cbiAgICAgICAgICogQHBhcmFtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsIFRoZSBvcmlnaW5hbCBzdGF0ZSBjb3VudCB0b3RhbC5cbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIHByb3BvcnRpb25zIGFyZSB3aXRoaW5nIGV4cGVjdGVkIGxpbWl0c1xuICAgICAgICAgKi9cbiAgICAgICAgY3Jvc3NDaGVja0RpYWdvbmFsKHN0YXJ0SSAvKmludCovLCBjZW50ZXJKIC8qaW50Ki8sIG1heENvdW50IC8qaW50Ki8sIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnQgPSB0aGlzLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50KCk7XG4gICAgICAgICAgICAvLyBTdGFydCBjb3VudGluZyB1cCwgbGVmdCBmcm9tIGNlbnRlciBmaW5kaW5nIGJsYWNrIGNlbnRlciBtYXNzXG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJID49IGkgJiYgY2VudGVySiA+PSBpICYmIGltYWdlLmdldChjZW50ZXJKIC0gaSwgc3RhcnRJIC0gaSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0SSA8IGkgfHwgY2VudGVySiA8IGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb250aW51ZSB1cCwgbGVmdCBmaW5kaW5nIHdoaXRlIHNwYWNlXG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJID49IGkgJiYgY2VudGVySiA+PSBpICYmICFpbWFnZS5nZXQoY2VudGVySiAtIGksIHN0YXJ0SSAtIGkpICYmXG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBhbHJlYWR5IHRvbyBtYW55IG1vZHVsZXMgaW4gdGhpcyBzdGF0ZSBvciByYW4gb2ZmIHRoZSBlZGdlOlxuICAgICAgICAgICAgaWYgKHN0YXJ0SSA8IGkgfHwgY2VudGVySiA8IGkgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29udGludWUgdXAsIGxlZnQgZmluZGluZyBibGFjayBib3JkZXJcbiAgICAgICAgICAgIHdoaWxlIChzdGFydEkgPj0gaSAmJiBjZW50ZXJKID49IGkgJiYgaW1hZ2UuZ2V0KGNlbnRlckogLSBpLCBzdGFydEkgLSBpKSAmJlxuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1heEkgPSBpbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IG1heEogPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgLy8gTm93IGFsc28gY291bnQgZG93biwgcmlnaHQgZnJvbSBjZW50ZXJcbiAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SSArIGkgPCBtYXhJICYmIGNlbnRlckogKyBpIDwgbWF4SiAmJiBpbWFnZS5nZXQoY2VudGVySiArIGksIHN0YXJ0SSArIGkpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJhbiBvZmYgdGhlIGVkZ2U/XG4gICAgICAgICAgICBpZiAoc3RhcnRJICsgaSA+PSBtYXhJIHx8IGNlbnRlckogKyBpID49IG1heEopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJICsgaSA8IG1heEkgJiYgY2VudGVySiArIGkgPCBtYXhKICYmICFpbWFnZS5nZXQoY2VudGVySiArIGksIHN0YXJ0SSArIGkpICYmXG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSA8IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydEkgKyBpID49IG1heEkgfHwgY2VudGVySiArIGkgPj0gbWF4SiB8fCBzdGF0ZUNvdW50WzNdID49IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SSArIGkgPCBtYXhJICYmIGNlbnRlckogKyBpIDwgbWF4SiAmJiBpbWFnZS5nZXQoY2VudGVySiArIGksIHN0YXJ0SSArIGkpICYmXG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA8IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZUNvdW50WzRdID49IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBmaW5kZXItcGF0dGVybi1saWtlIHNlY3Rpb24sIGJ1dCBpdHMgc2l6ZSBpcyBtb3JlIHRoYW4gMTAwJSBkaWZmZXJlbnQgdGhhblxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBhc3N1bWUgaXQncyBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICsgc3RhdGVDb3VudFs0XTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhzdGF0ZUNvdW50VG90YWwgLSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgPCAyICogb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgJiZcbiAgICAgICAgICAgICAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5BZnRlciBhIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvdGVudGlhbCBmaW5kZXIgcGF0dGVybiwgdGhpcyBtZXRob2RcbiAgICAgICAgICogXCJjcm9zcy1jaGVja3NcIiBieSBzY2FubmluZyBkb3duIHZlcnRpY2FsbHkgdGhyb3VnaCB0aGUgY2VudGVyIG9mIHRoZSBwb3NzaWJsZVxuICAgICAgICAgKiBmaW5kZXIgcGF0dGVybiB0byBzZWUgaWYgdGhlIHNhbWUgcHJvcG9ydGlvbiBpcyBkZXRlY3RlZC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdGFydEkgcm93IHdoZXJlIGEgZmluZGVyIHBhdHRlcm4gd2FzIGRldGVjdGVkXG4gICAgICAgICAqIEBwYXJhbSBjZW50ZXJKIGNlbnRlciBvZiB0aGUgc2VjdGlvbiB0aGF0IGFwcGVhcnMgdG8gY3Jvc3MgYSBmaW5kZXIgcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0gbWF4Q291bnQgbWF4aW11bSByZWFzb25hYmxlIG51bWJlciBvZiBtb2R1bGVzIHRoYXQgc2hvdWxkIGJlXG4gICAgICAgICAqIG9ic2VydmVkIGluIGFueSByZWFkaW5nIHN0YXRlLCBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGUgaG9yaXpvbnRhbCBzY2FuXG4gICAgICAgICAqIEByZXR1cm4gdmVydGljYWwgY2VudGVyIG9mIGZpbmRlciBwYXR0ZXJuLCBvciB7QGxpbmsgRmxvYXQjTmFOfSBpZiBub3QgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGNyb3NzQ2hlY2tWZXJ0aWNhbChzdGFydEkgLyppbnQqLywgY2VudGVySiAvKmludCovLCBtYXhDb3VudCAvKmludCovLCBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICAgICAgICBjb25zdCBtYXhJID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50ID0gdGhpcy5nZXRDcm9zc0NoZWNrU3RhdGVDb3VudCgpO1xuICAgICAgICAgICAgLy8gU3RhcnQgY291bnRpbmcgdXAgZnJvbSBjZW50ZXJcbiAgICAgICAgICAgIGxldCBpID0gc3RhcnRJO1xuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgIWltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGFscmVhZHkgdG9vIG1hbnkgbW9kdWxlcyBpbiB0aGlzIHN0YXRlIG9yIHJhbiBvZmYgdGhlIGVkZ2U6XG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbMF0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgYWxzbyBjb3VudCBkb3duIGZyb20gY2VudGVyXG4gICAgICAgICAgICBpID0gc3RhcnRJICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbWF4SSAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IG1heEkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmICFpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFszXSA8IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSBtYXhJIHx8IHN0YXRlQ291bnRbM10gPj0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzRdIDwgbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlQ291bnRbNF0gPj0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBmaW5kZXItcGF0dGVybi1saWtlIHNlY3Rpb24sIGJ1dCBpdHMgc2l6ZSBpcyBtb3JlIHRoYW4gNDAlIGRpZmZlcmVudCB0aGFuXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwsIGFzc3VtZSBpdCdzIGEgZmFsc2UgcG9zaXRpdmVcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXSArIHN0YXRlQ291bnRbM10gK1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF07XG4gICAgICAgICAgICBpZiAoNSAqIE1hdGguYWJzKHN0YXRlQ291bnRUb3RhbCAtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSA+PSAyICogb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkgPyBGaW5kZXJQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaSkgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkxpa2Uge0BsaW5rICNjcm9zc0NoZWNrVmVydGljYWwoaW50LCBpbnQsIGludCwgaW50KX0sIGFuZCBpbiBmYWN0IGlzIGJhc2ljYWxseSBpZGVudGljYWwsXG4gICAgICAgICAqIGV4Y2VwdCBpdCByZWFkcyBob3Jpem9udGFsbHkgaW5zdGVhZCBvZiB2ZXJ0aWNhbGx5LiBUaGlzIGlzIHVzZWQgdG8gY3Jvc3MtY3Jvc3NcbiAgICAgICAgICogY2hlY2sgYSB2ZXJ0aWNhbCBjcm9zcyBjaGVjayBhbmQgbG9jYXRlIHRoZSByZWFsIGNlbnRlciBvZiB0aGUgYWxpZ25tZW50IHBhdHRlcm4uPC9wPlxuICAgICAgICAgKi9cbiAgICAgICAgY3Jvc3NDaGVja0hvcml6b250YWwoc3RhcnRKIC8qaW50Ki8sIGNlbnRlckkgLyppbnQqLywgbWF4Q291bnQgLyppbnQqLywgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICAgICAgY29uc3QgbWF4SiA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50ID0gdGhpcy5nZXRDcm9zc0NoZWNrU3RhdGVDb3VudCgpO1xuICAgICAgICAgICAgbGV0IGogPSBzdGFydEo7XG4gICAgICAgICAgICB3aGlsZSAoaiA+PSAwICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0rKztcbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGogPj0gMCAmJiAhaW1hZ2UuZ2V0KGosIGNlbnRlckkpICYmIHN0YXRlQ291bnRbMV0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPCAwIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaiA+PSAwICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSAmJiBzdGF0ZUNvdW50WzBdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSsrO1xuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZUNvdW50WzBdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaiA9IHN0YXJ0SiArIDE7XG4gICAgICAgICAgICB3aGlsZSAoaiA8IG1heEogJiYgaW1hZ2UuZ2V0KGosIGNlbnRlckkpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqID09PSBtYXhKKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqIDwgbWF4SiAmJiAhaW1hZ2UuZ2V0KGosIGNlbnRlckkpICYmIHN0YXRlQ291bnRbM10gPCBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10rKztcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiA9PT0gbWF4SiB8fCBzdGF0ZUNvdW50WzNdID49IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqIDwgbWF4SiAmJiBpbWFnZS5nZXQoaiwgY2VudGVySSkgJiYgc3RhdGVDb3VudFs0XSA8IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSsrO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZUNvdW50WzRdID49IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZmluZGVyLXBhdHRlcm4tbGlrZSBzZWN0aW9uLCBidXQgaXRzIHNpemUgaXMgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQgdGhhblxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBhc3N1bWUgaXQncyBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdO1xuICAgICAgICAgICAgaWYgKDUgKiBNYXRoLmFicyhzdGF0ZUNvdW50VG90YWwgLSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgPj0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkgPyBGaW5kZXJQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaikgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlRoaXMgaXMgY2FsbGVkIHdoZW4gYSBob3Jpem9udGFsIHNjYW4gZmluZHMgYSBwb3NzaWJsZSBhbGlnbm1lbnQgcGF0dGVybi4gSXQgd2lsbFxuICAgICAgICAgKiBjcm9zcyBjaGVjayB3aXRoIGEgdmVydGljYWwgc2NhbiwgYW5kIGlmIHN1Y2Nlc3NmdWwsIHdpbGwsIGFoLCBjcm9zcy1jcm9zcy1jaGVja1xuICAgICAgICAgKiB3aXRoIGFub3RoZXIgaG9yaXpvbnRhbCBzY2FuLiBUaGlzIGlzIG5lZWRlZCBwcmltYXJpbHkgdG8gbG9jYXRlIHRoZSByZWFsIGhvcml6b250YWxcbiAgICAgICAgICogY2VudGVyIG9mIHRoZSBwYXR0ZXJuIGluIGNhc2VzIG9mIGV4dHJlbWUgc2tldy5cbiAgICAgICAgICogQW5kIHRoZW4gd2UgY3Jvc3MtY3Jvc3MtY3Jvc3MgY2hlY2sgd2l0aCBhbm90aGVyIGRpYWdvbmFsIHNjYW4uPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5JZiB0aGF0IHN1Y2NlZWRzIHRoZSBmaW5kZXIgcGF0dGVybiBsb2NhdGlvbiBpcyBhZGRlZCB0byBhIGxpc3QgdGhhdCB0cmFja3NcbiAgICAgICAgICogdGhlIG51bWJlciBvZiB0aW1lcyBlYWNoIGxvY2F0aW9uIGhhcyBiZWVuIG5lYXJseS1tYXRjaGVkIGFzIGEgZmluZGVyIHBhdHRlcm4uXG4gICAgICAgICAqIEVhY2ggYWRkaXRpb25hbCBmaW5kIGlzIG1vcmUgZXZpZGVuY2UgdGhhdCB0aGUgbG9jYXRpb24gaXMgaW4gZmFjdCBhIGZpbmRlclxuICAgICAgICAgKiBwYXR0ZXJuIGNlbnRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3RhdGVDb3VudCByZWFkaW5nIHN0YXRlIG1vZHVsZSBjb3VudHMgZnJvbSBob3Jpem9udGFsIHNjYW5cbiAgICAgICAgICogQHBhcmFtIGkgcm93IHdoZXJlIGZpbmRlciBwYXR0ZXJuIG1heSBiZSBmb3VuZFxuICAgICAgICAgKiBAcGFyYW0gaiBlbmQgb2YgcG9zc2libGUgZmluZGVyIHBhdHRlcm4gaW4gcm93XG4gICAgICAgICAqIEBwYXJhbSBwdXJlQmFyY29kZSB0cnVlIGlmIGluIFwicHVyZSBiYXJjb2RlXCIgbW9kZVxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgYSBmaW5kZXIgcGF0dGVybiBjYW5kaWRhdGUgd2FzIGZvdW5kIHRoaXMgdGltZVxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSAvKmludCovLCBqIC8qaW50Ki8sIHB1cmVCYXJjb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdO1xuICAgICAgICAgICAgbGV0IGNlbnRlckogPSBGaW5kZXJQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaik7XG4gICAgICAgICAgICBsZXQgY2VudGVySSA9IHRoaXMuY3Jvc3NDaGVja1ZlcnRpY2FsKGksIC8qKGludCkgKi8gTWF0aC5mbG9vcihjZW50ZXJKKSwgc3RhdGVDb3VudFsyXSwgc3RhdGVDb3VudFRvdGFsKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oY2VudGVySSkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZS1jcm9zcyBjaGVja1xuICAgICAgICAgICAgICAgIGNlbnRlckogPSB0aGlzLmNyb3NzQ2hlY2tIb3Jpem9udGFsKC8qKGludCkgKi8gTWF0aC5mbG9vcihjZW50ZXJKKSwgLyooaW50KSAqLyBNYXRoLmZsb29yKGNlbnRlckkpLCBzdGF0ZUNvdW50WzJdLCBzdGF0ZUNvdW50VG90YWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oY2VudGVySikgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFwdXJlQmFyY29kZSB8fCB0aGlzLmNyb3NzQ2hlY2tEaWFnb25hbCgvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySSksIC8qKGludCkgKi8gTWF0aC5mbG9vcihjZW50ZXJKKSwgc3RhdGVDb3VudFsyXSwgc3RhdGVDb3VudFRvdGFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IHN0YXRlQ291bnRUb3RhbCAvIDcuMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlQ2VudGVycyA9IHRoaXMucG9zc2libGVDZW50ZXJzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IHBvc3NpYmxlQ2VudGVycy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSBwb3NzaWJsZUNlbnRlcnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYWJvdXQgdGhlIHNhbWUgY2VudGVyIGFuZCBtb2R1bGUgc2l6ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZW50ZXIuYWJvdXRFcXVhbHMoZXN0aW1hdGVkTW9kdWxlU2l6ZSwgY2VudGVySSwgY2VudGVySikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnNbaW5kZXhdID0gY2VudGVyLmNvbWJpbmVFc3RpbWF0ZShjZW50ZXJJLCBjZW50ZXJKLCBlc3RpbWF0ZWRNb2R1bGVTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgRmluZGVyUGF0dGVybiQxKGNlbnRlckosIGNlbnRlckksIGVzdGltYXRlZE1vZHVsZVNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayAhPT0gbnVsbCAmJiB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBudW1iZXIgb2Ygcm93cyB3ZSBjb3VsZCBzYWZlbHkgc2tpcCBkdXJpbmcgc2Nhbm5pbmcsIGJhc2VkIG9uIHRoZSBmaXJzdFxuICAgICAgICAgKiAgICAgICAgIHR3byBmaW5kZXIgcGF0dGVybnMgdGhhdCBoYXZlIGJlZW4gbG9jYXRlZC4gSW4gc29tZSBjYXNlcyB0aGVpciBwb3NpdGlvbiB3aWxsXG4gICAgICAgICAqICAgICAgICAgYWxsb3cgdXMgdG8gaW5mZXIgdGhhdCB0aGUgdGhpcmQgcGF0dGVybiBtdXN0IGxpZSBiZWxvdyBhIGNlcnRhaW4gcG9pbnQgZmFydGhlclxuICAgICAgICAgKiAgICAgICAgIGRvd24gaW4gdGhlIGltYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgZmluZFJvd1NraXAoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXggPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobWF4IDw9IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaXJzdENvbmZpcm1lZENlbnRlciA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNlbnRlciBvZiB0aGlzLnBvc3NpYmxlQ2VudGVycykge1xuICAgICAgICAgICAgICAgIGlmIChjZW50ZXIuZ2V0Q291bnQoKSA+PSBGaW5kZXJQYXR0ZXJuRmluZGVyLkNFTlRFUl9RVU9SVU0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0Q29uZmlybWVkQ2VudGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Q29uZmlybWVkQ2VudGVyID0gY2VudGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0d28gY29uZmlybWVkIGNlbnRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhvdyBmYXIgZG93biBjYW4gd2Ugc2tpcCBiZWZvcmUgcmVzdW1pbmcgbG9va2luZyBmb3IgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhdHRlcm4/IEluIHRoZSB3b3JzdCBjYXNlLCBvbmx5IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbmNlIGluIHRoZSB4IC8geSBjb29yZGluYXRlcyBvZiB0aGUgdHdvIGNlbnRlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZXJlIHlvdSBmaW5kIHRvcCBsZWZ0IGxhc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1NraXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8qKGludCkgKi8gTWF0aC5mbG9vcigoTWF0aC5hYnMoZmlyc3RDb25maXJtZWRDZW50ZXIuZ2V0WCgpIC0gY2VudGVyLmdldFgoKSkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGZpcnN0Q29uZmlybWVkQ2VudGVyLmdldFkoKSAtIGNlbnRlci5nZXRZKCkpKSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgd2UgaGF2ZSBmb3VuZCBhdCBsZWFzdCAzIGZpbmRlciBwYXR0ZXJucyB0aGF0IGhhdmUgYmVlbiBkZXRlY3RlZFxuICAgICAgICAgKiAgICAgICAgIGF0IGxlYXN0IHtAbGluayAjQ0VOVEVSX1FVT1JVTX0gdGltZXMgZWFjaCwgYW5kLCB0aGUgZXN0aW1hdGVkIG1vZHVsZSBzaXplIG9mIHRoZVxuICAgICAgICAgKiAgICAgICAgIGNhbmRpZGF0ZXMgaXMgXCJwcmV0dHkgc2ltaWxhclwiXG4gICAgICAgICAqL1xuICAgICAgICBoYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzKCkge1xuICAgICAgICAgICAgbGV0IGNvbmZpcm1lZENvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCB0b3RhbE1vZHVsZVNpemUgPSAwLjA7XG4gICAgICAgICAgICBjb25zdCBtYXggPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdGhpcy5wb3NzaWJsZUNlbnRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5nZXRDb3VudCgpID49IEZpbmRlclBhdHRlcm5GaW5kZXIuQ0VOVEVSX1FVT1JVTSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maXJtZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gcGF0dGVybi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpcm1lZENvdW50IDwgMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9LLCB3ZSBoYXZlIGF0IGxlYXN0IDMgY29uZmlybWVkIGNlbnRlcnMsIGJ1dCwgaXQncyBwb3NzaWJsZSB0aGF0IG9uZSBpcyBhIFwiZmFsc2UgcG9zaXRpdmVcIlxuICAgICAgICAgICAgLy8gYW5kIHRoYXQgd2UgbmVlZCB0byBrZWVwIGxvb2tpbmcuIFdlIGRldGVjdCB0aGlzIGJ5IGFza2luZyBpZiB0aGUgZXN0aW1hdGVkIG1vZHVsZSBzaXplc1xuICAgICAgICAgICAgLy8gdmFyeSB0b28gbXVjaC4gV2UgYXJiaXRyYXJpbHkgc2F5IHRoYXQgd2hlbiB0aGUgdG90YWwgZGV2aWF0aW9uIGZyb20gYXZlcmFnZSBleGNlZWRzXG4gICAgICAgICAgICAvLyA1JSBvZiB0aGUgdG90YWwgbW9kdWxlIHNpemUgZXN0aW1hdGVzLCBpdCdzIHRvbyBtdWNoLlxuICAgICAgICAgICAgY29uc3QgYXZlcmFnZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIG1heDtcbiAgICAgICAgICAgIGxldCB0b3RhbERldmlhdGlvbiA9IDAuMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0aGlzLnBvc3NpYmxlQ2VudGVycykge1xuICAgICAgICAgICAgICAgIHRvdGFsRGV2aWF0aW9uICs9IE1hdGguYWJzKHBhdHRlcm4uZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG90YWxEZXZpYXRpb24gPD0gMC4wNSAqIHRvdGFsTW9kdWxlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0aGUgMyBiZXN0IHtAbGluayBGaW5kZXJQYXR0ZXJufXMgZnJvbSBvdXIgbGlzdCBvZiBjYW5kaWRhdGVzLiBUaGUgXCJiZXN0XCIgYXJlXG4gICAgICAgICAqICAgICAgICAgdGhvc2UgdGhhdCBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXQgbGVhc3Qge0BsaW5rICNDRU5URVJfUVVPUlVNfSB0aW1lcywgYW5kIHdob3NlIG1vZHVsZVxuICAgICAgICAgKiAgICAgICAgIHNpemUgZGlmZmVycyBmcm9tIHRoZSBhdmVyYWdlIGFtb25nIHRob3NlIHBhdHRlcm5zIHRoZSBsZWFzdFxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIDMgc3VjaCBmaW5kZXIgcGF0dGVybnMgZG8gbm90IGV4aXN0XG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RCZXN0UGF0dGVybnMoKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFNpemUgPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc3RhcnRTaXplIDwgMykge1xuICAgICAgICAgICAgICAgIC8vIENvdWxkbid0IGZpbmQgZW5vdWdoIGZpbmRlciBwYXR0ZXJuc1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9zc2libGVDZW50ZXJzID0gdGhpcy5wb3NzaWJsZUNlbnRlcnM7XG4gICAgICAgICAgICBsZXQgYXZlcmFnZTtcbiAgICAgICAgICAgIC8vIEZpbHRlciBvdXRsaWVyIHBvc3NpYmlsaXRpZXMgd2hvc2UgbW9kdWxlIHNpemUgaXMgdG9vIGRpZmZlcmVudFxuICAgICAgICAgICAgaWYgKHN0YXJ0U2l6ZSA+IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBCdXQgd2UgY2FuIG9ubHkgYWZmb3JkIHRvIGRvIHNvIGlmIHdlIGhhdmUgYXQgbGVhc3QgNCBwb3NzaWJpbGl0aWVzIHRvIGNob29zZSBmcm9tXG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsTW9kdWxlU2l6ZSA9IDAuMDtcbiAgICAgICAgICAgICAgICBsZXQgc3F1YXJlID0gMC4wO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2VudGVyIG9mIHRoaXMucG9zc2libGVDZW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBjZW50ZXIuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlICs9IHNpemUgKiBzaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdmVyYWdlID0gdG90YWxNb2R1bGVTaXplIC8gc3RhcnRTaXplO1xuICAgICAgICAgICAgICAgIGxldCBzdGREZXYgPSBNYXRoLnNxcnQoc3F1YXJlIC8gc3RhcnRTaXplIC0gYXZlcmFnZSAqIGF2ZXJhZ2UpO1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5zb3J0KFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIDxwPk9yZGVycyBieSBmdXJ0aGVzdCBmcm9tIGF2ZXJhZ2U8L3A+XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLy8gRnVydGhlc3RGcm9tQXZlcmFnZUNvbXBhcmF0b3IgaW1wbGVtZW50cyBDb21wYXJhdG9yPEZpbmRlclBhdHRlcm4+XG4gICAgICAgICAgICAgICAgKGNlbnRlcjEsIGNlbnRlcjIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZEEgPSBNYXRoLmFicyhjZW50ZXIyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkQiA9IE1hdGguYWJzKGNlbnRlcjEuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkQSA8IGRCID8gLTEgOiBkQSA+IGRCID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGltaXQgPSBNYXRoLm1heCgwLjIgKiBhdmVyYWdlLCBzdGREZXYpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zc2libGVDZW50ZXJzLmxlbmd0aCAmJiBwb3NzaWJsZUNlbnRlcnMubGVuZ3RoID4gMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBwb3NzaWJsZUNlbnRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhwYXR0ZXJuLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zc2libGVDZW50ZXJzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBhd2F5IGFsbCBidXQgdGhvc2UgZmlyc3Qgc2l6ZSBjYW5kaWRhdGUgcG9pbnRzIHdlIGZvdW5kLlxuICAgICAgICAgICAgICAgIGxldCB0b3RhbE1vZHVsZVNpemUgPSAwLjA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb3NzaWJsZUNlbnRlciBvZiBwb3NzaWJsZUNlbnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxNb2R1bGVTaXplICs9IHBvc3NpYmxlQ2VudGVyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXZlcmFnZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIHBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzLnNvcnQoXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogPHA+T3JkZXJzIGJ5IHtAbGluayBGaW5kZXJQYXR0ZXJuI2dldENvdW50KCl9LCBkZXNjZW5kaW5nLjwvcD5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAvLyBDZW50ZXJDb21wYXJhdG9yIGltcGxlbWVudHMgQ29tcGFyYXRvcjxGaW5kZXJQYXR0ZXJuPlxuICAgICAgICAgICAgICAgIChjZW50ZXIxLCBjZW50ZXIyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZW50ZXIyLmdldENvdW50KCkgPT09IGNlbnRlcjEuZ2V0Q291bnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZEEgPSBNYXRoLmFicyhjZW50ZXIyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZEIgPSBNYXRoLmFicyhjZW50ZXIxLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRBIDwgZEIgPyAxIDogZEEgPiBkQiA/IC0xIDogMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXIyLmdldENvdW50KCkgLSBjZW50ZXIxLmdldENvdW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnMuc3BsaWNlKDMpOyAvLyB0aGlzIGlzIG5vdCByZWFseSBuZWNlc3NhcnkgYXMgd2Ugb25seSByZXR1cm4gZmlyc3QgMyBhbnl3YXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzWzBdLFxuICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVyc1sxXSxcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnNbMl1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5DRU5URVJfUVVPUlVNID0gMjtcbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLk1JTl9TS0lQID0gMzsgLy8gMSBwaXhlbC9tb2R1bGUgdGltZXMgMyBtb2R1bGVzL2NlbnRlclxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIuTUFYX01PRFVMRVMgPSA1NzsgLy8gc3VwcG9ydCB1cCB0byB2ZXJzaW9uIDEwIGZvciBtb2JpbGUgY2xpZW50c1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGxvZ2ljIHRoYXQgY2FuIGRldGVjdCBhIFFSIENvZGUgaW4gYW4gaW1hZ2UsIGV2ZW4gaWYgdGhlIFFSIENvZGVcbiAgICAgKiBpcyByb3RhdGVkIG9yIHNrZXdlZCwgb3IgcGFydGlhbGx5IG9ic2N1cmVkLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGV0ZWN0b3IkMiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGltYWdlKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0SW1hZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRSZXN1bHRQb2ludENhbGxiYWNrKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGV0ZWN0cyBhIFFSIENvZGUgaW4gYW4gaW1hZ2UuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBEZXRlY3RvclJlc3VsdH0gZW5jYXBzdWxhdGluZyByZXN1bHRzIG9mIGRldGVjdGluZyBhIFFSIENvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBRUiBDb2RlIGNhbm5vdCBiZSBmb3VuZFxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBhIFFSIENvZGUgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgICAgICovXG4gICAgICAgIC8vIHB1YmxpYyBkZXRlY3QoKTogRGV0ZWN0b3JSZXN1bHQgLyp0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiovIHtcbiAgICAgICAgLy8gICByZXR1cm4gZGV0ZWN0KG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRldGVjdHMgYSBRUiBDb2RlIGluIGFuIGltYWdlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIG9wdGlvbmFsIGhpbnRzIHRvIGRldGVjdG9yXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIERldGVjdG9yUmVzdWx0fSBlbmNhcHN1bGF0aW5nIHJlc3VsdHMgb2YgZGV0ZWN0aW5nIGEgUVIgQ29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIFFSIENvZGUgY2Fubm90IGJlIGZvdW5kXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgUVIgQ29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGV0ZWN0KGhpbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgPSAoaGludHMgPT09IG51bGwgfHwgaGludHMgPT09IHVuZGVmaW5lZCkgPyBudWxsIDpcbiAgICAgICAgICAgICAgICAvKihSZXN1bHRQb2ludENhbGxiYWNrKSAqLyBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XG4gICAgICAgICAgICBjb25zdCBmaW5kZXIgPSBuZXcgRmluZGVyUGF0dGVybkZpbmRlcih0aGlzLmltYWdlLCB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2spO1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGZpbmRlci5maW5kKGhpbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NGaW5kZXJQYXR0ZXJuSW5mbyhpbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzRmluZGVyUGF0dGVybkluZm8oaW5mbykge1xuICAgICAgICAgICAgY29uc3QgdG9wTGVmdCA9IGluZm8uZ2V0VG9wTGVmdCgpO1xuICAgICAgICAgICAgY29uc3QgdG9wUmlnaHQgPSBpbmZvLmdldFRvcFJpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBib3R0b21MZWZ0ID0gaW5mby5nZXRCb3R0b21MZWZ0KCk7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVTaXplID0gdGhpcy5jYWxjdWxhdGVNb2R1bGVTaXplKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0KTtcbiAgICAgICAgICAgIGlmIChtb2R1bGVTaXplIDwgMS4wKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCdObyBwYXR0ZXJuIGZvdW5kIGluIHByb2NjZXNzIGZpbmRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IERldGVjdG9yJDIuY29tcHV0ZURpbWVuc2lvbih0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgbW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBwcm92aXNpb25hbFZlcnNpb24gPSBWZXJzaW9uJDEuZ2V0UHJvdmlzaW9uYWxWZXJzaW9uRm9yRGltZW5zaW9uKGRpbWVuc2lvbik7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVzQmV0d2VlbkZQQ2VudGVycyA9IHByb3Zpc2lvbmFsVmVyc2lvbi5nZXREaW1lbnNpb25Gb3JWZXJzaW9uKCkgLSA3O1xuICAgICAgICAgICAgbGV0IGFsaWdubWVudFBhdHRlcm4gPSBudWxsO1xuICAgICAgICAgICAgLy8gQW55dGhpbmcgYWJvdmUgdmVyc2lvbiAxIGhhcyBhbiBhbGlnbm1lbnQgcGF0dGVyblxuICAgICAgICAgICAgaWYgKHByb3Zpc2lvbmFsVmVyc2lvbi5nZXRBbGlnbm1lbnRQYXR0ZXJuQ2VudGVycygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBHdWVzcyB3aGVyZSBhIFwiYm90dG9tIHJpZ2h0XCIgZmluZGVyIHBhdHRlcm4gd291bGQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAgICAgY29uc3QgYm90dG9tUmlnaHRYID0gdG9wUmlnaHQuZ2V0WCgpIC0gdG9wTGVmdC5nZXRYKCkgKyBib3R0b21MZWZ0LmdldFgoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBib3R0b21SaWdodFkgPSB0b3BSaWdodC5nZXRZKCkgLSB0b3BMZWZ0LmdldFkoKSArIGJvdHRvbUxlZnQuZ2V0WSgpO1xuICAgICAgICAgICAgICAgIC8vIEVzdGltYXRlIHRoYXQgYWxpZ25tZW50IHBhdHRlcm4gaXMgY2xvc2VyIGJ5IDMgbW9kdWxlc1xuICAgICAgICAgICAgICAgIC8vIGZyb20gXCJib3R0b20gcmlnaHRcIiB0byBrbm93biB0b3AgbGVmdCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb25Ub1RvcExlZnQgPSAxLjAgLSAzLjAgLyBtb2R1bGVzQmV0d2VlbkZQQ2VudGVycztcbiAgICAgICAgICAgICAgICBjb25zdCBlc3RBbGlnbm1lbnRYID0gLyooaW50KSAqLyBNYXRoLmZsb29yKHRvcExlZnQuZ2V0WCgpICsgY29ycmVjdGlvblRvVG9wTGVmdCAqIChib3R0b21SaWdodFggLSB0b3BMZWZ0LmdldFgoKSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVzdEFsaWdubWVudFkgPSAvKihpbnQpICovIE1hdGguZmxvb3IodG9wTGVmdC5nZXRZKCkgKyBjb3JyZWN0aW9uVG9Ub3BMZWZ0ICogKGJvdHRvbVJpZ2h0WSAtIHRvcExlZnQuZ2V0WSgpKSk7XG4gICAgICAgICAgICAgICAgLy8gS2luZCBvZiBhcmJpdHJhcnkgLS0gZXhwYW5kIHNlYXJjaCByYWRpdXMgYmVmb3JlIGdpdmluZyB1cFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSA0OyBpIDw9IDE2OyBpIDw8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRQYXR0ZXJuID0gdGhpcy5maW5kQWxpZ25tZW50SW5SZWdpb24obW9kdWxlU2l6ZSwgZXN0QWxpZ25tZW50WCwgZXN0QWxpZ25tZW50WSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAocmUgLypOb3RGb3VuZEV4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZSBpbnN0YW5jZW9mIE5vdEZvdW5kRXhjZXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IG5leHQgcm91bmRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbGlnbm1lbnQgcGF0dGVybi4uLiB3ZWxsIHRyeSBhbnl3YXkgd2l0aG91dCBpdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gRGV0ZWN0b3IkMi5jcmVhdGVUcmFuc2Zvcm0odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGFsaWdubWVudFBhdHRlcm4sIGRpbWVuc2lvbik7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gRGV0ZWN0b3IkMi5zYW1wbGVHcmlkKHRoaXMuaW1hZ2UsIHRyYW5zZm9ybSwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIGxldCBwb2ludHM7XG4gICAgICAgICAgICBpZiAoYWxpZ25tZW50UGF0dGVybiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IFtib3R0b21MZWZ0LCB0b3BMZWZ0LCB0b3BSaWdodF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBbYm90dG9tTGVmdCwgdG9wTGVmdCwgdG9wUmlnaHQsIGFsaWdubWVudFBhdHRlcm5dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXRlY3RvclJlc3VsdChiaXRzLCBwb2ludHMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjcmVhdGVUcmFuc2Zvcm0odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGFsaWdubWVudFBhdHRlcm4sIGRpbWVuc2lvbiAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBkaW1NaW51c1RocmVlID0gZGltZW5zaW9uIC0gMy41O1xuICAgICAgICAgICAgbGV0IGJvdHRvbVJpZ2h0WDsgLypmbG9hdCovXG4gICAgICAgICAgICBsZXQgYm90dG9tUmlnaHRZOyAvKmZsb2F0Ki9cbiAgICAgICAgICAgIGxldCBzb3VyY2VCb3R0b21SaWdodFg7IC8qZmxvYXQqL1xuICAgICAgICAgICAgbGV0IHNvdXJjZUJvdHRvbVJpZ2h0WTsgLypmbG9hdCovXG4gICAgICAgICAgICBpZiAoYWxpZ25tZW50UGF0dGVybiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0WCA9IGFsaWdubWVudFBhdHRlcm4uZ2V0WCgpO1xuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0WSA9IGFsaWdubWVudFBhdHRlcm4uZ2V0WSgpO1xuICAgICAgICAgICAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0WCA9IGRpbU1pbnVzVGhyZWUgLSAzLjA7XG4gICAgICAgICAgICAgICAgc291cmNlQm90dG9tUmlnaHRZID0gc291cmNlQm90dG9tUmlnaHRYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgaGF2ZSBhbiBhbGlnbm1lbnQgcGF0dGVybiwganVzdCBtYWtlIHVwIHRoZSBib3R0b20tcmlnaHQgcG9pbnRcbiAgICAgICAgICAgICAgICBib3R0b21SaWdodFggPSAodG9wUmlnaHQuZ2V0WCgpIC0gdG9wTGVmdC5nZXRYKCkpICsgYm90dG9tTGVmdC5nZXRYKCk7XG4gICAgICAgICAgICAgICAgYm90dG9tUmlnaHRZID0gKHRvcFJpZ2h0LmdldFkoKSAtIHRvcExlZnQuZ2V0WSgpKSArIGJvdHRvbUxlZnQuZ2V0WSgpO1xuICAgICAgICAgICAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0WCA9IGRpbU1pbnVzVGhyZWU7XG4gICAgICAgICAgICAgICAgc291cmNlQm90dG9tUmlnaHRZID0gZGltTWludXNUaHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5xdWFkcmlsYXRlcmFsVG9RdWFkcmlsYXRlcmFsKDMuNSwgMy41LCBkaW1NaW51c1RocmVlLCAzLjUsIHNvdXJjZUJvdHRvbVJpZ2h0WCwgc291cmNlQm90dG9tUmlnaHRZLCAzLjUsIGRpbU1pbnVzVGhyZWUsIHRvcExlZnQuZ2V0WCgpLCB0b3BMZWZ0LmdldFkoKSwgdG9wUmlnaHQuZ2V0WCgpLCB0b3BSaWdodC5nZXRZKCksIGJvdHRvbVJpZ2h0WCwgYm90dG9tUmlnaHRZLCBib3R0b21MZWZ0LmdldFgoKSwgYm90dG9tTGVmdC5nZXRZKCkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBzYW1wbGVHcmlkKGltYWdlLCB0cmFuc2Zvcm0sIGRpbWVuc2lvbiAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVyID0gR3JpZFNhbXBsZXJJbnN0YW5jZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZXIuc2FtcGxlR3JpZFdpdGhUcmFuc2Zvcm0oaW1hZ2UsIGRpbWVuc2lvbiwgZGltZW5zaW9uLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5Db21wdXRlcyB0aGUgZGltZW5zaW9uIChudW1iZXIgb2YgbW9kdWxlcyBvbiBhIHNpemUpIG9mIHRoZSBRUiBDb2RlIGJhc2VkIG9uIHRoZSBwb3NpdGlvblxuICAgICAgICAgKiBvZiB0aGUgZmluZGVyIHBhdHRlcm5zIGFuZCBlc3RpbWF0ZWQgbW9kdWxlIHNpemUuPC9wPlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNvbXB1dGVEaW1lbnNpb24odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIG1vZHVsZVNpemUgLypmbG9hdCovKSB7XG4gICAgICAgICAgICBjb25zdCB0bHRyQ2VudGVyc0RpbWVuc2lvbiA9IE1hdGhVdGlscy5yb3VuZChSZXN1bHRQb2ludC5kaXN0YW5jZSh0b3BMZWZ0LCB0b3BSaWdodCkgLyBtb2R1bGVTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IHRsYmxDZW50ZXJzRGltZW5zaW9uID0gTWF0aFV0aWxzLnJvdW5kKFJlc3VsdFBvaW50LmRpc3RhbmNlKHRvcExlZnQsIGJvdHRvbUxlZnQpIC8gbW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICBsZXQgZGltZW5zaW9uID0gTWF0aC5mbG9vcigodGx0ckNlbnRlcnNEaW1lbnNpb24gKyB0bGJsQ2VudGVyc0RpbWVuc2lvbikgLyAyKSArIDc7XG4gICAgICAgICAgICBzd2l0Y2ggKGRpbWVuc2lvbiAmIDB4MDMpIHsgLy8gbW9kIDRcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbisrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyAxPyBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb24tLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oJ0RpbWVuc2lvbnMgY291bGQgYmUgbm90IGZvdW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpbWVuc2lvbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+Q29tcHV0ZXMgYW4gYXZlcmFnZSBlc3RpbWF0ZWQgbW9kdWxlIHNpemUgYmFzZWQgb24gZXN0aW1hdGVkIGRlcml2ZWQgZnJvbSB0aGUgcG9zaXRpb25zXG4gICAgICAgICAqIG9mIHRoZSB0aHJlZSBmaW5kZXIgcGF0dGVybnMuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdG9wTGVmdCBkZXRlY3RlZCB0b3AtbGVmdCBmaW5kZXIgcGF0dGVybiBjZW50ZXJcbiAgICAgICAgICogQHBhcmFtIHRvcFJpZ2h0IGRldGVjdGVkIHRvcC1yaWdodCBmaW5kZXIgcGF0dGVybiBjZW50ZXJcbiAgICAgICAgICogQHBhcmFtIGJvdHRvbUxlZnQgZGV0ZWN0ZWQgYm90dG9tLWxlZnQgZmluZGVyIHBhdHRlcm4gY2VudGVyXG4gICAgICAgICAqIEByZXR1cm4gZXN0aW1hdGVkIG1vZHVsZSBzaXplXG4gICAgICAgICAqL1xuICAgICAgICBjYWxjdWxhdGVNb2R1bGVTaXplKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0KSB7XG4gICAgICAgICAgICAvLyBUYWtlIHRoZSBhdmVyYWdlXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuY2FsY3VsYXRlTW9kdWxlU2l6ZU9uZVdheSh0b3BMZWZ0LCB0b3BSaWdodCkgK1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlTW9kdWxlU2l6ZU9uZVdheSh0b3BMZWZ0LCBib3R0b21MZWZ0KSkgLyAyLjA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkVzdGltYXRlcyBtb2R1bGUgc2l6ZSBiYXNlZCBvbiB0d28gZmluZGVyIHBhdHRlcm5zIC0tIGl0IHVzZXNcbiAgICAgICAgICoge0BsaW5rICNzaXplT2ZCbGFja1doaXRlQmxhY2tSdW5Cb3RoV2F5cyhpbnQsIGludCwgaW50LCBpbnQpfSB0byBmaWd1cmUgdGhlXG4gICAgICAgICAqIHdpZHRoIG9mIGVhY2gsIG1lYXN1cmluZyBhbG9uZyB0aGUgYXhpcyBiZXR3ZWVuIHRoZWlyIGNlbnRlcnMuPC9wPlxuICAgICAgICAgKi9cbiAgICAgICAgY2FsY3VsYXRlTW9kdWxlU2l6ZU9uZVdheShwYXR0ZXJuLCBvdGhlclBhdHRlcm4pIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemVFc3QxID0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW5Cb3RoV2F5cygvKihpbnQpICovIE1hdGguZmxvb3IocGF0dGVybi5nZXRYKCkpLCBcbiAgICAgICAgICAgIC8qKGludCkgKi8gTWF0aC5mbG9vcihwYXR0ZXJuLmdldFkoKSksIFxuICAgICAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKG90aGVyUGF0dGVybi5nZXRYKCkpLCBcbiAgICAgICAgICAgIC8qKGludCkgKi8gTWF0aC5mbG9vcihvdGhlclBhdHRlcm4uZ2V0WSgpKSk7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVTaXplRXN0MiA9IHRoaXMuc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuQm90aFdheXMoLyooaW50KSAqLyBNYXRoLmZsb29yKG90aGVyUGF0dGVybi5nZXRYKCkpLCBcbiAgICAgICAgICAgIC8qKGludCkgKi8gTWF0aC5mbG9vcihvdGhlclBhdHRlcm4uZ2V0WSgpKSwgXG4gICAgICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3IocGF0dGVybi5nZXRYKCkpLCBcbiAgICAgICAgICAgIC8qKGludCkgKi8gTWF0aC5mbG9vcihwYXR0ZXJuLmdldFkoKSkpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG1vZHVsZVNpemVFc3QxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGVTaXplRXN0MiAvIDcuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTihtb2R1bGVTaXplRXN0MikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZUVzdDEgLyA3LjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdmVyYWdlIHRoZW0sIGFuZCBkaXZpZGUgYnkgNyBzaW5jZSB3ZSd2ZSBjb3VudGVkIHRoZSB3aWR0aCBvZiAzIGJsYWNrIG1vZHVsZXMsXG4gICAgICAgICAgICAvLyBhbmQgMSB3aGl0ZSBhbmQgMSBibGFjayBtb2R1bGUgb24gZWl0aGVyIHNpZGUuIEVyZ28sIGRpdmlkZSBzdW0gYnkgMTQuXG4gICAgICAgICAgICByZXR1cm4gKG1vZHVsZVNpemVFc3QxICsgbW9kdWxlU2l6ZUVzdDIpIC8gMTQuMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIHtAbGluayAjc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKGludCwgaW50LCBpbnQsIGludCl9OyBjb21wdXRlcyB0aGUgdG90YWwgd2lkdGggb2ZcbiAgICAgICAgICogYSBmaW5kZXIgcGF0dGVybiBieSBsb29raW5nIGZvciBhIGJsYWNrLXdoaXRlLWJsYWNrIHJ1biBmcm9tIHRoZSBjZW50ZXIgaW4gdGhlIGRpcmVjdGlvblxuICAgICAgICAgKiBvZiBhbm90aGVyIHBvaW50IChhbm90aGVyIGZpbmRlciBwYXR0ZXJuIGNlbnRlciksIGFuZCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIHRvby5cbiAgICAgICAgICovXG4gICAgICAgIHNpemVPZkJsYWNrV2hpdGVCbGFja1J1bkJvdGhXYXlzKGZyb21YIC8qaW50Ki8sIGZyb21ZIC8qaW50Ki8sIHRvWCAvKmludCovLCB0b1kgLyppbnQqLykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKGZyb21YLCBmcm9tWSwgdG9YLCB0b1kpO1xuICAgICAgICAgICAgLy8gTm93IGNvdW50IG90aGVyIHdheSAtLSBkb24ndCBydW4gb2ZmIGltYWdlIHRob3VnaCBvZiBjb3Vyc2VcbiAgICAgICAgICAgIGxldCBzY2FsZSA9IDEuMDtcbiAgICAgICAgICAgIGxldCBvdGhlclRvWCA9IGZyb21YIC0gKHRvWCAtIGZyb21YKTtcbiAgICAgICAgICAgIGlmIChvdGhlclRvWCA8IDApIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9IGZyb21YIC8gLyooZmxvYXQpICovIChmcm9tWCAtIG90aGVyVG9YKTtcbiAgICAgICAgICAgICAgICBvdGhlclRvWCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdGhlclRvWCA+PSB0aGlzLmltYWdlLmdldFdpZHRoKCkpIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9ICh0aGlzLmltYWdlLmdldFdpZHRoKCkgLSAxIC0gZnJvbVgpIC8gLyooZmxvYXQpICovIChvdGhlclRvWCAtIGZyb21YKTtcbiAgICAgICAgICAgICAgICBvdGhlclRvWCA9IHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb3RoZXJUb1kgPSAvKihpbnQpICovIE1hdGguZmxvb3IoZnJvbVkgLSAodG9ZIC0gZnJvbVkpICogc2NhbGUpO1xuICAgICAgICAgICAgc2NhbGUgPSAxLjA7XG4gICAgICAgICAgICBpZiAob3RoZXJUb1kgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSBmcm9tWSAvIC8qKGZsb2F0KSAqLyAoZnJvbVkgLSBvdGhlclRvWSk7XG4gICAgICAgICAgICAgICAgb3RoZXJUb1kgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3RoZXJUb1kgPj0gdGhpcy5pbWFnZS5nZXRIZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgIHNjYWxlID0gKHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCkgLSAxIC0gZnJvbVkpIC8gLyooZmxvYXQpICovIChvdGhlclRvWSAtIGZyb21ZKTtcbiAgICAgICAgICAgICAgICBvdGhlclRvWSA9IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3RoZXJUb1ggPSAvKihpbnQpICovIE1hdGguZmxvb3IoZnJvbVggKyAob3RoZXJUb1ggLSBmcm9tWCkgKiBzY2FsZSk7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW4oZnJvbVgsIGZyb21ZLCBvdGhlclRvWCwgb3RoZXJUb1kpO1xuICAgICAgICAgICAgLy8gTWlkZGxlIHBpeGVsIGlzIGRvdWJsZS1jb3VudGVkIHRoaXMgd2F5OyBzdWJ0cmFjdCAxXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0IC0gMS4wO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5UaGlzIG1ldGhvZCB0cmFjZXMgYSBsaW5lIGZyb20gYSBwb2ludCBpbiB0aGUgaW1hZ2UsIGluIHRoZSBkaXJlY3Rpb24gdG93YXJkcyBhbm90aGVyIHBvaW50LlxuICAgICAgICAgKiBJdCBiZWdpbnMgaW4gYSBibGFjayByZWdpb24sIGFuZCBrZWVwcyBnb2luZyB1bnRpbCBpdCBmaW5kcyB3aGl0ZSwgdGhlbiBibGFjaywgdGhlbiB3aGl0ZSBhZ2Fpbi5cbiAgICAgICAgICogSXQgcmVwb3J0cyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgc3RhcnQgdG8gdGhpcyBwb2ludC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlRoaXMgaXMgdXNlZCB3aGVuIGZpZ3VyaW5nIG91dCBob3cgd2lkZSBhIGZpbmRlciBwYXR0ZXJuIGlzLCB3aGVuIHRoZSBmaW5kZXIgcGF0dGVyblxuICAgICAgICAgKiBtYXkgYmUgc2tld2VkIG9yIHJvdGF0ZWQuPC9wPlxuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKGZyb21YIC8qaW50Ki8sIGZyb21ZIC8qaW50Ki8sIHRvWCAvKmludCovLCB0b1kgLyppbnQqLykge1xuICAgICAgICAgICAgLy8gTWlsZCB2YXJpYW50IG9mIEJyZXNlbmhhbSdzIGFsZ29yaXRobVxuICAgICAgICAgICAgLy8gc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlc2VuaGFtJ3NfbGluZV9hbGdvcml0aG1cbiAgICAgICAgICAgIGNvbnN0IHN0ZWVwID0gTWF0aC5hYnModG9ZIC0gZnJvbVkpID4gTWF0aC5hYnModG9YIC0gZnJvbVgpO1xuICAgICAgICAgICAgaWYgKHN0ZWVwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBmcm9tWDtcbiAgICAgICAgICAgICAgICBmcm9tWCA9IGZyb21ZO1xuICAgICAgICAgICAgICAgIGZyb21ZID0gdGVtcDtcbiAgICAgICAgICAgICAgICB0ZW1wID0gdG9YO1xuICAgICAgICAgICAgICAgIHRvWCA9IHRvWTtcbiAgICAgICAgICAgICAgICB0b1kgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZHggPSBNYXRoLmFicyh0b1ggLSBmcm9tWCk7XG4gICAgICAgICAgICBjb25zdCBkeSA9IE1hdGguYWJzKHRvWSAtIGZyb21ZKTtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IC1keCAvIDI7XG4gICAgICAgICAgICBjb25zdCB4c3RlcCA9IGZyb21YIDwgdG9YID8gMSA6IC0xO1xuICAgICAgICAgICAgY29uc3QgeXN0ZXAgPSBmcm9tWSA8IHRvWSA/IDEgOiAtMTtcbiAgICAgICAgICAgIC8vIEluIGJsYWNrIHBpeGVscywgbG9va2luZyBmb3Igd2hpdGUsIGZpcnN0IG9yIHNlY29uZCB0aW1lLlxuICAgICAgICAgICAgbGV0IHN0YXRlID0gMDtcbiAgICAgICAgICAgIC8vIExvb3AgdXAgdW50aWwgeCA9PSB0b1gsIGJ1dCBub3QgYmV5b25kXG4gICAgICAgICAgICBjb25zdCB4TGltaXQgPSB0b1ggKyB4c3RlcDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSBmcm9tWCwgeSA9IGZyb21ZOyB4ICE9PSB4TGltaXQ7IHggKz0geHN0ZXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFsWCA9IHN0ZWVwID8geSA6IHg7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhbFkgPSBzdGVlcCA/IHggOiB5O1xuICAgICAgICAgICAgICAgIC8vIERvZXMgY3VycmVudCBwaXhlbCBtZWFuIHdlIGhhdmUgbW92ZWQgd2hpdGUgdG8gYmxhY2sgb3IgdmljZSB2ZXJzYT9cbiAgICAgICAgICAgICAgICAvLyBTY2FubmluZyBibGFjayBpbiBzdGF0ZSAwLDIgYW5kIHdoaXRlIGluIHN0YXRlIDEsIHNvIGlmIHdlIGZpbmQgdGhlIHdyb25nXG4gICAgICAgICAgICAgICAgLy8gY29sb3IsIGFkdmFuY2UgdG8gbmV4dCBzdGF0ZSBvciBlbmQgaWYgd2UgYXJlIGluIHN0YXRlIDIgYWxyZWFkeVxuICAgICAgICAgICAgICAgIGlmICgoc3RhdGUgPT09IDEpID09PSB0aGlzLmltYWdlLmdldChyZWFsWCwgcmVhbFkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5kaXN0YW5jZSh4LCB5LCBmcm9tWCwgZnJvbVkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9yICs9IGR5O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPT09IHRvWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeSArPSB5c3RlcDtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgLT0gZHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm91bmQgYmxhY2std2hpdGUtYmxhY2s7IGdpdmUgdGhlIGJlbmVmaXQgb2YgdGhlIGRvdWJ0IHRoYXQgdGhlIG5leHQgcGl4ZWwgb3V0c2lkZSB0aGUgaW1hZ2VcbiAgICAgICAgICAgIC8vIGlzIFwid2hpdGVcIiBzbyB0aGlzIGxhc3QgcG9pbnQgYXQgKHRvWCt4U3RlcCx0b1kpIGlzIHRoZSByaWdodCBlbmRpbmcuIFRoaXMgaXMgcmVhbGx5IGFcbiAgICAgICAgICAgIC8vIHNtYWxsIGFwcHJveGltYXRpb247ICh0b1greFN0ZXAsdG9ZK3lTdGVwKSBtaWdodCBiZSByZWFsbHkgY29ycmVjdC4gSWdub3JlIHRoaXMuXG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLmRpc3RhbmNlKHRvWCArIHhzdGVwLCB0b1ksIGZyb21YLCBmcm9tWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIHdlIGRpZG4ndCBmaW5kIGV2ZW4gYmxhY2std2hpdGUtYmxhY2s7IG5vIGVzdGltYXRlIGlzIHJlYWxseSBwb3NzaWJsZVxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+QXR0ZW1wdHMgdG8gbG9jYXRlIGFuIGFsaWdubWVudCBwYXR0ZXJuIGluIGEgbGltaXRlZCByZWdpb24gb2YgdGhlIGltYWdlLCB3aGljaCBpc1xuICAgICAgICAgKiBndWVzc2VkIHRvIGNvbnRhaW4gaXQuIFRoaXMgbWV0aG9kIHVzZXMge0BsaW5rIEFsaWdubWVudFBhdHRlcm59LjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG92ZXJhbGxFc3RNb2R1bGVTaXplIGVzdGltYXRlZCBtb2R1bGUgc2l6ZSBzbyBmYXJcbiAgICAgICAgICogQHBhcmFtIGVzdEFsaWdubWVudFggeCBjb29yZGluYXRlIG9mIGNlbnRlciBvZiBhcmVhIHByb2JhYmx5IGNvbnRhaW5pbmcgYWxpZ25tZW50IHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIGVzdEFsaWdubWVudFkgeSBjb29yZGluYXRlIG9mIGFib3ZlXG4gICAgICAgICAqIEBwYXJhbSBhbGxvd2FuY2VGYWN0b3IgbnVtYmVyIG9mIHBpeGVscyBpbiBhbGwgZGlyZWN0aW9ucyB0byBzZWFyY2ggZnJvbSB0aGUgY2VudGVyXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIEFsaWdubWVudFBhdHRlcm59IGlmIGZvdW5kLCBvciBudWxsIG90aGVyd2lzZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJzIGR1cmluZyBkZXRlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRBbGlnbm1lbnRJblJlZ2lvbihvdmVyYWxsRXN0TW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIGVzdEFsaWdubWVudFggLyppbnQqLywgZXN0QWxpZ25tZW50WSAvKmludCovLCBhbGxvd2FuY2VGYWN0b3IgLypmbG9hdCovKSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciBhbiBhbGlnbm1lbnQgcGF0dGVybiAoMyBtb2R1bGVzIGluIHNpemUpIGFyb3VuZCB3aGVyZSBpdFxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlXG4gICAgICAgICAgICBjb25zdCBhbGxvd2FuY2UgPSAvKihpbnQpICovIE1hdGguZmxvb3IoYWxsb3dhbmNlRmFjdG9yICogb3ZlcmFsbEVzdE1vZHVsZVNpemUpO1xuICAgICAgICAgICAgY29uc3QgYWxpZ25tZW50QXJlYUxlZnRYID0gTWF0aC5tYXgoMCwgZXN0QWxpZ25tZW50WCAtIGFsbG93YW5jZSk7XG4gICAgICAgICAgICBjb25zdCBhbGlnbm1lbnRBcmVhUmlnaHRYID0gTWF0aC5taW4odGhpcy5pbWFnZS5nZXRXaWR0aCgpIC0gMSwgZXN0QWxpZ25tZW50WCArIGFsbG93YW5jZSk7XG4gICAgICAgICAgICBpZiAoYWxpZ25tZW50QXJlYVJpZ2h0WCAtIGFsaWdubWVudEFyZWFMZWZ0WCA8IG92ZXJhbGxFc3RNb2R1bGVTaXplICogMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbignQWxpZ25tZW50IHRvcCBleGNlZWRzIGVzdGltYXRlZCBtb2R1bGUgc2l6ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFsaWdubWVudEFyZWFUb3BZID0gTWF0aC5tYXgoMCwgZXN0QWxpZ25tZW50WSAtIGFsbG93YW5jZSk7XG4gICAgICAgICAgICBjb25zdCBhbGlnbm1lbnRBcmVhQm90dG9tWSA9IE1hdGgubWluKHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCkgLSAxLCBlc3RBbGlnbm1lbnRZICsgYWxsb3dhbmNlKTtcbiAgICAgICAgICAgIGlmIChhbGlnbm1lbnRBcmVhQm90dG9tWSAtIGFsaWdubWVudEFyZWFUb3BZIDwgb3ZlcmFsbEVzdE1vZHVsZVNpemUgKiAzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCdBbGlnbm1lbnQgYm90dG9tIGV4Y2VlZHMgZXN0aW1hdGVkIG1vZHVsZSBzaXplLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWxpZ25tZW50RmluZGVyID0gbmV3IEFsaWdubWVudFBhdHRlcm5GaW5kZXIodGhpcy5pbWFnZSwgYWxpZ25tZW50QXJlYUxlZnRYLCBhbGlnbm1lbnRBcmVhVG9wWSwgYWxpZ25tZW50QXJlYVJpZ2h0WCAtIGFsaWdubWVudEFyZWFMZWZ0WCwgYWxpZ25tZW50QXJlYUJvdHRvbVkgLSBhbGlnbm1lbnRBcmVhVG9wWSwgb3ZlcmFsbEVzdE1vZHVsZVNpemUsIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gYWxpZ25tZW50RmluZGVyLmZpbmQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgLyoqXG4gICAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjYW4gZGV0ZWN0IGFuZCBkZWNvZGUgUVIgQ29kZXMgaW4gYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIFFSQ29kZVJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IERlY29kZXIkMigpO1xuICAgICAgICB9XG4gICAgICAgIGdldERlY29kZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2NhdGVzIGFuZCBkZWNvZGVzIGEgUVIgY29kZSBpbiBhbiBpbWFnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBhIHJlcHJlc2VudGluZzogc3RyaW5nIHRoZSBjb250ZW50IGVuY29kZWQgYnkgdGhlIFFSIGNvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhIFFSIGNvZGUgY2Fubm90IGJlIGZvdW5kXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgUVIgY29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcbiAgICAgICAgICovXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgLy8gcHVibGljIGRlY29kZShpbWFnZTogQmluYXJ5Qml0bWFwKTogUmVzdWx0IC8qdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uLCBDaGVja3N1bUV4Y2VwdGlvbiwgRm9ybWF0RXhjZXB0aW9uICovIHtcbiAgICAgICAgLy8gICByZXR1cm4gdGhpcy5kZWNvZGUoaW1hZ2UsIG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBkZWNvZGUoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgICAgICBsZXQgZGVjb2RlclJlc3VsdDtcbiAgICAgICAgICAgIGxldCBwb2ludHM7XG4gICAgICAgICAgICBpZiAoaGludHMgIT09IHVuZGVmaW5lZCAmJiBoaW50cyAhPT0gbnVsbCAmJiB1bmRlZmluZWQgIT09IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlBVUkVfQkFSQ09ERSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRzID0gUVJDb2RlUmVhZGVyLmV4dHJhY3RQdXJlQml0cyhpbWFnZS5nZXRCbGFja01hdHJpeCgpKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gdGhpcy5kZWNvZGVyLmRlY29kZUJpdE1hdHJpeChiaXRzLCBoaW50cyk7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gUVJDb2RlUmVhZGVyLk5PX1BPSU5UUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldGVjdG9yUmVzdWx0ID0gbmV3IERldGVjdG9yJDIoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSkuZGV0ZWN0KGhpbnRzKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gdGhpcy5kZWNvZGVyLmRlY29kZUJpdE1hdHJpeChkZXRlY3RvclJlc3VsdC5nZXRCaXRzKCksIGhpbnRzKTtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBkZXRlY3RvclJlc3VsdC5nZXRQb2ludHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBjb2RlIHdhcyBtaXJyb3JlZDogc3dhcCB0aGUgYm90dG9tLWxlZnQgYW5kIHRoZSB0b3AtcmlnaHQgcG9pbnRzLlxuICAgICAgICAgICAgaWYgKGRlY29kZXJSZXN1bHQuZ2V0T3RoZXIoKSBpbnN0YW5jZW9mIFFSQ29kZURlY29kZXJNZXRhRGF0YSkge1xuICAgICAgICAgICAgICAgIGRlY29kZXJSZXN1bHQuZ2V0T3RoZXIoKS5hcHBseU1pcnJvcmVkQ29ycmVjdGlvbihwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFJlc3VsdChkZWNvZGVyUmVzdWx0LmdldFRleHQoKSwgZGVjb2RlclJlc3VsdC5nZXRSYXdCeXRlcygpLCB1bmRlZmluZWQsIHBvaW50cywgQmFyY29kZUZvcm1hdCQxLlFSX0NPREUsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCBieXRlU2VnbWVudHMgPSBkZWNvZGVyUmVzdWx0LmdldEJ5dGVTZWdtZW50cygpO1xuICAgICAgICAgICAgaWYgKGJ5dGVTZWdtZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5CWVRFX1NFR01FTlRTLCBieXRlU2VnbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWNMZXZlbCA9IGRlY29kZXJSZXN1bHQuZ2V0RUNMZXZlbCgpO1xuICAgICAgICAgICAgaWYgKGVjTGV2ZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuRVJST1JfQ09SUkVDVElPTl9MRVZFTCwgZWNMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjb2RlclJlc3VsdC5oYXNTdHJ1Y3R1cmVkQXBwZW5kKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuU1RSVUNUVVJFRF9BUFBFTkRfU0VRVUVOQ0UsIGRlY29kZXJSZXN1bHQuZ2V0U3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5TVFJVQ1RVUkVEX0FQUEVORF9QQVJJVFksIGRlY29kZXJSZXN1bHQuZ2V0U3RydWN0dXJlZEFwcGVuZFBhcml0eSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgZGV0ZWN0cyBhIGNvZGUgaW4gYSBcInB1cmVcIiBpbWFnZSAtLSB0aGF0IGlzLCBwdXJlIG1vbm9jaHJvbWUgaW1hZ2VcbiAgICAgICAgICogd2hpY2ggY29udGFpbnMgb25seSBhbiB1bnJvdGF0ZWQsIHVuc2tld2VkLCBpbWFnZSBvZiBhIGNvZGUsIHdpdGggc29tZSB3aGl0ZSBib3JkZXJcbiAgICAgICAgICogYXJvdW5kIGl0LiBUaGlzIGlzIGEgc3BlY2lhbGl6ZWQgbWV0aG9kIHRoYXQgd29ya3MgZXhjZXB0aW9uYWxseSBmYXN0IGluIHRoaXMgc3BlY2lhbFxuICAgICAgICAgKiBjYXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2VlIGNvbS5nb29nbGUuenhpbmcuZGF0YW1hdHJpeC5EYXRhTWF0cml4UmVhZGVyI2V4dHJhY3RQdXJlQml0cyhCaXRNYXRyaXgpXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZXh0cmFjdFB1cmVCaXRzKGltYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0VG9wQmxhY2sgPSBpbWFnZS5nZXRUb3BMZWZ0T25CaXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0Qm90dG9tQmxhY2sgPSBpbWFnZS5nZXRCb3R0b21SaWdodE9uQml0KCk7XG4gICAgICAgICAgICBpZiAobGVmdFRvcEJsYWNrID09PSBudWxsIHx8IHJpZ2h0Qm90dG9tQmxhY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemUgPSB0aGlzLm1vZHVsZVNpemUobGVmdFRvcEJsYWNrLCBpbWFnZSk7XG4gICAgICAgICAgICBsZXQgdG9wID0gbGVmdFRvcEJsYWNrWzFdO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IHJpZ2h0Qm90dG9tQmxhY2tbMV07XG4gICAgICAgICAgICBsZXQgbGVmdCA9IGxlZnRUb3BCbGFja1swXTtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHJpZ2h0Qm90dG9tQmxhY2tbMF07XG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2shXG4gICAgICAgICAgICBpZiAobGVmdCA+PSByaWdodCB8fCB0b3AgPj0gYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm90dG9tIC0gdG9wICE9PSByaWdodCAtIGxlZnQpIHtcbiAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UsIHdoZXJlIGJvdHRvbS1yaWdodCBtb2R1bGUgd2Fzbid0IGJsYWNrIHNvIHdlIGZvdW5kIHNvbWV0aGluZyBlbHNlIGluIHRoZSBsYXN0IHJvd1xuICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBpdCdzIGEgc3F1YXJlLCBzbyB1c2UgaGVpZ2h0IGFzIHRoZSB3aWR0aFxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIChib3R0b20gLSB0b3ApO1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCA+PSBpbWFnZS5nZXRXaWR0aCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFib3J0IGlmIHRoYXQgd291bGQgbm90IG1ha2Ugc2Vuc2UgLS0gb2ZmIGltYWdlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeFdpZHRoID0gTWF0aC5yb3VuZCgocmlnaHQgLSBsZWZ0ICsgMSkgLyBtb2R1bGVTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeEhlaWdodCA9IE1hdGgucm91bmQoKGJvdHRvbSAtIHRvcCArIDEpIC8gbW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICBpZiAobWF0cml4V2lkdGggPD0gMCB8fCBtYXRyaXhIZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdHJpeEhlaWdodCAhPT0gbWF0cml4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHBvc3NpYmx5IGRlY29kZSBzcXVhcmUgcmVnaW9uc1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHVzaCBpbiB0aGUgXCJib3JkZXJcIiBieSBoYWxmIHRoZSBtb2R1bGUgd2lkdGggc28gdGhhdCB3ZSBzdGFydFxuICAgICAgICAgICAgLy8gc2FtcGxpbmcgaW4gdGhlIG1pZGRsZSBvZiB0aGUgbW9kdWxlLiBKdXN0IGluIGNhc2UgdGhlIGltYWdlIGlzIGFcbiAgICAgICAgICAgIC8vIGxpdHRsZSBvZmYsIHRoaXMgd2lsbCBoZWxwIHJlY292ZXIuXG4gICAgICAgICAgICBjb25zdCBudWRnZSA9IC8qKGludCkgKi8gTWF0aC5mbG9vcihtb2R1bGVTaXplIC8gMi4wKTtcbiAgICAgICAgICAgIHRvcCArPSBudWRnZTtcbiAgICAgICAgICAgIGxlZnQgKz0gbnVkZ2U7XG4gICAgICAgICAgICAvLyBCdXQgY2FyZWZ1bCB0aGF0IHRoaXMgZG9lcyBub3Qgc2FtcGxlIG9mZiB0aGUgZWRnZVxuICAgICAgICAgICAgLy8gXCJyaWdodFwiIGlzIHRoZSBmYXJ0aGVzdC1yaWdodCB2YWxpZCBwaXhlbCBsb2NhdGlvbiAtLSByaWdodCsxIGlzIG5vdCBuZWNlc3NhcmlseVxuICAgICAgICAgICAgLy8gVGhpcyBpcyBwb3NpdGl2ZSBieSBob3cgbXVjaCB0aGUgaW5uZXIgeCBsb29wIGJlbG93IHdvdWxkIGJlIHRvbyBsYXJnZVxuICAgICAgICAgICAgY29uc3QgbnVkZ2VkVG9vRmFyUmlnaHQgPSBsZWZ0ICsgLyooaW50KSAqLyBNYXRoLmZsb29yKChtYXRyaXhXaWR0aCAtIDEpICogbW9kdWxlU2l6ZSkgLSByaWdodDtcbiAgICAgICAgICAgIGlmIChudWRnZWRUb29GYXJSaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobnVkZ2VkVG9vRmFyUmlnaHQgPiBudWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZWl0aGVyIHdheSBmaXRzOyBhYm9ydFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVmdCAtPSBudWRnZWRUb29GYXJSaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlZSBsb2dpYyBhYm92ZVxuICAgICAgICAgICAgY29uc3QgbnVkZ2VkVG9vRmFyRG93biA9IHRvcCArIC8qKGludCkgKi8gTWF0aC5mbG9vcigobWF0cml4SGVpZ2h0IC0gMSkgKiBtb2R1bGVTaXplKSAtIGJvdHRvbTtcbiAgICAgICAgICAgIGlmIChudWRnZWRUb29GYXJEb3duID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChudWRnZWRUb29GYXJEb3duID4gbnVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVpdGhlciB3YXkgZml0czsgYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvcCAtPSBudWRnZWRUb29GYXJEb3duO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IGp1c3QgcmVhZCBvZmYgdGhlIGJpdHNcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBuZXcgQml0TWF0cml4KG1hdHJpeFdpZHRoLCBtYXRyaXhIZWlnaHQpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBtYXRyaXhIZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlPZmZzZXQgPSB0b3AgKyAvKihpbnQpICovIE1hdGguZmxvb3IoeSAqIG1vZHVsZVNpemUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbWF0cml4V2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGxlZnQgKyAvKihpbnQpICovIE1hdGguZmxvb3IoeCAqIG1vZHVsZVNpemUpLCBpT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYml0cy5zZXQoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbW9kdWxlU2l6ZShsZWZ0VG9wQmxhY2ssIGltYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGxldCB4ID0gbGVmdFRvcEJsYWNrWzBdO1xuICAgICAgICAgICAgbGV0IHkgPSBsZWZ0VG9wQmxhY2tbMV07XG4gICAgICAgICAgICBsZXQgaW5CbGFjayA9IHRydWU7XG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbnMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHggPCB3aWR0aCAmJiB5IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluQmxhY2sgIT09IGltYWdlLmdldCh4LCB5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKyt0cmFuc2l0aW9ucyA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5CbGFjayA9ICFpbkJsYWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4Kys7XG4gICAgICAgICAgICAgICAgeSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPT09IHdpZHRoIHx8IHkgPT09IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICh4IC0gbGVmdFRvcEJsYWNrWzBdKSAvIDcuMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBRUkNvZGVSZWFkZXIuTk9fUE9JTlRTID0gbmV3IEFycmF5KCk7XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIFNJVEEgTGFiIChrZXZpbi5vc3VsbGl2YW5Ac2l0YS5hZXJvKVxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgUERGNDE3Q29tbW9uIHtcbiAgICAgICAgUERGNDE3Q29tbW9uKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gbW9kdWxlQml0Q291bnQgdmFsdWVzIHRvIHN1bVxuICAgICAgICAgKiBAcmV0dXJuIHN1bSBvZiB2YWx1ZXNcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgY2FsbCB7QGxpbmsgTWF0aFV0aWxzI3N1bShpbnRbXSl9XG4gICAgICAgICAqL1xuICAgICAgICAvLyBARGVwcmVjYXRlZFxuICAgICAgICBzdGF0aWMgZ2V0Qml0Q291bnRTdW0obW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuc3VtKG1vZHVsZUJpdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgdG9JbnRBcnJheShsaXN0KSB7XG4gICAgICAgICAgICBpZiAobGlzdCA9PSBudWxsIHx8ICFsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQREY0MTdDb21tb24uRU1QVFlfSU5UX0FSUkFZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkobGlzdC5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbnRlZ2VyIG9mIGxpc3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IGludGVnZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gc3ltYm9sIGVuY29kZWQgc3ltYm9sIHRvIHRyYW5zbGF0ZSB0byBhIGNvZGV3b3JkXG4gICAgICAgICAqIEByZXR1cm4gdGhlIGNvZGV3b3JkIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHN5bWJvbC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRDb2Rld29yZChzeW1ib2wgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgaSA9IEFycmF5cy5iaW5hcnlTZWFyY2goUERGNDE3Q29tbW9uLlNZTUJPTF9UQUJMRSwgc3ltYm9sICYgMHgzRkZGRik7XG4gICAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFBERjQxN0NvbW1vbi5DT0RFV09SRF9UQUJMRVtpXSAtIDEpICUgUERGNDE3Q29tbW9uLk5VTUJFUl9PRl9DT0RFV09SRFM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUERGNDE3Q29tbW9uLk5VTUJFUl9PRl9DT0RFV09SRFMgPSA5Mjk7XG4gICAgLy8gTWF4aW11bSBDb2Rld29yZHMgKERhdGEgKyBFcnJvcikuXG4gICAgUERGNDE3Q29tbW9uLk1BWF9DT0RFV09SRFNfSU5fQkFSQ09ERSA9IFBERjQxN0NvbW1vbi5OVU1CRVJfT0ZfQ09ERVdPUkRTIC0gMTtcbiAgICBQREY0MTdDb21tb24uTUlOX1JPV1NfSU5fQkFSQ09ERSA9IDM7XG4gICAgUERGNDE3Q29tbW9uLk1BWF9ST1dTX0lOX0JBUkNPREUgPSA5MDtcbiAgICAvLyBPbmUgbGVmdCByb3cgaW5kaWNhdGlvbiBjb2x1bW4gKyBtYXggMzAgZGF0YSBjb2x1bW5zICsgb25lIHJpZ2h0IHJvdyBpbmRpY2F0b3IgY29sdW1uXG4gICAgLy8gcHVibGljIHN0YXRpYyAvKmZpbmFsKi8gTUFYX0NPREVXT1JEU19JTl9ST1c6IC8qaW50Ki8gbnVtYmVyID0gMzI7XG4gICAgUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fQ09ERVdPUkQgPSAxNztcbiAgICBQREY0MTdDb21tb24uTU9EVUxFU19JTl9TVE9QX1BBVFRFUk4gPSAxODtcbiAgICBQREY0MTdDb21tb24uQkFSU19JTl9NT0RVTEUgPSA4O1xuICAgIFBERjQxN0NvbW1vbi5FTVBUWV9JTlRfQVJSQVkgPSBuZXcgSW50MzJBcnJheShbXSk7XG4gICAgLyoqXG4gICAgICogVGhlIHNvcnRlZCB0YWJsZSBvZiBhbGwgcG9zc2libGUgc3ltYm9scy4gRXh0cmFjdGVkIGZyb20gdGhlIFBERjQxN1xuICAgICAqIHNwZWNpZmljYXRpb24uIFRoZSBpbmRleCBvZiBhIHN5bWJvbCBpbiB0aGlzIHRhYmxlIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgICAqIGluZGV4IGludG8gdGhlIGNvZGV3b3JkIHRhYmxlLlxuICAgICAqL1xuICAgIFBERjQxN0NvbW1vbi5TWU1CT0xfVEFCTEUgPSBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAweDEwMjVlLCAweDEwMjdhLCAweDEwMjllLCAweDEwMmJjLCAweDEwMmYyLCAweDEwMmY0LCAweDEwMzJlLCAweDEwMzRlLCAweDEwMzVjLCAweDEwMzk2LCAweDEwM2E2LCAweDEwM2FjLFxuICAgICAgICAweDEwNDIyLCAweDEwNDI4LCAweDEwNDM2LCAweDEwNDQyLCAweDEwNDQ0LCAweDEwNDQ4LCAweDEwNDUwLCAweDEwNDVlLCAweDEwNDY2LCAweDEwNDZjLCAweDEwNDdhLCAweDEwNDgyLFxuICAgICAgICAweDEwNDllLCAweDEwNGEwLCAweDEwNGJjLCAweDEwNGM2LCAweDEwNGQ4LCAweDEwNGVlLCAweDEwNGYyLCAweDEwNGY0LCAweDEwNTA0LCAweDEwNTA4LCAweDEwNTEwLCAweDEwNTFlLFxuICAgICAgICAweDEwNTIwLCAweDEwNTNjLCAweDEwNTQwLCAweDEwNTc4LCAweDEwNTg2LCAweDEwNThjLCAweDEwNTk4LCAweDEwNWIwLCAweDEwNWJlLCAweDEwNWNlLCAweDEwNWRjLCAweDEwNWUyLFxuICAgICAgICAweDEwNWU0LCAweDEwNWU4LCAweDEwNWY2LCAweDEwNjJlLCAweDEwNjRlLCAweDEwNjVjLCAweDEwNjhlLCAweDEwNjljLCAweDEwNmI4LCAweDEwNmRlLCAweDEwNmZhLCAweDEwNzE2LFxuICAgICAgICAweDEwNzI2LCAweDEwNzJjLCAweDEwNzQ2LCAweDEwNzRjLCAweDEwNzU4LCAweDEwNzZlLCAweDEwNzkyLCAweDEwNzk0LCAweDEwN2EyLCAweDEwN2E0LCAweDEwN2E4LCAweDEwN2I2LFxuICAgICAgICAweDEwODIyLCAweDEwODI4LCAweDEwODQyLCAweDEwODQ4LCAweDEwODUwLCAweDEwODVlLCAweDEwODY2LCAweDEwODZjLCAweDEwODdhLCAweDEwODgyLCAweDEwODg0LCAweDEwODkwLFxuICAgICAgICAweDEwODllLCAweDEwOGEwLCAweDEwOGJjLCAweDEwOGM2LCAweDEwOGNjLCAweDEwOGQ4LCAweDEwOGVlLCAweDEwOGYyLCAweDEwOGY0LCAweDEwOTAyLCAweDEwOTA4LCAweDEwOTFlLFxuICAgICAgICAweDEwOTIwLCAweDEwOTNjLCAweDEwOTQwLCAweDEwOTc4LCAweDEwOTg2LCAweDEwOTk4LCAweDEwOWIwLCAweDEwOWJlLCAweDEwOWNlLCAweDEwOWRjLCAweDEwOWUyLCAweDEwOWU0LFxuICAgICAgICAweDEwOWU4LCAweDEwOWY2LCAweDEwYTA4LCAweDEwYTEwLCAweDEwYTFlLCAweDEwYTIwLCAweDEwYTNjLCAweDEwYTQwLCAweDEwYTc4LCAweDEwYWYwLCAweDEwYjA2LCAweDEwYjBjLFxuICAgICAgICAweDEwYjE4LCAweDEwYjMwLCAweDEwYjNlLCAweDEwYjYwLCAweDEwYjdjLCAweDEwYjhlLCAweDEwYjljLCAweDEwYmI4LCAweDEwYmMyLCAweDEwYmM0LCAweDEwYmM4LCAweDEwYmQwLFxuICAgICAgICAweDEwYmRlLCAweDEwYmU2LCAweDEwYmVjLCAweDEwYzJlLCAweDEwYzRlLCAweDEwYzVjLCAweDEwYzYyLCAweDEwYzY0LCAweDEwYzY4LCAweDEwYzc2LCAweDEwYzhlLCAweDEwYzljLFxuICAgICAgICAweDEwY2I4LCAweDEwY2MyLCAweDEwY2M0LCAweDEwY2M4LCAweDEwY2QwLCAweDEwY2RlLCAweDEwY2U2LCAweDEwY2VjLCAweDEwY2ZhLCAweDEwZDBlLCAweDEwZDFjLCAweDEwZDM4LFxuICAgICAgICAweDEwZDcwLCAweDEwZDdlLCAweDEwZDgyLCAweDEwZDg0LCAweDEwZDg4LCAweDEwZDkwLCAweDEwZDllLCAweDEwZGEwLCAweDEwZGJjLCAweDEwZGM2LCAweDEwZGNjLCAweDEwZGQ4LFxuICAgICAgICAweDEwZGVlLCAweDEwZGYyLCAweDEwZGY0LCAweDEwZTE2LCAweDEwZTI2LCAweDEwZTJjLCAweDEwZTQ2LCAweDEwZTU4LCAweDEwZTZlLCAweDEwZTg2LCAweDEwZThjLCAweDEwZTk4LFxuICAgICAgICAweDEwZWIwLCAweDEwZWJlLCAweDEwZWNlLCAweDEwZWRjLCAweDEwZjBhLCAweDEwZjEyLCAweDEwZjE0LCAweDEwZjIyLCAweDEwZjI4LCAweDEwZjM2LCAweDEwZjQyLCAweDEwZjQ0LFxuICAgICAgICAweDEwZjQ4LCAweDEwZjUwLCAweDEwZjVlLCAweDEwZjY2LCAweDEwZjZjLCAweDEwZmIyLCAweDEwZmI0LCAweDExMDIyLCAweDExMDI4LCAweDExMDQyLCAweDExMDQ4LCAweDExMDUwLFxuICAgICAgICAweDExMDVlLCAweDExMDdhLCAweDExMDgyLCAweDExMDg0LCAweDExMDkwLCAweDExMDllLCAweDExMGEwLCAweDExMGJjLCAweDExMGM2LCAweDExMGNjLCAweDExMGQ4LCAweDExMGVlLFxuICAgICAgICAweDExMGYyLCAweDExMGY0LCAweDExMTAyLCAweDExMTFlLCAweDExMTIwLCAweDExMTNjLCAweDExMTQwLCAweDExMTc4LCAweDExMTg2LCAweDExMTk4LCAweDExMWIwLCAweDExMWJlLFxuICAgICAgICAweDExMWNlLCAweDExMWRjLCAweDExMWUyLCAweDExMWU0LCAweDExMWU4LCAweDExMWY2LCAweDExMjA4LCAweDExMjFlLCAweDExMjIwLCAweDExMjc4LCAweDExMmYwLCAweDExMzBjLFxuICAgICAgICAweDExMzMwLCAweDExMzNlLCAweDExMzYwLCAweDExMzdjLCAweDExMzhlLCAweDExMzljLCAweDExM2I4LCAweDExM2MyLCAweDExM2M4LCAweDExM2QwLCAweDExM2RlLCAweDExM2U2LFxuICAgICAgICAweDExM2VjLCAweDExNDA4LCAweDExNDEwLCAweDExNDFlLCAweDExNDIwLCAweDExNDNjLCAweDExNDQwLCAweDExNDc4LCAweDExNGYwLCAweDExNWUwLCAweDExNjBjLCAweDExNjE4LFxuICAgICAgICAweDExNjMwLCAweDExNjNlLCAweDExNjYwLCAweDExNjdjLCAweDExNmMwLCAweDExNmY4LCAweDExNzFjLCAweDExNzM4LCAweDExNzcwLCAweDExNzdlLCAweDExNzgyLCAweDExNzg0LFxuICAgICAgICAweDExNzg4LCAweDExNzkwLCAweDExNzllLCAweDExN2EwLCAweDExN2JjLCAweDExN2M2LCAweDExN2NjLCAweDExN2Q4LCAweDExN2VlLCAweDExODJlLCAweDExODM0LCAweDExODRlLFxuICAgICAgICAweDExODVjLCAweDExODYyLCAweDExODY0LCAweDExODY4LCAweDExODc2LCAweDExODhlLCAweDExODljLCAweDExOGI4LCAweDExOGMyLCAweDExOGM4LCAweDExOGQwLCAweDExOGRlLFxuICAgICAgICAweDExOGU2LCAweDExOGVjLCAweDExOGZhLCAweDExOTBlLCAweDExOTFjLCAweDExOTM4LCAweDExOTcwLCAweDExOTdlLCAweDExOTgyLCAweDExOTg0LCAweDExOTkwLCAweDExOTllLFxuICAgICAgICAweDExOWEwLCAweDExOWJjLCAweDExOWM2LCAweDExOWNjLCAweDExOWQ4LCAweDExOWVlLCAweDExOWYyLCAweDExOWY0LCAweDExYTBlLCAweDExYTFjLCAweDExYTM4LCAweDExYTcwLFxuICAgICAgICAweDExYTdlLCAweDExYWUwLCAweDExYWZjLCAweDExYjA4LCAweDExYjEwLCAweDExYjFlLCAweDExYjIwLCAweDExYjNjLCAweDExYjQwLCAweDExYjc4LCAweDExYjhjLCAweDExYjk4LFxuICAgICAgICAweDExYmIwLCAweDExYmJlLCAweDExYmNlLCAweDExYmRjLCAweDExYmUyLCAweDExYmU0LCAweDExYmU4LCAweDExYmY2LCAweDExYzE2LCAweDExYzI2LCAweDExYzJjLCAweDExYzQ2LFxuICAgICAgICAweDExYzRjLCAweDExYzU4LCAweDExYzZlLCAweDExYzg2LCAweDExYzk4LCAweDExY2IwLCAweDExY2JlLCAweDExY2NlLCAweDExY2RjLCAweDExY2UyLCAweDExY2U0LCAweDExY2U4LFxuICAgICAgICAweDExY2Y2LCAweDExZDA2LCAweDExZDBjLCAweDExZDE4LCAweDExZDMwLCAweDExZDNlLCAweDExZDYwLCAweDExZDdjLCAweDExZDhlLCAweDExZDljLCAweDExZGI4LCAweDExZGM0LFxuICAgICAgICAweDExZGM4LCAweDExZGQwLCAweDExZGRlLCAweDExZGU2LCAweDExZGVjLCAweDExZGZhLCAweDExZTBhLCAweDExZTEyLCAweDExZTE0LCAweDExZTIyLCAweDExZTI0LCAweDExZTI4LFxuICAgICAgICAweDExZTM2LCAweDExZTQyLCAweDExZTQ0LCAweDExZTUwLCAweDExZTVlLCAweDExZTY2LCAweDExZTZjLCAweDExZTgyLCAweDExZTg0LCAweDExZTg4LCAweDExZTkwLCAweDExZTllLFxuICAgICAgICAweDExZWEwLCAweDExZWJjLCAweDExZWM2LCAweDExZWNjLCAweDExZWQ4LCAweDExZWVlLCAweDExZjFhLCAweDExZjJlLCAweDExZjMyLCAweDExZjM0LCAweDExZjRlLCAweDExZjVjLFxuICAgICAgICAweDExZjYyLCAweDExZjY0LCAweDExZjY4LCAweDExZjc2LCAweDEyMDQ4LCAweDEyMDVlLCAweDEyMDgyLCAweDEyMDg0LCAweDEyMDkwLCAweDEyMDllLCAweDEyMGEwLCAweDEyMGJjLFxuICAgICAgICAweDEyMGQ4LCAweDEyMGYyLCAweDEyMGY0LCAweDEyMTA4LCAweDEyMTFlLCAweDEyMTIwLCAweDEyMTNjLCAweDEyMTQwLCAweDEyMTc4LCAweDEyMTg2LCAweDEyMTk4LCAweDEyMWIwLFxuICAgICAgICAweDEyMWJlLCAweDEyMWUyLCAweDEyMWU0LCAweDEyMWU4LCAweDEyMWY2LCAweDEyMjA0LCAweDEyMjEwLCAweDEyMjFlLCAweDEyMjIwLCAweDEyMjc4LCAweDEyMmYwLCAweDEyMzA2LFxuICAgICAgICAweDEyMzBjLCAweDEyMzMwLCAweDEyMzNlLCAweDEyMzYwLCAweDEyMzdjLCAweDEyMzhlLCAweDEyMzljLCAweDEyM2I4LCAweDEyM2MyLCAweDEyM2M4LCAweDEyM2QwLCAweDEyM2U2LFxuICAgICAgICAweDEyM2VjLCAweDEyNDFlLCAweDEyNDIwLCAweDEyNDNjLCAweDEyNGYwLCAweDEyNWUwLCAweDEyNjE4LCAweDEyNjNlLCAweDEyNjYwLCAweDEyNjdjLCAweDEyNmMwLCAweDEyNmY4LFxuICAgICAgICAweDEyNzM4LCAweDEyNzcwLCAweDEyNzdlLCAweDEyNzgyLCAweDEyNzg0LCAweDEyNzkwLCAweDEyNzllLCAweDEyN2EwLCAweDEyN2JjLCAweDEyN2M2LCAweDEyN2NjLCAweDEyN2Q4LFxuICAgICAgICAweDEyN2VlLCAweDEyODIwLCAweDEyODNjLCAweDEyODQwLCAweDEyODc4LCAweDEyOGYwLCAweDEyOWUwLCAweDEyYmMwLCAweDEyYzE4LCAweDEyYzMwLCAweDEyYzNlLCAweDEyYzYwLFxuICAgICAgICAweDEyYzdjLCAweDEyY2MwLCAweDEyY2Y4LCAweDEyZGYwLCAweDEyZTFjLCAweDEyZTM4LCAweDEyZTcwLCAweDEyZTdlLCAweDEyZWUwLCAweDEyZWZjLCAweDEyZjA0LCAweDEyZjA4LFxuICAgICAgICAweDEyZjEwLCAweDEyZjIwLCAweDEyZjNjLCAweDEyZjQwLCAweDEyZjc4LCAweDEyZjg2LCAweDEyZjhjLCAweDEyZjk4LCAweDEyZmIwLCAweDEyZmJlLCAweDEyZmNlLCAweDEyZmRjLFxuICAgICAgICAweDEzMDJlLCAweDEzMDRlLCAweDEzMDVjLCAweDEzMDYyLCAweDEzMDY4LCAweDEzMDhlLCAweDEzMDljLCAweDEzMGI4LCAweDEzMGMyLCAweDEzMGM4LCAweDEzMGQwLCAweDEzMGRlLFxuICAgICAgICAweDEzMGVjLCAweDEzMGZhLCAweDEzMTBlLCAweDEzMTM4LCAweDEzMTcwLCAweDEzMTdlLCAweDEzMTgyLCAweDEzMTg0LCAweDEzMTkwLCAweDEzMTllLCAweDEzMWEwLCAweDEzMWJjLFxuICAgICAgICAweDEzMWM2LCAweDEzMWNjLCAweDEzMWQ4LCAweDEzMWYyLCAweDEzMWY0LCAweDEzMjBlLCAweDEzMjFjLCAweDEzMjcwLCAweDEzMjdlLCAweDEzMmUwLCAweDEzMmZjLCAweDEzMzA4LFxuICAgICAgICAweDEzMzFlLCAweDEzMzIwLCAweDEzMzNjLCAweDEzMzQwLCAweDEzMzc4LCAweDEzMzg2LCAweDEzMzk4LCAweDEzM2IwLCAweDEzM2JlLCAweDEzM2NlLCAweDEzM2RjLCAweDEzM2UyLFxuICAgICAgICAweDEzM2U0LCAweDEzM2U4LCAweDEzM2Y2LCAweDEzNDBlLCAweDEzNDFjLCAweDEzNDM4LCAweDEzNDcwLCAweDEzNDdlLCAweDEzNGUwLCAweDEzNGZjLCAweDEzNWMwLCAweDEzNWY4LFxuICAgICAgICAweDEzNjA4LCAweDEzNjEwLCAweDEzNjFlLCAweDEzNjIwLCAweDEzNjNjLCAweDEzNjQwLCAweDEzNjc4LCAweDEzNmYwLCAweDEzNzBjLCAweDEzNzE4LCAweDEzNzMwLCAweDEzNzNlLFxuICAgICAgICAweDEzNzYwLCAweDEzNzdjLCAweDEzNzljLCAweDEzN2I4LCAweDEzN2MyLCAweDEzN2M0LCAweDEzN2M4LCAweDEzN2QwLCAweDEzN2RlLCAweDEzN2U2LCAweDEzN2VjLCAweDEzODE2LFxuICAgICAgICAweDEzODI2LCAweDEzODJjLCAweDEzODQ2LCAweDEzODRjLCAweDEzODU4LCAweDEzODZlLCAweDEzODc0LCAweDEzODg2LCAweDEzODk4LCAweDEzOGIwLCAweDEzOGJlLCAweDEzOGNlLFxuICAgICAgICAweDEzOGRjLCAweDEzOGUyLCAweDEzOGU0LCAweDEzOGU4LCAweDEzOTA2LCAweDEzOTBjLCAweDEzOTMwLCAweDEzOTNlLCAweDEzOTYwLCAweDEzOTdjLCAweDEzOThlLCAweDEzOTljLFxuICAgICAgICAweDEzOWI4LCAweDEzOWM4LCAweDEzOWQwLCAweDEzOWRlLCAweDEzOWU2LCAweDEzOWVjLCAweDEzOWZhLCAweDEzYTA2LCAweDEzYTBjLCAweDEzYTE4LCAweDEzYTMwLCAweDEzYTNlLFxuICAgICAgICAweDEzYTYwLCAweDEzYTdjLCAweDEzYWMwLCAweDEzYWY4LCAweDEzYjBlLCAweDEzYjFjLCAweDEzYjM4LCAweDEzYjcwLCAweDEzYjdlLCAweDEzYjg4LCAweDEzYjkwLCAweDEzYjllLFxuICAgICAgICAweDEzYmEwLCAweDEzYmJjLCAweDEzYmNjLCAweDEzYmQ4LCAweDEzYmVlLCAweDEzYmYyLCAweDEzYmY0LCAweDEzYzEyLCAweDEzYzE0LCAweDEzYzIyLCAweDEzYzI0LCAweDEzYzI4LFxuICAgICAgICAweDEzYzM2LCAweDEzYzQyLCAweDEzYzQ4LCAweDEzYzUwLCAweDEzYzVlLCAweDEzYzY2LCAweDEzYzZjLCAweDEzYzgyLCAweDEzYzg0LCAweDEzYzkwLCAweDEzYzllLCAweDEzY2EwLFxuICAgICAgICAweDEzY2JjLCAweDEzY2M2LCAweDEzY2NjLCAweDEzY2Q4LCAweDEzY2VlLCAweDEzZDAyLCAweDEzZDA0LCAweDEzZDA4LCAweDEzZDEwLCAweDEzZDFlLCAweDEzZDIwLCAweDEzZDNjLFxuICAgICAgICAweDEzZDQwLCAweDEzZDc4LCAweDEzZDg2LCAweDEzZDhjLCAweDEzZDk4LCAweDEzZGIwLCAweDEzZGJlLCAweDEzZGNlLCAweDEzZGRjLCAweDEzZGU0LCAweDEzZGU4LCAweDEzZGY2LFxuICAgICAgICAweDEzZTFhLCAweDEzZTJlLCAweDEzZTMyLCAweDEzZTM0LCAweDEzZTRlLCAweDEzZTVjLCAweDEzZTYyLCAweDEzZTY0LCAweDEzZTY4LCAweDEzZTc2LCAweDEzZThlLCAweDEzZTljLFxuICAgICAgICAweDEzZWI4LCAweDEzZWMyLCAweDEzZWM0LCAweDEzZWM4LCAweDEzZWQwLCAweDEzZWRlLCAweDEzZWU2LCAweDEzZWVjLCAweDEzZjI2LCAweDEzZjJjLCAweDEzZjNhLCAweDEzZjQ2LFxuICAgICAgICAweDEzZjRjLCAweDEzZjU4LCAweDEzZjZlLCAweDEzZjcyLCAweDEzZjc0LCAweDE0MDgyLCAweDE0MDllLCAweDE0MGEwLCAweDE0MGJjLCAweDE0MTA0LCAweDE0MTA4LCAweDE0MTEwLFxuICAgICAgICAweDE0MTFlLCAweDE0MTIwLCAweDE0MTNjLCAweDE0MTQwLCAweDE0MTc4LCAweDE0MThjLCAweDE0MTk4LCAweDE0MWIwLCAweDE0MWJlLCAweDE0MWUyLCAweDE0MWU0LCAweDE0MWU4LFxuICAgICAgICAweDE0MjA4LCAweDE0MjEwLCAweDE0MjFlLCAweDE0MjIwLCAweDE0MjNjLCAweDE0MjQwLCAweDE0Mjc4LCAweDE0MmYwLCAweDE0MzA2LCAweDE0MzBjLCAweDE0MzE4LCAweDE0MzMwLFxuICAgICAgICAweDE0MzNlLCAweDE0MzYwLCAweDE0MzdjLCAweDE0MzhlLCAweDE0M2MyLCAweDE0M2M0LCAweDE0M2M4LCAweDE0M2QwLCAweDE0M2U2LCAweDE0M2VjLCAweDE0NDA4LCAweDE0NDEwLFxuICAgICAgICAweDE0NDFlLCAweDE0NDIwLCAweDE0NDNjLCAweDE0NDQwLCAweDE0NDc4LCAweDE0NGYwLCAweDE0NWUwLCAweDE0NjBjLCAweDE0NjE4LCAweDE0NjMwLCAweDE0NjNlLCAweDE0NjYwLFxuICAgICAgICAweDE0NjdjLCAweDE0NmMwLCAweDE0NmY4LCAweDE0NzFjLCAweDE0NzM4LCAweDE0NzcwLCAweDE0NzdlLCAweDE0NzgyLCAweDE0Nzg0LCAweDE0Nzg4LCAweDE0NzkwLCAweDE0N2EwLFxuICAgICAgICAweDE0N2JjLCAweDE0N2M2LCAweDE0N2NjLCAweDE0N2Q4LCAweDE0N2VlLCAweDE0ODEwLCAweDE0ODIwLCAweDE0ODNjLCAweDE0ODQwLCAweDE0ODc4LCAweDE0OGYwLCAweDE0OWUwLFxuICAgICAgICAweDE0YmMwLCAweDE0YzMwLCAweDE0YzNlLCAweDE0YzYwLCAweDE0YzdjLCAweDE0Y2MwLCAweDE0Y2Y4LCAweDE0ZGYwLCAweDE0ZTM4LCAweDE0ZTcwLCAweDE0ZTdlLCAweDE0ZWUwLFxuICAgICAgICAweDE0ZWZjLCAweDE0ZjA0LCAweDE0ZjA4LCAweDE0ZjEwLCAweDE0ZjFlLCAweDE0ZjIwLCAweDE0ZjNjLCAweDE0ZjQwLCAweDE0Zjc4LCAweDE0Zjg2LCAweDE0ZjhjLCAweDE0Zjk4LFxuICAgICAgICAweDE0ZmIwLCAweDE0ZmNlLCAweDE0ZmRjLCAweDE1MDIwLCAweDE1MDQwLCAweDE1MDc4LCAweDE1MGYwLCAweDE1MWUwLCAweDE1M2MwLCAweDE1ODYwLCAweDE1ODdjLCAweDE1OGMwLFxuICAgICAgICAweDE1OGY4LCAweDE1OWYwLCAweDE1YmUwLCAweDE1YzcwLCAweDE1YzdlLCAweDE1Y2UwLCAweDE1Y2ZjLCAweDE1ZGMwLCAweDE1ZGY4LCAweDE1ZTA4LCAweDE1ZTEwLCAweDE1ZTIwLFxuICAgICAgICAweDE1ZTQwLCAweDE1ZTc4LCAweDE1ZWYwLCAweDE1ZjBjLCAweDE1ZjE4LCAweDE1ZjMwLCAweDE1ZjYwLCAweDE1ZjdjLCAweDE1ZjhlLCAweDE1ZjljLCAweDE1ZmI4LCAweDE2MDRlLFxuICAgICAgICAweDE2MDVjLCAweDE2MDhlLCAweDE2MDljLCAweDE2MGI4LCAweDE2MGMyLCAweDE2MGM0LCAweDE2MGM4LCAweDE2MGRlLCAweDE2MTBlLCAweDE2MTFjLCAweDE2MTM4LCAweDE2MTcwLFxuICAgICAgICAweDE2MTdlLCAweDE2MTg0LCAweDE2MTg4LCAweDE2MTkwLCAweDE2MTllLCAweDE2MWEwLCAweDE2MWJjLCAweDE2MWM2LCAweDE2MWNjLCAweDE2MWQ4LCAweDE2MWYyLCAweDE2MWY0LFxuICAgICAgICAweDE2MjBlLCAweDE2MjFjLCAweDE2MjM4LCAweDE2MjcwLCAweDE2MjdlLCAweDE2MmUwLCAweDE2MmZjLCAweDE2MzA0LCAweDE2MzA4LCAweDE2MzEwLCAweDE2MzFlLCAweDE2MzIwLFxuICAgICAgICAweDE2MzNjLCAweDE2MzQwLCAweDE2Mzc4LCAweDE2Mzg2LCAweDE2MzhjLCAweDE2Mzk4LCAweDE2M2IwLCAweDE2M2JlLCAweDE2M2NlLCAweDE2M2RjLCAweDE2M2UyLCAweDE2M2U0LFxuICAgICAgICAweDE2M2U4LCAweDE2M2Y2LCAweDE2NDBlLCAweDE2NDFjLCAweDE2NDM4LCAweDE2NDcwLCAweDE2NDdlLCAweDE2NGUwLCAweDE2NGZjLCAweDE2NWMwLCAweDE2NWY4LCAweDE2NjEwLFxuICAgICAgICAweDE2NjFlLCAweDE2NjIwLCAweDE2NjNjLCAweDE2NjQwLCAweDE2Njc4LCAweDE2NmYwLCAweDE2NzE4LCAweDE2NzMwLCAweDE2NzNlLCAweDE2NzYwLCAweDE2NzdjLCAweDE2NzhlLFxuICAgICAgICAweDE2NzljLCAweDE2N2I4LCAweDE2N2MyLCAweDE2N2M0LCAweDE2N2M4LCAweDE2N2QwLCAweDE2N2RlLCAweDE2N2U2LCAweDE2N2VjLCAweDE2ODFjLCAweDE2ODM4LCAweDE2ODcwLFxuICAgICAgICAweDE2OGUwLCAweDE2OGZjLCAweDE2OWMwLCAweDE2OWY4LCAweDE2YmYwLCAweDE2YzEwLCAweDE2YzFlLCAweDE2YzIwLCAweDE2YzNjLCAweDE2YzQwLCAweDE2Yzc4LCAweDE2Y2YwLFxuICAgICAgICAweDE2ZGUwLCAweDE2ZTE4LCAweDE2ZTMwLCAweDE2ZTNlLCAweDE2ZTYwLCAweDE2ZTdjLCAweDE2ZWMwLCAweDE2ZWY4LCAweDE2ZjFjLCAweDE2ZjM4LCAweDE2ZjcwLCAweDE2ZjdlLFxuICAgICAgICAweDE2Zjg0LCAweDE2Zjg4LCAweDE2ZjkwLCAweDE2ZjllLCAweDE2ZmEwLCAweDE2ZmJjLCAweDE2ZmM2LCAweDE2ZmNjLCAweDE2ZmQ4LCAweDE3MDI2LCAweDE3MDJjLCAweDE3MDQ2LFxuICAgICAgICAweDE3MDRjLCAweDE3MDU4LCAweDE3MDZlLCAweDE3MDg2LCAweDE3MDhjLCAweDE3MDk4LCAweDE3MGIwLCAweDE3MGJlLCAweDE3MGNlLCAweDE3MGRjLCAweDE3MGU4LCAweDE3MTA2LFxuICAgICAgICAweDE3MTBjLCAweDE3MTE4LCAweDE3MTMwLCAweDE3MTNlLCAweDE3MTYwLCAweDE3MTdjLCAweDE3MThlLCAweDE3MTljLCAweDE3MWI4LCAweDE3MWMyLCAweDE3MWM0LCAweDE3MWM4LFxuICAgICAgICAweDE3MWQwLCAweDE3MWRlLCAweDE3MWU2LCAweDE3MWVjLCAweDE3MWZhLCAweDE3MjA2LCAweDE3MjBjLCAweDE3MjE4LCAweDE3MjMwLCAweDE3MjNlLCAweDE3MjYwLCAweDE3MjdjLFxuICAgICAgICAweDE3MmMwLCAweDE3MmY4LCAweDE3MzBlLCAweDE3MzFjLCAweDE3MzM4LCAweDE3MzcwLCAweDE3MzdlLCAweDE3Mzg4LCAweDE3MzkwLCAweDE3MzllLCAweDE3M2EwLCAweDE3M2JjLFxuICAgICAgICAweDE3M2NjLCAweDE3M2Q4LCAweDE3M2VlLCAweDE3M2YyLCAweDE3M2Y0LCAweDE3NDBjLCAweDE3NDE4LCAweDE3NDMwLCAweDE3NDNlLCAweDE3NDYwLCAweDE3NDdjLCAweDE3NGMwLFxuICAgICAgICAweDE3NGY4LCAweDE3NWYwLCAweDE3NjBlLCAweDE3NjFjLCAweDE3NjM4LCAweDE3NjcwLCAweDE3NjdlLCAweDE3NmUwLCAweDE3NmZjLCAweDE3NzA4LCAweDE3NzEwLCAweDE3NzFlLFxuICAgICAgICAweDE3NzIwLCAweDE3NzNjLCAweDE3NzQwLCAweDE3Nzc4LCAweDE3Nzk4LCAweDE3N2IwLCAweDE3N2JlLCAweDE3N2RjLCAweDE3N2UyLCAweDE3N2U0LCAweDE3N2U4LCAweDE3ODIyLFxuICAgICAgICAweDE3ODI0LCAweDE3ODI4LCAweDE3ODM2LCAweDE3ODQyLCAweDE3ODQ0LCAweDE3ODQ4LCAweDE3ODUwLCAweDE3ODVlLCAweDE3ODY2LCAweDE3ODZjLCAweDE3ODgyLCAweDE3ODg0LFxuICAgICAgICAweDE3ODg4LCAweDE3ODkwLCAweDE3ODllLCAweDE3OGEwLCAweDE3OGJjLCAweDE3OGM2LCAweDE3OGNjLCAweDE3OGQ4LCAweDE3OGVlLCAweDE3OGYyLCAweDE3OGY0LCAweDE3OTAyLFxuICAgICAgICAweDE3OTA0LCAweDE3OTA4LCAweDE3OTEwLCAweDE3OTFlLCAweDE3OTIwLCAweDE3OTNjLCAweDE3OTQwLCAweDE3OTc4LCAweDE3OTg2LCAweDE3OThjLCAweDE3OTk4LCAweDE3OWIwLFxuICAgICAgICAweDE3OWJlLCAweDE3OWNlLCAweDE3OWRjLCAweDE3OWUyLCAweDE3OWU0LCAweDE3OWU4LCAweDE3OWY2LCAweDE3YTA0LCAweDE3YTA4LCAweDE3YTEwLCAweDE3YTFlLCAweDE3YTIwLFxuICAgICAgICAweDE3YTNjLCAweDE3YTQwLCAweDE3YTc4LCAweDE3YWYwLCAweDE3YjA2LCAweDE3YjBjLCAweDE3YjE4LCAweDE3YjMwLCAweDE3YjNlLCAweDE3YjYwLCAweDE3YjdjLCAweDE3YjhlLFxuICAgICAgICAweDE3YjljLCAweDE3YmI4LCAweDE3YmM0LCAweDE3YmM4LCAweDE3YmQwLCAweDE3YmRlLCAweDE3YmU2LCAweDE3YmVjLCAweDE3YzJlLCAweDE3YzMyLCAweDE3YzM0LCAweDE3YzRlLFxuICAgICAgICAweDE3YzVjLCAweDE3YzYyLCAweDE3YzY0LCAweDE3YzY4LCAweDE3Yzc2LCAweDE3YzhlLCAweDE3YzljLCAweDE3Y2I4LCAweDE3Y2MyLCAweDE3Y2M0LCAweDE3Y2M4LCAweDE3Y2QwLFxuICAgICAgICAweDE3Y2RlLCAweDE3Y2U2LCAweDE3Y2VjLCAweDE3ZDBlLCAweDE3ZDFjLCAweDE3ZDM4LCAweDE3ZDcwLCAweDE3ZDgyLCAweDE3ZDg0LCAweDE3ZDg4LCAweDE3ZDkwLCAweDE3ZDllLFxuICAgICAgICAweDE3ZGEwLCAweDE3ZGJjLCAweDE3ZGM2LCAweDE3ZGNjLCAweDE3ZGQ4LCAweDE3ZGVlLCAweDE3ZTI2LCAweDE3ZTJjLCAweDE3ZTNhLCAweDE3ZTQ2LCAweDE3ZTRjLCAweDE3ZTU4LFxuICAgICAgICAweDE3ZTZlLCAweDE3ZTcyLCAweDE3ZTc0LCAweDE3ZTg2LCAweDE3ZThjLCAweDE3ZTk4LCAweDE3ZWIwLCAweDE3ZWNlLCAweDE3ZWRjLCAweDE3ZWUyLCAweDE3ZWU0LCAweDE3ZWU4LFxuICAgICAgICAweDE3ZWY2LCAweDE4MTNhLCAweDE4MTcyLCAweDE4MTc0LCAweDE4MjE2LCAweDE4MjI2LCAweDE4MjNhLCAweDE4MjRjLCAweDE4MjU4LCAweDE4MjZlLCAweDE4MjcyLCAweDE4Mjc0LFxuICAgICAgICAweDE4Mjk4LCAweDE4MmJlLCAweDE4MmUyLCAweDE4MmU0LCAweDE4MmU4LCAweDE4MmY2LCAweDE4MzVlLCAweDE4MzdhLCAweDE4M2FlLCAweDE4M2Q2LCAweDE4NDE2LCAweDE4NDI2LFxuICAgICAgICAweDE4NDJjLCAweDE4NDNhLCAweDE4NDQ2LCAweDE4NDU4LCAweDE4NDZlLCAweDE4NDcyLCAweDE4NDc0LCAweDE4NDg2LCAweDE4NGIwLCAweDE4NGJlLCAweDE4NGNlLCAweDE4NGRjLFxuICAgICAgICAweDE4NGUyLCAweDE4NGU0LCAweDE4NGU4LCAweDE4NGY2LCAweDE4NTA2LCAweDE4NTBjLCAweDE4NTE4LCAweDE4NTMwLCAweDE4NTNlLCAweDE4NTYwLCAweDE4NTdjLCAweDE4NThlLFxuICAgICAgICAweDE4NTljLCAweDE4NWI4LCAweDE4NWMyLCAweDE4NWM0LCAweDE4NWM4LCAweDE4NWQwLCAweDE4NWRlLCAweDE4NWU2LCAweDE4NWVjLCAweDE4NWZhLCAweDE4NjEyLCAweDE4NjE0LFxuICAgICAgICAweDE4NjIyLCAweDE4NjI4LCAweDE4NjM2LCAweDE4NjQyLCAweDE4NjUwLCAweDE4NjVlLCAweDE4NjdhLCAweDE4NjgyLCAweDE4Njg0LCAweDE4Njg4LCAweDE4NjkwLCAweDE4NjllLFxuICAgICAgICAweDE4NmEwLCAweDE4NmJjLCAweDE4NmM2LCAweDE4NmNjLCAweDE4NmQ4LCAweDE4NmVlLCAweDE4NmYyLCAweDE4NmY0LCAweDE4NzJlLCAweDE4NzRlLCAweDE4NzVjLCAweDE4Nzk2LFxuICAgICAgICAweDE4N2E2LCAweDE4N2FjLCAweDE4N2QyLCAweDE4N2Q0LCAweDE4ODI2LCAweDE4ODJjLCAweDE4ODNhLCAweDE4ODQ2LCAweDE4ODRjLCAweDE4ODU4LCAweDE4ODZlLCAweDE4ODcyLFxuICAgICAgICAweDE4ODc0LCAweDE4ODg2LCAweDE4ODk4LCAweDE4OGIwLCAweDE4OGJlLCAweDE4OGNlLCAweDE4OGRjLCAweDE4OGUyLCAweDE4OGU0LCAweDE4OGU4LCAweDE4OGY2LCAweDE4OTBjLFxuICAgICAgICAweDE4OTMwLCAweDE4OTNlLCAweDE4OTYwLCAweDE4OTdjLCAweDE4OThlLCAweDE4OWI4LCAweDE4OWMyLCAweDE4OWM4LCAweDE4OWQwLCAweDE4OWRlLCAweDE4OWU2LCAweDE4OWVjLFxuICAgICAgICAweDE4OWZhLCAweDE4YTE4LCAweDE4YTMwLCAweDE4YTNlLCAweDE4YTYwLCAweDE4YTdjLCAweDE4YWMwLCAweDE4YWY4LCAweDE4YjFjLCAweDE4YjM4LCAweDE4YjcwLCAweDE4YjdlLFxuICAgICAgICAweDE4YjgyLCAweDE4Yjg0LCAweDE4Yjg4LCAweDE4YjkwLCAweDE4YjllLCAweDE4YmEwLCAweDE4YmJjLCAweDE4YmM2LCAweDE4YmNjLCAweDE4YmQ4LCAweDE4YmVlLCAweDE4YmYyLFxuICAgICAgICAweDE4YmY0LCAweDE4YzIyLCAweDE4YzI0LCAweDE4YzI4LCAweDE4YzM2LCAweDE4YzQyLCAweDE4YzQ4LCAweDE4YzUwLCAweDE4YzVlLCAweDE4YzY2LCAweDE4YzdhLCAweDE4YzgyLFxuICAgICAgICAweDE4Yzg0LCAweDE4YzkwLCAweDE4YzllLCAweDE4Y2EwLCAweDE4Y2JjLCAweDE4Y2NjLCAweDE4Y2YyLCAweDE4Y2Y0LCAweDE4ZDA0LCAweDE4ZDA4LCAweDE4ZDEwLCAweDE4ZDFlLFxuICAgICAgICAweDE4ZDIwLCAweDE4ZDNjLCAweDE4ZDQwLCAweDE4ZDc4LCAweDE4ZDg2LCAweDE4ZDk4LCAweDE4ZGNlLCAweDE4ZGUyLCAweDE4ZGU0LCAweDE4ZGU4LCAweDE4ZTJlLCAweDE4ZTMyLFxuICAgICAgICAweDE4ZTM0LCAweDE4ZTRlLCAweDE4ZTVjLCAweDE4ZTYyLCAweDE4ZTY0LCAweDE4ZTY4LCAweDE4ZThlLCAweDE4ZTljLCAweDE4ZWI4LCAweDE4ZWMyLCAweDE4ZWM0LCAweDE4ZWM4LFxuICAgICAgICAweDE4ZWQwLCAweDE4ZWZhLCAweDE4ZjE2LCAweDE4ZjI2LCAweDE4ZjJjLCAweDE4ZjQ2LCAweDE4ZjRjLCAweDE4ZjU4LCAweDE4ZjZlLCAweDE4ZjhhLCAweDE4ZjkyLCAweDE4Zjk0LFxuICAgICAgICAweDE4ZmEyLCAweDE4ZmE0LCAweDE4ZmE4LCAweDE4ZmI2LCAweDE5MDJjLCAweDE5MDNhLCAweDE5MDQ2LCAweDE5MDRjLCAweDE5MDU4LCAweDE5MDcyLCAweDE5MDc0LCAweDE5MDg2LFxuICAgICAgICAweDE5MDk4LCAweDE5MGIwLCAweDE5MGJlLCAweDE5MGNlLCAweDE5MGRjLCAweDE5MGUyLCAweDE5MGU4LCAweDE5MGY2LCAweDE5MTA2LCAweDE5MTBjLCAweDE5MTMwLCAweDE5MTNlLFxuICAgICAgICAweDE5MTYwLCAweDE5MTdjLCAweDE5MThlLCAweDE5MTljLCAweDE5MWI4LCAweDE5MWMyLCAweDE5MWM4LCAweDE5MWQwLCAweDE5MWRlLCAweDE5MWU2LCAweDE5MWVjLCAweDE5MWZhLFxuICAgICAgICAweDE5MjE4LCAweDE5MjNlLCAweDE5MjYwLCAweDE5MjdjLCAweDE5MmMwLCAweDE5MmY4LCAweDE5MzM4LCAweDE5MzcwLCAweDE5MzdlLCAweDE5MzgyLCAweDE5Mzg0LCAweDE5MzkwLFxuICAgICAgICAweDE5MzllLCAweDE5M2EwLCAweDE5M2JjLCAweDE5M2M2LCAweDE5M2NjLCAweDE5M2Q4LCAweDE5M2VlLCAweDE5M2YyLCAweDE5M2Y0LCAweDE5NDMwLCAweDE5NDNlLCAweDE5NDYwLFxuICAgICAgICAweDE5NDdjLCAweDE5NGMwLCAweDE5NGY4LCAweDE5NWYwLCAweDE5NjM4LCAweDE5NjcwLCAweDE5NjdlLCAweDE5NmUwLCAweDE5NmZjLCAweDE5NzAyLCAweDE5NzA0LCAweDE5NzA4LFxuICAgICAgICAweDE5NzEwLCAweDE5NzIwLCAweDE5NzNjLCAweDE5NzQwLCAweDE5Nzc4LCAweDE5Nzg2LCAweDE5NzhjLCAweDE5Nzk4LCAweDE5N2IwLCAweDE5N2JlLCAweDE5N2NlLCAweDE5N2RjLFxuICAgICAgICAweDE5N2UyLCAweDE5N2U0LCAweDE5N2U4LCAweDE5ODIyLCAweDE5ODI0LCAweDE5ODQyLCAweDE5ODQ4LCAweDE5ODUwLCAweDE5ODVlLCAweDE5ODY2LCAweDE5ODdhLCAweDE5ODgyLFxuICAgICAgICAweDE5ODg0LCAweDE5ODkwLCAweDE5ODllLCAweDE5OGEwLCAweDE5OGJjLCAweDE5OGNjLCAweDE5OGYyLCAweDE5OGY0LCAweDE5OTAyLCAweDE5OTA4LCAweDE5OTFlLCAweDE5OTIwLFxuICAgICAgICAweDE5OTNjLCAweDE5OTQwLCAweDE5OTc4LCAweDE5OTg2LCAweDE5OTk4LCAweDE5OWNlLCAweDE5OWUyLCAweDE5OWU0LCAweDE5OWU4LCAweDE5YTA4LCAweDE5YTEwLCAweDE5YTFlLFxuICAgICAgICAweDE5YTIwLCAweDE5YTNjLCAweDE5YTQwLCAweDE5YTc4LCAweDE5YWYwLCAweDE5YjE4LCAweDE5YjNlLCAweDE5YjYwLCAweDE5YjljLCAweDE5YmMyLCAweDE5YmM0LCAweDE5YmM4LFxuICAgICAgICAweDE5YmQwLCAweDE5YmU2LCAweDE5YzJlLCAweDE5YzM0LCAweDE5YzRlLCAweDE5YzVjLCAweDE5YzYyLCAweDE5YzY0LCAweDE5YzY4LCAweDE5YzhlLCAweDE5YzljLCAweDE5Y2I4LFxuICAgICAgICAweDE5Y2MyLCAweDE5Y2M4LCAweDE5Y2QwLCAweDE5Y2U2LCAweDE5Y2ZhLCAweDE5ZDBlLCAweDE5ZDFjLCAweDE5ZDM4LCAweDE5ZDcwLCAweDE5ZDdlLCAweDE5ZDgyLCAweDE5ZDg0LFxuICAgICAgICAweDE5ZDg4LCAweDE5ZDkwLCAweDE5ZGEwLCAweDE5ZGNjLCAweDE5ZGYyLCAweDE5ZGY0LCAweDE5ZTE2LCAweDE5ZTI2LCAweDE5ZTJjLCAweDE5ZTQ2LCAweDE5ZTRjLCAweDE5ZTU4LFxuICAgICAgICAweDE5ZTc0LCAweDE5ZTg2LCAweDE5ZThjLCAweDE5ZTk4LCAweDE5ZWIwLCAweDE5ZWJlLCAweDE5ZWNlLCAweDE5ZWUyLCAweDE5ZWU0LCAweDE5ZWU4LCAweDE5ZjBhLCAweDE5ZjEyLFxuICAgICAgICAweDE5ZjE0LCAweDE5ZjIyLCAweDE5ZjI0LCAweDE5ZjI4LCAweDE5ZjQyLCAweDE5ZjQ0LCAweDE5ZjQ4LCAweDE5ZjUwLCAweDE5ZjVlLCAweDE5ZjZjLCAweDE5ZjlhLCAweDE5ZmFlLFxuICAgICAgICAweDE5ZmIyLCAweDE5ZmI0LCAweDFhMDQ2LCAweDFhMDRjLCAweDFhMDcyLCAweDFhMDc0LCAweDFhMDg2LCAweDFhMDhjLCAweDFhMDk4LCAweDFhMGIwLCAweDFhMGJlLCAweDFhMGUyLFxuICAgICAgICAweDFhMGU0LCAweDFhMGU4LCAweDFhMGY2LCAweDFhMTA2LCAweDFhMTBjLCAweDFhMTE4LCAweDFhMTMwLCAweDFhMTNlLCAweDFhMTYwLCAweDFhMTdjLCAweDFhMThlLCAweDFhMTljLFxuICAgICAgICAweDFhMWI4LCAweDFhMWMyLCAweDFhMWM0LCAweDFhMWM4LCAweDFhMWQwLCAweDFhMWRlLCAweDFhMWU2LCAweDFhMWVjLCAweDFhMjE4LCAweDFhMjMwLCAweDFhMjNlLCAweDFhMjYwLFxuICAgICAgICAweDFhMjdjLCAweDFhMmMwLCAweDFhMmY4LCAweDFhMzFjLCAweDFhMzM4LCAweDFhMzcwLCAweDFhMzdlLCAweDFhMzgyLCAweDFhMzg0LCAweDFhMzg4LCAweDFhMzkwLCAweDFhMzllLFxuICAgICAgICAweDFhM2EwLCAweDFhM2JjLCAweDFhM2M2LCAweDFhM2NjLCAweDFhM2Q4LCAweDFhM2VlLCAweDFhM2YyLCAweDFhM2Y0LCAweDFhNDE4LCAweDFhNDMwLCAweDFhNDNlLCAweDFhNDYwLFxuICAgICAgICAweDFhNDdjLCAweDFhNGMwLCAweDFhNGY4LCAweDFhNWYwLCAweDFhNjFjLCAweDFhNjM4LCAweDFhNjcwLCAweDFhNjdlLCAweDFhNmUwLCAweDFhNmZjLCAweDFhNzAyLCAweDFhNzA0LFxuICAgICAgICAweDFhNzA4LCAweDFhNzEwLCAweDFhNzFlLCAweDFhNzIwLCAweDFhNzNjLCAweDFhNzQwLCAweDFhNzc4LCAweDFhNzg2LCAweDFhNzhjLCAweDFhNzk4LCAweDFhN2IwLCAweDFhN2JlLFxuICAgICAgICAweDFhN2NlLCAweDFhN2RjLCAweDFhN2UyLCAweDFhN2U0LCAweDFhN2U4LCAweDFhODMwLCAweDFhODYwLCAweDFhODdjLCAweDFhOGMwLCAweDFhOGY4LCAweDFhOWYwLCAweDFhYmUwLFxuICAgICAgICAweDFhYzcwLCAweDFhYzdlLCAweDFhY2UwLCAweDFhY2ZjLCAweDFhZGMwLCAweDFhZGY4LCAweDFhZTA0LCAweDFhZTA4LCAweDFhZTEwLCAweDFhZTIwLCAweDFhZTNjLCAweDFhZTQwLFxuICAgICAgICAweDFhZTc4LCAweDFhZWYwLCAweDFhZjA2LCAweDFhZjBjLCAweDFhZjE4LCAweDFhZjMwLCAweDFhZjNlLCAweDFhZjYwLCAweDFhZjdjLCAweDFhZjhlLCAweDFhZjljLCAweDFhZmI4LFxuICAgICAgICAweDFhZmM0LCAweDFhZmM4LCAweDFhZmQwLCAweDFhZmRlLCAweDFiMDQyLCAweDFiMDVlLCAweDFiMDdhLCAweDFiMDgyLCAweDFiMDg0LCAweDFiMDg4LCAweDFiMDkwLCAweDFiMDllLFxuICAgICAgICAweDFiMGEwLCAweDFiMGJjLCAweDFiMGNjLCAweDFiMGYyLCAweDFiMGY0LCAweDFiMTAyLCAweDFiMTA0LCAweDFiMTA4LCAweDFiMTEwLCAweDFiMTFlLCAweDFiMTIwLCAweDFiMTNjLFxuICAgICAgICAweDFiMTQwLCAweDFiMTc4LCAweDFiMTg2LCAweDFiMTk4LCAweDFiMWNlLCAweDFiMWUyLCAweDFiMWU0LCAweDFiMWU4LCAweDFiMjA0LCAweDFiMjA4LCAweDFiMjEwLCAweDFiMjFlLFxuICAgICAgICAweDFiMjIwLCAweDFiMjNjLCAweDFiMjQwLCAweDFiMjc4LCAweDFiMmYwLCAweDFiMzBjLCAweDFiMzNlLCAweDFiMzYwLCAweDFiMzljLCAweDFiM2MyLCAweDFiM2M0LCAweDFiM2M4LFxuICAgICAgICAweDFiM2QwLCAweDFiM2U2LCAweDFiNDEwLCAweDFiNDFlLCAweDFiNDIwLCAweDFiNDNjLCAweDFiNDQwLCAweDFiNDc4LCAweDFiNGYwLCAweDFiNWUwLCAweDFiNjE4LCAweDFiNjYwLFxuICAgICAgICAweDFiNjdjLCAweDFiNmMwLCAweDFiNzM4LCAweDFiNzgyLCAweDFiNzg0LCAweDFiNzg4LCAweDFiNzkwLCAweDFiNzllLCAweDFiN2EwLCAweDFiN2NjLCAweDFiODJlLCAweDFiODRlLFxuICAgICAgICAweDFiODVjLCAweDFiODhlLCAweDFiODljLCAweDFiOGI4LCAweDFiOGMyLCAweDFiOGM0LCAweDFiOGM4LCAweDFiOGQwLCAweDFiOGU2LCAweDFiOGZhLCAweDFiOTBlLCAweDFiOTFjLFxuICAgICAgICAweDFiOTM4LCAweDFiOTcwLCAweDFiOTdlLCAweDFiOTgyLCAweDFiOTg0LCAweDFiOTg4LCAweDFiOTkwLCAweDFiOTllLCAweDFiOWEwLCAweDFiOWNjLCAweDFiOWYyLCAweDFiOWY0LFxuICAgICAgICAweDFiYTBlLCAweDFiYTFjLCAweDFiYTM4LCAweDFiYTcwLCAweDFiYTdlLCAweDFiYWUwLCAweDFiYWZjLCAweDFiYjA4LCAweDFiYjEwLCAweDFiYjIwLCAweDFiYjNjLCAweDFiYjQwLFxuICAgICAgICAweDFiYjk4LCAweDFiYmNlLCAweDFiYmUyLCAweDFiYmU0LCAweDFiYmU4LCAweDFiYzE2LCAweDFiYzI2LCAweDFiYzJjLCAweDFiYzQ2LCAweDFiYzRjLCAweDFiYzU4LCAweDFiYzcyLFxuICAgICAgICAweDFiYzc0LCAweDFiYzg2LCAweDFiYzhjLCAweDFiYzk4LCAweDFiY2IwLCAweDFiY2JlLCAweDFiY2NlLCAweDFiY2UyLCAweDFiY2U0LCAweDFiY2U4LCAweDFiZDA2LCAweDFiZDBjLFxuICAgICAgICAweDFiZDE4LCAweDFiZDMwLCAweDFiZDNlLCAweDFiZDYwLCAweDFiZDdjLCAweDFiZDljLCAweDFiZGMyLCAweDFiZGM0LCAweDFiZGM4LCAweDFiZGQwLCAweDFiZGU2LCAweDFiZGZhLFxuICAgICAgICAweDFiZTEyLCAweDFiZTE0LCAweDFiZTIyLCAweDFiZTI0LCAweDFiZTI4LCAweDFiZTQyLCAweDFiZTQ0LCAweDFiZTQ4LCAweDFiZTUwLCAweDFiZTVlLCAweDFiZTY2LCAweDFiZTgyLFxuICAgICAgICAweDFiZTg0LCAweDFiZTg4LCAweDFiZTkwLCAweDFiZTllLCAweDFiZWEwLCAweDFiZWJjLCAweDFiZWNjLCAweDFiZWY0LCAweDFiZjFhLCAweDFiZjJlLCAweDFiZjMyLCAweDFiZjM0LFxuICAgICAgICAweDFiZjRlLCAweDFiZjVjLCAweDFiZjYyLCAweDFiZjY0LCAweDFiZjY4LCAweDFjMDlhLCAweDFjMGIyLCAweDFjMGI0LCAweDFjMTFhLCAweDFjMTMyLCAweDFjMTM0LCAweDFjMTYyLFxuICAgICAgICAweDFjMTY0LCAweDFjMTY4LCAweDFjMTc2LCAweDFjMWJhLCAweDFjMjFhLCAweDFjMjMyLCAweDFjMjM0LCAweDFjMjRlLCAweDFjMjVjLCAweDFjMjYyLCAweDFjMjY0LCAweDFjMjY4LFxuICAgICAgICAweDFjMjc2LCAweDFjMjhlLCAweDFjMmMyLCAweDFjMmM0LCAweDFjMmM4LCAweDFjMmQwLCAweDFjMmRlLCAweDFjMmU2LCAweDFjMmVjLCAweDFjMmZhLCAweDFjMzE2LCAweDFjMzI2LFxuICAgICAgICAweDFjMzNhLCAweDFjMzQ2LCAweDFjMzRjLCAweDFjMzcyLCAweDFjMzc0LCAweDFjNDFhLCAweDFjNDJlLCAweDFjNDMyLCAweDFjNDM0LCAweDFjNDRlLCAweDFjNDVjLCAweDFjNDYyLFxuICAgICAgICAweDFjNDY0LCAweDFjNDY4LCAweDFjNDc2LCAweDFjNDhlLCAweDFjNDljLCAweDFjNGI4LCAweDFjNGMyLCAweDFjNGM4LCAweDFjNGQwLCAweDFjNGRlLCAweDFjNGU2LCAweDFjNGVjLFxuICAgICAgICAweDFjNGZhLCAweDFjNTFjLCAweDFjNTM4LCAweDFjNTcwLCAweDFjNTdlLCAweDFjNTgyLCAweDFjNTg0LCAweDFjNTg4LCAweDFjNTkwLCAweDFjNTllLCAweDFjNWEwLCAweDFjNWJjLFxuICAgICAgICAweDFjNWM2LCAweDFjNWNjLCAweDFjNWQ4LCAweDFjNWVlLCAweDFjNWYyLCAweDFjNWY0LCAweDFjNjE2LCAweDFjNjI2LCAweDFjNjJjLCAweDFjNjNhLCAweDFjNjQ2LCAweDFjNjRjLFxuICAgICAgICAweDFjNjU4LCAweDFjNjZlLCAweDFjNjcyLCAweDFjNjc0LCAweDFjNjg2LCAweDFjNjhjLCAweDFjNjk4LCAweDFjNmIwLCAweDFjNmJlLCAweDFjNmNlLCAweDFjNmRjLCAweDFjNmUyLFxuICAgICAgICAweDFjNmU0LCAweDFjNmU4LCAweDFjNzEyLCAweDFjNzE0LCAweDFjNzIyLCAweDFjNzI4LCAweDFjNzM2LCAweDFjNzQyLCAweDFjNzQ0LCAweDFjNzQ4LCAweDFjNzUwLCAweDFjNzVlLFxuICAgICAgICAweDFjNzY2LCAweDFjNzZjLCAweDFjNzdhLCAweDFjN2FlLCAweDFjN2Q2LCAweDFjN2VhLCAweDFjODFhLCAweDFjODJlLCAweDFjODMyLCAweDFjODM0LCAweDFjODRlLCAweDFjODVjLFxuICAgICAgICAweDFjODYyLCAweDFjODY0LCAweDFjODY4LCAweDFjODc2LCAweDFjODhlLCAweDFjODljLCAweDFjOGI4LCAweDFjOGMyLCAweDFjOGM4LCAweDFjOGQwLCAweDFjOGRlLCAweDFjOGU2LFxuICAgICAgICAweDFjOGVjLCAweDFjOGZhLCAweDFjOTBlLCAweDFjOTM4LCAweDFjOTcwLCAweDFjOTdlLCAweDFjOTgyLCAweDFjOTg0LCAweDFjOTkwLCAweDFjOTllLCAweDFjOWEwLCAweDFjOWJjLFxuICAgICAgICAweDFjOWM2LCAweDFjOWNjLCAweDFjOWQ4LCAweDFjOWVlLCAweDFjOWYyLCAweDFjOWY0LCAweDFjYTM4LCAweDFjYTcwLCAweDFjYTdlLCAweDFjYWUwLCAweDFjYWZjLCAweDFjYjAyLFxuICAgICAgICAweDFjYjA0LCAweDFjYjA4LCAweDFjYjEwLCAweDFjYjIwLCAweDFjYjNjLCAweDFjYjQwLCAweDFjYjc4LCAweDFjYjg2LCAweDFjYjhjLCAweDFjYjk4LCAweDFjYmIwLCAweDFjYmJlLFxuICAgICAgICAweDFjYmNlLCAweDFjYmRjLCAweDFjYmUyLCAweDFjYmU0LCAweDFjYmU4LCAweDFjYmY2LCAweDFjYzE2LCAweDFjYzI2LCAweDFjYzJjLCAweDFjYzNhLCAweDFjYzQ2LCAweDFjYzU4LFxuICAgICAgICAweDFjYzcyLCAweDFjYzc0LCAweDFjYzg2LCAweDFjY2IwLCAweDFjY2JlLCAweDFjY2NlLCAweDFjY2UyLCAweDFjY2U0LCAweDFjY2U4LCAweDFjZDA2LCAweDFjZDBjLCAweDFjZDE4LFxuICAgICAgICAweDFjZDMwLCAweDFjZDNlLCAweDFjZDYwLCAweDFjZDdjLCAweDFjZDljLCAweDFjZGMyLCAweDFjZGM0LCAweDFjZGM4LCAweDFjZGQwLCAweDFjZGRlLCAweDFjZGU2LCAweDFjZGZhLFxuICAgICAgICAweDFjZTIyLCAweDFjZTI4LCAweDFjZTQyLCAweDFjZTUwLCAweDFjZTVlLCAweDFjZTY2LCAweDFjZTdhLCAweDFjZTgyLCAweDFjZTg0LCAweDFjZTg4LCAweDFjZTkwLCAweDFjZTllLFxuICAgICAgICAweDFjZWEwLCAweDFjZWJjLCAweDFjZWNjLCAweDFjZWYyLCAweDFjZWY0LCAweDFjZjJlLCAweDFjZjMyLCAweDFjZjM0LCAweDFjZjRlLCAweDFjZjVjLCAweDFjZjYyLCAweDFjZjY0LFxuICAgICAgICAweDFjZjY4LCAweDFjZjk2LCAweDFjZmE2LCAweDFjZmFjLCAweDFjZmNhLCAweDFjZmQyLCAweDFjZmQ0LCAweDFkMDJlLCAweDFkMDMyLCAweDFkMDM0LCAweDFkMDRlLCAweDFkMDVjLFxuICAgICAgICAweDFkMDYyLCAweDFkMDY0LCAweDFkMDY4LCAweDFkMDc2LCAweDFkMDhlLCAweDFkMDljLCAweDFkMGI4LCAweDFkMGMyLCAweDFkMGM0LCAweDFkMGM4LCAweDFkMGQwLCAweDFkMGRlLFxuICAgICAgICAweDFkMGU2LCAweDFkMGVjLCAweDFkMGZhLCAweDFkMTFjLCAweDFkMTM4LCAweDFkMTcwLCAweDFkMTdlLCAweDFkMTgyLCAweDFkMTg0LCAweDFkMTg4LCAweDFkMTkwLCAweDFkMTllLFxuICAgICAgICAweDFkMWEwLCAweDFkMWJjLCAweDFkMWM2LCAweDFkMWNjLCAweDFkMWQ4LCAweDFkMWVlLCAweDFkMWYyLCAweDFkMWY0LCAweDFkMjFjLCAweDFkMjM4LCAweDFkMjcwLCAweDFkMjdlLFxuICAgICAgICAweDFkMmUwLCAweDFkMmZjLCAweDFkMzAyLCAweDFkMzA0LCAweDFkMzA4LCAweDFkMzEwLCAweDFkMzFlLCAweDFkMzIwLCAweDFkMzNjLCAweDFkMzQwLCAweDFkMzc4LCAweDFkMzg2LFxuICAgICAgICAweDFkMzhjLCAweDFkMzk4LCAweDFkM2IwLCAweDFkM2JlLCAweDFkM2NlLCAweDFkM2RjLCAweDFkM2UyLCAweDFkM2U0LCAweDFkM2U4LCAweDFkM2Y2LCAweDFkNDcwLCAweDFkNDdlLFxuICAgICAgICAweDFkNGUwLCAweDFkNGZjLCAweDFkNWMwLCAweDFkNWY4LCAweDFkNjA0LCAweDFkNjA4LCAweDFkNjEwLCAweDFkNjIwLCAweDFkNjQwLCAweDFkNjc4LCAweDFkNmYwLCAweDFkNzA2LFxuICAgICAgICAweDFkNzBjLCAweDFkNzE4LCAweDFkNzMwLCAweDFkNzNlLCAweDFkNzYwLCAweDFkNzdjLCAweDFkNzhlLCAweDFkNzljLCAweDFkN2I4LCAweDFkN2MyLCAweDFkN2M0LCAweDFkN2M4LFxuICAgICAgICAweDFkN2QwLCAweDFkN2RlLCAweDFkN2U2LCAweDFkN2VjLCAweDFkODI2LCAweDFkODJjLCAweDFkODNhLCAweDFkODQ2LCAweDFkODRjLCAweDFkODU4LCAweDFkODcyLCAweDFkODc0LFxuICAgICAgICAweDFkODg2LCAweDFkODhjLCAweDFkODk4LCAweDFkOGIwLCAweDFkOGJlLCAweDFkOGNlLCAweDFkOGUyLCAweDFkOGU0LCAweDFkOGU4LCAweDFkOGY2LCAweDFkOTBjLCAweDFkOTE4LFxuICAgICAgICAweDFkOTMwLCAweDFkOTNlLCAweDFkOTYwLCAweDFkOTdjLCAweDFkOTljLCAweDFkOWMyLCAweDFkOWM0LCAweDFkOWM4LCAweDFkOWQwLCAweDFkOWU2LCAweDFkOWZhLCAweDFkYTBjLFxuICAgICAgICAweDFkYTE4LCAweDFkYTMwLCAweDFkYTNlLCAweDFkYTYwLCAweDFkYTdjLCAweDFkYWMwLCAweDFkYWY4LCAweDFkYjM4LCAweDFkYjgyLCAweDFkYjg0LCAweDFkYjg4LCAweDFkYjkwLFxuICAgICAgICAweDFkYjllLCAweDFkYmEwLCAweDFkYmNjLCAweDFkYmYyLCAweDFkYmY0LCAweDFkYzIyLCAweDFkYzQyLCAweDFkYzQ0LCAweDFkYzQ4LCAweDFkYzUwLCAweDFkYzVlLCAweDFkYzY2LFxuICAgICAgICAweDFkYzdhLCAweDFkYzgyLCAweDFkYzg0LCAweDFkYzg4LCAweDFkYzkwLCAweDFkYzllLCAweDFkY2EwLCAweDFkY2JjLCAweDFkY2NjLCAweDFkY2YyLCAweDFkY2Y0LCAweDFkZDA0LFxuICAgICAgICAweDFkZDA4LCAweDFkZDEwLCAweDFkZDFlLCAweDFkZDIwLCAweDFkZDNjLCAweDFkZDQwLCAweDFkZDc4LCAweDFkZDg2LCAweDFkZDk4LCAweDFkZGNlLCAweDFkZGUyLCAweDFkZGU0LFxuICAgICAgICAweDFkZGU4LCAweDFkZTJlLCAweDFkZTMyLCAweDFkZTM0LCAweDFkZTRlLCAweDFkZTVjLCAweDFkZTYyLCAweDFkZTY0LCAweDFkZTY4LCAweDFkZThlLCAweDFkZTljLCAweDFkZWI4LFxuICAgICAgICAweDFkZWMyLCAweDFkZWM0LCAweDFkZWM4LCAweDFkZWQwLCAweDFkZWU2LCAweDFkZWZhLCAweDFkZjE2LCAweDFkZjI2LCAweDFkZjJjLCAweDFkZjQ2LCAweDFkZjRjLCAweDFkZjU4LFxuICAgICAgICAweDFkZjcyLCAweDFkZjc0LCAweDFkZjhhLCAweDFkZjkyLCAweDFkZjk0LCAweDFkZmEyLCAweDFkZmE0LCAweDFkZmE4LCAweDFlMDhhLCAweDFlMDkyLCAweDFlMDk0LCAweDFlMGEyLFxuICAgICAgICAweDFlMGE0LCAweDFlMGE4LCAweDFlMGI2LCAweDFlMGRhLCAweDFlMTBhLCAweDFlMTEyLCAweDFlMTE0LCAweDFlMTIyLCAweDFlMTI0LCAweDFlMTI4LCAweDFlMTM2LCAweDFlMTQyLFxuICAgICAgICAweDFlMTQ0LCAweDFlMTQ4LCAweDFlMTUwLCAweDFlMTY2LCAweDFlMTZjLCAweDFlMTdhLCAweDFlMTlhLCAweDFlMWIyLCAweDFlMWI0LCAweDFlMjBhLCAweDFlMjEyLCAweDFlMjE0LFxuICAgICAgICAweDFlMjIyLCAweDFlMjI0LCAweDFlMjI4LCAweDFlMjM2LCAweDFlMjQyLCAweDFlMjQ4LCAweDFlMjUwLCAweDFlMjVlLCAweDFlMjY2LCAweDFlMjZjLCAweDFlMjdhLCAweDFlMjgyLFxuICAgICAgICAweDFlMjg0LCAweDFlMjg4LCAweDFlMjkwLCAweDFlMmEwLCAweDFlMmJjLCAweDFlMmM2LCAweDFlMmNjLCAweDFlMmQ4LCAweDFlMmVlLCAweDFlMmYyLCAweDFlMmY0LCAweDFlMzFhLFxuICAgICAgICAweDFlMzMyLCAweDFlMzM0LCAweDFlMzVjLCAweDFlMzYyLCAweDFlMzY0LCAweDFlMzY4LCAweDFlM2JhLCAweDFlNDBhLCAweDFlNDEyLCAweDFlNDE0LCAweDFlNDIyLCAweDFlNDI4LFxuICAgICAgICAweDFlNDM2LCAweDFlNDQyLCAweDFlNDQ4LCAweDFlNDUwLCAweDFlNDVlLCAweDFlNDY2LCAweDFlNDZjLCAweDFlNDdhLCAweDFlNDgyLCAweDFlNDg0LCAweDFlNDkwLCAweDFlNDllLFxuICAgICAgICAweDFlNGEwLCAweDFlNGJjLCAweDFlNGM2LCAweDFlNGNjLCAweDFlNGQ4LCAweDFlNGVlLCAweDFlNGYyLCAweDFlNGY0LCAweDFlNTAyLCAweDFlNTA0LCAweDFlNTA4LCAweDFlNTEwLFxuICAgICAgICAweDFlNTFlLCAweDFlNTIwLCAweDFlNTNjLCAweDFlNTQwLCAweDFlNTc4LCAweDFlNTg2LCAweDFlNThjLCAweDFlNTk4LCAweDFlNWIwLCAweDFlNWJlLCAweDFlNWNlLCAweDFlNWRjLFxuICAgICAgICAweDFlNWUyLCAweDFlNWU0LCAweDFlNWU4LCAweDFlNWY2LCAweDFlNjFhLCAweDFlNjJlLCAweDFlNjMyLCAweDFlNjM0LCAweDFlNjRlLCAweDFlNjVjLCAweDFlNjYyLCAweDFlNjY4LFxuICAgICAgICAweDFlNjhlLCAweDFlNjljLCAweDFlNmI4LCAweDFlNmMyLCAweDFlNmM0LCAweDFlNmM4LCAweDFlNmQwLCAweDFlNmU2LCAweDFlNmZhLCAweDFlNzE2LCAweDFlNzI2LCAweDFlNzJjLFxuICAgICAgICAweDFlNzNhLCAweDFlNzQ2LCAweDFlNzRjLCAweDFlNzU4LCAweDFlNzcyLCAweDFlNzc0LCAweDFlNzkyLCAweDFlNzk0LCAweDFlN2EyLCAweDFlN2E0LCAweDFlN2E4LCAweDFlN2I2LFxuICAgICAgICAweDFlODEyLCAweDFlODE0LCAweDFlODIyLCAweDFlODI0LCAweDFlODI4LCAweDFlODM2LCAweDFlODQyLCAweDFlODQ0LCAweDFlODQ4LCAweDFlODUwLCAweDFlODVlLCAweDFlODY2LFxuICAgICAgICAweDFlODZjLCAweDFlODdhLCAweDFlODgyLCAweDFlODg0LCAweDFlODg4LCAweDFlODkwLCAweDFlODllLCAweDFlOGEwLCAweDFlOGJjLCAweDFlOGM2LCAweDFlOGNjLCAweDFlOGQ4LFxuICAgICAgICAweDFlOGVlLCAweDFlOGYyLCAweDFlOGY0LCAweDFlOTAyLCAweDFlOTA0LCAweDFlOTA4LCAweDFlOTEwLCAweDFlOTIwLCAweDFlOTNjLCAweDFlOTQwLCAweDFlOTc4LCAweDFlOTg2LFxuICAgICAgICAweDFlOThjLCAweDFlOTk4LCAweDFlOWIwLCAweDFlOWJlLCAweDFlOWNlLCAweDFlOWRjLCAweDFlOWUyLCAweDFlOWU0LCAweDFlOWU4LCAweDFlOWY2LCAweDFlYTA0LCAweDFlYTA4LFxuICAgICAgICAweDFlYTEwLCAweDFlYTIwLCAweDFlYTQwLCAweDFlYTc4LCAweDFlYWYwLCAweDFlYjA2LCAweDFlYjBjLCAweDFlYjE4LCAweDFlYjMwLCAweDFlYjNlLCAweDFlYjYwLCAweDFlYjdjLFxuICAgICAgICAweDFlYjhlLCAweDFlYjljLCAweDFlYmI4LCAweDFlYmMyLCAweDFlYmM0LCAweDFlYmM4LCAweDFlYmQwLCAweDFlYmRlLCAweDFlYmU2LCAweDFlYmVjLCAweDFlYzFhLCAweDFlYzJlLFxuICAgICAgICAweDFlYzMyLCAweDFlYzM0LCAweDFlYzRlLCAweDFlYzVjLCAweDFlYzYyLCAweDFlYzY0LCAweDFlYzY4LCAweDFlYzhlLCAweDFlYzljLCAweDFlY2I4LCAweDFlY2MyLCAweDFlY2M0LFxuICAgICAgICAweDFlY2M4LCAweDFlY2QwLCAweDFlY2U2LCAweDFlY2ZhLCAweDFlZDBlLCAweDFlZDFjLCAweDFlZDM4LCAweDFlZDcwLCAweDFlZDdlLCAweDFlZDgyLCAweDFlZDg0LCAweDFlZDg4LFxuICAgICAgICAweDFlZDkwLCAweDFlZDllLCAweDFlZGEwLCAweDFlZGNjLCAweDFlZGYyLCAweDFlZGY0LCAweDFlZTE2LCAweDFlZTI2LCAweDFlZTJjLCAweDFlZTNhLCAweDFlZTQ2LCAweDFlZTRjLFxuICAgICAgICAweDFlZTU4LCAweDFlZTZlLCAweDFlZTcyLCAweDFlZTc0LCAweDFlZTg2LCAweDFlZThjLCAweDFlZTk4LCAweDFlZWIwLCAweDFlZWJlLCAweDFlZWNlLCAweDFlZWRjLCAweDFlZWUyLFxuICAgICAgICAweDFlZWU0LCAweDFlZWU4LCAweDFlZjEyLCAweDFlZjIyLCAweDFlZjI0LCAweDFlZjI4LCAweDFlZjM2LCAweDFlZjQyLCAweDFlZjQ0LCAweDFlZjQ4LCAweDFlZjUwLCAweDFlZjVlLFxuICAgICAgICAweDFlZjY2LCAweDFlZjZjLCAweDFlZjdhLCAweDFlZmFlLCAweDFlZmIyLCAweDFlZmI0LCAweDFlZmQ2LCAweDFmMDk2LCAweDFmMGE2LCAweDFmMGFjLCAweDFmMGJhLCAweDFmMGNhLFxuICAgICAgICAweDFmMGQyLCAweDFmMGQ0LCAweDFmMTE2LCAweDFmMTI2LCAweDFmMTJjLCAweDFmMTNhLCAweDFmMTQ2LCAweDFmMTRjLCAweDFmMTU4LCAweDFmMTZlLCAweDFmMTcyLCAweDFmMTc0LFxuICAgICAgICAweDFmMThhLCAweDFmMTkyLCAweDFmMTk0LCAweDFmMWEyLCAweDFmMWE0LCAweDFmMWE4LCAweDFmMWRhLCAweDFmMjE2LCAweDFmMjI2LCAweDFmMjJjLCAweDFmMjNhLCAweDFmMjQ2LFxuICAgICAgICAweDFmMjU4LCAweDFmMjZlLCAweDFmMjcyLCAweDFmMjc0LCAweDFmMjg2LCAweDFmMjhjLCAweDFmMjk4LCAweDFmMmIwLCAweDFmMmJlLCAweDFmMmNlLCAweDFmMmRjLCAweDFmMmUyLFxuICAgICAgICAweDFmMmU0LCAweDFmMmU4LCAweDFmMmY2LCAweDFmMzBhLCAweDFmMzEyLCAweDFmMzE0LCAweDFmMzIyLCAweDFmMzI4LCAweDFmMzQyLCAweDFmMzQ0LCAweDFmMzQ4LCAweDFmMzUwLFxuICAgICAgICAweDFmMzVlLCAweDFmMzY2LCAweDFmMzdhLCAweDFmMzlhLCAweDFmM2FlLCAweDFmM2IyLCAweDFmM2I0LCAweDFmNDE2LCAweDFmNDI2LCAweDFmNDJjLCAweDFmNDNhLCAweDFmNDQ2LFxuICAgICAgICAweDFmNDRjLCAweDFmNDU4LCAweDFmNDZlLCAweDFmNDcyLCAweDFmNDc0LCAweDFmNDg2LCAweDFmNDhjLCAweDFmNDk4LCAweDFmNGIwLCAweDFmNGJlLCAweDFmNGNlLCAweDFmNGRjLFxuICAgICAgICAweDFmNGUyLCAweDFmNGU0LCAweDFmNGU4LCAweDFmNGY2LCAweDFmNTA2LCAweDFmNTBjLCAweDFmNTE4LCAweDFmNTMwLCAweDFmNTNlLCAweDFmNTYwLCAweDFmNTdjLCAweDFmNThlLFxuICAgICAgICAweDFmNTljLCAweDFmNWI4LCAweDFmNWMyLCAweDFmNWM0LCAweDFmNWM4LCAweDFmNWQwLCAweDFmNWRlLCAweDFmNWU2LCAweDFmNWVjLCAweDFmNWZhLCAweDFmNjBhLCAweDFmNjEyLFxuICAgICAgICAweDFmNjE0LCAweDFmNjIyLCAweDFmNjI0LCAweDFmNjI4LCAweDFmNjM2LCAweDFmNjQyLCAweDFmNjQ0LCAweDFmNjQ4LCAweDFmNjUwLCAweDFmNjVlLCAweDFmNjY2LCAweDFmNjdhLFxuICAgICAgICAweDFmNjgyLCAweDFmNjg0LCAweDFmNjg4LCAweDFmNjkwLCAweDFmNjllLCAweDFmNmEwLCAweDFmNmJjLCAweDFmNmNjLCAweDFmNmYyLCAweDFmNmY0LCAweDFmNzFhLCAweDFmNzJlLFxuICAgICAgICAweDFmNzMyLCAweDFmNzM0LCAweDFmNzRlLCAweDFmNzVjLCAweDFmNzYyLCAweDFmNzY0LCAweDFmNzY4LCAweDFmNzc2LCAweDFmNzk2LCAweDFmN2E2LCAweDFmN2FjLCAweDFmN2JhLFxuICAgICAgICAweDFmN2QyLCAweDFmN2Q0LCAweDFmODlhLCAweDFmOGFlLCAweDFmOGIyLCAweDFmOGI0LCAweDFmOGQ2LCAweDFmOGVhLCAweDFmOTFhLCAweDFmOTJlLCAweDFmOTMyLCAweDFmOTM0LFxuICAgICAgICAweDFmOTRlLCAweDFmOTVjLCAweDFmOTYyLCAweDFmOTY0LCAweDFmOTY4LCAweDFmOTc2LCAweDFmOTk2LCAweDFmOWE2LCAweDFmOWFjLCAweDFmOWJhLCAweDFmOWNhLCAweDFmOWQyLFxuICAgICAgICAweDFmOWQ0LCAweDFmYTFhLCAweDFmYTJlLCAweDFmYTMyLCAweDFmYTM0LCAweDFmYTRlLCAweDFmYTVjLCAweDFmYTYyLCAweDFmYTY0LCAweDFmYTY4LCAweDFmYTc2LCAweDFmYThlLFxuICAgICAgICAweDFmYTljLCAweDFmYWI4LCAweDFmYWMyLCAweDFmYWM0LCAweDFmYWM4LCAweDFmYWQwLCAweDFmYWRlLCAweDFmYWU2LCAweDFmYWVjLCAweDFmYjE2LCAweDFmYjI2LCAweDFmYjJjLFxuICAgICAgICAweDFmYjNhLCAweDFmYjQ2LCAweDFmYjRjLCAweDFmYjU4LCAweDFmYjZlLCAweDFmYjcyLCAweDFmYjc0LCAweDFmYjhhLCAweDFmYjkyLCAweDFmYjk0LCAweDFmYmEyLCAweDFmYmE0LFxuICAgICAgICAweDFmYmE4LCAweDFmYmI2LCAweDFmYmRhXG4gICAgXSk7XG4gICAgLyoqXG4gICAgICogVGhpcyB0YWJsZSBjb250YWlucyB0byBjb2Rld29yZHMgZm9yIGFsbCBzeW1ib2xzLlxuICAgICAqL1xuICAgIFBERjQxN0NvbW1vbi5DT0RFV09SRF9UQUJMRSA9IEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgIDI2MjcsIDE4MTksIDI2MjIsIDI2MjEsIDE4MTMsIDE4MTIsIDI3MjksIDI3MjQsIDI3MjMsIDI3NzksIDI3NzQsIDI3NzMsIDkwMiwgODk2LCA5MDgsIDg2OCwgODY1LCA4NjEsIDg1OSwgMjUxMSxcbiAgICAgICAgODczLCA4NzEsIDE3ODAsIDgzNSwgMjQ5MywgODI1LCAyNDkxLCA4NDIsIDgzNywgODQ0LCAxNzY0LCAxNzYyLCA4MTEsIDgxMCwgODA5LCAyNDgzLCA4MDcsIDI0ODIsIDgwNiwgMjQ4MCwgODE1LFxuICAgICAgICA4MTQsIDgxMywgODEyLCAyNDg0LCA4MTcsIDgxNiwgMTc0NSwgMTc0NCwgMTc0MiwgMTc0NiwgMjY1NSwgMjYzNywgMjYzNSwgMjYyNiwgMjYyNSwgMjYyMywgMjYyOCwgMTgyMCwgMjc1MixcbiAgICAgICAgMjczOSwgMjczNywgMjcyOCwgMjcyNywgMjcyNSwgMjczMCwgMjc4NSwgMjc4MywgMjc3OCwgMjc3NywgMjc3NSwgMjc4MCwgNzg3LCA3ODEsIDc0NywgNzM5LCA3MzYsIDI0MTMsIDc1NCwgNzUyLFxuICAgICAgICAxNzE5LCA2OTIsIDY4OSwgNjgxLCAyMzcxLCA2NzgsIDIzNjksIDcwMCwgNjk3LCA2OTQsIDcwMywgMTY4OCwgMTY4NiwgNjQyLCA2MzgsIDIzNDMsIDYzMSwgMjM0MSwgNjI3LCAyMzM4LCA2NTEsXG4gICAgICAgIDY0NiwgNjQzLCAyMzQ1LCA2NTQsIDY1MiwgMTY1MiwgMTY1MCwgMTY0NywgMTY1NCwgNjAxLCA1OTksIDIzMjIsIDU5NiwgMjMyMSwgNTk0LCAyMzE5LCAyMzE3LCA2MTEsIDYxMCwgNjA4LCA2MDYsXG4gICAgICAgIDIzMjQsIDYwMywgMjMyMywgNjE1LCA2MTQsIDYxMiwgMTYxNywgMTYxNiwgMTYxNCwgMTYxMiwgNjE2LCAxNjE5LCAxNjE4LCAyNTc1LCAyNTM4LCAyNTM2LCA5MDUsIDkwMSwgODk4LCA5MDksXG4gICAgICAgIDI1MDksIDI1MDcsIDI1MDQsIDg3MCwgODY3LCA4NjQsIDg2MCwgMjUxMiwgODc1LCA4NzIsIDE3ODEsIDI0OTAsIDI0ODksIDI0ODcsIDI0ODUsIDE3NDgsIDgzNiwgODM0LCA4MzIsIDgzMCxcbiAgICAgICAgMjQ5NCwgODI3LCAyNDkyLCA4NDMsIDg0MSwgODM5LCA4NDUsIDE3NjUsIDE3NjMsIDI3MDEsIDI2NzYsIDI2NzQsIDI2NTMsIDI2NDgsIDI2NTYsIDI2MzQsIDI2MzMsIDI2MzEsIDI2MjksXG4gICAgICAgIDE4MjEsIDI2MzgsIDI2MzYsIDI3NzAsIDI3NjMsIDI3NjEsIDI3NTAsIDI3NDUsIDI3NTMsIDI3MzYsIDI3MzUsIDI3MzMsIDI3MzEsIDE4NDgsIDI3NDAsIDI3MzgsIDI3ODYsIDI3ODQsIDU5MSxcbiAgICAgICAgNTg4LCA1NzYsIDU2OSwgNTY2LCAyMjk2LCAxNTkwLCA1MzcsIDUzNCwgNTI2LCAyMjc2LCA1MjIsIDIyNzQsIDU0NSwgNTQyLCA1MzksIDU0OCwgMTU3MiwgMTU3MCwgNDgxLCAyMjQ1LCA0NjYsXG4gICAgICAgIDIyNDIsIDQ2MiwgMjIzOSwgNDkyLCA0ODUsIDQ4MiwgMjI0OSwgNDk2LCA0OTQsIDE1MzQsIDE1MzEsIDE1MjgsIDE1MzgsIDQxMywgMjE5NiwgNDA2LCAyMTkxLCAyMTg4LCA0MjUsIDQxOSxcbiAgICAgICAgMjIwMiwgNDE1LCAyMTk5LCA0MzIsIDQzMCwgNDI3LCAxNDcyLCAxNDY3LCAxNDY0LCA0MzMsIDE0NzYsIDE0NzQsIDM2OCwgMzY3LCAyMTYwLCAzNjUsIDIxNTksIDM2MiwgMjE1NywgMjE1NSxcbiAgICAgICAgMjE1MiwgMzc4LCAzNzcsIDM3NSwgMjE2NiwgMzcyLCAyMTY1LCAzNjksIDIxNjIsIDM4MywgMzgxLCAzNzksIDIxNjgsIDE0MTksIDE0MTgsIDE0MTYsIDE0MTQsIDM4NSwgMTQxMSwgMzg0LFxuICAgICAgICAxNDIzLCAxNDIyLCAxNDIwLCAxNDI0LCAyNDYxLCA4MDIsIDI0NDEsIDI0MzksIDc5MCwgNzg2LCA3ODMsIDc5NCwgMjQwOSwgMjQwNiwgMjQwMywgNzUwLCA3NDIsIDczOCwgMjQxNCwgNzU2LFxuICAgICAgICA3NTMsIDE3MjAsIDIzNjcsIDIzNjUsIDIzNjIsIDIzNTksIDE2NjMsIDY5MywgNjkxLCA2ODQsIDIzNzMsIDY4MCwgMjM3MCwgNzAyLCA2OTksIDY5NiwgNzA0LCAxNjkwLCAxNjg3LCAyMzM3LFxuICAgICAgICAyMzM2LCAyMzM0LCAyMzMyLCAxNjI0LCAyMzI5LCAxNjIyLCA2NDAsIDYzNywgMjM0NCwgNjM0LCAyMzQyLCA2MzAsIDIzNDAsIDY1MCwgNjQ4LCA2NDUsIDIzNDYsIDY1NSwgNjUzLCAxNjUzLFxuICAgICAgICAxNjUxLCAxNjQ5LCAxNjU1LCAyNjEyLCAyNTk3LCAyNTk1LCAyNTcxLCAyNTY4LCAyNTY1LCAyNTc2LCAyNTM0LCAyNTI5LCAyNTI2LCAxNzg3LCAyNTQwLCAyNTM3LCA5MDcsIDkwNCwgOTAwLFxuICAgICAgICA5MTAsIDI1MDMsIDI1MDIsIDI1MDAsIDI0OTgsIDE3NjgsIDI0OTUsIDE3NjcsIDI1MTAsIDI1MDgsIDI1MDYsIDg2OSwgODY2LCA4NjMsIDI1MTMsIDg3NiwgODc0LCAxNzgyLCAyNzIwLCAyNzEzLFxuICAgICAgICAyNzExLCAyNjk3LCAyNjk0LCAyNjkxLCAyNzAyLCAyNjcyLCAyNjcwLCAyNjY0LCAxODI4LCAyNjc4LCAyNjc1LCAyNjQ3LCAyNjQ2LCAyNjQ0LCAyNjQyLCAxODIzLCAyNjM5LCAxODIyLCAyNjU0LFxuICAgICAgICAyNjUyLCAyNjUwLCAyNjU3LCAyNzcxLCAxODU1LCAyNzY1LCAyNzYyLCAxODUwLCAxODQ5LCAyNzUxLCAyNzQ5LCAyNzQ3LCAyNzU0LCAzNTMsIDIxNDgsIDM0NCwgMzQyLCAzMzYsIDIxNDIsXG4gICAgICAgIDMzMiwgMjE0MCwgMzQ1LCAxMzc1LCAxMzczLCAzMDYsIDIxMzAsIDI5OSwgMjEyOCwgMjk1LCAyMTI1LCAzMTksIDMxNCwgMzExLCAyMTMyLCAxMzU0LCAxMzUyLCAxMzQ5LCAxMzU2LCAyNjIsXG4gICAgICAgIDI1NywgMjEwMSwgMjUzLCAyMDk2LCAyMDkzLCAyNzQsIDI3MywgMjY3LCAyMTA3LCAyNjMsIDIxMDQsIDI4MCwgMjc4LCAyNzUsIDEzMTYsIDEzMTEsIDEzMDgsIDEzMjAsIDEzMTgsIDIwNTIsXG4gICAgICAgIDIwMiwgMjA1MCwgMjA0NCwgMjA0MCwgMjE5LCAyMDYzLCAyMTIsIDIwNjAsIDIwOCwgMjA1NSwgMjI0LCAyMjEsIDIwNjYsIDEyNjAsIDEyNTgsIDEyNTIsIDIzMSwgMTI0OCwgMjI5LCAxMjY2LFxuICAgICAgICAxMjY0LCAxMjYxLCAxMjY4LCAxNTUsIDE5OTgsIDE1MywgMTk5NiwgMTk5NCwgMTk5MSwgMTk4OCwgMTY1LCAxNjQsIDIwMDcsIDE2MiwgMjAwNiwgMTU5LCAyMDAzLCAyMDAwLCAxNzIsIDE3MSxcbiAgICAgICAgMTY5LCAyMDEyLCAxNjYsIDIwMTAsIDExODYsIDExODQsIDExODIsIDExNzksIDE3NSwgMTE3NiwgMTczLCAxMTkyLCAxMTkxLCAxMTg5LCAxMTg3LCAxNzYsIDExOTQsIDExOTMsIDIzMTMsXG4gICAgICAgIDIzMDcsIDIzMDUsIDU5MiwgNTg5LCAyMjk0LCAyMjkyLCAyMjg5LCA1NzgsIDU3MiwgNTY4LCAyMjk3LCA1ODAsIDE1OTEsIDIyNzIsIDIyNjcsIDIyNjQsIDE1NDcsIDUzOCwgNTM2LCA1MjksXG4gICAgICAgIDIyNzgsIDUyNSwgMjI3NSwgNTQ3LCA1NDQsIDU0MSwgMTU3NCwgMTU3MSwgMjIzNywgMjIzNSwgMjIyOSwgMTQ5MywgMjIyNSwgMTQ4OSwgNDc4LCAyMjQ3LCA0NzAsIDIyNDQsIDQ2NSwgMjI0MSxcbiAgICAgICAgNDkzLCA0ODgsIDQ4NCwgMjI1MCwgNDk4LCA0OTUsIDE1MzYsIDE1MzMsIDE1MzAsIDE1MzksIDIxODcsIDIxODYsIDIxODQsIDIxODIsIDE0MzIsIDIxNzksIDE0MzAsIDIxNzYsIDE0MjcsIDQxNCxcbiAgICAgICAgNDEyLCAyMTk3LCA0MDksIDIxOTUsIDQwNSwgMjE5MywgMjE5MCwgNDI2LCA0MjQsIDQyMSwgMjIwMywgNDE4LCAyMjAxLCA0MzEsIDQyOSwgMTQ3MywgMTQ3MSwgMTQ2OSwgMTQ2NiwgNDM0LFxuICAgICAgICAxNDc3LCAxNDc1LCAyNDc4LCAyNDcyLCAyNDcwLCAyNDU5LCAyNDU3LCAyNDU0LCAyNDYyLCA4MDMsIDI0MzcsIDI0MzIsIDI0MjksIDE3MjYsIDI0NDMsIDI0NDAsIDc5MiwgNzg5LCA3ODUsXG4gICAgICAgIDI0MDEsIDIzOTksIDIzOTMsIDE3MDIsIDIzODksIDE2OTksIDI0MTEsIDI0MDgsIDI0MDUsIDc0NSwgNzQxLCAyNDE1LCA3NTgsIDc1NSwgMTcyMSwgMjM1OCwgMjM1NywgMjM1NSwgMjM1MyxcbiAgICAgICAgMTY2MSwgMjM1MCwgMTY2MCwgMjM0NywgMTY1NywgMjM2OCwgMjM2NiwgMjM2NCwgMjM2MSwgMTY2NiwgNjkwLCA2ODcsIDIzNzQsIDY4MywgMjM3MiwgNzAxLCA2OTgsIDcwNSwgMTY5MSwgMTY4OSxcbiAgICAgICAgMjYxOSwgMjYxNywgMjYxMCwgMjYwOCwgMjYwNSwgMjYxMywgMjU5MywgMjU4OCwgMjU4NSwgMTgwMywgMjU5OSwgMjU5NiwgMjU2MywgMjU2MSwgMjU1NSwgMTc5NywgMjU1MSwgMTc5NSwgMjU3MyxcbiAgICAgICAgMjU3MCwgMjU2NywgMjU3NywgMjUyNSwgMjUyNCwgMjUyMiwgMjUyMCwgMTc4NiwgMjUxNywgMTc4NSwgMjUxNCwgMTc4MywgMjUzNSwgMjUzMywgMjUzMSwgMjUyOCwgMTc4OCwgMjU0MSwgMjUzOSxcbiAgICAgICAgOTA2LCA5MDMsIDkxMSwgMjcyMSwgMTg0NCwgMjcxNSwgMjcxMiwgMTgzOCwgMTgzNiwgMjY5OSwgMjY5NiwgMjY5MywgMjcwMywgMTgyNywgMTgyNiwgMTgyNCwgMjY3MywgMjY3MSwgMjY2OSxcbiAgICAgICAgMjY2NiwgMTgyOSwgMjY3OSwgMjY3NywgMTg1OCwgMTg1NywgMjc3MiwgMTg1NCwgMTg1MywgMTg1MSwgMTg1NiwgMjc2NiwgMjc2NCwgMTQzLCAxOTg3LCAxMzksIDE5ODYsIDEzNSwgMTMzLFxuICAgICAgICAxMzEsIDE5ODQsIDEyOCwgMTk4MywgMTI1LCAxOTgxLCAxMzgsIDEzNywgMTM2LCAxOTg1LCAxMTMzLCAxMTMyLCAxMTMwLCAxMTIsIDExMCwgMTk3NCwgMTA3LCAxOTczLCAxMDQsIDE5NzEsXG4gICAgICAgIDE5NjksIDEyMiwgMTIxLCAxMTksIDExNywgMTk3NywgMTE0LCAxOTc2LCAxMjQsIDExMTUsIDExMTQsIDExMTIsIDExMTAsIDExMTcsIDExMTYsIDg0LCA4MywgMTk1MywgODEsIDE5NTIsIDc4LFxuICAgICAgICAxOTUwLCAxOTQ4LCAxOTQ1LCA5NCwgOTMsIDkxLCAxOTU5LCA4OCwgMTk1OCwgODUsIDE5NTUsIDk5LCA5NywgOTUsIDE5NjEsIDEwODYsIDEwODUsIDEwODMsIDEwODEsIDEwNzgsIDEwMCxcbiAgICAgICAgMTA5MCwgMTA4OSwgMTA4NywgMTA5MSwgNDksIDQ3LCAxOTE3LCA0NCwgMTkxNSwgMTkxMywgMTkxMCwgMTkwNywgNTksIDE5MjYsIDU2LCAxOTI1LCA1MywgMTkyMiwgMTkxOSwgNjYsIDY0LFxuICAgICAgICAxOTMxLCA2MSwgMTkyOSwgMTA0MiwgMTA0MCwgMTAzOCwgNzEsIDEwMzUsIDcwLCAxMDMyLCA2OCwgMTA0OCwgMTA0NywgMTA0NSwgMTA0MywgMTA1MCwgMTA0OSwgMTIsIDEwLCAxODY5LCAxODY3LFxuICAgICAgICAxODY0LCAxODYxLCAyMSwgMTg4MCwgMTksIDE4NzcsIDE4NzQsIDE4NzEsIDI4LCAxODg4LCAyNSwgMTg4NiwgMjIsIDE4ODMsIDk4MiwgOTgwLCA5NzcsIDk3NCwgMzIsIDMwLCA5OTEsIDk4OSxcbiAgICAgICAgOTg3LCA5ODQsIDM0LCA5OTUsIDk5NCwgOTkyLCAyMTUxLCAyMTUwLCAyMTQ3LCAyMTQ2LCAyMTQ0LCAzNTYsIDM1NSwgMzU0LCAyMTQ5LCAyMTM5LCAyMTM4LCAyMTM2LCAyMTM0LCAxMzU5LFxuICAgICAgICAzNDMsIDM0MSwgMzM4LCAyMTQzLCAzMzUsIDIxNDEsIDM0OCwgMzQ3LCAzNDYsIDEzNzYsIDEzNzQsIDIxMjQsIDIxMjMsIDIxMjEsIDIxMTksIDEzMjYsIDIxMTYsIDEzMjQsIDMxMCwgMzA4LFxuICAgICAgICAzMDUsIDIxMzEsIDMwMiwgMjEyOSwgMjk4LCAyMTI3LCAzMjAsIDMxOCwgMzE2LCAzMTMsIDIxMzMsIDMyMiwgMzIxLCAxMzU1LCAxMzUzLCAxMzUxLCAxMzU3LCAyMDkyLCAyMDkxLCAyMDg5LFxuICAgICAgICAyMDg3LCAxMjc2LCAyMDg0LCAxMjc0LCAyMDgxLCAxMjcxLCAyNTksIDIxMDIsIDI1NiwgMjEwMCwgMjUyLCAyMDk4LCAyMDk1LCAyNzIsIDI2OSwgMjEwOCwgMjY2LCAyMTA2LCAyODEsIDI3OSxcbiAgICAgICAgMjc3LCAxMzE3LCAxMzE1LCAxMzEzLCAxMzEwLCAyODIsIDEzMjEsIDEzMTksIDIwMzksIDIwMzcsIDIwMzUsIDIwMzIsIDEyMDMsIDIwMjksIDEyMDAsIDExOTcsIDIwNywgMjA1MywgMjA1LFxuICAgICAgICAyMDUxLCAyMDEsIDIwNDksIDIwNDYsIDIwNDMsIDIyMCwgMjE4LCAyMDY0LCAyMTUsIDIwNjIsIDIxMSwgMjA1OSwgMjI4LCAyMjYsIDIyMywgMjA2OSwgMTI1OSwgMTI1NywgMTI1NCwgMjMyLFxuICAgICAgICAxMjUxLCAyMzAsIDEyNjcsIDEyNjUsIDEyNjMsIDIzMTYsIDIzMTUsIDIzMTIsIDIzMTEsIDIzMDksIDIzMTQsIDIzMDQsIDIzMDMsIDIzMDEsIDIyOTksIDE1OTMsIDIzMDgsIDIzMDYsIDU5MCxcbiAgICAgICAgMjI4OCwgMjI4NywgMjI4NSwgMjI4MywgMTU3OCwgMjI4MCwgMTU3NywgMjI5NSwgMjI5MywgMjI5MSwgNTc5LCA1NzcsIDU3NCwgNTcxLCAyMjk4LCA1ODIsIDU4MSwgMTU5MiwgMjI2MywgMjI2MixcbiAgICAgICAgMjI2MCwgMjI1OCwgMTU0NSwgMjI1NSwgMTU0NCwgMjI1MiwgMTU0MSwgMjI3MywgMjI3MSwgMjI2OSwgMjI2NiwgMTU1MCwgNTM1LCA1MzIsIDIyNzksIDUyOCwgMjI3NywgNTQ2LCA1NDMsIDU0OSxcbiAgICAgICAgMTU3NSwgMTU3MywgMjIyNCwgMjIyMiwgMjIyMCwgMTQ4NiwgMjIxNywgMTQ4NSwgMjIxNCwgMTQ4MiwgMTQ3OSwgMjIzOCwgMjIzNiwgMjIzNCwgMjIzMSwgMTQ5NiwgMjIyOCwgMTQ5MiwgNDgwLFxuICAgICAgICA0NzcsIDIyNDgsIDQ3MywgMjI0NiwgNDY5LCAyMjQzLCA0OTAsIDQ4NywgMjI1MSwgNDk3LCAxNTM3LCAxNTM1LCAxNTMyLCAyNDc3LCAyNDc2LCAyNDc0LCAyNDc5LCAyNDY5LCAyNDY4LCAyNDY2LFxuICAgICAgICAyNDY0LCAxNzMwLCAyNDczLCAyNDcxLCAyNDUzLCAyNDUyLCAyNDUwLCAyNDQ4LCAxNzI5LCAyNDQ1LCAxNzI4LCAyNDYwLCAyNDU4LCAyNDU2LCAyNDYzLCA4MDUsIDgwNCwgMjQyOCwgMjQyNyxcbiAgICAgICAgMjQyNSwgMjQyMywgMTcyNSwgMjQyMCwgMTcyNCwgMjQxNywgMTcyMiwgMjQzOCwgMjQzNiwgMjQzNCwgMjQzMSwgMTcyNywgMjQ0NCwgMjQ0MiwgNzkzLCA3OTEsIDc4OCwgNzk1LCAyMzg4LFxuICAgICAgICAyMzg2LCAyMzg0LCAxNjk3LCAyMzgxLCAxNjk2LCAyMzc4LCAxNjk0LCAxNjkyLCAyNDAyLCAyNDAwLCAyMzk4LCAyMzk1LCAxNzAzLCAyMzkyLCAxNzAxLCAyNDEyLCAyNDEwLCAyNDA3LCA3NTEsXG4gICAgICAgIDc0OCwgNzQ0LCAyNDE2LCA3NTksIDc1NywgMTgwNywgMjYyMCwgMjYxOCwgMTgwNiwgMTgwNSwgMjYxMSwgMjYwOSwgMjYwNywgMjYxNCwgMTgwMiwgMTgwMSwgMTc5OSwgMjU5NCwgMjU5MixcbiAgICAgICAgMjU5MCwgMjU4NywgMTgwNCwgMjYwMCwgMjU5OCwgMTc5NCwgMTc5MywgMTc5MSwgMTc4OSwgMjU2NCwgMjU2MiwgMjU2MCwgMjU1NywgMTc5OCwgMjU1NCwgMTc5NiwgMjU3NCwgMjU3MiwgMjU2OSxcbiAgICAgICAgMjU3OCwgMTg0NywgMTg0NiwgMjcyMiwgMTg0MywgMTg0MiwgMTg0MCwgMTg0NSwgMjcxNiwgMjcxNCwgMTgzNSwgMTgzNCwgMTgzMiwgMTgzMCwgMTgzOSwgMTgzNywgMjcwMCwgMjY5OCwgMjY5NSxcbiAgICAgICAgMjcwNCwgMTgxNywgMTgxMSwgMTgxMCwgODk3LCA4NjIsIDE3NzcsIDgyOSwgODI2LCA4MzgsIDE3NjAsIDE3NTgsIDgwOCwgMjQ4MSwgMTc0MSwgMTc0MCwgMTczOCwgMTc0MywgMjYyNCwgMTgxOCxcbiAgICAgICAgMjcyNiwgMjc3NiwgNzgyLCA3NDAsIDczNywgMTcxNSwgNjg2LCA2NzksIDY5NSwgMTY4MiwgMTY4MCwgNjM5LCA2MjgsIDIzMzksIDY0NywgNjQ0LCAxNjQ1LCAxNjQzLCAxNjQwLCAxNjQ4LFxuICAgICAgICA2MDIsIDYwMCwgNTk3LCA1OTUsIDIzMjAsIDU5MywgMjMxOCwgNjA5LCA2MDcsIDYwNCwgMTYxMSwgMTYxMCwgMTYwOCwgMTYwNiwgNjEzLCAxNjE1LCAxNjEzLCAyMzI4LCA5MjYsIDkyNCwgODkyLFxuICAgICAgICA4ODYsIDg5OSwgODU3LCA4NTAsIDI1MDUsIDE3NzgsIDgyNCwgODIzLCA4MjEsIDgxOSwgMjQ4OCwgODE4LCAyNDg2LCA4MzMsIDgzMSwgODI4LCA4NDAsIDE3NjEsIDE3NTksIDI2NDksIDI2MzIsXG4gICAgICAgIDI2MzAsIDI3NDYsIDI3MzQsIDI3MzIsIDI3ODIsIDI3ODEsIDU3MCwgNTY3LCAxNTg3LCA1MzEsIDUyNywgNTIzLCA1NDAsIDE1NjYsIDE1NjQsIDQ3NiwgNDY3LCA0NjMsIDIyNDAsIDQ4NixcbiAgICAgICAgNDgzLCAxNTI0LCAxNTIxLCAxNTE4LCAxNTI5LCA0MTEsIDQwMywgMjE5MiwgMzk5LCAyMTg5LCA0MjMsIDQxNiwgMTQ2MiwgMTQ1NywgMTQ1NCwgNDI4LCAxNDY4LCAxNDY1LCAyMjEwLCAzNjYsXG4gICAgICAgIDM2MywgMjE1OCwgMzYwLCAyMTU2LCAzNTcsIDIxNTMsIDM3NiwgMzczLCAzNzAsIDIxNjMsIDE0MTAsIDE0MDksIDE0MDcsIDE0MDUsIDM4MiwgMTQwMiwgMzgwLCAxNDE3LCAxNDE1LCAxNDEyLFxuICAgICAgICAxNDIxLCAyMTc1LCAyMTc0LCA3NzcsIDc3NCwgNzcxLCA3ODQsIDczMiwgNzI1LCA3MjIsIDI0MDQsIDc0MywgMTcxNiwgNjc2LCA2NzQsIDY2OCwgMjM2MywgNjY1LCAyMzYwLCA2ODUsIDE2ODQsXG4gICAgICAgIDE2ODEsIDYyNiwgNjI0LCA2MjIsIDIzMzUsIDYyMCwgMjMzMywgNjE3LCAyMzMwLCA2NDEsIDYzNSwgNjQ5LCAxNjQ2LCAxNjQ0LCAxNjQyLCAyNTY2LCA5MjgsIDkyNSwgMjUzMCwgMjUyNyxcbiAgICAgICAgODk0LCA4OTEsIDg4OCwgMjUwMSwgMjQ5OSwgMjQ5NiwgODU4LCA4NTYsIDg1NCwgODUxLCAxNzc5LCAyNjkyLCAyNjY4LCAyNjY1LCAyNjQ1LCAyNjQzLCAyNjQwLCAyNjUxLCAyNzY4LCAyNzU5LFxuICAgICAgICAyNzU3LCAyNzQ0LCAyNzQzLCAyNzQxLCAyNzQ4LCAzNTIsIDEzODIsIDM0MCwgMzM3LCAzMzMsIDEzNzEsIDEzNjksIDMwNywgMzAwLCAyOTYsIDIxMjYsIDMxNSwgMzEyLCAxMzQ3LCAxMzQyLFxuICAgICAgICAxMzUwLCAyNjEsIDI1OCwgMjUwLCAyMDk3LCAyNDYsIDIwOTQsIDI3MSwgMjY4LCAyNjQsIDEzMDYsIDEzMDEsIDEyOTgsIDI3NiwgMTMxMiwgMTMwOSwgMjExNSwgMjAzLCAyMDQ4LCAxOTUsXG4gICAgICAgIDIwNDUsIDE5MSwgMjA0MSwgMjEzLCAyMDksIDIwNTYsIDEyNDYsIDEyNDQsIDEyMzgsIDIyNSwgMTIzNCwgMjIyLCAxMjU2LCAxMjUzLCAxMjQ5LCAxMjYyLCAyMDgwLCAyMDc5LCAxNTQsIDE5OTcsXG4gICAgICAgIDE1MCwgMTk5NSwgMTQ3LCAxOTkyLCAxOTg5LCAxNjMsIDE2MCwgMjAwNCwgMTU2LCAyMDAxLCAxMTc1LCAxMTc0LCAxMTcyLCAxMTcwLCAxMTY3LCAxNzAsIDExNjQsIDE2NywgMTE4NSwgMTE4MyxcbiAgICAgICAgMTE4MCwgMTE3NywgMTc0LCAxMTkwLCAxMTg4LCAyMDI1LCAyMDI0LCAyMDIyLCA1ODcsIDU4NiwgNTY0LCA1NTksIDU1NiwgMjI5MCwgNTczLCAxNTg4LCA1MjAsIDUxOCwgNTEyLCAyMjY4LFxuICAgICAgICA1MDgsIDIyNjUsIDUzMCwgMTU2OCwgMTU2NSwgNDYxLCA0NTcsIDIyMzMsIDQ1MCwgMjIzMCwgNDQ2LCAyMjI2LCA0NzksIDQ3MSwgNDg5LCAxNTI2LCAxNTIzLCAxNTIwLCAzOTcsIDM5NSxcbiAgICAgICAgMjE4NSwgMzkyLCAyMTgzLCAzODksIDIxODAsIDIxNzcsIDQxMCwgMjE5NCwgNDAyLCA0MjIsIDE0NjMsIDE0NjEsIDE0NTksIDE0NTYsIDE0NzAsIDI0NTUsIDc5OSwgMjQzMywgMjQzMCwgNzc5LFxuICAgICAgICA3NzYsIDc3MywgMjM5NywgMjM5NCwgMjM5MCwgNzM0LCA3MjgsIDcyNCwgNzQ2LCAxNzE3LCAyMzU2LCAyMzU0LCAyMzUxLCAyMzQ4LCAxNjU4LCA2NzcsIDY3NSwgNjczLCA2NzAsIDY2NywgNjg4LFxuICAgICAgICAxNjg1LCAxNjgzLCAyNjA2LCAyNTg5LCAyNTg2LCAyNTU5LCAyNTU2LCAyNTUyLCA5MjcsIDI1MjMsIDI1MjEsIDI1MTgsIDI1MTUsIDE3ODQsIDI1MzIsIDg5NSwgODkzLCA4OTAsIDI3MTgsXG4gICAgICAgIDI3MDksIDI3MDcsIDI2ODksIDI2ODcsIDI2ODQsIDI2NjMsIDI2NjIsIDI2NjAsIDI2NTgsIDE4MjUsIDI2NjcsIDI3NjksIDE4NTIsIDI3NjAsIDI3NTgsIDE0MiwgMTQxLCAxMTM5LCAxMTM4LFxuICAgICAgICAxMzQsIDEzMiwgMTI5LCAxMjYsIDE5ODIsIDExMjksIDExMjgsIDExMjYsIDExMzEsIDExMywgMTExLCAxMDgsIDEwNSwgMTk3MiwgMTAxLCAxOTcwLCAxMjAsIDExOCwgMTE1LCAxMTA5LCAxMTA4LFxuICAgICAgICAxMTA2LCAxMTA0LCAxMjMsIDExMTMsIDExMTEsIDgyLCA3OSwgMTk1MSwgNzUsIDE5NDksIDcyLCAxOTQ2LCA5MiwgODksIDg2LCAxOTU2LCAxMDc3LCAxMDc2LCAxMDc0LCAxMDcyLCA5OCxcbiAgICAgICAgMTA2OSwgOTYsIDEwODQsIDEwODIsIDEwNzksIDEwODgsIDE5NjgsIDE5NjcsIDQ4LCA0NSwgMTkxNiwgNDIsIDE5MTQsIDM5LCAxOTExLCAxOTA4LCA2MCwgNTcsIDU0LCAxOTIzLCA1MCwgMTkyMCxcbiAgICAgICAgMTAzMSwgMTAzMCwgMTAyOCwgMTAyNiwgNjcsIDEwMjMsIDY1LCAxMDIwLCA2MiwgMTA0MSwgMTAzOSwgMTAzNiwgMTAzMywgNjksIDEwNDYsIDEwNDQsIDE5NDQsIDE5NDMsIDE5NDEsIDExLCA5LFxuICAgICAgICAxODY4LCA3LCAxODY1LCAxODYyLCAxODU5LCAyMCwgMTg3OCwgMTYsIDE4NzUsIDEzLCAxODcyLCA5NzAsIDk2OCwgOTY2LCA5NjMsIDI5LCA5NjAsIDI2LCAyMywgOTgzLCA5ODEsIDk3OCwgOTc1LFxuICAgICAgICAzMywgOTcxLCAzMSwgOTkwLCA5ODgsIDk4NSwgMTkwNiwgMTkwNCwgMTkwMiwgOTkzLCAzNTEsIDIxNDUsIDEzODMsIDMzMSwgMzMwLCAzMjgsIDMyNiwgMjEzNywgMzIzLCAyMTM1LCAzMzksXG4gICAgICAgIDEzNzIsIDEzNzAsIDI5NCwgMjkzLCAyOTEsIDI4OSwgMjEyMiwgMjg2LCAyMTIwLCAyODMsIDIxMTcsIDMwOSwgMzAzLCAzMTcsIDEzNDgsIDEzNDYsIDEzNDQsIDI0NSwgMjQ0LCAyNDIsIDIwOTAsXG4gICAgICAgIDIzOSwgMjA4OCwgMjM2LCAyMDg1LCAyMDgyLCAyNjAsIDIwOTksIDI0OSwgMjcwLCAxMzA3LCAxMzA1LCAxMzAzLCAxMzAwLCAxMzE0LCAxODksIDIwMzgsIDE4NiwgMjAzNiwgMTgzLCAyMDMzLFxuICAgICAgICAyMDMwLCAyMDI2LCAyMDYsIDE5OCwgMjA0NywgMTk0LCAyMTYsIDEyNDcsIDEyNDUsIDEyNDMsIDEyNDAsIDIyNywgMTIzNywgMTI1NSwgMjMxMCwgMjMwMiwgMjMwMCwgMjI4NiwgMjI4NCxcbiAgICAgICAgMjI4MSwgNTY1LCA1NjMsIDU2MSwgNTU4LCA1NzUsIDE1ODksIDIyNjEsIDIyNTksIDIyNTYsIDIyNTMsIDE1NDIsIDUyMSwgNTE5LCA1MTcsIDUxNCwgMjI3MCwgNTExLCA1MzMsIDE1NjksXG4gICAgICAgIDE1NjcsIDIyMjMsIDIyMjEsIDIyMTgsIDIyMTUsIDE0ODMsIDIyMTEsIDE0ODAsIDQ1OSwgNDU2LCA0NTMsIDIyMzIsIDQ0OSwgNDc0LCA0OTEsIDE1MjcsIDE1MjUsIDE1MjIsIDI0NzUsIDI0NjcsXG4gICAgICAgIDI0NjUsIDI0NTEsIDI0NDksIDI0NDYsIDgwMSwgODAwLCAyNDI2LCAyNDI0LCAyNDIxLCAyNDE4LCAxNzIzLCAyNDM1LCA3ODAsIDc3OCwgNzc1LCAyMzg3LCAyMzg1LCAyMzgyLCAyMzc5LFxuICAgICAgICAxNjk1LCAyMzc1LCAxNjkzLCAyMzk2LCA3MzUsIDczMywgNzMwLCA3MjcsIDc0OSwgMTcxOCwgMjYxNiwgMjYxNSwgMjYwNCwgMjYwMywgMjYwMSwgMjU4NCwgMjU4MywgMjU4MSwgMjU3OSxcbiAgICAgICAgMTgwMCwgMjU5MSwgMjU1MCwgMjU0OSwgMjU0NywgMjU0NSwgMTc5MiwgMjU0MiwgMTc5MCwgMjU1OCwgOTI5LCAyNzE5LCAxODQxLCAyNzEwLCAyNzA4LCAxODMzLCAxODMxLCAyNjkwLCAyNjg4LFxuICAgICAgICAyNjg2LCAxODE1LCAxODA5LCAxODA4LCAxNzc0LCAxNzU2LCAxNzU0LCAxNzM3LCAxNzM2LCAxNzM0LCAxNzM5LCAxODE2LCAxNzExLCAxNjc2LCAxNjc0LCA2MzMsIDYyOSwgMTYzOCwgMTYzNixcbiAgICAgICAgMTYzMywgMTY0MSwgNTk4LCAxNjA1LCAxNjA0LCAxNjAyLCAxNjAwLCA2MDUsIDE2MDksIDE2MDcsIDIzMjcsIDg4NywgODUzLCAxNzc1LCA4MjIsIDgyMCwgMTc1NywgMTc1NSwgMTU4NCwgNTI0LFxuICAgICAgICAxNTYwLCAxNTU4LCA0NjgsIDQ2NCwgMTUxNCwgMTUxMSwgMTUwOCwgMTUxOSwgNDA4LCA0MDQsIDQwMCwgMTQ1MiwgMTQ0NywgMTQ0NCwgNDE3LCAxNDU4LCAxNDU1LCAyMjA4LCAzNjQsIDM2MSxcbiAgICAgICAgMzU4LCAyMTU0LCAxNDAxLCAxNDAwLCAxMzk4LCAxMzk2LCAzNzQsIDEzOTMsIDM3MSwgMTQwOCwgMTQwNiwgMTQwMywgMTQxMywgMjE3MywgMjE3MiwgNzcyLCA3MjYsIDcyMywgMTcxMiwgNjcyLFxuICAgICAgICA2NjksIDY2NiwgNjgyLCAxNjc4LCAxNjc1LCA2MjUsIDYyMywgNjIxLCA2MTgsIDIzMzEsIDYzNiwgNjMyLCAxNjM5LCAxNjM3LCAxNjM1LCA5MjAsIDkxOCwgODg0LCA4ODAsIDg4OSwgODQ5LFxuICAgICAgICA4NDgsIDg0NywgODQ2LCAyNDk3LCA4NTUsIDg1MiwgMTc3NiwgMjY0MSwgMjc0MiwgMjc4NywgMTM4MCwgMzM0LCAxMzY3LCAxMzY1LCAzMDEsIDI5NywgMTM0MCwgMTMzOCwgMTMzNSwgMTM0MyxcbiAgICAgICAgMjU1LCAyNTEsIDI0NywgMTI5NiwgMTI5MSwgMTI4OCwgMjY1LCAxMzAyLCAxMjk5LCAyMTEzLCAyMDQsIDE5NiwgMTkyLCAyMDQyLCAxMjMyLCAxMjMwLCAxMjI0LCAyMTQsIDEyMjAsIDIxMCxcbiAgICAgICAgMTI0MiwgMTIzOSwgMTIzNSwgMTI1MCwgMjA3NywgMjA3NSwgMTUxLCAxNDgsIDE5OTMsIDE0NCwgMTk5MCwgMTE2MywgMTE2MiwgMTE2MCwgMTE1OCwgMTE1NSwgMTYxLCAxMTUyLCAxNTcsXG4gICAgICAgIDExNzMsIDExNzEsIDExNjgsIDExNjUsIDE2OCwgMTE4MSwgMTE3OCwgMjAyMSwgMjAyMCwgMjAxOCwgMjAyMywgNTg1LCA1NjAsIDU1NywgMTU4NSwgNTE2LCA1MDksIDE1NjIsIDE1NTksIDQ1OCxcbiAgICAgICAgNDQ3LCAyMjI3LCA0NzIsIDE1MTYsIDE1MTMsIDE1MTAsIDM5OCwgMzk2LCAzOTMsIDM5MCwgMjE4MSwgMzg2LCAyMTc4LCA0MDcsIDE0NTMsIDE0NTEsIDE0NDksIDE0NDYsIDQyMCwgMTQ2MCxcbiAgICAgICAgMjIwOSwgNzY5LCA3NjQsIDcyMCwgNzEyLCAyMzkxLCA3MjksIDE3MTMsIDY2NCwgNjYzLCA2NjEsIDY1OSwgMjM1MiwgNjU2LCAyMzQ5LCA2NzEsIDE2NzksIDE2NzcsIDI1NTMsIDkyMiwgOTE5LFxuICAgICAgICAyNTE5LCAyNTE2LCA4ODUsIDg4MywgODgxLCAyNjg1LCAyNjYxLCAyNjU5LCAyNzY3LCAyNzU2LCAyNzU1LCAxNDAsIDExMzcsIDExMzYsIDEzMCwgMTI3LCAxMTI1LCAxMTI0LCAxMTIyLCAxMTI3LFxuICAgICAgICAxMDksIDEwNiwgMTAyLCAxMTAzLCAxMTAyLCAxMTAwLCAxMDk4LCAxMTYsIDExMDcsIDExMDUsIDE5ODAsIDgwLCA3NiwgNzMsIDE5NDcsIDEwNjgsIDEwNjcsIDEwNjUsIDEwNjMsIDkwLCAxMDYwLFxuICAgICAgICA4NywgMTA3NSwgMTA3MywgMTA3MCwgMTA4MCwgMTk2NiwgMTk2NSwgNDYsIDQzLCA0MCwgMTkxMiwgMzYsIDE5MDksIDEwMTksIDEwMTgsIDEwMTYsIDEwMTQsIDU4LCAxMDExLCA1NSwgMTAwOCxcbiAgICAgICAgNTEsIDEwMjksIDEwMjcsIDEwMjQsIDEwMjEsIDYzLCAxMDM3LCAxMDM0LCAxOTQwLCAxOTM5LCAxOTM3LCAxOTQyLCA4LCAxODY2LCA0LCAxODYzLCAxLCAxODYwLCA5NTYsIDk1NCwgOTUyLFxuICAgICAgICA5NDksIDk0NiwgMTcsIDE0LCA5NjksIDk2NywgOTY0LCA5NjEsIDI3LCA5NTcsIDI0LCA5NzksIDk3NiwgOTcyLCAxOTAxLCAxOTAwLCAxODk4LCAxODk2LCA5ODYsIDE5MDUsIDE5MDMsIDM1MCxcbiAgICAgICAgMzQ5LCAxMzgxLCAzMjksIDMyNywgMzI0LCAxMzY4LCAxMzY2LCAyOTIsIDI5MCwgMjg3LCAyODQsIDIxMTgsIDMwNCwgMTM0MSwgMTMzOSwgMTMzNywgMTM0NSwgMjQzLCAyNDAsIDIzNywgMjA4NixcbiAgICAgICAgMjMzLCAyMDgzLCAyNTQsIDEyOTcsIDEyOTUsIDEyOTMsIDEyOTAsIDEzMDQsIDIxMTQsIDE5MCwgMTg3LCAxODQsIDIwMzQsIDE4MCwgMjAzMSwgMTc3LCAyMDI3LCAxOTksIDEyMzMsIDEyMzEsXG4gICAgICAgIDEyMjksIDEyMjYsIDIxNywgMTIyMywgMTI0MSwgMjA3OCwgMjA3NiwgNTg0LCA1NTUsIDU1NCwgNTUyLCA1NTAsIDIyODIsIDU2MiwgMTU4NiwgNTA3LCA1MDYsIDUwNCwgNTAyLCAyMjU3LCA0OTksXG4gICAgICAgIDIyNTQsIDUxNSwgMTU2MywgMTU2MSwgNDQ1LCA0NDMsIDQ0MSwgMjIxOSwgNDM4LCAyMjE2LCA0MzUsIDIyMTIsIDQ2MCwgNDU0LCA0NzUsIDE1MTcsIDE1MTUsIDE1MTIsIDI0NDcsIDc5OCxcbiAgICAgICAgNzk3LCAyNDIyLCAyNDE5LCA3NzAsIDc2OCwgNzY2LCAyMzgzLCAyMzgwLCAyMzc2LCA3MjEsIDcxOSwgNzE3LCA3MTQsIDczMSwgMTcxNCwgMjYwMiwgMjU4MiwgMjU4MCwgMjU0OCwgMjU0NixcbiAgICAgICAgMjU0MywgOTIzLCA5MjEsIDI3MTcsIDI3MDYsIDI3MDUsIDI2ODMsIDI2ODIsIDI2ODAsIDE3NzEsIDE3NTIsIDE3NTAsIDE3MzMsIDE3MzIsIDE3MzEsIDE3MzUsIDE4MTQsIDE3MDcsIDE2NzAsXG4gICAgICAgIDE2NjgsIDE2MzEsIDE2MjksIDE2MjYsIDE2MzQsIDE1OTksIDE1OTgsIDE1OTYsIDE1OTQsIDE2MDMsIDE2MDEsIDIzMjYsIDE3NzIsIDE3NTMsIDE3NTEsIDE1ODEsIDE1NTQsIDE1NTIsIDE1MDQsXG4gICAgICAgIDE1MDEsIDE0OTgsIDE1MDksIDE0NDIsIDE0MzcsIDE0MzQsIDQwMSwgMTQ0OCwgMTQ0NSwgMjIwNiwgMTM5MiwgMTM5MSwgMTM4OSwgMTM4NywgMTM4NCwgMzU5LCAxMzk5LCAxMzk3LCAxMzk0LFxuICAgICAgICAxNDA0LCAyMTcxLCAyMTcwLCAxNzA4LCAxNjcyLCAxNjY5LCA2MTksIDE2MzIsIDE2MzAsIDE2MjgsIDE3NzMsIDEzNzgsIDEzNjMsIDEzNjEsIDEzMzMsIDEzMjgsIDEzMzYsIDEyODYsIDEyODEsXG4gICAgICAgIDEyNzgsIDI0OCwgMTI5MiwgMTI4OSwgMjExMSwgMTIxOCwgMTIxNiwgMTIxMCwgMTk3LCAxMjA2LCAxOTMsIDEyMjgsIDEyMjUsIDEyMjEsIDEyMzYsIDIwNzMsIDIwNzEsIDExNTEsIDExNTAsXG4gICAgICAgIDExNDgsIDExNDYsIDE1MiwgMTE0MywgMTQ5LCAxMTQwLCAxNDUsIDExNjEsIDExNTksIDExNTYsIDExNTMsIDE1OCwgMTE2OSwgMTE2NiwgMjAxNywgMjAxNiwgMjAxNCwgMjAxOSwgMTU4MixcbiAgICAgICAgNTEwLCAxNTU2LCAxNTUzLCA0NTIsIDQ0OCwgMTUwNiwgMTUwMCwgMzk0LCAzOTEsIDM4NywgMTQ0MywgMTQ0MSwgMTQzOSwgMTQzNiwgMTQ1MCwgMjIwNywgNzY1LCA3MTYsIDcxMywgMTcwOSxcbiAgICAgICAgNjYyLCA2NjAsIDY1NywgMTY3MywgMTY3MSwgOTE2LCA5MTQsIDg3OSwgODc4LCA4NzcsIDg4MiwgMTEzNSwgMTEzNCwgMTEyMSwgMTEyMCwgMTExOCwgMTEyMywgMTA5NywgMTA5NiwgMTA5NCxcbiAgICAgICAgMTA5MiwgMTAzLCAxMTAxLCAxMDk5LCAxOTc5LCAxMDU5LCAxMDU4LCAxMDU2LCAxMDU0LCA3NywgMTA1MSwgNzQsIDEwNjYsIDEwNjQsIDEwNjEsIDEwNzEsIDE5NjQsIDE5NjMsIDEwMDcsXG4gICAgICAgIDEwMDYsIDEwMDQsIDEwMDIsIDk5OSwgNDEsIDk5NiwgMzcsIDEwMTcsIDEwMTUsIDEwMTIsIDEwMDksIDUyLCAxMDI1LCAxMDIyLCAxOTM2LCAxOTM1LCAxOTMzLCAxOTM4LCA5NDIsIDk0MCxcbiAgICAgICAgOTM4LCA5MzUsIDkzMiwgNSwgMiwgOTU1LCA5NTMsIDk1MCwgOTQ3LCAxOCwgOTQzLCAxNSwgOTY1LCA5NjIsIDk1OCwgMTg5NSwgMTg5NCwgMTg5MiwgMTg5MCwgOTczLCAxODk5LCAxODk3LFxuICAgICAgICAxMzc5LCAzMjUsIDEzNjQsIDEzNjIsIDI4OCwgMjg1LCAxMzM0LCAxMzMyLCAxMzMwLCAyNDEsIDIzOCwgMjM0LCAxMjg3LCAxMjg1LCAxMjgzLCAxMjgwLCAxMjk0LCAyMTEyLCAxODgsIDE4NSxcbiAgICAgICAgMTgxLCAxNzgsIDIwMjgsIDEyMTksIDEyMTcsIDEyMTUsIDEyMTIsIDIwMCwgMTIwOSwgMTIyNywgMjA3NCwgMjA3MiwgNTgzLCA1NTMsIDU1MSwgMTU4MywgNTA1LCA1MDMsIDUwMCwgNTEzLFxuICAgICAgICAxNTU3LCAxNTU1LCA0NDQsIDQ0MiwgNDM5LCA0MzYsIDIyMTMsIDQ1NSwgNDUxLCAxNTA3LCAxNTA1LCAxNTAyLCA3OTYsIDc2MywgNzYyLCA3NjAsIDc2NywgNzExLCA3MTAsIDcwOCwgNzA2LFxuICAgICAgICAyMzc3LCA3MTgsIDcxNSwgMTcxMCwgMjU0NCwgOTE3LCA5MTUsIDI2ODEsIDE2MjcsIDE1OTcsIDE1OTUsIDIzMjUsIDE3NjksIDE3NDksIDE3NDcsIDE0OTksIDE0MzgsIDE0MzUsIDIyMDQsXG4gICAgICAgIDEzOTAsIDEzODgsIDEzODUsIDEzOTUsIDIxNjksIDIxNjcsIDE3MDQsIDE2NjUsIDE2NjIsIDE2MjUsIDE2MjMsIDE2MjAsIDE3NzAsIDEzMjksIDEyODIsIDEyNzksIDIxMDksIDEyMTQsIDEyMDcsXG4gICAgICAgIDEyMjIsIDIwNjgsIDIwNjUsIDExNDksIDExNDcsIDExNDQsIDExNDEsIDE0NiwgMTE1NywgMTE1NCwgMjAxMywgMjAxMSwgMjAwOCwgMjAxNSwgMTU3OSwgMTU0OSwgMTU0NiwgMTQ5NSwgMTQ4NyxcbiAgICAgICAgMTQzMywgMTQzMSwgMTQyOCwgMTQyNSwgMzg4LCAxNDQwLCAyMjA1LCAxNzA1LCA2NTgsIDE2NjcsIDE2NjQsIDExMTksIDEwOTUsIDEwOTMsIDE5NzgsIDEwNTcsIDEwNTUsIDEwNTIsIDEwNjIsXG4gICAgICAgIDE5NjIsIDE5NjAsIDEwMDUsIDEwMDMsIDEwMDAsIDk5NywgMzgsIDEwMTMsIDEwMTAsIDE5MzIsIDE5MzAsIDE5MjcsIDE5MzQsIDk0MSwgOTM5LCA5MzYsIDkzMywgNiwgOTMwLCAzLCA5NTEsXG4gICAgICAgIDk0OCwgOTQ0LCAxODg5LCAxODg3LCAxODg0LCAxODgxLCA5NTksIDE4OTMsIDE4OTEsIDM1LCAxMzc3LCAxMzYwLCAxMzU4LCAxMzI3LCAxMzI1LCAxMzIyLCAxMzMxLCAxMjc3LCAxMjc1LFxuICAgICAgICAxMjcyLCAxMjY5LCAyMzUsIDEyODQsIDIxMTAsIDEyMDUsIDEyMDQsIDEyMDEsIDExOTgsIDE4MiwgMTE5NSwgMTc5LCAxMjEzLCAyMDcwLCAyMDY3LCAxNTgwLCA1MDEsIDE1NTEsIDE1NDgsXG4gICAgICAgIDQ0MCwgNDM3LCAxNDk3LCAxNDk0LCAxNDkwLCAxNTAzLCA3NjEsIDcwOSwgNzA3LCAxNzA2LCA5MTMsIDkxMiwgMjE5OCwgMTM4NiwgMjE2NCwgMjE2MSwgMTYyMSwgMTc2NiwgMjEwMywgMTIwOCxcbiAgICAgICAgMjA1OCwgMjA1NCwgMTE0NSwgMTE0MiwgMjAwNSwgMjAwMiwgMTk5OSwgMjAwOSwgMTQ4OCwgMTQyOSwgMTQyNiwgMjIwMCwgMTY5OCwgMTY1OSwgMTY1NiwgMTk3NSwgMTA1MywgMTk1NywgMTk1NCxcbiAgICAgICAgMTAwMSwgOTk4LCAxOTI0LCAxOTIxLCAxOTE4LCAxOTI4LCA5MzcsIDkzNCwgOTMxLCAxODc5LCAxODc2LCAxODczLCAxODcwLCA5NDUsIDE4ODUsIDE4ODIsIDEzMjMsIDEyNzMsIDEyNzAsXG4gICAgICAgIDIxMDUsIDEyMDIsIDExOTksIDExOTYsIDEyMTEsIDIwNjEsIDIwNTcsIDE1NzYsIDE1NDMsIDE1NDAsIDE0ODQsIDE0ODEsIDE0NzgsIDE0OTEsIDE3MDBcbiAgICBdKTtcblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTGlzdDtcbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKnB1YmxpYyBmaW5hbCovIGNsYXNzIFBERjQxN0RldGVjdG9yUmVzdWx0IHtcbiAgICAgICAgY29uc3RydWN0b3IoYml0cywgcG9pbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgICAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qml0cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UG9pbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheXM7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTWFwO1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBsb2dpYyB0aGF0IGNhbiBkZXRlY3QgYSBQREY0MTcgQ29kZSBpbiBhbiBpbWFnZSwgZXZlbiBpZiB0aGVcbiAgICAgKiBQREY0MTcgQ29kZSBpcyByb3RhdGVkIG9yIHNrZXdlZCwgb3IgcGFydGlhbGx5IG9ic2N1cmVkLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU0lUQSBMYWIgKGtldmluLm9zdWxsaXZhbkBzaXRhLmFlcm8pXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKnB1YmxpYyovIC8qZmluYWwqLyBjbGFzcyBEZXRlY3RvciQzIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRldGVjdHMgYSBQREY0MTcgQ29kZSBpbiBhbiBpbWFnZS4gT25seSBjaGVja3MgMCBhbmQgMTgwIGRlZ3JlZSByb3RhdGlvbnMuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgYmFyY29kZSBpbWFnZSB0byBkZWNvZGVcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIG9wdGlvbmFsIGhpbnRzIHRvIGRldGVjdG9yXG4gICAgICAgICAqIEBwYXJhbSBtdWx0aXBsZSBpZiB0cnVlLCB0aGVuIHRoZSBpbWFnZSBpcyBzZWFyY2hlZCBmb3IgbXVsdGlwbGUgY29kZXMuIElmIGZhbHNlLCB0aGVuIGF0IG1vc3Qgb25lIGNvZGUgd2lsbFxuICAgICAgICAgKiBiZSBmb3VuZCBhbmQgcmV0dXJuZWRcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgUERGNDE3RGV0ZWN0b3JSZXN1bHR9IGVuY2Fwc3VsYXRpbmcgcmVzdWx0cyBvZiBkZXRlY3RpbmcgYSBQREY0MTcgY29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIG5vIFBERjQxNyBDb2RlIGNhbiBiZSBmb3VuZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRldGVjdE11bHRpcGxlKGltYWdlLCBoaW50cywgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gZGV0ZWN0aW9uIGltcHJvdmVtZW50LCB0cnlIYXJkZXIgY291bGQgdHJ5IHNldmVyYWwgZGlmZmVyZW50IGx1bWluYW5jZSB0aHJlc2hvbGRzL2JsYWNrcG9pbnRzIG9yIGV2ZW5cbiAgICAgICAgICAgIC8vIGRpZmZlcmVudCBiaW5hcml6ZXJzXG4gICAgICAgICAgICAvLyBib29sZWFuIHRyeUhhcmRlciA9IGhpbnRzICE9IG51bGwgJiYgaGludHMuY29udGFpbnNLZXkoRGVjb2RlSGludFR5cGUuVFJZX0hBUkRFUik7XG4gICAgICAgICAgICBsZXQgYml0TWF0cml4ID0gaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKTtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlQ29vcmRpbmF0ZXMgPSBEZXRlY3RvciQzLmRldGVjdChtdWx0aXBsZSwgYml0TWF0cml4KTtcbiAgICAgICAgICAgIGlmICghYmFyY29kZUNvb3JkaW5hdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJpdE1hdHJpeCA9IGJpdE1hdHJpeC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5yb3RhdGUxODAoKTtcbiAgICAgICAgICAgICAgICBiYXJjb2RlQ29vcmRpbmF0ZXMgPSBEZXRlY3RvciQzLmRldGVjdChtdWx0aXBsZSwgYml0TWF0cml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUERGNDE3RGV0ZWN0b3JSZXN1bHQoYml0TWF0cml4LCBiYXJjb2RlQ29vcmRpbmF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlY3RzIFBERjQxNyBjb2RlcyBpbiBhbiBpbWFnZS4gT25seSBjaGVja3MgMCBkZWdyZWUgcm90YXRpb25cbiAgICAgICAgICogQHBhcmFtIG11bHRpcGxlIGlmIHRydWUsIHRoZW4gdGhlIGltYWdlIGlzIHNlYXJjaGVkIGZvciBtdWx0aXBsZSBjb2Rlcy4gSWYgZmFsc2UsIHRoZW4gYXQgbW9zdCBvbmUgY29kZSB3aWxsXG4gICAgICAgICAqIGJlIGZvdW5kIGFuZCByZXR1cm5lZFxuICAgICAgICAgKiBAcGFyYW0gYml0TWF0cml4IGJpdCBtYXRyaXggdG8gZGV0ZWN0IGJhcmNvZGVzIGluXG4gICAgICAgICAqIEByZXR1cm4gTGlzdCBvZiBSZXN1bHRQb2ludCBhcnJheXMgY29udGFpbmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgZm91bmQgYmFyY29kZXNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZXRlY3QobXVsdGlwbGUsIGJpdE1hdHJpeCkge1xuICAgICAgICAgICAgY29uc3QgYmFyY29kZUNvb3JkaW5hdGVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICBsZXQgcm93ID0gMDtcbiAgICAgICAgICAgIGxldCBjb2x1bW4gPSAwO1xuICAgICAgICAgICAgbGV0IGZvdW5kQmFyY29kZUluUm93ID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAocm93IDwgYml0TWF0cml4LmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVydGljZXMgPSBEZXRlY3RvciQzLmZpbmRWZXJ0aWNlcyhiaXRNYXRyaXgsIHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAodmVydGljZXNbMF0gPT0gbnVsbCAmJiB2ZXJ0aWNlc1szXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRCYXJjb2RlSW5Sb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRpZG4ndCBmaW5kIGFueSBiYXJjb2RlIHNvIHRoYXQncyB0aGUgZW5kIG9mIHNlYXJjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZGlkbid0IGZpbmQgYSBiYXJjb2RlIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBjb2x1bW4gYW5kIHJvdy4gVHJ5IGFnYWluIGZyb20gdGhlIGZpcnN0IGNvbHVtbiBhbmQgc2xpZ2h0bHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVsb3cgdGhlIGxvd2VzdCBiYXJjb2RlIHdlIGZvdW5kIHNvIGZhci5cbiAgICAgICAgICAgICAgICAgICAgZm91bmRCYXJjb2RlSW5Sb3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXJjb2RlQ29vcmRpbmF0ZSBvZiBiYXJjb2RlQ29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXJjb2RlQ29vcmRpbmF0ZVsxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gTWF0aC50cnVuYyhNYXRoLm1heChyb3csIGJhcmNvZGVDb29yZGluYXRlWzFdLmdldFkoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhcmNvZGVDb29yZGluYXRlWzNdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBNYXRoLm1heChyb3csIE1hdGgudHJ1bmMoYmFyY29kZUNvb3JkaW5hdGVbM10uZ2V0WSgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm93ICs9IERldGVjdG9yJDMuUk9XX1NURVA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3VuZEJhcmNvZGVJblJvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYmFyY29kZUNvb3JkaW5hdGVzLnB1c2godmVydGljZXMpO1xuICAgICAgICAgICAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgcmlnaHQgcm93IGluZGljYXRvciBjb2x1bW4sIHRoZW4gY29udGludWUgdGhlIHNlYXJjaCBmb3IgdGhlIG5leHQgYmFyY29kZSBhZnRlciB0aGVcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBwYXR0ZXJuIG9mIHRoZSBiYXJjb2RlIGp1c3QgZm91bmQuXG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2VzWzJdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gTWF0aC50cnVuYyh2ZXJ0aWNlc1syXS5nZXRYKCkpO1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBNYXRoLnRydW5jKHZlcnRpY2VzWzJdLmdldFkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBNYXRoLnRydW5jKHZlcnRpY2VzWzRdLmdldFgoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IE1hdGgudHJ1bmModmVydGljZXNbNF0uZ2V0WSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFyY29kZUNvb3JkaW5hdGVzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2NhdGUgdGhlIHZlcnRpY2VzIGFuZCB0aGUgY29kZXdvcmRzIGFyZWEgb2YgYSBibGFjayBibG9iIHVzaW5nIHRoZSBTdGFydFxuICAgICAgICAgKiBhbmQgU3RvcCBwYXR0ZXJucyBhcyBsb2NhdG9ycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1hdHJpeCB0aGUgc2Nhbm5lZCBiYXJjb2RlIGltYWdlLlxuICAgICAgICAgKiBAcmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZlcnRpY2VzOlxuICAgICAgICAgKiAgICAgICAgICAgdmVydGljZXNbMF0geCwgeSB0b3AgbGVmdCBiYXJjb2RlXG4gICAgICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1sxXSB4LCB5IGJvdHRvbSBsZWZ0IGJhcmNvZGVcbiAgICAgICAgICogICAgICAgICAgIHZlcnRpY2VzWzJdIHgsIHkgdG9wIHJpZ2h0IGJhcmNvZGVcbiAgICAgICAgICogICAgICAgICAgIHZlcnRpY2VzWzNdIHgsIHkgYm90dG9tIHJpZ2h0IGJhcmNvZGVcbiAgICAgICAgICogICAgICAgICAgIHZlcnRpY2VzWzRdIHgsIHkgdG9wIGxlZnQgY29kZXdvcmQgYXJlYVxuICAgICAgICAgKiAgICAgICAgICAgdmVydGljZXNbNV0geCwgeSBib3R0b20gbGVmdCBjb2Rld29yZCBhcmVhXG4gICAgICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1s2XSB4LCB5IHRvcCByaWdodCBjb2Rld29yZCBhcmVhXG4gICAgICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1s3XSB4LCB5IGJvdHRvbSByaWdodCBjb2Rld29yZCBhcmVhXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZmluZFZlcnRpY2VzKG1hdHJpeCwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBtYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgLy8gY29uc3QgcmVzdWx0ID0gbmV3IFJlc3VsdFBvaW50WzhdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KDgpO1xuICAgICAgICAgICAgRGV0ZWN0b3IkMy5jb3B5VG9SZXN1bHQocmVzdWx0LCBEZXRlY3RvciQzLmZpbmRSb3dzV2l0aFBhdHRlcm4obWF0cml4LCBoZWlnaHQsIHdpZHRoLCBzdGFydFJvdywgc3RhcnRDb2x1bW4sIERldGVjdG9yJDMuU1RBUlRfUEFUVEVSTiksIERldGVjdG9yJDMuSU5ERVhFU19TVEFSVF9QQVRURVJOKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbNF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gTWF0aC50cnVuYyhyZXN1bHRbNF0uZ2V0WCgpKTtcbiAgICAgICAgICAgICAgICBzdGFydFJvdyA9IE1hdGgudHJ1bmMocmVzdWx0WzRdLmdldFkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBEZXRlY3RvciQzLmNvcHlUb1Jlc3VsdChyZXN1bHQsIERldGVjdG9yJDMuZmluZFJvd3NXaXRoUGF0dGVybihtYXRyaXgsIGhlaWdodCwgd2lkdGgsIHN0YXJ0Um93LCBzdGFydENvbHVtbiwgRGV0ZWN0b3IkMy5TVE9QX1BBVFRFUk4pLCBEZXRlY3RvciQzLklOREVYRVNfU1RPUF9QQVRURVJOKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNvcHlUb1Jlc3VsdChyZXN1bHQsIHRtcFJlc3VsdCwgZGVzdGluYXRpb25JbmRleGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc3RpbmF0aW9uSW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtkZXN0aW5hdGlvbkluZGV4ZXNbaV1dID0gdG1wUmVzdWx0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmaW5kUm93c1dpdGhQYXR0ZXJuKG1hdHJpeCwgaGVpZ2h0LCB3aWR0aCwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uLCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAvLyBjb25zdCByZXN1bHQgPSBuZXcgUmVzdWx0UG9pbnRbNF07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXJzID0gbmV3IEludDMyQXJyYXkocGF0dGVybi5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICg7IHN0YXJ0Um93IDwgaGVpZ2h0OyBzdGFydFJvdyArPSBEZXRlY3RvciQzLlJPV19TVEVQKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxvYyA9IERldGVjdG9yJDMuZmluZEd1YXJkUGF0dGVybihtYXRyaXgsIHN0YXJ0Q29sdW1uLCBzdGFydFJvdywgd2lkdGgsIGZhbHNlLCBwYXR0ZXJuLCBjb3VudGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKGxvYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFydFJvdyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUm93TG9jID0gRGV0ZWN0b3IkMy5maW5kR3VhcmRQYXR0ZXJuKG1hdHJpeCwgc3RhcnRDb2x1bW4sIC0tc3RhcnRSb3csIHdpZHRoLCBmYWxzZSwgcGF0dGVybiwgY291bnRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzUm93TG9jICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2MgPSBwcmV2aW91c1Jvd0xvYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Um93Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WzBdID0gbmV3IFJlc3VsdFBvaW50KGxvY1swXSwgc3RhcnRSb3cpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbMV0gPSBuZXcgUmVzdWx0UG9pbnQobG9jWzFdLCBzdGFydFJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0b3BSb3cgPSBzdGFydFJvdyArIDE7XG4gICAgICAgICAgICAvLyBMYXN0IHJvdyBvZiB0aGUgY3VycmVudCBzeW1ib2wgdGhhdCBjb250YWlucyBwYXR0ZXJuXG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2tpcHBlZFJvd0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXNSb3dMb2MgPSBJbnQzMkFycmF5LmZyb20oW01hdGgudHJ1bmMocmVzdWx0WzBdLmdldFgoKSksIE1hdGgudHJ1bmMocmVzdWx0WzFdLmdldFgoKSldKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgc3RvcFJvdyA8IGhlaWdodDsgc3RvcFJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYyA9IERldGVjdG9yJDMuZmluZEd1YXJkUGF0dGVybihtYXRyaXgsIHByZXZpb3VzUm93TG9jWzBdLCBzdG9wUm93LCB3aWR0aCwgZmFsc2UsIHBhdHRlcm4sIGNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBmb3VuZCBwYXR0ZXJuIGlzIG9ubHkgY29uc2lkZXJlZCB0byBiZWxvbmcgdG8gdGhlIHNhbWUgYmFyY29kZSBpZiB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgZGlmZmVyIHRvbyBtdWNoLiBQYXR0ZXJuIGRyaWZ0IHNob3VsZCBiZSBub3QgYmlnZ2VyIHRoYW4gdHdvIGZvciBjb25zZWN1dGl2ZSByb3dzLiBXaXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgaGlnaGVyIG51bWJlciBvZiBza2lwcGVkIHJvd3MgZHJpZnQgY291bGQgYmUgbGFyZ2VyLiBUbyBrZWVwIGl0IHNpbXBsZSBmb3Igbm93LCB3ZSBhbGxvdyBhIHNsaWdodGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGxhcmdlciBkcmlmdCBhbmQgZG9uJ3QgY2hlY2sgZm9yIHNraXBwZWQgcm93cy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhwcmV2aW91c1Jvd0xvY1swXSAtIGxvY1swXSkgPCBEZXRlY3RvciQzLk1BWF9QQVRURVJOX0RSSUZUICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhwcmV2aW91c1Jvd0xvY1sxXSAtIGxvY1sxXSkgPCBEZXRlY3RvciQzLk1BWF9QQVRURVJOX0RSSUZUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1Jvd0xvYyA9IGxvYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRSb3dDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZFJvd0NvdW50ID4gRGV0ZWN0b3IkMy5TS0lQUEVEX1JPV19DT1VOVF9NQVgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRSb3dDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0b3BSb3cgLT0gc2tpcHBlZFJvd0NvdW50ICsgMTtcbiAgICAgICAgICAgICAgICByZXN1bHRbMl0gPSBuZXcgUmVzdWx0UG9pbnQocHJldmlvdXNSb3dMb2NbMF0sIHN0b3BSb3cpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFszXSA9IG5ldyBSZXN1bHRQb2ludChwcmV2aW91c1Jvd0xvY1sxXSwgc3RvcFJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RvcFJvdyAtIHN0YXJ0Um93IDwgRGV0ZWN0b3IkMy5CQVJDT0RFX01JTl9IRUlHSFQpIHtcbiAgICAgICAgICAgICAgICBBcnJheXMuZmlsbChyZXN1bHQsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG1hdHJpeCByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gY29sdW1uIHggcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSByb3cgeSBwb3NpdGlvbiB0byBzdGFydCBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIHdpZHRoIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRvIHNlYXJjaCBvbiB0aGlzIHJvd1xuICAgICAgICAgKiBAcGFyYW0gcGF0dGVybiBwYXR0ZXJuIG9mIGNvdW50cyBvZiBudW1iZXIgb2YgYmxhY2sgYW5kIHdoaXRlIHBpeGVscyB0aGF0IGFyZVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgYmVpbmcgc2VhcmNoZWQgZm9yIGFzIGEgcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0gY291bnRlcnMgYXJyYXkgb2YgY291bnRlcnMsIGFzIGxvbmcgYXMgcGF0dGVybiwgdG8gcmUtdXNlXG4gICAgICAgICAqIEByZXR1cm4gc3RhcnQvZW5kIGhvcml6b250YWwgb2Zmc2V0IG9mIGd1YXJkIHBhdHRlcm4sIGFzIGFuIGFycmF5IG9mIHR3byBpbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZpbmRHdWFyZFBhdHRlcm4obWF0cml4LCBjb2x1bW4sIHJvdywgd2lkdGgsIHdoaXRlRmlyc3QsIHBhdHRlcm4sIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICBBcnJheXMuZmlsbFdpdGhpbihjb3VudGVycywgMCwgY291bnRlcnMubGVuZ3RoLCAwKTtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSBjb2x1bW47XG4gICAgICAgICAgICBsZXQgcGl4ZWxEcmlmdCA9IDA7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgYmxhY2sgcGl4ZWxzIGxlZnQgb2YgdGhlIGN1cnJlbnQgcGl4ZWwgc2hpZnQgdG8gdGhlIGxlZnQsIGJ1dCBvbmx5IGZvciBNQVhfUElYRUxfRFJJRlQgcGl4ZWxzXG4gICAgICAgICAgICB3aGlsZSAobWF0cml4LmdldChwYXR0ZXJuU3RhcnQsIHJvdykgJiYgcGF0dGVyblN0YXJ0ID4gMCAmJiBwaXhlbERyaWZ0KysgPCBEZXRlY3RvciQzLk1BWF9QSVhFTF9EUklGVCkge1xuICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHggPSBwYXR0ZXJuU3RhcnQ7XG4gICAgICAgICAgICBsZXQgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuTGVuZ3RoID0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpc1doaXRlID0gd2hpdGVGaXJzdDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGl4ZWwgPSBtYXRyaXguZ2V0KHgsIHJvdyk7XG4gICAgICAgICAgICAgICAgaWYgKHBpeGVsICE9PSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IHBhdHRlcm5MZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRGV0ZWN0b3IkMy5wYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgcGF0dGVybiwgRGV0ZWN0b3IkMy5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSkgPCBEZXRlY3RvciQzLk1BWF9BVkdfVkFSSUFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoW3BhdHRlcm5TdGFydCwgeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJzWzBdICsgY291bnRlcnNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvdW50ZXJzLCAyLCBjb3VudGVycywgMCwgY291bnRlclBvc2l0aW9uIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSBwYXR0ZXJuTGVuZ3RoIC0gMSAmJlxuICAgICAgICAgICAgICAgIERldGVjdG9yJDMucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIERldGVjdG9yJDMuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpIDwgRGV0ZWN0b3IkMy5NQVhfQVZHX1ZBUklBTkNFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KFtwYXR0ZXJuU3RhcnQsIHggLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBob3cgY2xvc2VseSBhIHNldCBvZiBvYnNlcnZlZCBjb3VudHMgb2YgcnVucyBvZiBibGFjay93aGl0ZVxuICAgICAgICAgKiB2YWx1ZXMgbWF0Y2hlcyBhIGdpdmVuIHRhcmdldCBwYXR0ZXJuLiBUaGlzIGlzIHJlcG9ydGVkIGFzIHRoZSByYXRpbyBvZlxuICAgICAgICAgKiB0aGUgdG90YWwgdmFyaWFuY2UgZnJvbSB0aGUgZXhwZWN0ZWQgcGF0dGVybiBwcm9wb3J0aW9ucyBhY3Jvc3MgYWxsXG4gICAgICAgICAqIHBhdHRlcm4gZWxlbWVudHMsIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBhdHRlcm4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb3VudGVycyBvYnNlcnZlZCBjb3VudGVyc1xuICAgICAgICAgKiBAcGFyYW0gcGF0dGVybiBleHBlY3RlZCBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBtYXhJbmRpdmlkdWFsVmFyaWFuY2UgVGhlIG1vc3QgYW55IGNvdW50ZXIgY2FuIGRpZmZlciBiZWZvcmUgd2UgZ2l2ZSB1cFxuICAgICAgICAgKiBAcmV0dXJuIHJhdGlvIG9mIHRvdGFsIHZhcmlhbmNlIGJldHdlZW4gY291bnRlcnMgYW5kIHBhdHRlcm4gY29tcGFyZWQgdG8gdG90YWwgcGF0dGVybiBzaXplXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIG1heEluZGl2aWR1YWxWYXJpYW5jZSkge1xuICAgICAgICAgICAgbGV0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgIHBhdHRlcm5MZW5ndGggKz0gcGF0dGVybltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3RhbCA8IHBhdHRlcm5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBldmVuIGhhdmUgb25lIHBpeGVsIHBlciB1bml0IG9mIGJhciB3aWR0aCwgYXNzdW1lIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBpcyB0b28gc21hbGwgdG8gcmVsaWFibHkgbWF0Y2gsIHNvIGZhaWw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIC8qRmxvYXQuUE9TSVRJVkVfSU5GSU5JVFkqLyBJbmZpbml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGZha2UgZmxvYXRpbmctcG9pbnQgbWF0aCBpbiBpbnRlZ2Vycy4gV2UganVzdCBuZWVkIHRvIHVzZSBtb3JlIGJpdHMuXG4gICAgICAgICAgICAvLyBTY2FsZSB1cCBwYXR0ZXJuTGVuZ3RoIHNvIHRoYXQgaW50ZXJtZWRpYXRlIHZhbHVlcyBiZWxvdyBsaWtlIHNjYWxlZENvdW50ZXIgd2lsbCBoYXZlXG4gICAgICAgICAgICAvLyBtb3JlIFwic2lnbmlmaWNhbnQgZGlnaXRzXCIuXG4gICAgICAgICAgICBsZXQgdW5pdEJhcldpZHRoID0gdG90YWwgLyBwYXR0ZXJuTGVuZ3RoO1xuICAgICAgICAgICAgbWF4SW5kaXZpZHVhbFZhcmlhbmNlICo9IHVuaXRCYXJXaWR0aDtcbiAgICAgICAgICAgIGxldCB0b3RhbFZhcmlhbmNlID0gMC4wO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBudW1Db3VudGVyczsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50ZXIgPSBjb3VudGVyc1t4XTtcbiAgICAgICAgICAgICAgICBsZXQgc2NhbGVkUGF0dGVybiA9IHBhdHRlcm5beF0gKiB1bml0QmFyV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IHZhcmlhbmNlID0gY291bnRlciA+IHNjYWxlZFBhdHRlcm4gPyBjb3VudGVyIC0gc2NhbGVkUGF0dGVybiA6IHNjYWxlZFBhdHRlcm4gLSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYW5jZSA+IG1heEluZGl2aWR1YWxWYXJpYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLypGbG9hdC5QT1NJVElWRV9JTkZJTklUWSovIEluZmluaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3RhbFZhcmlhbmNlICs9IHZhcmlhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsVmFyaWFuY2UgLyB0b3RhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEZXRlY3RvciQzLklOREVYRVNfU1RBUlRfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbMCwgNCwgMSwgNV0pO1xuICAgIERldGVjdG9yJDMuSU5ERVhFU19TVE9QX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzYsIDIsIDcsIDNdKTtcbiAgICBEZXRlY3RvciQzLk1BWF9BVkdfVkFSSUFOQ0UgPSAwLjQyO1xuICAgIERldGVjdG9yJDMuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UgPSAwLjg7XG4gICAgLy8gQiBTIEIgUyBCIFMgQiBTIEJhci9TcGFjZSBwYXR0ZXJuXG4gICAgLy8gMTExMTExMTEgMCAxIDAgMSAwIDEgMDAwXG4gICAgRGV0ZWN0b3IkMy5TVEFSVF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFs4LCAxLCAxLCAxLCAxLCAxLCAxLCAzXSk7XG4gICAgLy8gMTExMTExMSAwIDEgMDAwIDEgMCAxIDAwIDFcbiAgICBEZXRlY3RvciQzLlNUT1BfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbNywgMSwgMSwgMywgMSwgMSwgMSwgMiwgMV0pO1xuICAgIERldGVjdG9yJDMuTUFYX1BJWEVMX0RSSUZUID0gMztcbiAgICBEZXRlY3RvciQzLk1BWF9QQVRURVJOX0RSSUZUID0gNTtcbiAgICAvLyBpZiB3ZSBzZXQgdGhlIHZhbHVlIHRvbyBsb3csIHRoZW4gd2UgZG9uJ3QgZGV0ZWN0IHRoZSBjb3JyZWN0IGhlaWdodCBvZiB0aGUgYmFyIGlmIHRoZSBzdGFydCBwYXR0ZXJucyBhcmUgZGFtYWdlZC5cbiAgICAvLyBpZiB3ZSBzZXQgdGhlIHZhbHVlIHRvbyBoaWdoLCB0aGVuIHdlIG1pZ2h0IGRldGVjdCB0aGUgc3RhcnQgcGF0dGVybiBmcm9tIGEgbmVpZ2hib3IgYmFyY29kZS5cbiAgICBEZXRlY3RvciQzLlNLSVBQRURfUk9XX0NPVU5UX01BWCA9IDI1O1xuICAgIC8vIEEgUERGNDcxIGJhcmNvZGUgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMyByb3dzLCB3aXRoIGVhY2ggcm93IGJlaW5nID49IDMgdGltZXMgdGhlIG1vZHVsZSB3aWR0aC4gVGhlcmVmb3JlIGl0IHNob3VsZCBiZSBhdCBsZWFzdFxuICAgIC8vIDkgcGl4ZWxzIHRhbGwuIFRvIGJlIGNvbnNlcnZhdGl2ZSwgd2UgdXNlIGFib3V0IGhhbGYgdGhlIHNpemUgdG8gZW5zdXJlIHdlIGRvbid0IG1pc3MgaXQuXG4gICAgRGV0ZWN0b3IkMy5ST1dfU1RFUCA9IDU7XG4gICAgRGV0ZWN0b3IkMy5CQVJDT0RFX01JTl9IRUlHSFQgPSAxMDtcblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAxMiBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICogQHNlZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5yZWVkc29sb21vbi5HZW5lcmljR0ZQb2x5XG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIE1vZHVsdXNQb2x5IHtcbiAgICAgICAgY29uc3RydWN0b3IoZmllbGQsIGNvZWZmaWNpZW50cykge1xuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgICAgICBsZXQgY29lZmZpY2llbnRzTGVuZ3RoID0gLyppbnQqLyBjb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50c0xlbmd0aCA+IDEgJiYgY29lZmZpY2llbnRzWzBdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyB0ZXJtIG11c3QgYmUgbm9uLXplcm8gZm9yIGFueXRoaW5nIGV4Y2VwdCB0aGUgY29uc3RhbnQgcG9seW5vbWlhbCBcIjBcIlxuICAgICAgICAgICAgICAgIGxldCBmaXJzdE5vblplcm8gPSAvKmludCovIDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGZpcnN0Tm9uWmVybyA8IGNvZWZmaWNpZW50c0xlbmd0aCAmJiBjb2VmZmljaWVudHNbZmlyc3ROb25aZXJvXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9uWmVybyA9PT0gY29lZmZpY2llbnRzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoY29lZmZpY2llbnRzTGVuZ3RoIC0gZmlyc3ROb25aZXJvKTtcbiAgICAgICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShjb2VmZmljaWVudHMsIGZpcnN0Tm9uWmVybywgdGhpcy5jb2VmZmljaWVudHMsIDAsIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmZmljaWVudHMgPSBjb2VmZmljaWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q29lZmZpY2llbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGRlZ3JlZSBvZiB0aGlzIHBvbHlub21pYWxcbiAgICAgICAgICovXG4gICAgICAgIGdldERlZ3JlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWZmIHRoaXMgcG9seW5vbWlhbCBpcyB0aGUgbW9ub21pYWwgXCIwXCJcbiAgICAgICAgICovXG4gICAgICAgIGlzWmVybygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50c1swXSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBjb2VmZmljaWVudCBvZiB4XmRlZ3JlZSB0ZXJtIGluIHRoaXMgcG9seW5vbWlhbFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29lZmZpY2llbnQoZGVncmVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHNbdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoIC0gMSAtIGRlZ3JlZV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gZXZhbHVhdGlvbiBvZiB0aGlzIHBvbHlub21pYWwgYXQgYSBnaXZlbiBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgZXZhbHVhdGVBdChhKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSB4XjAgY29lZmZpY2llbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2VmZmljaWVudCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSnVzdCB0aGUgc3VtIG9mIHRoZSBjb2VmZmljaWVudHNcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gLyppbnQqLyAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZWZmaWNpZW50IC8qaW50Ki8gb2YgdGhpcy5jb2VmZmljaWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gdGhpcy5maWVsZC5hZGQoc3VtLCBjb2VmZmljaWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gLyppbnQqLyB0aGlzLmNvZWZmaWNpZW50c1swXTtcbiAgICAgICAgICAgIGxldCBzaXplID0gLyppbnQqLyB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAxOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWVsZC5hZGQodGhpcy5maWVsZC5tdWx0aXBseShhLCByZXN1bHQpLCB0aGlzLmNvZWZmaWNpZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdNb2R1bHVzUG9seXMgZG8gbm90IGhhdmUgc2FtZSBNb2R1bHVzR0YgZmllbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc21hbGxlckNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgbGV0IGxhcmdlckNvZWZmaWNpZW50cyA9IG90aGVyLmNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIGlmIChzbWFsbGVyQ29lZmZpY2llbnRzLmxlbmd0aCA+IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IHNtYWxsZXJDb2VmZmljaWVudHM7XG4gICAgICAgICAgICAgICAgc21hbGxlckNvZWZmaWNpZW50cyA9IGxhcmdlckNvZWZmaWNpZW50cztcbiAgICAgICAgICAgICAgICBsYXJnZXJDb2VmZmljaWVudHMgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN1bURpZmYgPSBuZXcgSW50MzJBcnJheShsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBsZW5ndGhEaWZmID0gLyppbnQqLyBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoIC0gc21hbGxlckNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBDb3B5IGhpZ2gtb3JkZXIgdGVybXMgb25seSBmb3VuZCBpbiBoaWdoZXItZGVncmVlIHBvbHlub21pYWwncyBjb2VmZmljaWVudHNcbiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkobGFyZ2VyQ29lZmZpY2llbnRzLCAwLCBzdW1EaWZmLCAwLCBsZW5ndGhEaWZmKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IGxlbmd0aERpZmY7IGkgPCBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW1EaWZmW2ldID0gdGhpcy5maWVsZC5hZGQoc21hbGxlckNvZWZmaWNpZW50c1tpIC0gbGVuZ3RoRGlmZl0sIGxhcmdlckNvZWZmaWNpZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIHN1bURpZmYpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ01vZHVsdXNQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIE1vZHVsdXNHRiBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRpdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkob3RoZXIpIHtcbiAgICAgICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIE1vZHVsdXNQb2x5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlPdGhlcihvdGhlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcihvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHlPdGhlcihvdGhlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdNb2R1bHVzUG9seXMgZG8gbm90IGhhdmUgc2FtZSBNb2R1bHVzR0YgZmllbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzWmVybygpIHx8IG90aGVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuZmllbGQuZ2V0WmVybygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgbmV3IEludDMyQXJyYXkoWzBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYUNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgbGV0IGFMZW5ndGggPSAvKmludCovIGFDb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGJDb2VmZmljaWVudHMgPSBvdGhlci5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBsZXQgYkxlbmd0aCA9IC8qaW50Ki8gYkNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KGFMZW5ndGggKyBiTGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgYUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFDb2VmZiA9IC8qaW50Ki8gYUNvZWZmaWNpZW50c1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqIC8qaW50Ki8gPSAwOyBqIDwgYkxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RbaSArIGpdID0gdGhpcy5maWVsZC5hZGQocHJvZHVjdFtpICsgal0sIHRoaXMuZmllbGQubXVsdGlwbHkoYUNvZWZmLCBiQ29lZmZpY2llbnRzW2pdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBwcm9kdWN0KTtcbiAgICAgICAgfVxuICAgICAgICBuZWdhdGl2ZSgpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gLyppbnQqLyB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbmVnYXRpdmVDb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZUNvZWZmaWNpZW50c1tpXSA9IHRoaXMuZmllbGQuc3VidHJhY3QoMCwgdGhpcy5jb2VmZmljaWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBuZWdhdGl2ZUNvZWZmaWNpZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHlTY2FsYXIoc2NhbGFyKSB7XG4gICAgICAgICAgICBpZiAoc2NhbGFyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBuZXcgSW50MzJBcnJheShbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2FsYXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaXplID0gLyppbnQqLyB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb2R1Y3RbaV0gPSB0aGlzLmZpZWxkLm11bHRpcGx5KHRoaXMuY29lZmZpY2llbnRzW2ldLCBzY2FsYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBwcm9kdWN0KTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseUJ5TW9ub21pYWwoZGVncmVlLCBjb2VmZmljaWVudCkge1xuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIG5ldyBJbnQzMkFycmF5KFswXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNpemUgPSAvKmludCovIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBwcm9kdWN0ID0gbmV3IEludDMyQXJyYXkoc2l6ZSArIGRlZ3JlZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvZHVjdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkodGhpcy5jb2VmZmljaWVudHNbaV0sIGNvZWZmaWNpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgcHJvZHVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgTW9kdWx1c1BvbHlbXSBkaXZpZGUob3RoZXI6IE1vZHVsdXNQb2x5KSB7XG4gICAgICAgICAgaWYgKCFmaWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiTW9kdWx1c1BvbHlzIGRvIG5vdCBoYXZlIHNhbWUgTW9kdWx1c0dGIGZpZWxkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3RoZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJEaXZpZGUgYnkgMFwiKTtcbiAgICAgICAgICB9XG4gICAgICBcbiAgICAgICAgICBsZXQgcXVvdGllbnQ6IE1vZHVsdXNQb2x5ID0gZmllbGQuZ2V0WmVybygpO1xuICAgICAgICAgIGxldCByZW1haW5kZXI6IE1vZHVsdXNQb2x5ID0gdGhpcztcbiAgICAgIFxuICAgICAgICAgIGxldCBkZW5vbWluYXRvckxlYWRpbmdUZXJtOiAvKmludC8gbnVtYmVyID0gb3RoZXIuZ2V0Q29lZmZpY2llbnQob3RoZXIuZ2V0RGVncmVlKCkpO1xuICAgICAgICAgIGxldCBpbnZlcnNlRGVub21pbmF0b3JMZWFkaW5nVGVybTogLyppbnQvIG51bWJlciA9IGZpZWxkLmludmVyc2UoZGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICBcbiAgICAgICAgICB3aGlsZSAocmVtYWluZGVyLmdldERlZ3JlZSgpID49IG90aGVyLmdldERlZ3JlZSgpICYmICFyZW1haW5kZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIGxldCBkZWdyZWVEaWZmZXJlbmNlOiAvKmludC8gbnVtYmVyID0gcmVtYWluZGVyLmdldERlZ3JlZSgpIC0gb3RoZXIuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICBsZXQgc2NhbGU6IC8qaW50LyBudW1iZXIgPSBmaWVsZC5tdWx0aXBseShyZW1haW5kZXIuZ2V0Q29lZmZpY2llbnQocmVtYWluZGVyLmdldERlZ3JlZSgpKSwgaW52ZXJzZURlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xuICAgICAgICAgICAgbGV0IHRlcm06IE1vZHVsdXNQb2x5ID0gb3RoZXIubXVsdGlwbHlCeU1vbm9taWFsKGRlZ3JlZURpZmZlcmVuY2UsIHNjYWxlKTtcbiAgICAgICAgICAgIGxldCBpdGVyYXRpb25RdW90aWVudDogTW9kdWx1c1BvbHkgPSBmaWVsZC5idWlsZE1vbm9taWFsKGRlZ3JlZURpZmZlcmVuY2UsIHNjYWxlKTtcbiAgICAgICAgICAgIHF1b3RpZW50ID0gcXVvdGllbnQuYWRkKGl0ZXJhdGlvblF1b3RpZW50KTtcbiAgICAgICAgICAgIHJlbWFpbmRlciA9IHJlbWFpbmRlci5zdWJ0cmFjdCh0ZXJtKTtcbiAgICAgICAgICB9XG4gICAgICBcbiAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5W10geyBxdW90aWVudCwgcmVtYWluZGVyIH07XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCAvKjggKiB0aGlzLmdldERlZ3JlZSgpKi8pOyAvLyBkeW5hbWljIHN0cmluZyBzaXplIGluIEpTXG4gICAgICAgICAgICBmb3IgKGxldCBkZWdyZWUgLyppbnQqLyA9IHRoaXMuZ2V0RGVncmVlKCk7IGRlZ3JlZSA+PSAwOyBkZWdyZWUtLSkge1xuICAgICAgICAgICAgICAgIGxldCBjb2VmZmljaWVudCA9IC8qaW50Ki8gdGhpcy5nZXRDb2VmZmljaWVudChkZWdyZWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcgLSAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmaWNpZW50ID0gLWNvZWZmaWNpZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcgKyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlID09PSAwIHx8IGNvZWZmaWNpZW50ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGNvZWZmaWNpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgneCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgneF4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGRlZ3JlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBNb2R1bHVzQmFzZSB7XG4gICAgICAgIGFkZChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEgKyBiKSAlIHRoaXMubW9kdWx1cztcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubW9kdWx1cyArIGEgLSBiKSAlIHRoaXMubW9kdWx1cztcbiAgICAgICAgfVxuICAgICAgICBleHAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbYV07XG4gICAgICAgIH1cbiAgICAgICAgbG9nKGEpIHtcbiAgICAgICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9nVGFibGVbYV07XG4gICAgICAgIH1cbiAgICAgICAgaW52ZXJzZShhKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcml0aG1ldGljRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVt0aGlzLm1vZHVsdXMgLSB0aGlzLmxvZ1RhYmxlW2FdIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPT09IDAgfHwgYiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbKHRoaXMubG9nVGFibGVbYV0gKyB0aGlzLmxvZ1RhYmxlW2JdKSAlICh0aGlzLm1vZHVsdXMgLSAxKV07XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZHVsdXM7XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBvID09PSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMiBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5BIGZpZWxkIGJhc2VkIG9uIHBvd2VycyBvZiBhIGdlbmVyYXRvciBpbnRlZ2VyLCBtb2R1bG8gc29tZSBtb2R1bHVzLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICogQHNlZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5yZWVkc29sb21vbi5HZW5lcmljR0ZcbiAgICAgKi9cbiAgICAvKnB1YmxpYyBmaW5hbCovIGNsYXNzIE1vZHVsdXNHRiBleHRlbmRzIE1vZHVsdXNCYXNlIHtcbiAgICAgICAgLy8gcHJpdmF0ZSAvKmZpbmFsKi8gbW9kdWx1czogLyppbnQqLyBudW1iZXI7XG4gICAgICAgIGNvbnN0cnVjdG9yKG1vZHVsdXMsIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMubW9kdWx1cyA9IG1vZHVsdXM7XG4gICAgICAgICAgICB0aGlzLmV4cFRhYmxlID0gbmV3IEludDMyQXJyYXkobW9kdWx1cyk7XG4gICAgICAgICAgICB0aGlzLmxvZ1RhYmxlID0gbmV3IEludDMyQXJyYXkobW9kdWx1cyk7XG4gICAgICAgICAgICBsZXQgeCA9IC8qaW50Ki8gMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBtb2R1bHVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cFRhYmxlW2ldID0geDtcbiAgICAgICAgICAgICAgICB4ID0gKHggKiBnZW5lcmF0b3IpICUgbW9kdWx1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBtb2R1bHVzIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dUYWJsZVt0aGlzLmV4cFRhYmxlW2ldXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsb2dUYWJsZVswXSA9PSAwIGJ1dCB0aGlzIHNob3VsZCBuZXZlciBiZSB1c2VkXG4gICAgICAgICAgICB0aGlzLnplcm8gPSBuZXcgTW9kdWx1c1BvbHkodGhpcywgbmV3IEludDMyQXJyYXkoWzBdKSk7XG4gICAgICAgICAgICB0aGlzLm9uZSA9IG5ldyBNb2R1bHVzUG9seSh0aGlzLCBuZXcgSW50MzJBcnJheShbMV0pKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRaZXJvKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgICAgICBnZXRPbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRNb25vbWlhbChkZWdyZWUsIGNvZWZmaWNpZW50KSB7XG4gICAgICAgICAgICBpZiAoZGVncmVlIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoZGVncmVlICsgMSk7XG4gICAgICAgICAgICBjb2VmZmljaWVudHNbMF0gPSBjb2VmZmljaWVudDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcywgY29lZmZpY2llbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNb2R1bHVzR0YuUERGNDE3X0dGID0gbmV3IE1vZHVsdXNHRihQREY0MTdDb21tb24uTlVNQkVSX09GX0NPREVXT1JEUywgMyk7XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMTIgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5QREY0MTcgZXJyb3IgY29ycmVjdGlvbiBpbXBsZW1lbnRhdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGlzIDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JlZWQlRTIlODAlOTNTb2xvbW9uX2Vycm9yX2NvcnJlY3Rpb24jRXhhbXBsZVwiPmV4YW1wbGU8L2E+XG4gICAgICogaXMgcXVpdGUgdXNlZnVsIGluIHVuZGVyc3RhbmRpbmcgdGhlIGFsZ29yaXRobS48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBzZWUgY29tLmdvb2dsZS56eGluZy5jb21tb24ucmVlZHNvbG9tb24uUmVlZFNvbG9tb25EZWNvZGVyXG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBFcnJvckNvcnJlY3Rpb24ge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSBNb2R1bHVzR0YuUERGNDE3X0dGO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gcmVjZWl2ZWQgcmVjZWl2ZWQgY29kZXdvcmRzXG4gICAgICAgICAqIEBwYXJhbSBudW1FQ0NvZGV3b3JkcyBudW1iZXIgb2YgdGhvc2UgY29kZXdvcmRzIHVzZWQgZm9yIEVDXG4gICAgICAgICAqIEBwYXJhbSBlcmFzdXJlcyBsb2NhdGlvbiBvZiBlcmFzdXJlc1xuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBlcnJvcnNcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvcnMgY2Fubm90IGJlIGNvcnJlY3RlZCwgbWF5YmUgYmVjYXVzZSBvZiB0b28gbWFueSBlcnJvcnNcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZShyZWNlaXZlZCwgbnVtRUNDb2Rld29yZHMsIGVyYXN1cmVzKSB7XG4gICAgICAgICAgICBsZXQgcG9seSA9IG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCByZWNlaXZlZCk7XG4gICAgICAgICAgICBsZXQgUyA9IG5ldyBJbnQzMkFycmF5KG51bUVDQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gbnVtRUNDb2Rld29yZHM7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZXZhbHVhdGlvbiA9IHBvbHkuZXZhbHVhdGVBdCh0aGlzLmZpZWxkLmV4cChpKSk7XG4gICAgICAgICAgICAgICAgU1tudW1FQ0NvZGV3b3JkcyAtIGldID0gZXZhbHVhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGtub3duRXJyb3JzID0gdGhpcy5maWVsZC5nZXRPbmUoKTtcbiAgICAgICAgICAgIGlmIChlcmFzdXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlcmFzdXJlIG9mIGVyYXN1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiID0gdGhpcy5maWVsZC5leHAocmVjZWl2ZWQubGVuZ3RoIC0gMSAtIGVyYXN1cmUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgKDEgLSBieCkgdGVybTpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgbmV3IEludDMyQXJyYXkoW3RoaXMuZmllbGQuc3VidHJhY3QoMCwgYiksIDFdKSk7XG4gICAgICAgICAgICAgICAgICAgIGtub3duRXJyb3JzID0ga25vd25FcnJvcnMubXVsdGlwbHkodGVybSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN5bmRyb21lID0gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIFMpO1xuICAgICAgICAgICAgLy8gc3luZHJvbWUgPSBzeW5kcm9tZS5tdWx0aXBseShrbm93bkVycm9ycyk7XG4gICAgICAgICAgICBsZXQgc2lnbWFPbWVnYSA9IHRoaXMucnVuRXVjbGlkZWFuQWxnb3JpdGhtKHRoaXMuZmllbGQuYnVpbGRNb25vbWlhbChudW1FQ0NvZGV3b3JkcywgMSksIHN5bmRyb21lLCBudW1FQ0NvZGV3b3Jkcyk7XG4gICAgICAgICAgICBsZXQgc2lnbWEgPSBzaWdtYU9tZWdhWzBdO1xuICAgICAgICAgICAgbGV0IG9tZWdhID0gc2lnbWFPbWVnYVsxXTtcbiAgICAgICAgICAgIC8vIHNpZ21hID0gc2lnbWEubXVsdGlwbHkoa25vd25FcnJvcnMpO1xuICAgICAgICAgICAgbGV0IGVycm9yTG9jYXRpb25zID0gdGhpcy5maW5kRXJyb3JMb2NhdGlvbnMoc2lnbWEpO1xuICAgICAgICAgICAgbGV0IGVycm9yTWFnbml0dWRlcyA9IHRoaXMuZmluZEVycm9yTWFnbml0dWRlcyhvbWVnYSwgc2lnbWEsIGVycm9yTG9jYXRpb25zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBlcnJvckxvY2F0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHJlY2VpdmVkLmxlbmd0aCAtIDEgLSB0aGlzLmZpZWxkLmxvZyhlcnJvckxvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbi5nZXRDaGVja3N1bUluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkW3Bvc2l0aW9uXSA9IHRoaXMuZmllbGQuc3VidHJhY3QocmVjZWl2ZWRbcG9zaXRpb25dLCBlcnJvck1hZ25pdHVkZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9yTG9jYXRpb25zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIE1vZHVsdXNQb2x5XG4gICAgICAgICAqIEBwYXJhbSBhXG4gICAgICAgICAqIEBwYXJhbSBNb2R1bHVzUG9seVxuICAgICAgICAgKiBAcGFyYW0gYlxuICAgICAgICAgKiBAcGFyYW0gaW50XG4gICAgICAgICAqIEBwYXJhbSBSXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHJ1bkV1Y2xpZGVhbkFsZ29yaXRobShhLCBiLCBSKSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgYSdzIGRlZ3JlZSBpcyA+PSBiJ3NcbiAgICAgICAgICAgIGlmIChhLmdldERlZ3JlZSgpIDwgYi5nZXREZWdyZWUoKSkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gYTtcbiAgICAgICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgICAgICBiID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByTGFzdCA9IGE7XG4gICAgICAgICAgICBsZXQgciA9IGI7XG4gICAgICAgICAgICBsZXQgdExhc3QgPSB0aGlzLmZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgIGxldCB0ID0gdGhpcy5maWVsZC5nZXRPbmUoKTtcbiAgICAgICAgICAgIC8vIFJ1biBFdWNsaWRlYW4gYWxnb3JpdGhtIHVudGlsIHIncyBkZWdyZWUgaXMgbGVzcyB0aGFuIFIvMlxuICAgICAgICAgICAgd2hpbGUgKHIuZ2V0RGVncmVlKCkgPj0gTWF0aC5yb3VuZChSIC8gMikpIHtcbiAgICAgICAgICAgICAgICBsZXQgckxhc3RMYXN0ID0gckxhc3Q7XG4gICAgICAgICAgICAgICAgbGV0IHRMYXN0TGFzdCA9IHRMYXN0O1xuICAgICAgICAgICAgICAgIHJMYXN0ID0gcjtcbiAgICAgICAgICAgICAgICB0TGFzdCA9IHQ7XG4gICAgICAgICAgICAgICAgLy8gRGl2aWRlIHJMYXN0TGFzdCBieSByTGFzdCwgd2l0aCBxdW90aWVudCBpbiBxIGFuZCByZW1haW5kZXIgaW4gclxuICAgICAgICAgICAgICAgIGlmIChyTGFzdC5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPb3BzLCBFdWNsaWRlYW4gYWxnb3JpdGhtIGFscmVhZHkgdGVybWluYXRlZD9cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb24uZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByID0gckxhc3RMYXN0O1xuICAgICAgICAgICAgICAgIGxldCBxID0gdGhpcy5maWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0gPSByTGFzdC5nZXRDb2VmZmljaWVudChyTGFzdC5nZXREZWdyZWUoKSk7XG4gICAgICAgICAgICAgICAgbGV0IGRsdEludmVyc2UgPSB0aGlzLmZpZWxkLmludmVyc2UoZGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIuZ2V0RGVncmVlKCkgPj0gckxhc3QuZ2V0RGVncmVlKCkgJiYgIXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlZ3JlZURpZmYgPSByLmdldERlZ3JlZSgpIC0gckxhc3QuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzY2FsZSA9IHRoaXMuZmllbGQubXVsdGlwbHkoci5nZXRDb2VmZmljaWVudChyLmdldERlZ3JlZSgpKSwgZGx0SW52ZXJzZSk7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLmFkZCh0aGlzLmZpZWxkLmJ1aWxkTW9ub21pYWwoZGVncmVlRGlmZiwgc2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgciA9IHIuc3VidHJhY3Qockxhc3QubXVsdGlwbHlCeU1vbm9taWFsKGRlZ3JlZURpZmYsIHNjYWxlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSBxLm11bHRpcGx5KHRMYXN0KS5zdWJ0cmFjdCh0TGFzdExhc3QpLm5lZ2F0aXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2lnbWFUaWxkZUF0WmVybyA9IHQuZ2V0Q29lZmZpY2llbnQoMCk7XG4gICAgICAgICAgICBpZiAoc2lnbWFUaWxkZUF0WmVybyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uLmdldENoZWNrc3VtSW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbnZlcnNlID0gdGhpcy5maWVsZC5pbnZlcnNlKHNpZ21hVGlsZGVBdFplcm8pO1xuICAgICAgICAgICAgbGV0IHNpZ21hID0gdC5tdWx0aXBseShpbnZlcnNlKTtcbiAgICAgICAgICAgIGxldCBvbWVnYSA9IHIubXVsdGlwbHkoaW52ZXJzZSk7XG4gICAgICAgICAgICByZXR1cm4gW3NpZ21hLCBvbWVnYV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlcnJvckxvY2F0b3JcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZmluZEVycm9yTG9jYXRpb25zKGVycm9yTG9jYXRvcikge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGRpcmVjdCBhcHBsaWNhdGlvbiBvZiBDaGllbidzIHNlYXJjaFxuICAgICAgICAgICAgbGV0IG51bUVycm9ycyA9IGVycm9yTG9jYXRvci5nZXREZWdyZWUoKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgSW50MzJBcnJheShudW1FcnJvcnMpO1xuICAgICAgICAgICAgbGV0IGUgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMTsgaSA8IHRoaXMuZmllbGQuZ2V0U2l6ZSgpICYmIGUgPCBudW1FcnJvcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvckxvY2F0b3IuZXZhbHVhdGVBdChpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZV0gPSB0aGlzLmZpZWxkLmludmVyc2UoaSk7XG4gICAgICAgICAgICAgICAgICAgIGUrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSAhPT0gbnVtRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb24uZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmaW5kRXJyb3JNYWduaXR1ZGVzKGVycm9yRXZhbHVhdG9yLCBlcnJvckxvY2F0b3IsIGVycm9yTG9jYXRpb25zKSB7XG4gICAgICAgICAgICBsZXQgZXJyb3JMb2NhdG9yRGVncmVlID0gZXJyb3JMb2NhdG9yLmdldERlZ3JlZSgpO1xuICAgICAgICAgICAgbGV0IGZvcm1hbERlcml2YXRpdmVDb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShlcnJvckxvY2F0b3JEZWdyZWUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMTsgaSA8PSBlcnJvckxvY2F0b3JEZWdyZWU7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvcm1hbERlcml2YXRpdmVDb2VmZmljaWVudHNbZXJyb3JMb2NhdG9yRGVncmVlIC0gaV0gPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpZWxkLm11bHRpcGx5KGksIGVycm9yTG9jYXRvci5nZXRDb2VmZmljaWVudChpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9ybWFsRGVyaXZhdGl2ZSA9IG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBmb3JtYWxEZXJpdmF0aXZlQ29lZmZpY2llbnRzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZGlyZWN0bHkgYXBwbHlpbmcgRm9ybmV5J3MgRm9ybXVsYVxuICAgICAgICAgICAgbGV0IHMgPSBlcnJvckxvY2F0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkocyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhpSW52ZXJzZSA9IHRoaXMuZmllbGQuaW52ZXJzZShlcnJvckxvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgbGV0IG51bWVyYXRvciA9IHRoaXMuZmllbGQuc3VidHJhY3QoMCwgZXJyb3JFdmFsdWF0b3IuZXZhbHVhdGVBdCh4aUludmVyc2UpKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVub21pbmF0b3IgPSB0aGlzLmZpZWxkLmludmVyc2UoZm9ybWFsRGVyaXZhdGl2ZS5ldmFsdWF0ZUF0KHhpSW52ZXJzZSkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkobnVtZXJhdG9yLCBkZW5vbWluYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIEJvdW5kaW5nQm94IHtcbiAgICAgICAgY29uc3RydWN0b3IoaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCkge1xuICAgICAgICAgICAgaWYgKGltYWdlIGluc3RhbmNlb2YgQm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yXzIoaW1hZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvcl8xKGltYWdlLCB0b3BMZWZ0LCBib3R0b21MZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VcbiAgICAgICAgICogQHBhcmFtIHRvcExlZnRcbiAgICAgICAgICogQHBhcmFtIGJvdHRvbUxlZnRcbiAgICAgICAgICogQHBhcmFtIHRvcFJpZ2h0XG4gICAgICAgICAqIEBwYXJhbSBib3R0b21SaWdodFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcl8xKGltYWdlLCB0b3BMZWZ0LCBib3R0b21MZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRVbnNwZWNpZmllZCA9IHRvcExlZnQgPT0gbnVsbCB8fCBib3R0b21MZWZ0ID09IG51bGw7XG4gICAgICAgICAgICBjb25zdCByaWdodFVuc3BlY2lmaWVkID0gdG9wUmlnaHQgPT0gbnVsbCB8fCBib3R0b21SaWdodCA9PSBudWxsO1xuICAgICAgICAgICAgaWYgKGxlZnRVbnNwZWNpZmllZCAmJiByaWdodFVuc3BlY2lmaWVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdFVuc3BlY2lmaWVkKSB7XG4gICAgICAgICAgICAgICAgdG9wTGVmdCA9IG5ldyBSZXN1bHRQb2ludCgwLCB0b3BSaWdodC5nZXRZKCkpO1xuICAgICAgICAgICAgICAgIGJvdHRvbUxlZnQgPSBuZXcgUmVzdWx0UG9pbnQoMCwgYm90dG9tUmlnaHQuZ2V0WSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0VW5zcGVjaWZpZWQpIHtcbiAgICAgICAgICAgICAgICB0b3BSaWdodCA9IG5ldyBSZXN1bHRQb2ludChpbWFnZS5nZXRXaWR0aCgpIC0gMSwgdG9wTGVmdC5nZXRZKCkpO1xuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0ID0gbmV3IFJlc3VsdFBvaW50KGltYWdlLmdldFdpZHRoKCkgLSAxLCBib3R0b21MZWZ0LmdldFkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLnRvcExlZnQgPSB0b3BMZWZ0O1xuICAgICAgICAgICAgdGhpcy5ib3R0b21MZWZ0ID0gYm90dG9tTGVmdDtcbiAgICAgICAgICAgIHRoaXMudG9wUmlnaHQgPSB0b3BSaWdodDtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tUmlnaHQgPSBib3R0b21SaWdodDtcbiAgICAgICAgICAgIHRoaXMubWluWCA9IE1hdGgudHJ1bmMoTWF0aC5taW4odG9wTGVmdC5nZXRYKCksIGJvdHRvbUxlZnQuZ2V0WCgpKSk7XG4gICAgICAgICAgICB0aGlzLm1heFggPSBNYXRoLnRydW5jKE1hdGgubWF4KHRvcFJpZ2h0LmdldFgoKSwgYm90dG9tUmlnaHQuZ2V0WCgpKSk7XG4gICAgICAgICAgICB0aGlzLm1pblkgPSBNYXRoLnRydW5jKE1hdGgubWluKHRvcExlZnQuZ2V0WSgpLCB0b3BSaWdodC5nZXRZKCkpKTtcbiAgICAgICAgICAgIHRoaXMubWF4WSA9IE1hdGgudHJ1bmMoTWF0aC5tYXgoYm90dG9tTGVmdC5nZXRZKCksIGJvdHRvbVJpZ2h0LmdldFkoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cnVjdG9yXzIoYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBib3VuZGluZ0JveC5pbWFnZTtcbiAgICAgICAgICAgIHRoaXMudG9wTGVmdCA9IGJvdW5kaW5nQm94LmdldFRvcExlZnQoKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tTGVmdCA9IGJvdW5kaW5nQm94LmdldEJvdHRvbUxlZnQoKTtcbiAgICAgICAgICAgIHRoaXMudG9wUmlnaHQgPSBib3VuZGluZ0JveC5nZXRUb3BSaWdodCgpO1xuICAgICAgICAgICAgdGhpcy5ib3R0b21SaWdodCA9IGJvdW5kaW5nQm94LmdldEJvdHRvbVJpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLm1pblggPSBib3VuZGluZ0JveC5nZXRNaW5YKCk7XG4gICAgICAgICAgICB0aGlzLm1heFggPSBib3VuZGluZ0JveC5nZXRNYXhYKCk7XG4gICAgICAgICAgICB0aGlzLm1pblkgPSBib3VuZGluZ0JveC5nZXRNaW5ZKCk7XG4gICAgICAgICAgICB0aGlzLm1heFkgPSBib3VuZGluZ0JveC5nZXRNYXhZKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBtZXJnZShsZWZ0Qm94LCByaWdodEJveCkge1xuICAgICAgICAgICAgaWYgKGxlZnRCb3ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByaWdodEJveDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyaWdodEJveCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRCb3g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KGxlZnRCb3guaW1hZ2UsIGxlZnRCb3gudG9wTGVmdCwgbGVmdEJveC5ib3R0b21MZWZ0LCByaWdodEJveC50b3BSaWdodCwgcmlnaHRCb3guYm90dG9tUmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBhZGRNaXNzaW5nUm93cyhtaXNzaW5nU3RhcnRSb3dzLCBtaXNzaW5nRW5kUm93cywgaXNMZWZ0KSB7XG4gICAgICAgICAgICBsZXQgbmV3VG9wTGVmdCA9IHRoaXMudG9wTGVmdDtcbiAgICAgICAgICAgIGxldCBuZXdCb3R0b21MZWZ0ID0gdGhpcy5ib3R0b21MZWZ0O1xuICAgICAgICAgICAgbGV0IG5ld1RvcFJpZ2h0ID0gdGhpcy50b3BSaWdodDtcbiAgICAgICAgICAgIGxldCBuZXdCb3R0b21SaWdodCA9IHRoaXMuYm90dG9tUmlnaHQ7XG4gICAgICAgICAgICBpZiAobWlzc2luZ1N0YXJ0Um93cyA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9wID0gaXNMZWZ0ID8gdGhpcy50b3BMZWZ0IDogdGhpcy50b3BSaWdodDtcbiAgICAgICAgICAgICAgICBsZXQgbmV3TWluWSA9IE1hdGgudHJ1bmModG9wLmdldFkoKSAtIG1pc3NpbmdTdGFydFJvd3MpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdNaW5ZIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNaW5ZID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5ld1RvcCA9IG5ldyBSZXN1bHRQb2ludCh0b3AuZ2V0WCgpLCBuZXdNaW5ZKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RvcExlZnQgPSBuZXdUb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdUb3BSaWdodCA9IG5ld1RvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWlzc2luZ0VuZFJvd3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJvdHRvbSA9IGlzTGVmdCA/IHRoaXMuYm90dG9tTGVmdCA6IHRoaXMuYm90dG9tUmlnaHQ7XG4gICAgICAgICAgICAgICAgbGV0IG5ld01heFkgPSBNYXRoLnRydW5jKGJvdHRvbS5nZXRZKCkgKyBtaXNzaW5nRW5kUm93cyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld01heFkgPj0gdGhpcy5pbWFnZS5nZXRIZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXhZID0gdGhpcy5pbWFnZS5nZXRIZWlnaHQoKSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBuZXdCb3R0b20gPSBuZXcgUmVzdWx0UG9pbnQoYm90dG9tLmdldFgoKSwgbmV3TWF4WSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdCb3R0b21MZWZ0ID0gbmV3Qm90dG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Qm90dG9tUmlnaHQgPSBuZXdCb3R0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh0aGlzLmltYWdlLCBuZXdUb3BMZWZ0LCBuZXdCb3R0b21MZWZ0LCBuZXdUb3BSaWdodCwgbmV3Qm90dG9tUmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGdldE1pblgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW5YO1xuICAgICAgICB9XG4gICAgICAgIGdldE1heFgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhYO1xuICAgICAgICB9XG4gICAgICAgIGdldE1pblkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW5ZO1xuICAgICAgICB9XG4gICAgICAgIGdldE1heFkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhZO1xuICAgICAgICB9XG4gICAgICAgIGdldFRvcExlZnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3BMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGdldFRvcFJpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9wUmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qm90dG9tTGVmdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbUxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qm90dG9tUmlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3R0b21SaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5kZWNvZGVyO1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBCYXJjb2RlTWV0YWRhdGEge1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb2x1bW5Db3VudCwgcm93Q291bnRVcHBlclBhcnQsIHJvd0NvdW50TG93ZXJQYXJ0LCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5Db3VudCA9IGNvbHVtbkNvdW50O1xuICAgICAgICAgICAgdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbCA9IGVycm9yQ29ycmVjdGlvbkxldmVsO1xuICAgICAgICAgICAgdGhpcy5yb3dDb3VudFVwcGVyUGFydCA9IHJvd0NvdW50VXBwZXJQYXJ0O1xuICAgICAgICAgICAgdGhpcy5yb3dDb3VudExvd2VyUGFydCA9IHJvd0NvdW50TG93ZXJQYXJ0O1xuICAgICAgICAgICAgdGhpcy5yb3dDb3VudCA9IHJvd0NvdW50VXBwZXJQYXJ0ICsgcm93Q291bnRMb3dlclBhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q29sdW1uQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5Db3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXRFcnJvckNvcnJlY3Rpb25MZXZlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsO1xuICAgICAgICB9XG4gICAgICAgIGdldFJvd0NvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93Q291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Um93Q291bnRVcHBlclBhcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dDb3VudFVwcGVyUGFydDtcbiAgICAgICAgfVxuICAgICAgICBnZXRSb3dDb3VudExvd2VyUGFydCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0NvdW50TG93ZXJQYXJ0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSmF2YSBGb3JtYXR0ZXIgY2xhc3MgcG9seWZpbGwgdGhhdCB3b3JrcyBpbiB0aGUgSlMgd2F5LlxuICAgICAqL1xuICAgIGNsYXNzIEZvcm1hdHRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTM0Mzk3MTEvNDM2NzY4M1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3RyXG4gICAgICAgICAqIEBwYXJhbSBhcnJcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmb3JtKHN0ciwgYXJyKSB7XG4gICAgICAgICAgICBsZXQgaSA9IC0xO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZXhwLCBwMCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwID09PSAnJSUnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyUnO1xuICAgICAgICAgICAgICAgIGlmIChhcnJbKytpXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGV4cCA9IHAyID8gcGFyc2VJbnQocDIuc3Vic3RyKDEpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IHAzID8gcGFyc2VJbnQocDMuc3Vic3RyKDEpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgdmFsO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocDQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcnJbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFycltpXSkudG9GaXhlZChleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcnJbaV0pLnRvUHJlY2lzaW9uKGV4cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFycltpXSkudG9FeHBvbmVudGlhbChleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQoYXJyW2ldKS50b1N0cmluZyhiYXNlID8gYmFzZSA6IDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQocGFyc2VJbnQoYXJyW2ldLCBiYXNlID8gYmFzZSA6IDEwKS50b1ByZWNpc2lvbihleHApKS50b0ZpeGVkKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnID8gSlNPTi5zdHJpbmdpZnkodmFsKSA6ICgrdmFsKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KHAxKTsgLyogcGFkZGluZyBzaXplICovXG4gICAgICAgICAgICAgICAgbGV0IGNoID0gcDEgJiYgKHAxWzBdICsgJycpID09PSAnMCcgPyAnMCcgOiAnICc7IC8qIGlzbnVsbD8gKi9cbiAgICAgICAgICAgICAgICB3aGlsZSAodmFsLmxlbmd0aCA8IHNpemUpXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHAwICE9PSB1bmRlZmluZWQgPyB2YWwgKyBjaCA6IGNoICsgdmFsOyAvKiBpc21pbnVzPyAqL1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvJSgtKT8oMD9bMC05XSspPyhbLl1bMC05XSspPyhbI11bMC05XSspPyhbc2NmcGV4ZCVdKS9nO1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZ2V4LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhcHBlbmQgVGhlIG5ldyBzdHJpbmcgdG8gYXBwZW5kLlxuICAgICAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWV0cyB2YWx1ZXMgdG8gYmUgZm9ybWF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmb3JtYXQoYXBwZW5kLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciArPSBGb3JtYXR0ZXIuZm9ybShhcHBlbmQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBGb3JtYXR0ZXIgc3RyaW5nIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIGNsYXNzIERldGVjdGlvblJlc3VsdENvbHVtbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIC8vIHRoaXMuY29kZXdvcmRzID0gbmV3IENvZGV3b3JkW2JvdW5kaW5nQm94LmdldE1heFkoKSAtIGJvdW5kaW5nQm94LmdldE1pblkoKSArIDFdO1xuICAgICAgICAgICAgdGhpcy5jb2Rld29yZHMgPSBuZXcgQXJyYXkoYm91bmRpbmdCb3guZ2V0TWF4WSgpIC0gYm91bmRpbmdCb3guZ2V0TWluWSgpICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLypmaW5hbCovIGdldENvZGV3b3JkTmVhcmJ5KGltYWdlUm93KSB7XG4gICAgICAgICAgICBsZXQgY29kZXdvcmQgPSB0aGlzLmdldENvZGV3b3JkKGltYWdlUm93KTtcbiAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGV3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBEZXRlY3Rpb25SZXN1bHRDb2x1bW4uTUFYX05FQVJCWV9ESVNUQU5DRTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5lYXJJbWFnZVJvdyA9IHRoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoaW1hZ2VSb3cpIC0gaTtcbiAgICAgICAgICAgICAgICBpZiAobmVhckltYWdlUm93ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmQgPSB0aGlzLmNvZGV3b3Jkc1tuZWFySW1hZ2VSb3ddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGV3b3JkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5lYXJJbWFnZVJvdyA9IHRoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoaW1hZ2VSb3cpICsgaTtcbiAgICAgICAgICAgICAgICBpZiAobmVhckltYWdlUm93IDwgdGhpcy5jb2Rld29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkID0gdGhpcy5jb2Rld29yZHNbbmVhckltYWdlUm93XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2Rld29yZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qZmluYWwgaW50Ki8gaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoaW1hZ2VSb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWFnZVJvdyAtIHRoaXMuYm91bmRpbmdCb3guZ2V0TWluWSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qZmluYWwgdm9pZCovIHNldENvZGV3b3JkKGltYWdlUm93LCBjb2Rld29yZCkge1xuICAgICAgICAgICAgdGhpcy5jb2Rld29yZHNbdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChpbWFnZVJvdyldID0gY29kZXdvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgLypmaW5hbCovIGdldENvZGV3b3JkKGltYWdlUm93KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2Rld29yZHNbdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChpbWFnZVJvdyldO1xuICAgICAgICB9XG4gICAgICAgIC8qZmluYWwqLyBnZXRCb3VuZGluZ0JveCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nQm94O1xuICAgICAgICB9XG4gICAgICAgIC8qZmluYWwqLyBnZXRDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcigpO1xuICAgICAgICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvZGV3b3JkIG9mIHRoaXMuY29kZXdvcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnJTNkOiAgICB8ICAgJW4nLCByb3crKyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCclM2Q6ICUzZHwlM2QlbicsIHJvdysrLCBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSwgY29kZXdvcmQuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uLk1BWF9ORUFSQllfRElTVEFOQ0UgPSA1O1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkNvbGxlY3Rpb247XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5IYXNoTWFwO1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTWFwO1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTWFwLkVudHJ5O1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBCYXJjb2RlVmFsdWUge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYW4gb2NjdXJyZW5jZSBvZiBhIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnRydW5jKHZhbHVlKTtcbiAgICAgICAgICAgIGxldCBjb25maWRlbmNlID0gdGhpcy52YWx1ZXMuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb25maWRlbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWRlbmNlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZGVuY2UrKztcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnNldCh2YWx1ZSwgY29uZmlkZW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgdGhlIG1heGltdW0gb2NjdXJyZW5jZSBvZiBhIHNldCB2YWx1ZSBhbmQgcmV0dXJucyBhbGwgdmFsdWVzIHdoaWNoIHdlcmUgc2V0IHdpdGggdGhpcyBvY2N1cnJlbmNlLlxuICAgICAgICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGludCwgY29udGFpbmluZyB0aGUgdmFsdWVzIHdpdGggdGhlIGhpZ2hlc3Qgb2NjdXJyZW5jZSwgb3IgbnVsbCwgaWYgbm8gdmFsdWUgd2FzIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICBsZXQgbWF4Q29uZmlkZW5jZSA9IC0xO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy52YWx1ZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgIGdldEtleTogKCkgPT4ga2V5LFxuICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZTogKCkgPT4gdmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuZ2V0VmFsdWUoKSA+IG1heENvbmZpZGVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4Q29uZmlkZW5jZSA9IGVudHJ5LmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeS5nZXRLZXkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVudHJ5LmdldFZhbHVlKCkgPT09IG1heENvbmZpZGVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkuZ2V0S2V5KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQREY0MTdDb21tb24udG9JbnRBcnJheShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGdldENvbmZpZGVuY2UodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5nZXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uIGV4dGVuZHMgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uIHtcbiAgICAgICAgY29uc3RydWN0b3IoYm91bmRpbmdCb3gsIGlzTGVmdCkge1xuICAgICAgICAgICAgc3VwZXIoYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgdGhpcy5faXNMZWZ0ID0gaXNMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHNldFJvd051bWJlcnMoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZCAvKkNvZGV3b3JkKi8gb2YgdGhpcy5nZXRDb2Rld29yZHMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlckFzUm93SW5kaWNhdG9yQ29sdW1uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IHByb3Blcmx5XG4gICAgICAgIC8vIFRPRE8gbWF5YmUgd2Ugc2hvdWxkIGFkZCBtaXNzaW5nIGNvZGV3b3JkcyB0byBzdG9yZSB0aGUgY29ycmVjdCByb3cgbnVtYmVyIHRvIG1ha2VcbiAgICAgICAgLy8gZmluZGluZyByb3cgbnVtYmVycyBmb3Igb3RoZXIgY29sdW1ucyBlYXNpZXJcbiAgICAgICAgLy8gdXNlIHJvdyBoZWlnaHQgY291bnQgdG8gbWFrZSBkZXRlY3Rpb24gb2YgaW52YWxpZCByb3cgbnVtYmVycyBtb3JlIHJlbGlhYmxlXG4gICAgICAgIGFkanVzdENvbXBsZXRlSW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyhiYXJjb2RlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZHMgPSB0aGlzLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRSb3dOdW1iZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUluY29ycmVjdENvZGV3b3Jkcyhjb2Rld29yZHMsIGJhcmNvZGVNZXRhZGF0YSk7XG4gICAgICAgICAgICBsZXQgYm91bmRpbmdCb3ggPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5faXNMZWZ0ID8gYm91bmRpbmdCb3guZ2V0VG9wTGVmdCgpIDogYm91bmRpbmdCb3guZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSB0aGlzLl9pc0xlZnQgPyBib3VuZGluZ0JveC5nZXRCb3R0b21MZWZ0KCkgOiBib3VuZGluZ0JveC5nZXRCb3R0b21SaWdodCgpO1xuICAgICAgICAgICAgbGV0IGZpcnN0Um93ID0gdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChNYXRoLnRydW5jKHRvcC5nZXRZKCkpKTtcbiAgICAgICAgICAgIGxldCBsYXN0Um93ID0gdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChNYXRoLnRydW5jKGJvdHRvbS5nZXRZKCkpKTtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYmUgY2FyZWZ1bCB1c2luZyB0aGUgYXZlcmFnZSByb3cgaGVpZ2h0LiBCYXJjb2RlIGNvdWxkIGJlIHNrZXdlZCBzbyB0aGF0IHdlIGhhdmUgc21hbGxlciBhbmRcbiAgICAgICAgICAgIC8vIHRhbGxlciByb3dzXG4gICAgICAgICAgICAvLyBmbG9hdCBhdmVyYWdlUm93SGVpZ2h0ID0gKGxhc3RSb3cgLSBmaXJzdFJvdykgLyAvKihmbG9hdCkqLyBiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlUm93ID0gLTE7XG4gICAgICAgICAgICBsZXQgbWF4Um93SGVpZ2h0ID0gMTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Um93SGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3Jkc1JvdyAvKmludCovID0gZmlyc3RSb3c7IGNvZGV3b3Jkc1JvdyA8IGxhc3RSb3c7IGNvZGV3b3Jkc1JvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgICAgIC8vICAgICAgZmxvYXQgZXhwZWN0ZWRSb3dOdW1iZXIgPSAoY29kZXdvcmRzUm93IC0gZmlyc3RSb3cpIC8gYXZlcmFnZVJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICAvLyAgICAgIGlmIChNYXRoLmFicyhjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSAtIGV4cGVjdGVkUm93TnVtYmVyKSA+IDIpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgU2ltcGxlTG9nLmxvZyhMRVZFTC5XQVJOSU5HLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgXCJSZW1vdmluZyBjb2Rld29yZCwgcm93TnVtYmVyU2tldyB0b28gaGlnaCwgY29kZXdvcmRbXCIgKyBjb2Rld29yZHNSb3cgKyBcIl06IEV4cGVjdGVkIFJvdzogXCIgK1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIGV4cGVjdGVkUm93TnVtYmVyICsgXCIsIFJlYWxSb3c6IFwiICsgY29kZXdvcmQuZ2V0Um93TnVtYmVyKCkgKyBcIiwgdmFsdWU6IFwiICsgY29kZXdvcmQuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcm93RGlmZmVyZW5jZSA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpIC0gYmFyY29kZVJvdztcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGltcHJvdmUgaGFuZGxpbmcgd2l0aCBjYXNlIHdoZXJlIGZpcnN0IHJvdyBpbmRpY2F0b3IgZG9lc24ndCBzdGFydCB3aXRoIDBcbiAgICAgICAgICAgICAgICBpZiAocm93RGlmZmVyZW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um93SGVpZ2h0Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJvd0RpZmZlcmVuY2UgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4Um93SGVpZ2h0ID0gTWF0aC5tYXgobWF4Um93SGVpZ2h0LCBjdXJyZW50Um93SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvd0hlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJhcmNvZGVSb3cgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocm93RGlmZmVyZW5jZSA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmQuZ2V0Um93TnVtYmVyKCkgPj0gYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCkgfHxcbiAgICAgICAgICAgICAgICAgICAgcm93RGlmZmVyZW5jZSA+IGNvZGV3b3Jkc1Jvdykge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hlY2tlZFJvd3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhSb3dIZWlnaHQgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkUm93cyA9IChtYXhSb3dIZWlnaHQgLSAyKSAqIHJvd0RpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkUm93cyA9IHJvd0RpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNsb3NlUHJldmlvdXNDb2Rld29yZEZvdW5kID0gY2hlY2tlZFJvd3MgPj0gY29kZXdvcmRzUm93O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAxOyBpIDw9IGNoZWNrZWRSb3dzICYmICFjbG9zZVByZXZpb3VzQ29kZXdvcmRGb3VuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBtdXN0IGJlIChoZWlnaHQgKiByb3dEaWZmZXJlbmNlKSBudW1iZXIgb2YgY29kZXdvcmRzIG1pc3NpbmcuIEZvciBub3cgd2UgYXNzdW1lIGhlaWdodCA9IDEuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBob3BlZnVsbHkgZ2V0IHJpZCBvZiBtb3N0IHByb2JsZW1zIGFscmVhZHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZVByZXZpb3VzQ29kZXdvcmRGb3VuZCA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgLSBpXSAhPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZVByZXZpb3VzQ29kZXdvcmRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZVJvdyA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvd0hlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gKGludCkgKGF2ZXJhZ2VSb3dIZWlnaHQgKyAwLjUpO1xuICAgICAgICB9XG4gICAgICAgIGdldFJvd0hlaWdodHMoKSB7XG4gICAgICAgICAgICBsZXQgYmFyY29kZU1ldGFkYXRhID0gdGhpcy5nZXRCYXJjb2RlTWV0YWRhdGEoKTtcbiAgICAgICAgICAgIGlmIChiYXJjb2RlTWV0YWRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGp1c3RJbmNvbXBsZXRlSW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyhiYXJjb2RlTWV0YWRhdGEpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3JkIC8qQ29kZXdvcmQqLyBvZiB0aGlzLmdldENvZGV3b3JkcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvd051bWJlciA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocm93TnVtYmVyID49IHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgbW9yZSByb3dzIHRoYW4gdGhlIGJhcmNvZGUgbWV0YWRhdGEgYWxsb3dzIGZvciwgaWdub3JlIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcm93TnVtYmVyXSsrO1xuICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB0aHJvdyBleGNlcHRpb24/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gbWF5YmUgd2Ugc2hvdWxkIGFkZCBtaXNzaW5nIGNvZGV3b3JkcyB0byBzdG9yZSB0aGUgY29ycmVjdCByb3cgbnVtYmVyIHRvIG1ha2VcbiAgICAgICAgLy8gZmluZGluZyByb3cgbnVtYmVycyBmb3Igb3RoZXIgY29sdW1ucyBlYXNpZXJcbiAgICAgICAgLy8gdXNlIHJvdyBoZWlnaHQgY291bnQgdG8gbWFrZSBkZXRlY3Rpb24gb2YgaW52YWxpZCByb3cgbnVtYmVycyBtb3JlIHJlbGlhYmxlXG4gICAgICAgIGFkanVzdEluY29tcGxldGVJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKGJhcmNvZGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgbGV0IGJvdW5kaW5nQm94ID0gdGhpcy5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMuX2lzTGVmdCA/IGJvdW5kaW5nQm94LmdldFRvcExlZnQoKSA6IGJvdW5kaW5nQm94LmdldFRvcFJpZ2h0KCk7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gdGhpcy5faXNMZWZ0ID8gYm91bmRpbmdCb3guZ2V0Qm90dG9tTGVmdCgpIDogYm91bmRpbmdCb3guZ2V0Qm90dG9tUmlnaHQoKTtcbiAgICAgICAgICAgIGxldCBmaXJzdFJvdyA9IHRoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoTWF0aC50cnVuYyh0b3AuZ2V0WSgpKSk7XG4gICAgICAgICAgICBsZXQgbGFzdFJvdyA9IHRoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoTWF0aC50cnVuYyhib3R0b20uZ2V0WSgpKSk7XG4gICAgICAgICAgICAvLyBmbG9hdCBhdmVyYWdlUm93SGVpZ2h0ID0gKGxhc3RSb3cgLSBmaXJzdFJvdykgLyAvKihmbG9hdCkqLyBiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZHMgPSB0aGlzLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVSb3cgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3Jkc1JvdyAvKmludCovID0gZmlyc3RSb3c7IGNvZGV3b3Jkc1JvdyA8IGxhc3RSb3c7IGNvZGV3b3Jkc1JvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlckFzUm93SW5kaWNhdG9yQ29sdW1uKCk7XG4gICAgICAgICAgICAgICAgbGV0IHJvd0RpZmZlcmVuY2UgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSAtIGJhcmNvZGVSb3c7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBpbXByb3ZlIGhhbmRsaW5nIHdpdGggY2FzZSB3aGVyZSBmaXJzdCByb3cgaW5kaWNhdG9yIGRvZXNuJ3Qgc3RhcnQgd2l0aCAwXG4gICAgICAgICAgICAgICAgaWYgKHJvd0RpZmZlcmVuY2UgPT09IDApIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyb3dEaWZmZXJlbmNlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhcmNvZGVSb3cgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZXdvcmQuZ2V0Um93TnVtYmVyKCkgPj0gYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmFyY29kZVJvdyA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiAoaW50KSAoYXZlcmFnZVJvd0hlaWdodCArIDAuNSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QmFyY29kZU1ldGFkYXRhKCkge1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkcyA9IHRoaXMuZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICBsZXQgYmFyY29kZUNvbHVtbkNvdW50ID0gbmV3IEJhcmNvZGVWYWx1ZSgpO1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydCA9IG5ldyBCYXJjb2RlVmFsdWUoKTtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlUm93Q291bnRMb3dlclBhcnQgPSBuZXcgQmFyY29kZVZhbHVlKCk7XG4gICAgICAgICAgICBsZXQgYmFyY29kZUVDTGV2ZWwgPSBuZXcgQmFyY29kZVZhbHVlKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZCAvKkNvZGV3b3JkKi8gb2YgY29kZXdvcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlckFzUm93SW5kaWNhdG9yQ29sdW1uKCk7XG4gICAgICAgICAgICAgICAgbGV0IHJvd0luZGljYXRvclZhbHVlID0gY29kZXdvcmQuZ2V0VmFsdWUoKSAlIDMwO1xuICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZFJvd051bWJlciA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkUm93TnVtYmVyICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZXdvcmRSb3dOdW1iZXIgJSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydC5zZXRWYWx1ZShyb3dJbmRpY2F0b3JWYWx1ZSAqIDMgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlRUNMZXZlbC5zZXRWYWx1ZShyb3dJbmRpY2F0b3JWYWx1ZSAvIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0LnNldFZhbHVlKHJvd0luZGljYXRvclZhbHVlICUgMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZUNvbHVtbkNvdW50LnNldFZhbHVlKHJvd0luZGljYXRvclZhbHVlICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYXliZSB3ZSBzaG91bGQgY2hlY2sgaWYgd2UgaGF2ZSBhbWJpZ3VvdXMgdmFsdWVzP1xuICAgICAgICAgICAgaWYgKChiYXJjb2RlQ29sdW1uQ291bnQuZ2V0VmFsdWUoKS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICAgICAgICAgKGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydC5nZXRWYWx1ZSgpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgICAgICAgICAoYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0LmdldFZhbHVlKCkubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAgICAgICAgIChiYXJjb2RlRUNMZXZlbC5nZXRWYWx1ZSgpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgICAgICAgICBiYXJjb2RlQ29sdW1uQ291bnQuZ2V0VmFsdWUoKVswXSA8IDEgfHxcbiAgICAgICAgICAgICAgICBiYXJjb2RlUm93Q291bnRVcHBlclBhcnQuZ2V0VmFsdWUoKVswXSArIGJhcmNvZGVSb3dDb3VudExvd2VyUGFydC5nZXRWYWx1ZSgpWzBdIDwgUERGNDE3Q29tbW9uLk1JTl9ST1dTX0lOX0JBUkNPREUgfHxcbiAgICAgICAgICAgICAgICBiYXJjb2RlUm93Q291bnRVcHBlclBhcnQuZ2V0VmFsdWUoKVswXSArIGJhcmNvZGVSb3dDb3VudExvd2VyUGFydC5nZXRWYWx1ZSgpWzBdID4gUERGNDE3Q29tbW9uLk1BWF9ST1dTX0lOX0JBUkNPREUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBiYXJjb2RlTWV0YWRhdGEgPSBuZXcgQmFyY29kZU1ldGFkYXRhKGJhcmNvZGVDb2x1bW5Db3VudC5nZXRWYWx1ZSgpWzBdLCBiYXJjb2RlUm93Q291bnRVcHBlclBhcnQuZ2V0VmFsdWUoKVswXSwgYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0LmdldFZhbHVlKClbMF0sIGJhcmNvZGVFQ0xldmVsLmdldFZhbHVlKClbMF0pO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJbmNvcnJlY3RDb2Rld29yZHMoY29kZXdvcmRzLCBiYXJjb2RlTWV0YWRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGJhcmNvZGVNZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVJbmNvcnJlY3RDb2Rld29yZHMoY29kZXdvcmRzLCBiYXJjb2RlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjb2Rld29yZHMgd2hpY2ggZG8gbm90IG1hdGNoIHRoZSBtZXRhZGF0YVxuICAgICAgICAgICAgLy8gVE9ETyBNYXliZSB3ZSBzaG91bGQga2VlcCB0aGUgaW5jb3JyZWN0IGNvZGV3b3JkcyBmb3IgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zP1xuICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmRSb3cgLyppbnQqLyA9IDA7IGNvZGV3b3JkUm93IDwgY29kZXdvcmRzLmxlbmd0aDsgY29kZXdvcmRSb3crKykge1xuICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IGNvZGV3b3Jkc1tjb2Rld29yZFJvd107XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZFJvd10gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJvd0luZGljYXRvclZhbHVlID0gY29kZXdvcmQuZ2V0VmFsdWUoKSAlIDMwO1xuICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZFJvd051bWJlciA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZFJvd051bWJlciA+IGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZFJvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRSb3dOdW1iZXIgKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2Rld29yZFJvd051bWJlciAlIDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0luZGljYXRvclZhbHVlICogMyArIDEgIT09IGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudFVwcGVyUGFydCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2NvZGV3b3JkUm93XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGgudHJ1bmMocm93SW5kaWNhdG9yVmFsdWUgLyAzKSAhPT0gYmFyY29kZU1ldGFkYXRhLmdldEVycm9yQ29ycmVjdGlvbkxldmVsKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRpY2F0b3JWYWx1ZSAlIDMgIT09IGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudExvd2VyUGFydCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2NvZGV3b3JkUm93XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0luZGljYXRvclZhbHVlICsgMSAhPT0gYmFyY29kZU1ldGFkYXRhLmdldENvbHVtbkNvdW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRSb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc0xlZnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnSXNMZWZ0OiAnICsgdGhpcy5faXNMZWZ0ICsgJ1xcbicgKyBzdXBlci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgRGV0ZWN0aW9uUmVzdWx0IHtcbiAgICAgICAgY29uc3RydWN0b3IoYmFyY29kZU1ldGFkYXRhLCBib3VuZGluZ0JveCkge1xuICAgICAgICAgICAgLypmaW5hbCovIHRoaXMuQURKVVNUX1JPV19OVU1CRVJfU0tJUCA9IDI7XG4gICAgICAgICAgICB0aGlzLmJhcmNvZGVNZXRhZGF0YSA9IGJhcmNvZGVNZXRhZGF0YTtcbiAgICAgICAgICAgIHRoaXMuYmFyY29kZUNvbHVtbkNvdW50ID0gYmFyY29kZU1ldGFkYXRhLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgICAgICAgICAvLyB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnMgPSBuZXcgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMl07XG4gICAgICAgICAgICB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnMgPSBuZXcgQXJyYXkodGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBnZXREZXRlY3Rpb25SZXN1bHRDb2x1bW5zKCkge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1swXSk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdEluZGljYXRvckNvbHVtblJvd051bWJlcnModGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV0pO1xuICAgICAgICAgICAgbGV0IHVuYWRqdXN0ZWRDb2Rld29yZENvdW50ID0gUERGNDE3Q29tbW9uLk1BWF9DT0RFV09SRFNfSU5fQkFSQ09ERTtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c1VuYWRqdXN0ZWRDb3VudDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1VuYWRqdXN0ZWRDb3VudCA9IHVuYWRqdXN0ZWRDb2Rld29yZENvdW50O1xuICAgICAgICAgICAgICAgIHVuYWRqdXN0ZWRDb2Rld29yZENvdW50ID0gdGhpcy5hZGp1c3RSb3dOdW1iZXJzQW5kR2V0Q291bnQoKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHVuYWRqdXN0ZWRDb2Rld29yZENvdW50ID4gMCAmJiB1bmFkanVzdGVkQ29kZXdvcmRDb3VudCA8IHByZXZpb3VzVW5hZGp1c3RlZENvdW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0SW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyhkZXRlY3Rpb25SZXN1bHRDb2x1bW4pIHtcbiAgICAgICAgICAgIGlmIChkZXRlY3Rpb25SZXN1bHRDb2x1bW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdENvbHVtblxuICAgICAgICAgICAgICAgICAgICAuYWRqdXN0Q29tcGxldGVJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKHRoaXMuYmFyY29kZU1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIGVuc3VyZSB0aGF0IG5vIGRldGVjdGVkIGNvZGV3b3JkcyB3aXRoIHVua25vd24gcm93IG51bWJlciBhcmUgbGVmdFxuICAgICAgICAvLyB3ZSBzaG91bGQgYmUgYWJsZSB0byBlc3RpbWF0ZSB0aGUgcm93IGhlaWdodCBhbmQgdXNlIGl0IGFzIGEgaGludCBmb3IgdGhlIHJvdyBudW1iZXJcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGFsc28gZmlsbCB0aGUgcm93cyB0b3AgdG8gYm90dG9tIGFuZCBib3R0b20gdG8gdG9wXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBjb2Rld29yZHMgd2hpY2ggZG9uJ3QgaGF2ZSBhIHZhbGlkIHJvdyBudW1iZXIuIE5vdGUgdGhhdCB0aGUgY291bnQgaXMgbm90IGFjY3VyYXRlIGFzIGNvZGV3b3Jkc1xuICAgICAgICAgKiB3aWxsIGJlIGNvdW50ZWQgc2V2ZXJhbCB0aW1lcy4gSXQganVzdCBzZXJ2ZXMgYXMgYW4gaW5kaWNhdG9yIHRvIHNlZSB3aGVuIHdlIGNhbiBzdG9wIGFkanVzdGluZyByb3cgbnVtYmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgYWRqdXN0Um93TnVtYmVyc0FuZEdldENvdW50KCkge1xuICAgICAgICAgICAgbGV0IHVuYWRqdXN0ZWRDb3VudCA9IHRoaXMuYWRqdXN0Um93TnVtYmVyc0J5Um93KCk7XG4gICAgICAgICAgICBpZiAodW5hZGp1c3RlZENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBiYXJjb2RlQ29sdW1uIC8qaW50Ki8gPSAxOyBiYXJjb2RlQ29sdW1uIDwgdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxOyBiYXJjb2RlQ29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3Jkc1JvdyAvKmludCovID0gMDsgY29kZXdvcmRzUm93IDwgY29kZXdvcmRzLmxlbmd0aDsgY29kZXdvcmRzUm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10uaGFzVmFsaWRSb3dOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RSb3dOdW1iZXJzKGJhcmNvZGVDb2x1bW4sIGNvZGV3b3Jkc1JvdywgY29kZXdvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmFkanVzdGVkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0Um93TnVtYmVyc0J5Um93KCkge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RSb3dOdW1iZXJzRnJvbUJvdGhSSSgpO1xuICAgICAgICAgICAgLy8gVE9ETyB3ZSBzaG91bGQgb25seSBkbyBmdWxsIHJvdyBhZGp1c3RtZW50cyBpZiByb3cgbnVtYmVycyBvZiBsZWZ0IGFuZCByaWdodCByb3cgaW5kaWNhdG9yIGNvbHVtbiBtYXRjaC5cbiAgICAgICAgICAgIC8vIE1heWJlIGl0J3MgZXZlbiBiZXR0ZXIgdG8gY2FsY3VsYXRlZCB0aGUgaGVpZ2h0IChyb3dzOiBkKSBhbmQgZGl2aWRlIGl0IGJ5IHRoZSBudW1iZXIgb2YgYmFyY29kZVxuICAgICAgICAgICAgLy8gcm93cy4gVGhpcywgdG9nZXRoZXIgd2l0aCB0aGUgTFJJIGFuZCBSUkkgcm93IG51bWJlcnMgc2hvdWxkIGFsbG93IHVzIHRvIGdldCBhIGdvb2QgZXN0aW1hdGUgd2hlcmUgYSByb3dcbiAgICAgICAgICAgIC8vIG51bWJlciBzdGFydHMgYW5kIGVuZHMuXG4gICAgICAgICAgICBsZXQgdW5hZGp1c3RlZENvdW50ID0gdGhpcy5hZGp1c3RSb3dOdW1iZXJzRnJvbUxSSSgpO1xuICAgICAgICAgICAgcmV0dXJuIHVuYWRqdXN0ZWRDb3VudCArIHRoaXMuYWRqdXN0Um93TnVtYmVyc0Zyb21SUkkoKTtcbiAgICAgICAgfVxuICAgICAgICBhZGp1c3RSb3dOdW1iZXJzRnJvbUJvdGhSSSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbMF0gPT0gbnVsbCB8fCB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IExSSWNvZGV3b3JkcyA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1swXS5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGxldCBSUkljb2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxXS5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3Jkc1JvdyAvKmludCovID0gMDsgY29kZXdvcmRzUm93IDwgTFJJY29kZXdvcmRzLmxlbmd0aDsgY29kZXdvcmRzUm93KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoTFJJY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBSUkljb2Rld29yZHNbY29kZXdvcmRzUm93XSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIExSSWNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddLmdldFJvd051bWJlcigpID09PSBSUkljb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBiYXJjb2RlQ29sdW1uIC8qaW50Ki8gPSAxOyBiYXJjb2RlQ29sdW1uIDw9IHRoaXMuYmFyY29kZUNvbHVtbkNvdW50OyBiYXJjb2RlQ29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uXS5nZXRDb2Rld29yZHMoKVtjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlcihMUkljb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvZGV3b3JkLmhhc1ZhbGlkUm93TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0uZ2V0Q29kZXdvcmRzKClbY29kZXdvcmRzUm93XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0Um93TnVtYmVyc0Zyb21SUkkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHVuYWRqdXN0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgY29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV0uZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZHNSb3cgLyppbnQqLyA9IDA7IGNvZGV3b3Jkc1JvdyA8IGNvZGV3b3Jkcy5sZW5ndGg7IGNvZGV3b3Jkc1JvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByb3dJbmRpY2F0b3JSb3dOdW1iZXIgPSBjb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBsZXQgaW52YWxpZFJvd0NvdW50cyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYmFyY29kZUNvbHVtbiAvKmludCovID0gdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxOyBiYXJjb2RlQ29sdW1uID4gMCAmJiBpbnZhbGlkUm93Q291bnRzIDwgdGhpcy5BREpVU1RfUk9XX05VTUJFUl9TS0lQOyBiYXJjb2RlQ29sdW1uLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkUm93Q291bnRzID0gRGV0ZWN0aW9uUmVzdWx0LmFkanVzdFJvd051bWJlcklmVmFsaWQocm93SW5kaWNhdG9yUm93TnVtYmVyLCBpbnZhbGlkUm93Q291bnRzLCBjb2Rld29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvZGV3b3JkLmhhc1ZhbGlkUm93TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmFkanVzdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmFkanVzdGVkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0Um93TnVtYmVyc0Zyb21MUkkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB1bmFkanVzdGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkcyA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1swXS5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3Jkc1JvdyAvKmludCovID0gMDsgY29kZXdvcmRzUm93IDwgY29kZXdvcmRzLmxlbmd0aDsgY29kZXdvcmRzUm93KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJvd0luZGljYXRvclJvd051bWJlciA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgIGxldCBpbnZhbGlkUm93Q291bnRzID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiYXJjb2RlQ29sdW1uIC8qaW50Ki8gPSAxOyBiYXJjb2RlQ29sdW1uIDwgdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxICYmIGludmFsaWRSb3dDb3VudHMgPCB0aGlzLkFESlVTVF9ST1dfTlVNQkVSX1NLSVA7IGJhcmNvZGVDb2x1bW4rKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmQgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0uZ2V0Q29kZXdvcmRzKClbY29kZXdvcmRzUm93XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRSb3dDb3VudHMgPSBEZXRlY3Rpb25SZXN1bHQuYWRqdXN0Um93TnVtYmVySWZWYWxpZChyb3dJbmRpY2F0b3JSb3dOdW1iZXIsIGludmFsaWRSb3dDb3VudHMsIGNvZGV3b3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29kZXdvcmQuaGFzVmFsaWRSb3dOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuYWRqdXN0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuYWRqdXN0ZWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYWRqdXN0Um93TnVtYmVySWZWYWxpZChyb3dJbmRpY2F0b3JSb3dOdW1iZXIsIGludmFsaWRSb3dDb3VudHMsIGNvZGV3b3JkKSB7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkUm93Q291bnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb2Rld29yZC5oYXNWYWxpZFJvd051bWJlcigpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkLmlzVmFsaWRSb3dOdW1iZXIocm93SW5kaWNhdG9yUm93TnVtYmVyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZC5zZXRSb3dOdW1iZXIocm93SW5kaWNhdG9yUm93TnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFJvd0NvdW50cyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK2ludmFsaWRSb3dDb3VudHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGludmFsaWRSb3dDb3VudHM7XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0Um93TnVtYmVycyhiYXJjb2RlQ29sdW1uLCBjb2Rld29yZHNSb3csIGNvZGV3b3Jkcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbiAtIDFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNDb2x1bW5Db2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbiAtIDFdLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgbGV0IG5leHRDb2x1bW5Db2Rld29yZHMgPSBwcmV2aW91c0NvbHVtbkNvZGV3b3JkcztcbiAgICAgICAgICAgIGlmICh0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbiArIDFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29sdW1uQ29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW4gKyAxXS5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxldCBvdGhlckNvZGV3b3JkczogQ29kZXdvcmRbXSA9IG5ldyBDb2Rld29yZFsxNF07XG4gICAgICAgICAgICBsZXQgb3RoZXJDb2Rld29yZHMgPSBuZXcgQXJyYXkoMTQpO1xuICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbMl0gPSBwcmV2aW91c0NvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbM10gPSBuZXh0Q29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICBpZiAoY29kZXdvcmRzUm93ID4gMCkge1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzBdID0gY29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDFdO1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzRdID0gcHJldmlvdXNDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93IC0gMV07XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbNV0gPSBuZXh0Q29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1JvdyA+IDEpIHtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s4XSA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgLSAyXTtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1sxMF0gPSBwcmV2aW91c0NvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgLSAyXTtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1sxMV0gPSBuZXh0Q29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1JvdyA8IGNvZGV3b3Jkcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbMV0gPSBjb2Rld29yZHNbY29kZXdvcmRzUm93ICsgMV07XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbNl0gPSBwcmV2aW91c0NvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgKyAxXTtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s3XSA9IG5leHRDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93ICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZXdvcmRzUm93IDwgY29kZXdvcmRzLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s5XSA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgKyAyXTtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1sxMl0gPSBwcmV2aW91c0NvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgKyAyXTtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1sxM10gPSBuZXh0Q29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgb3RoZXJDb2Rld29yZCBvZiBvdGhlckNvZGV3b3Jkcykge1xuICAgICAgICAgICAgICAgIGlmIChEZXRlY3Rpb25SZXN1bHQuYWRqdXN0Um93TnVtYmVyKGNvZGV3b3JkLCBvdGhlckNvZGV3b3JkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRydWUsIGlmIHJvdyBudW1iZXIgd2FzIGFkanVzdGVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhZGp1c3RSb3dOdW1iZXIoY29kZXdvcmQsIG90aGVyQ29kZXdvcmQpIHtcbiAgICAgICAgICAgIGlmIChvdGhlckNvZGV3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXJDb2Rld29yZC5oYXNWYWxpZFJvd051bWJlcigpICYmIG90aGVyQ29kZXdvcmQuZ2V0QnVja2V0KCkgPT09IGNvZGV3b3JkLmdldEJ1Y2tldCgpKSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmQuc2V0Um93TnVtYmVyKG90aGVyQ29kZXdvcmQuZ2V0Um93TnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGdldEJhcmNvZGVDb2x1bW5Db3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXRCYXJjb2RlUm93Q291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRCYXJjb2RlRUNMZXZlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhcmNvZGVNZXRhZGF0YS5nZXRFcnJvckNvcnJlY3Rpb25MZXZlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHNldEJvdW5kaW5nQm94KGJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qm91bmRpbmdCb3goKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGluZ0JveDtcbiAgICAgICAgfVxuICAgICAgICBzZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbiwgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uKSB7XG4gICAgICAgICAgICB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0gPSBkZXRlY3Rpb25SZXN1bHRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgbGV0IHJvd0luZGljYXRvckNvbHVtbiA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1swXTtcbiAgICAgICAgICAgIGlmIChyb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJvd0luZGljYXRvckNvbHVtbiA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1t0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJ5IChcbiAgICAgICAgICAgIGxldCBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKCk7XG4gICAgICAgICAgICAvLyApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3Jkc1JvdyAvKmludCovID0gMDsgY29kZXdvcmRzUm93IDwgcm93SW5kaWNhdG9yQ29sdW1uLmdldENvZGV3b3JkcygpLmxlbmd0aDsgY29kZXdvcmRzUm93KyspIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCdDVyAlM2Q6JywgY29kZXdvcmRzUm93KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiYXJjb2RlQ29sdW1uIC8qaW50Ki8gPSAwOyBiYXJjb2RlQ29sdW1uIDwgdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAyOyBiYXJjb2RlQ29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCcgICAgfCAgICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCcgICAgfCAgICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnICUzZHwlM2QnLCBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSwgY29kZXdvcmQuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGVjb2RlcjtcbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgQ29kZXdvcmQge1xuICAgICAgICBjb25zdHJ1Y3RvcihzdGFydFgsIGVuZFgsIGJ1Y2tldCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucm93TnVtYmVyID0gQ29kZXdvcmQuQkFSQ09ERV9ST1dfVU5LTk9XTjtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRYID0gTWF0aC50cnVuYyhzdGFydFgpO1xuICAgICAgICAgICAgdGhpcy5lbmRYID0gTWF0aC50cnVuYyhlbmRYKTtcbiAgICAgICAgICAgIHRoaXMuYnVja2V0ID0gTWF0aC50cnVuYyhidWNrZXQpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IE1hdGgudHJ1bmModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGhhc1ZhbGlkUm93TnVtYmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZFJvd051bWJlcih0aGlzLnJvd051bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgaXNWYWxpZFJvd051bWJlcihyb3dOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByb3dOdW1iZXIgIT09IENvZGV3b3JkLkJBUkNPREVfUk9XX1VOS05PV04gJiYgdGhpcy5idWNrZXQgPT09IChyb3dOdW1iZXIgJSAzKSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Um93TnVtYmVyQXNSb3dJbmRpY2F0b3JDb2x1bW4oKSB7XG4gICAgICAgICAgICB0aGlzLnJvd051bWJlciA9IE1hdGgudHJ1bmMoKE1hdGgudHJ1bmModGhpcy52YWx1ZSAvIDMwKSkgKiAzICsgTWF0aC50cnVuYyh0aGlzLmJ1Y2tldCAvIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZFggLSB0aGlzLnN0YXJ0WDtcbiAgICAgICAgfVxuICAgICAgICBnZXRTdGFydFgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydFg7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RW5kWCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZFg7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QnVja2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0O1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Um93TnVtYmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93TnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHNldFJvd051bWJlcihyb3dOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMucm93TnVtYmVyID0gcm93TnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIC8vICAgQE92ZXJyaWRlXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93TnVtYmVyICsgJ3wnICsgdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb2Rld29yZC5CQVJDT0RFX1JPV19VTktOT1dOID0gLTE7XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKiBAYXV0aG9yIGNyZWF0YWxlIEdtYkggKGNocmlzdG9waC5zY2h1bHpAY3JlYXRhbGUuZGUpXG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIFBERjQxN0NvZGV3b3JkRGVjb2RlciB7XG4gICAgICAgIC8qIEBub3RlXG4gICAgICAgICAqIHRoaXMgYWN0aW9uIGhhdmUgdG8gYmUgcGVyZm9ybWVkIGJlZm9yZSBmaXJzdCB1c2Ugb2YgY2xhc3NcbiAgICAgICAgICogLSBzdGF0aWMgY29uc3RydWN0b3JcbiAgICAgICAgICogd29ya2luZyB3aXRoIDMyYml0IGZsb2F0IChiYXNlZCBmcm9tIEphdmEgbG9naWMpXG4gICAgICAgICovXG4gICAgICAgIHN0YXRpYyBpbml0aWFsaXplKCkge1xuICAgICAgICAgICAgLy8gUHJlLWNvbXB1dGVzIHRoZSBzeW1ib2wgcmF0aW8gdGFibGUuXG4gICAgICAgICAgICBmb3IgKCAvKmludCovbGV0IGkgPSAwOyBpIDwgUERGNDE3Q29tbW9uLlNZTUJPTF9UQUJMRS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3ltYm9sID0gUERGNDE3Q29tbW9uLlNZTUJPTF9UQUJMRVtpXTtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEJpdCA9IGN1cnJlbnRTeW1ib2wgJiAweDE7XG4gICAgICAgICAgICAgICAgZm9yICggLyppbnQqL2xldCBqID0gMDsgaiA8IFBERjQxN0NvbW1vbi5CQVJTX0lOX01PRFVMRTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnRTeW1ib2wgJiAweDEpID09PSBjdXJyZW50Qml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplICs9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTeW1ib2wgPj49IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEJpdCA9IGN1cnJlbnRTeW1ib2wgJiAweDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghUERGNDE3Q29kZXdvcmREZWNvZGVyLlJBVElPU19UQUJMRVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLlJBVElPU19UQUJMRVtpXSA9IG5ldyBBcnJheShQREY0MTdDb21tb24uQkFSU19JTl9NT0RVTEUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEVbaV1bUERGNDE3Q29tbW9uLkJBUlNfSU5fTU9EVUxFIC0gaiAtIDFdID0gTWF0aC5mcm91bmQoc2l6ZSAvIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX0NPREVXT1JEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJTeW1ib2xUYWJsZVJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0RGVjb2RlZFZhbHVlKG1vZHVsZUJpdENvdW50KSB7XG4gICAgICAgICAgICBsZXQgZGVjb2RlZFZhbHVlID0gUERGNDE3Q29kZXdvcmREZWNvZGVyLmdldERlY29kZWRDb2Rld29yZFZhbHVlKFBERjQxN0NvZGV3b3JkRGVjb2Rlci5zYW1wbGVCaXRDb3VudHMobW9kdWxlQml0Q291bnQpKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkVmFsdWUgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQREY0MTdDb2Rld29yZERlY29kZXIuZ2V0Q2xvc2VzdERlY29kZWRWYWx1ZShtb2R1bGVCaXRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHNhbXBsZUJpdENvdW50cyhtb2R1bGVCaXRDb3VudCkge1xuICAgICAgICAgICAgbGV0IGJpdENvdW50U3VtID0gTWF0aFV0aWxzLnN1bShtb2R1bGVCaXRDb3VudCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkoUERGNDE3Q29tbW9uLkJBUlNfSU5fTU9EVUxFKTtcbiAgICAgICAgICAgIGxldCBiaXRDb3VudEluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBzdW1QcmV2aW91c0JpdHMgPSAwO1xuICAgICAgICAgICAgZm9yICggLyppbnQqL2xldCBpID0gMDsgaSA8IFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX0NPREVXT1JEOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc2FtcGxlSW5kZXggPSBiaXRDb3VudFN1bSAvICgyICogUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fQ09ERVdPUkQpICtcbiAgICAgICAgICAgICAgICAgICAgKGkgKiBiaXRDb3VudFN1bSkgLyBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRDtcbiAgICAgICAgICAgICAgICBpZiAoc3VtUHJldmlvdXNCaXRzICsgbW9kdWxlQml0Q291bnRbYml0Q291bnRJbmRleF0gPD0gc2FtcGxlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtUHJldmlvdXNCaXRzICs9IG1vZHVsZUJpdENvdW50W2JpdENvdW50SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBiaXRDb3VudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtiaXRDb3VudEluZGV4XSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0RGVjb2RlZENvZGV3b3JkVmFsdWUobW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgICAgIGxldCBkZWNvZGVkVmFsdWUgPSBQREY0MTdDb2Rld29yZERlY29kZXIuZ2V0Qml0VmFsdWUobW9kdWxlQml0Q291bnQpO1xuICAgICAgICAgICAgcmV0dXJuIFBERjQxN0NvbW1vbi5nZXRDb2Rld29yZChkZWNvZGVkVmFsdWUpID09PSAtMSA/IC0xIDogZGVjb2RlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRCaXRWYWx1ZShtb2R1bGVCaXRDb3VudCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IC8qbG9uZyovIDA7XG4gICAgICAgICAgICBmb3IgKGxldCAvKmludCovIGkgPSAwOyBpIDwgbW9kdWxlQml0Q291bnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKCAvKmludCovbGV0IGJpdCA9IDA7IGJpdCA8IG1vZHVsZUJpdENvdW50W2ldOyBiaXQrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDEpIHwgKGkgJSAyID09PSAwID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnRydW5jKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd29ya2luZyB3aXRoIDMyYml0IGZsb2F0IChhcyBpbiBKYXZhKVxuICAgICAgICBzdGF0aWMgZ2V0Q2xvc2VzdERlY29kZWRWYWx1ZShtb2R1bGVCaXRDb3VudCkge1xuICAgICAgICAgICAgbGV0IGJpdENvdW50U3VtID0gTWF0aFV0aWxzLnN1bShtb2R1bGVCaXRDb3VudCk7XG4gICAgICAgICAgICBsZXQgYml0Q291bnRSYXRpb3MgPSBuZXcgQXJyYXkoUERGNDE3Q29tbW9uLkJBUlNfSU5fTU9EVUxFKTtcbiAgICAgICAgICAgIGlmIChiaXRDb3VudFN1bSA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCAvKmludCovIGkgPSAwOyBpIDwgYml0Q291bnRSYXRpb3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYml0Q291bnRSYXRpb3NbaV0gPSBNYXRoLmZyb3VuZChtb2R1bGVCaXRDb3VudFtpXSAvIGJpdENvdW50U3VtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYmVzdE1hdGNoRXJyb3IgPSBGbG9hdC5NQVhfVkFMVUU7XG4gICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gLTE7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYlN5bWJvbFRhYmxlUmVhZHkpIHtcbiAgICAgICAgICAgICAgICBQREY0MTdDb2Rld29yZERlY29kZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICggLyppbnQqL2xldCBqID0gMDsgaiA8IFBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3IgPSAwLjA7XG4gICAgICAgICAgICAgICAgbGV0IHJhdGlvVGFibGVSb3cgPSBQREY0MTdDb2Rld29yZERlY29kZXIuUkFUSU9TX1RBQkxFW2pdO1xuICAgICAgICAgICAgICAgIGZvciAoIC8qaW50Ki9sZXQgayA9IDA7IGsgPCBQREY0MTdDb21tb24uQkFSU19JTl9NT0RVTEU7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGlmZiA9IE1hdGguZnJvdW5kKHJhdGlvVGFibGVSb3dba10gLSBiaXRDb3VudFJhdGlvc1trXSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yICs9IE1hdGguZnJvdW5kKGRpZmYgKiBkaWZmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yID49IGJlc3RNYXRjaEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2hFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2hFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSBQREY0MTdDb21tb24uU1lNQk9MX1RBQkxFW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZmxhZyB0aGF0IHRoZSB0YWJsZSBpcyByZWFkeSBmb3IgdXNlXG4gICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLmJTeW1ib2xUYWJsZVJlYWR5ID0gZmFsc2U7XG4gICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLlJBVElPU19UQUJMRSA9IG5ldyBBcnJheShQREY0MTdDb21tb24uU1lNQk9MX1RBQkxFLmxlbmd0aCkubWFwKHggPT4geCA9IG5ldyBBcnJheShQREY0MTdDb21tb24uQkFSU19JTl9NT0RVTEUpKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNztcbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKnB1YmxpYyBmaW5hbCovIGNsYXNzIFBERjQxN1Jlc3VsdE1ldGFkYXRhIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLnNlZ21lbnRDb3VudCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5maWxlU2l6ZSA9IC0xO1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tzdW0gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFNlZ21lbnQgSUQgcmVwcmVzZW50cyB0aGUgc2VnbWVudCBvZiB0aGUgd2hvbGUgZmlsZSBkaXN0cmlidXRlZCBvdmVyIGRpZmZlcmVudCBzeW1ib2xzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIEZpbGUgc2VnbWVudCBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VnbWVudEluZGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHNldFNlZ21lbnRJbmRleChzZWdtZW50SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgc2FtZSBmb3IgZWFjaCByZWxhdGVkIFBERjQxNyBzeW1ib2xcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBGaWxlIElEXG4gICAgICAgICAqL1xuICAgICAgICBnZXRGaWxlSWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RmlsZUlkKGZpbGVJZCkge1xuICAgICAgICAgICAgdGhpcy5maWxlSWQgPSBmaWxlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gYWx3YXlzIG51bGxcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgdXNlIGRlZGljYXRlZCBhbHJlYWR5IHBhcnNlZCBmaWVsZHNcbiAgICAgICAgICovXG4gICAgICAgIC8vICAgQERlcHJlY2F0ZWRcbiAgICAgICAgZ2V0T3B0aW9uYWxEYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uYWxEYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9uYWxEYXRhIG9sZCBvcHRpb25hbCBkYXRhIGZvcm1hdCBhcyBpbnQgYXJyYXlcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgcGFyc2UgYW5kIHVzZSBuZXcgZmllbGRzXG4gICAgICAgICAqL1xuICAgICAgICAvLyAgIEBEZXByZWNhdGVkXG4gICAgICAgIHNldE9wdGlvbmFsRGF0YShvcHRpb25hbERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uYWxEYXRhID0gb3B0aW9uYWxEYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgaXQgaXMgdGhlIGxhc3Qgc2VnbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaXNMYXN0U2VnbWVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3RTZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIHNldExhc3RTZWdtZW50KGxhc3RTZWdtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RTZWdtZW50ID0gbGFzdFNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gY291bnQgb2Ygc2VnbWVudHMsIC0xIGlmIG5vdCBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGdldFNlZ21lbnRDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWdtZW50Q291bnQoc2VnbWVudENvdW50IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudENvdW50ID0gc2VnbWVudENvdW50O1xuICAgICAgICB9XG4gICAgICAgIGdldFNlbmRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRlciB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNldFNlbmRlcihzZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICAgICAgICB9XG4gICAgICAgIGdldEFkZHJlc3NlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3NlZSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNldEFkZHJlc3NlZShhZGRyZXNzZWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzc2VlID0gYWRkcmVzc2VlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWxlbmFtZSBvZiB0aGUgZW5jb2RlZCBmaWxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gZmlsZW5hbWVcbiAgICAgICAgICovXG4gICAgICAgIGdldEZpbGVOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RmlsZU5hbWUoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWUgPSBmaWxlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogZmlsZXNpemUgaW4gYnl0ZXMgb2YgdGhlIGVuY29kZWQgZmlsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIGZpbGVzaXplIGluIGJ5dGVzLCAtMSBpZiBub3Qgc2V0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGaWxlU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIHNldEZpbGVTaXplKGZpbGVTaXplIC8qbG9uZyovKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVTaXplID0gZmlsZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDE2LWJpdCBDUkMgY2hlY2tzdW0gdXNpbmcgQ0NJVFQtMTZcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBjcmMgY2hlY2tzdW0sIC0xIGlmIG5vdCBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGdldENoZWNrc3VtKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tzdW07XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q2hlY2tzdW0oY2hlY2tzdW0gLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy5jaGVja3N1bSA9IGNoZWNrc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1bml4IGVwb2NrIHRpbWVzdGFtcCwgZWxhcHNlZCBzZWNvbmRzIHNpbmNlIDE5NzAtMDEtMDFcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBlbGFwc2VkIHNlY29uZHMsIC0xIGlmIG5vdCBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGdldFRpbWVzdGFtcCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lc3RhbXAodGltZXN0YW1wIC8qbG9uZyovKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbnlmaWxsIGZvciBKYXZhJ3MgTG9uZyBjbGFzcy5cbiAgICAgKi9cbiAgICBjbGFzcyBMb25nIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhIHN0cmluZyB0byBhIG51bWJlciwgc2luY2UgSlMgaGFzIG5vIHJlYWxseSBJbnQ2NC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG51bSBOdW1lcmljIHN0cmluZy5cbiAgICAgICAgICogQHBhcmFtIHJhZGl4IERlc3RpbmF0aW9uIHJhZGl4LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHBhcnNlTG9uZyhudW0sIHJhZGl4ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLCByYWRpeCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgTnVsbFBvaW50ZXJFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cbiAgICBOdWxsUG9pbnRlckV4Y2VwdGlvbi5raW5kID0gJ051bGxQb2ludGVyRXhjZXB0aW9uJztcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IChjKSAxOTk0LCAyMDA0LCBPcmFjbGUgYW5kL29yIGl0cyBhZmZpbGlhdGVzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICAgICAqIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi5cbiAgICAgKlxuICAgICAqIFRoaXMgY29kZSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXNcbiAgICAgKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbi4gIE9yYWNsZSBkZXNpZ25hdGVzIHRoaXNcbiAgICAgKiBwYXJ0aWN1bGFyIGZpbGUgYXMgc3ViamVjdCB0byB0aGUgXCJDbGFzc3BhdGhcIiBleGNlcHRpb24gYXMgcHJvdmlkZWRcbiAgICAgKiBieSBPcmFjbGUgaW4gdGhlIExJQ0VOU0UgZmlsZSB0aGF0IGFjY29tcGFuaWVkIHRoaXMgY29kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgY29kZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgICAqIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBvclxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgICAqIHZlcnNpb24gMiBmb3IgbW9yZSBkZXRhaWxzIChhIGNvcHkgaXMgaW5jbHVkZWQgaW4gdGhlIExJQ0VOU0UgZmlsZSB0aGF0XG4gICAgICogYWNjb21wYW5pZWQgdGhpcyBjb2RlKS5cbiAgICAgKlxuICAgICAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb25cbiAgICAgKiAyIGFsb25nIHdpdGggdGhpcyB3b3JrOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sXG4gICAgICogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLlxuICAgICAqXG4gICAgICogUGxlYXNlIGNvbnRhY3QgT3JhY2xlLCA1MDAgT3JhY2xlIFBhcmt3YXksIFJlZHdvb2QgU2hvcmVzLCBDQSA5NDA2NSBVU0FcbiAgICAgKiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55XG4gICAgICogcXVlc3Rpb25zLlxuICAgICAqL1xuICAgIC8vIHBhY2thZ2UgamF2YS5pbztcbiAgICAvKipcbiAgICAgKiBUaGlzIGFic3RyYWN0IGNsYXNzIGlzIHRoZSBzdXBlcmNsYXNzIG9mIGFsbCBjbGFzc2VzIHJlcHJlc2VudGluZ1xuICAgICAqIGFuIG91dHB1dCBzdHJlYW0gb2YgYnl0ZXMuIEFuIG91dHB1dCBzdHJlYW0gYWNjZXB0cyBvdXRwdXQgYnl0ZXNcbiAgICAgKiBhbmQgc2VuZHMgdGhlbSB0byBzb21lIHNpbmsuXG4gICAgICogPHA+XG4gICAgICogQXBwbGljYXRpb25zIHRoYXQgbmVlZCB0byBkZWZpbmUgYSBzdWJjbGFzcyBvZlxuICAgICAqIDxjb2RlPk91dHB1dFN0cmVhbTwvY29kZT4gbXVzdCBhbHdheXMgcHJvdmlkZSBhdCBsZWFzdCBhIG1ldGhvZFxuICAgICAqIHRoYXQgd3JpdGVzIG9uZSBieXRlIG9mIG91dHB1dC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgIEFydGh1ciB2YW4gSG9mZlxuICAgICAqIEBzZWUgICAgIGphdmEuaW8uQnVmZmVyZWRPdXRwdXRTdHJlYW1cbiAgICAgKiBAc2VlICAgICBqYXZhLmlvLkJ5dGVBcnJheU91dHB1dFN0cmVhbVxuICAgICAqIEBzZWUgICAgIGphdmEuaW8uRGF0YU91dHB1dFN0cmVhbVxuICAgICAqIEBzZWUgICAgIGphdmEuaW8uRmlsdGVyT3V0cHV0U3RyZWFtXG4gICAgICogQHNlZSAgICAgamF2YS5pby5JbnB1dFN0cmVhbVxuICAgICAqIEBzZWUgICAgIGphdmEuaW8uT3V0cHV0U3RyZWFtI3dyaXRlKGludClcbiAgICAgKiBAc2luY2UgICBKREsxLjBcbiAgICAgKi9cbiAgICAvKnB1YmxpYyovIGNsYXNzIE91dHB1dFN0cmVhbSAvKmltcGxlbWVudHMgQ2xvc2VhYmxlLCBGbHVzaGFibGUqLyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgPGNvZGU+Yi5sZW5ndGg8L2NvZGU+IGJ5dGVzIGZyb20gdGhlIHNwZWNpZmllZCBieXRlIGFycmF5XG4gICAgICAgICAqIHRvIHRoaXMgb3V0cHV0IHN0cmVhbS4gVGhlIGdlbmVyYWwgY29udHJhY3QgZm9yIDxjb2RlPndyaXRlKGIpPC9jb2RlPlxuICAgICAgICAgKiBpcyB0aGF0IGl0IHNob3VsZCBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWZmZWN0IGFzIHRoZSBjYWxsXG4gICAgICAgICAqIDxjb2RlPndyaXRlKGIsIDAsIGIubGVuZ3RoKTwvY29kZT4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgICAgIGIgICB0aGUgZGF0YS5cbiAgICAgICAgICogQGV4Y2VwdGlvbiAgSU9FeGNlcHRpb24gIGlmIGFuIEkvTyBlcnJvciBvY2N1cnMuXG4gICAgICAgICAqIEBzZWUgICAgICAgIGphdmEuaW8uT3V0cHV0U3RyZWFtI3dyaXRlKGJ5dGVbXSwgaW50LCBpbnQpXG4gICAgICAgICAqL1xuICAgICAgICB3cml0ZUJ5dGVzKGIpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlc09mZnNldChiLCAwLCBiLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyA8Y29kZT5sZW48L2NvZGU+IGJ5dGVzIGZyb20gdGhlIHNwZWNpZmllZCBieXRlIGFycmF5XG4gICAgICAgICAqIHN0YXJ0aW5nIGF0IG9mZnNldCA8Y29kZT5vZmY8L2NvZGU+IHRvIHRoaXMgb3V0cHV0IHN0cmVhbS5cbiAgICAgICAgICogVGhlIGdlbmVyYWwgY29udHJhY3QgZm9yIDxjb2RlPndyaXRlKGIsIG9mZiwgbGVuKTwvY29kZT4gaXMgdGhhdFxuICAgICAgICAgKiBzb21lIG9mIHRoZSBieXRlcyBpbiB0aGUgYXJyYXkgPGNvZGU+YjwvY29kZT4gYXJlIHdyaXR0ZW4gdG8gdGhlXG4gICAgICAgICAqIG91dHB1dCBzdHJlYW0gaW4gb3JkZXI7IGVsZW1lbnQgPGNvZGU+YltvZmZdPC9jb2RlPiBpcyB0aGUgZmlyc3RcbiAgICAgICAgICogYnl0ZSB3cml0dGVuIGFuZCA8Y29kZT5iW29mZitsZW4tMV08L2NvZGU+IGlzIHRoZSBsYXN0IGJ5dGUgd3JpdHRlblxuICAgICAgICAgKiBieSB0aGlzIG9wZXJhdGlvbi5cbiAgICAgICAgICogPHA+XG4gICAgICAgICAqIFRoZSA8Y29kZT53cml0ZTwvY29kZT4gbWV0aG9kIG9mIDxjb2RlPk91dHB1dFN0cmVhbTwvY29kZT4gY2FsbHNcbiAgICAgICAgICogdGhlIHdyaXRlIG1ldGhvZCBvZiBvbmUgYXJndW1lbnQgb24gZWFjaCBvZiB0aGUgYnl0ZXMgdG8gYmVcbiAgICAgICAgICogd3JpdHRlbiBvdXQuIFN1YmNsYXNzZXMgYXJlIGVuY291cmFnZWQgdG8gb3ZlcnJpZGUgdGhpcyBtZXRob2QgYW5kXG4gICAgICAgICAqIHByb3ZpZGUgYSBtb3JlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICogPHA+XG4gICAgICAgICAqIElmIDxjb2RlPmI8L2NvZGU+IGlzIDxjb2RlPm51bGw8L2NvZGU+LCBhXG4gICAgICAgICAqIDxjb2RlPk51bGxQb2ludGVyRXhjZXB0aW9uPC9jb2RlPiBpcyB0aHJvd24uXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBJZiA8Y29kZT5vZmY8L2NvZGU+IGlzIG5lZ2F0aXZlLCBvciA8Y29kZT5sZW48L2NvZGU+IGlzIG5lZ2F0aXZlLCBvclxuICAgICAgICAgKiA8Y29kZT5vZmYrbGVuPC9jb2RlPiBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXlcbiAgICAgICAgICogPGNvZGU+YjwvY29kZT4sIHRoZW4gYW4gPHR0PkluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb248L3R0PiBpcyB0aHJvd24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgICAgIGIgICAgIHRoZSBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gICAgICBvZmYgICB0aGUgc3RhcnQgb2Zmc2V0IGluIHRoZSBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gICAgICBsZW4gICB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLlxuICAgICAgICAgKiBAZXhjZXB0aW9uICBJT0V4Y2VwdGlvbiAgaWYgYW4gSS9PIGVycm9yIG9jY3Vycy4gSW4gcGFydGljdWxhcixcbiAgICAgICAgICogICAgICAgICAgICAgYW4gPGNvZGU+SU9FeGNlcHRpb248L2NvZGU+IGlzIHRocm93biBpZiB0aGUgb3V0cHV0XG4gICAgICAgICAqICAgICAgICAgICAgIHN0cmVhbSBpcyBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB3cml0ZUJ5dGVzT2Zmc2V0KGIsIG9mZiwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE51bGxQb2ludGVyRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgob2ZmIDwgMCkgfHwgKG9mZiA+IGIubGVuZ3RoKSB8fCAobGVuIDwgMCkgfHxcbiAgICAgICAgICAgICAgICAoKG9mZiArIGxlbikgPiBiLmxlbmd0aCkgfHwgKChvZmYgKyBsZW4pIDwgMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGUoYltvZmYgKyBpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsdXNoZXMgdGhpcyBvdXRwdXQgc3RyZWFtIGFuZCBmb3JjZXMgYW55IGJ1ZmZlcmVkIG91dHB1dCBieXRlc1xuICAgICAgICAgKiB0byBiZSB3cml0dGVuIG91dC4gVGhlIGdlbmVyYWwgY29udHJhY3Qgb2YgPGNvZGU+Zmx1c2g8L2NvZGU+IGlzXG4gICAgICAgICAqIHRoYXQgY2FsbGluZyBpdCBpcyBhbiBpbmRpY2F0aW9uIHRoYXQsIGlmIGFueSBieXRlcyBwcmV2aW91c2x5XG4gICAgICAgICAqIHdyaXR0ZW4gaGF2ZSBiZWVuIGJ1ZmZlcmVkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgb3V0cHV0XG4gICAgICAgICAqIHN0cmVhbSwgc3VjaCBieXRlcyBzaG91bGQgaW1tZWRpYXRlbHkgYmUgd3JpdHRlbiB0byB0aGVpclxuICAgICAgICAgKiBpbnRlbmRlZCBkZXN0aW5hdGlvbi5cbiAgICAgICAgICogPHA+XG4gICAgICAgICAqIElmIHRoZSBpbnRlbmRlZCBkZXN0aW5hdGlvbiBvZiB0aGlzIHN0cmVhbSBpcyBhbiBhYnN0cmFjdGlvbiBwcm92aWRlZCBieVxuICAgICAgICAgKiB0aGUgdW5kZXJseWluZyBvcGVyYXRpbmcgc3lzdGVtLCBmb3IgZXhhbXBsZSBhIGZpbGUsIHRoZW4gZmx1c2hpbmcgdGhlXG4gICAgICAgICAqIHN0cmVhbSBndWFyYW50ZWVzIG9ubHkgdGhhdCBieXRlcyBwcmV2aW91c2x5IHdyaXR0ZW4gdG8gdGhlIHN0cmVhbSBhcmVcbiAgICAgICAgICogcGFzc2VkIHRvIHRoZSBvcGVyYXRpbmcgc3lzdGVtIGZvciB3cml0aW5nOyBpdCBkb2VzIG5vdCBndWFyYW50ZWUgdGhhdFxuICAgICAgICAgKiB0aGV5IGFyZSBhY3R1YWxseSB3cml0dGVuIHRvIGEgcGh5c2ljYWwgZGV2aWNlIHN1Y2ggYXMgYSBkaXNrIGRyaXZlLlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogVGhlIDxjb2RlPmZsdXNoPC9jb2RlPiBtZXRob2Qgb2YgPGNvZGU+T3V0cHV0U3RyZWFtPC9jb2RlPiBkb2VzIG5vdGhpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGNlcHRpb24gIElPRXhjZXB0aW9uICBpZiBhbiBJL08gZXJyb3Igb2NjdXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgZmx1c2goKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlcyB0aGlzIG91dHB1dCBzdHJlYW0gYW5kIHJlbGVhc2VzIGFueSBzeXN0ZW0gcmVzb3VyY2VzXG4gICAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHN0cmVhbS4gVGhlIGdlbmVyYWwgY29udHJhY3Qgb2YgPGNvZGU+Y2xvc2U8L2NvZGU+XG4gICAgICAgICAqIGlzIHRoYXQgaXQgY2xvc2VzIHRoZSBvdXRwdXQgc3RyZWFtLiBBIGNsb3NlZCBzdHJlYW0gY2Fubm90IHBlcmZvcm1cbiAgICAgICAgICogb3V0cHV0IG9wZXJhdGlvbnMgYW5kIGNhbm5vdCBiZSByZW9wZW5lZC5cbiAgICAgICAgICogPHA+XG4gICAgICAgICAqIFRoZSA8Y29kZT5jbG9zZTwvY29kZT4gbWV0aG9kIG9mIDxjb2RlPk91dHB1dFN0cmVhbTwvY29kZT4gZG9lcyBub3RoaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhjZXB0aW9uICBJT0V4Y2VwdGlvbiAgaWYgYW4gSS9PIGVycm9yIG9jY3Vycy5cbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIE91dE9mTWVtb3J5RXJyb3IgZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IChjKSAxOTk0LCAyMDEwLCBPcmFjbGUgYW5kL29yIGl0cyBhZmZpbGlhdGVzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICAgICAqIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi5cbiAgICAgKlxuICAgICAqIFRoaXMgY29kZSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXNcbiAgICAgKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbi4gIE9yYWNsZSBkZXNpZ25hdGVzIHRoaXNcbiAgICAgKiBwYXJ0aWN1bGFyIGZpbGUgYXMgc3ViamVjdCB0byB0aGUgXCJDbGFzc3BhdGhcIiBleGNlcHRpb24gYXMgcHJvdmlkZWRcbiAgICAgKiBieSBPcmFjbGUgaW4gdGhlIExJQ0VOU0UgZmlsZSB0aGF0IGFjY29tcGFuaWVkIHRoaXMgY29kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgY29kZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgICAqIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBvclxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgICAqIHZlcnNpb24gMiBmb3IgbW9yZSBkZXRhaWxzIChhIGNvcHkgaXMgaW5jbHVkZWQgaW4gdGhlIExJQ0VOU0UgZmlsZSB0aGF0XG4gICAgICogYWNjb21wYW5pZWQgdGhpcyBjb2RlKS5cbiAgICAgKlxuICAgICAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb25cbiAgICAgKiAyIGFsb25nIHdpdGggdGhpcyB3b3JrOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sXG4gICAgICogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLlxuICAgICAqXG4gICAgICogUGxlYXNlIGNvbnRhY3QgT3JhY2xlLCA1MDAgT3JhY2xlIFBhcmt3YXksIFJlZHdvb2QgU2hvcmVzLCBDQSA5NDA2NSBVU0FcbiAgICAgKiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55XG4gICAgICogcXVlc3Rpb25zLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBhbiBvdXRwdXQgc3RyZWFtIGluIHdoaWNoIHRoZSBkYXRhIGlzXG4gICAgICogd3JpdHRlbiBpbnRvIGEgYnl0ZSBhcnJheS4gVGhlIGJ1ZmZlciBhdXRvbWF0aWNhbGx5IGdyb3dzIGFzIGRhdGFcbiAgICAgKiBpcyB3cml0dGVuIHRvIGl0LlxuICAgICAqIFRoZSBkYXRhIGNhbiBiZSByZXRyaWV2ZWQgdXNpbmcgPGNvZGU+dG9CeXRlQXJyYXkoKTwvY29kZT4gYW5kXG4gICAgICogPGNvZGU+dG9TdHJpbmcoKTwvY29kZT4uXG4gICAgICogPHA+XG4gICAgICogQ2xvc2luZyBhIDx0dD5CeXRlQXJyYXlPdXRwdXRTdHJlYW08L3R0PiBoYXMgbm8gZWZmZWN0LiBUaGUgbWV0aG9kcyBpblxuICAgICAqIHRoaXMgY2xhc3MgY2FuIGJlIGNhbGxlZCBhZnRlciB0aGUgc3RyZWFtIGhhcyBiZWVuIGNsb3NlZCB3aXRob3V0XG4gICAgICogZ2VuZXJhdGluZyBhbiA8dHQ+SU9FeGNlcHRpb248L3R0Pi5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgIEFydGh1ciB2YW4gSG9mZlxuICAgICAqIEBzaW5jZSAgIEpESzEuMFxuICAgICAqL1xuICAgIC8qcHVibGljKi8gY2xhc3MgQnl0ZUFycmF5T3V0cHV0U3RyZWFtIGV4dGVuZHMgT3V0cHV0U3RyZWFtIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgYnl0ZSBhcnJheSBvdXRwdXQgc3RyZWFtLiBUaGUgYnVmZmVyIGNhcGFjaXR5IGlzXG4gICAgICAgICAqIGluaXRpYWxseSAzMiBieXRlcywgdGhvdWdoIGl0cyBzaXplIGluY3JlYXNlcyBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vICAgICB0aGlzKDMyKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBieXRlIGFycmF5IG91dHB1dCBzdHJlYW0sIHdpdGggYSBidWZmZXIgY2FwYWNpdHkgb2ZcbiAgICAgICAgICogdGhlIHNwZWNpZmllZCBzaXplLCBpbiBieXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAgc2l6ZSAgIHRoZSBpbml0aWFsIHNpemUuXG4gICAgICAgICAqIEBleGNlcHRpb24gIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBzaXplIGlzIG5lZ2F0aXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3Ioc2l6ZSA9IDMyKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGluIHRoZSBidWZmZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAgICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTmVnYXRpdmUgaW5pdGlhbCBzaXplOiAnXG4gICAgICAgICAgICAgICAgICAgICsgc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmNyZWFzZXMgdGhlIGNhcGFjaXR5IGlmIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhhdCBpdCBjYW4gaG9sZFxuICAgICAgICAgKiBhdCBsZWFzdCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHNwZWNpZmllZCBieSB0aGUgbWluaW11bVxuICAgICAgICAgKiBjYXBhY2l0eSBhcmd1bWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1pbkNhcGFjaXR5IHRoZSBkZXNpcmVkIG1pbmltdW0gY2FwYWNpdHlcbiAgICAgICAgICogQHRocm93cyBPdXRPZk1lbW9yeUVycm9yIGlmIHtAY29kZSBtaW5DYXBhY2l0eSA8IDB9LiAgVGhpcyBpc1xuICAgICAgICAgKiBpbnRlcnByZXRlZCBhcyBhIHJlcXVlc3QgZm9yIHRoZSB1bnNhdGlzZmlhYmx5IGxhcmdlIGNhcGFjaXR5XG4gICAgICAgICAqIHtAY29kZSAobG9uZykgSW50ZWdlci5NQVhfVkFMVUUgKyAobWluQ2FwYWNpdHkgLSBJbnRlZ2VyLk1BWF9WQUxVRSl9LlxuICAgICAgICAgKi9cbiAgICAgICAgZW5zdXJlQ2FwYWNpdHkobWluQ2FwYWNpdHkpIHtcbiAgICAgICAgICAgIC8vIG92ZXJmbG93LWNvbnNjaW91cyBjb2RlXG4gICAgICAgICAgICBpZiAobWluQ2FwYWNpdHkgLSB0aGlzLmJ1Zi5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdyhtaW5DYXBhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluY3JlYXNlcyB0aGUgY2FwYWNpdHkgdG8gZW5zdXJlIHRoYXQgaXQgY2FuIGhvbGQgYXQgbGVhc3QgdGhlXG4gICAgICAgICAqIG51bWJlciBvZiBlbGVtZW50cyBzcGVjaWZpZWQgYnkgdGhlIG1pbmltdW0gY2FwYWNpdHkgYXJndW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtaW5DYXBhY2l0eSB0aGUgZGVzaXJlZCBtaW5pbXVtIGNhcGFjaXR5XG4gICAgICAgICAqL1xuICAgICAgICBncm93KG1pbkNhcGFjaXR5KSB7XG4gICAgICAgICAgICAvLyBvdmVyZmxvdy1jb25zY2lvdXMgY29kZVxuICAgICAgICAgICAgbGV0IG9sZENhcGFjaXR5ID0gdGhpcy5idWYubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG5ld0NhcGFjaXR5ID0gb2xkQ2FwYWNpdHkgPDwgMTtcbiAgICAgICAgICAgIGlmIChuZXdDYXBhY2l0eSAtIG1pbkNhcGFjaXR5IDwgMClcbiAgICAgICAgICAgICAgICBuZXdDYXBhY2l0eSA9IG1pbkNhcGFjaXR5O1xuICAgICAgICAgICAgaWYgKG5ld0NhcGFjaXR5IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChtaW5DYXBhY2l0eSA8IDApIC8vIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPdXRPZk1lbW9yeUVycm9yKCk7XG4gICAgICAgICAgICAgICAgbmV3Q2FwYWNpdHkgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmID0gQXJyYXlzLmNvcHlPZlVpbnQ4QXJyYXkodGhpcy5idWYsIG5ld0NhcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIHRoZSBzcGVjaWZpZWQgYnl0ZSB0byB0aGlzIGJ5dGUgYXJyYXkgb3V0cHV0IHN0cmVhbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAgYiAgIHRoZSBieXRlIHRvIGJlIHdyaXR0ZW4uXG4gICAgICAgICAqL1xuICAgICAgICB3cml0ZShiKSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuY291bnQgKyAxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMuY291bnRdID0gLyooYnl0ZSkqLyBiO1xuICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgPGNvZGU+bGVuPC9jb2RlPiBieXRlcyBmcm9tIHRoZSBzcGVjaWZpZWQgYnl0ZSBhcnJheVxuICAgICAgICAgKiBzdGFydGluZyBhdCBvZmZzZXQgPGNvZGU+b2ZmPC9jb2RlPiB0byB0aGlzIGJ5dGUgYXJyYXkgb3V0cHV0IHN0cmVhbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAgYiAgICAgdGhlIGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSAgIG9mZiAgIHRoZSBzdGFydCBvZmZzZXQgaW4gdGhlIGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSAgIGxlbiAgIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuXG4gICAgICAgICAqL1xuICAgICAgICB3cml0ZUJ5dGVzT2Zmc2V0KGIsIG9mZiwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoKG9mZiA8IDApIHx8IChvZmYgPiBiLmxlbmd0aCkgfHwgKGxlbiA8IDApIHx8XG4gICAgICAgICAgICAgICAgKChvZmYgKyBsZW4pIC0gYi5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuY291bnQgKyBsZW4pO1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShiLCBvZmYsIHRoaXMuYnVmLCB0aGlzLmNvdW50LCBsZW4pO1xuICAgICAgICAgICAgdGhpcy5jb3VudCArPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyB0aGUgY29tcGxldGUgY29udGVudHMgb2YgdGhpcyBieXRlIGFycmF5IG91dHB1dCBzdHJlYW0gdG9cbiAgICAgICAgICogdGhlIHNwZWNpZmllZCBvdXRwdXQgc3RyZWFtIGFyZ3VtZW50LCBhcyBpZiBieSBjYWxsaW5nIHRoZSBvdXRwdXRcbiAgICAgICAgICogc3RyZWFtJ3Mgd3JpdGUgbWV0aG9kIHVzaW5nIDxjb2RlPm91dC53cml0ZShidWYsIDAsIGNvdW50KTwvY29kZT4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgICAgIG91dCAgIHRoZSBvdXRwdXQgc3RyZWFtIHRvIHdoaWNoIHRvIHdyaXRlIHRoZSBkYXRhLlxuICAgICAgICAgKiBAZXhjZXB0aW9uICBJT0V4Y2VwdGlvbiAgaWYgYW4gSS9PIGVycm9yIG9jY3Vycy5cbiAgICAgICAgICovXG4gICAgICAgIHdyaXRlVG8ob3V0KSB7XG4gICAgICAgICAgICBvdXQud3JpdGVCeXRlc09mZnNldCh0aGlzLmJ1ZiwgMCwgdGhpcy5jb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUgPGNvZGU+Y291bnQ8L2NvZGU+IGZpZWxkIG9mIHRoaXMgYnl0ZSBhcnJheSBvdXRwdXRcbiAgICAgICAgICogc3RyZWFtIHRvIHplcm8sIHNvIHRoYXQgYWxsIGN1cnJlbnRseSBhY2N1bXVsYXRlZCBvdXRwdXQgaW4gdGhlXG4gICAgICAgICAqIG91dHB1dCBzdHJlYW0gaXMgZGlzY2FyZGVkLiBUaGUgb3V0cHV0IHN0cmVhbSBjYW4gYmUgdXNlZCBhZ2FpbixcbiAgICAgICAgICogcmV1c2luZyB0aGUgYWxyZWFkeSBhbGxvY2F0ZWQgYnVmZmVyIHNwYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2VlICAgICBqYXZhLmlvLkJ5dGVBcnJheUlucHV0U3RyZWFtI2NvdW50XG4gICAgICAgICAqL1xuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3bHkgYWxsb2NhdGVkIGJ5dGUgYXJyYXkuIEl0cyBzaXplIGlzIHRoZSBjdXJyZW50XG4gICAgICAgICAqIHNpemUgb2YgdGhpcyBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgdmFsaWQgY29udGVudHMgb2YgdGhlIGJ1ZmZlclxuICAgICAgICAgKiBoYXZlIGJlZW4gY29waWVkIGludG8gaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mIHRoaXMgb3V0cHV0IHN0cmVhbSwgYXMgYSBieXRlIGFycmF5LlxuICAgICAgICAgKiBAc2VlICAgICBqYXZhLmlvLkJ5dGVBcnJheU91dHB1dFN0cmVhbSNzaXplKClcbiAgICAgICAgICovXG4gICAgICAgIHRvQnl0ZUFycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5cy5jb3B5T2ZVaW50OEFycmF5KHRoaXMuYnVmLCB0aGlzLmNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBidWZmZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gIHRoZSB2YWx1ZSBvZiB0aGUgPGNvZGU+Y291bnQ8L2NvZGU+IGZpZWxkLCB3aGljaCBpcyB0aGUgbnVtYmVyXG4gICAgICAgICAqICAgICAgICAgIG9mIHZhbGlkIGJ5dGVzIGluIHRoaXMgb3V0cHV0IHN0cmVhbS5cbiAgICAgICAgICogQHNlZSAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW0jY291bnRcbiAgICAgICAgICovXG4gICAgICAgIHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZyhwYXJhbSkge1xuICAgICAgICAgICAgaWYgKCFwYXJhbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nX3ZvaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmdfc3RyaW5nKHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nX251bWJlcihwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoZSBidWZmZXIncyBjb250ZW50cyBpbnRvIGEgc3RyaW5nIGRlY29kaW5nIGJ5dGVzIHVzaW5nIHRoZVxuICAgICAgICAgKiBwbGF0Zm9ybSdzIGRlZmF1bHQgY2hhcmFjdGVyIHNldC4gVGhlIGxlbmd0aCBvZiB0aGUgbmV3IDx0dD5TdHJpbmc8L3R0PlxuICAgICAgICAgKiBpcyBhIGZ1bmN0aW9uIG9mIHRoZSBjaGFyYWN0ZXIgc2V0LCBhbmQgaGVuY2UgbWF5IG5vdCBiZSBlcXVhbCB0byB0aGVcbiAgICAgICAgICogc2l6ZSBvZiB0aGUgYnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD4gVGhpcyBtZXRob2QgYWx3YXlzIHJlcGxhY2VzIG1hbGZvcm1lZC1pbnB1dCBhbmQgdW5tYXBwYWJsZS1jaGFyYWN0ZXJcbiAgICAgICAgICogc2VxdWVuY2VzIHdpdGggdGhlIGRlZmF1bHQgcmVwbGFjZW1lbnQgc3RyaW5nIGZvciB0aGUgcGxhdGZvcm0nc1xuICAgICAgICAgKiBkZWZhdWx0IGNoYXJhY3RlciBzZXQuIFRoZSB7QGxpbmtwbGFpbiBqYXZhLm5pby5jaGFyc2V0LkNoYXJzZXREZWNvZGVyfVxuICAgICAgICAgKiBjbGFzcyBzaG91bGQgYmUgdXNlZCB3aGVuIG1vcmUgY29udHJvbCBvdmVyIHRoZSBkZWNvZGluZyBwcm9jZXNzIGlzXG4gICAgICAgICAqIHJlcXVpcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIFN0cmluZyBkZWNvZGVkIGZyb20gdGhlIGJ1ZmZlcidzIGNvbnRlbnRzLlxuICAgICAgICAgKiBAc2luY2UgIEpESzEuMVxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmdfdm9pZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nKHRoaXMuYnVmIC8qLCAwLCB0aGlzLmNvdW50Ki8pLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoZSBidWZmZXIncyBjb250ZW50cyBpbnRvIGEgc3RyaW5nIGJ5IGRlY29kaW5nIHRoZSBieXRlcyB1c2luZ1xuICAgICAgICAgKiB0aGUgc3BlY2lmaWVkIHtAbGluayBqYXZhLm5pby5jaGFyc2V0LkNoYXJzZXQgY2hhcnNldE5hbWV9LiBUaGUgbGVuZ3RoIG9mXG4gICAgICAgICAqIHRoZSBuZXcgPHR0PlN0cmluZzwvdHQ+IGlzIGEgZnVuY3Rpb24gb2YgdGhlIGNoYXJzZXQsIGFuZCBoZW5jZSBtYXkgbm90IGJlXG4gICAgICAgICAqIGVxdWFsIHRvIHRoZSBsZW5ndGggb2YgdGhlIGJ5dGUgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPiBUaGlzIG1ldGhvZCBhbHdheXMgcmVwbGFjZXMgbWFsZm9ybWVkLWlucHV0IGFuZCB1bm1hcHBhYmxlLWNoYXJhY3RlclxuICAgICAgICAgKiBzZXF1ZW5jZXMgd2l0aCB0aGlzIGNoYXJzZXQncyBkZWZhdWx0IHJlcGxhY2VtZW50IHN0cmluZy4gVGhlIHtAbGlua1xuICAgICAgICAgKiBqYXZhLm5pby5jaGFyc2V0LkNoYXJzZXREZWNvZGVyfSBjbGFzcyBzaG91bGQgYmUgdXNlZCB3aGVuIG1vcmUgY29udHJvbFxuICAgICAgICAgKiBvdmVyIHRoZSBkZWNvZGluZyBwcm9jZXNzIGlzIHJlcXVpcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIGNoYXJzZXROYW1lICB0aGUgbmFtZSBvZiBhIHN1cHBvcnRlZFxuICAgICAgICAgKiAgICAgICAgICAgICAge0BsaW5rcGxhaW4gamF2YS5uaW8uY2hhcnNldC5DaGFyc2V0IDwvY29kZT5jaGFyc2V0PGNvZGU+fVxuICAgICAgICAgKiBAcmV0dXJuIFN0cmluZyBkZWNvZGVkIGZyb20gdGhlIGJ1ZmZlcidzIGNvbnRlbnRzLlxuICAgICAgICAgKiBAZXhjZXB0aW9uICBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uXG4gICAgICAgICAqICAgICAgICAgICAgIElmIHRoZSBuYW1lZCBjaGFyc2V0IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICogQHNpbmNlICAgSkRLMS4xXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZ19zdHJpbmcoY2hhcnNldE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nKHRoaXMuYnVmIC8qLCAwLCB0aGlzLmNvdW50LCBjaGFyc2V0TmFtZSovKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3bHkgYWxsb2NhdGVkIHN0cmluZy4gSXRzIHNpemUgaXMgdGhlIGN1cnJlbnQgc2l6ZSBvZlxuICAgICAgICAgKiB0aGUgb3V0cHV0IHN0cmVhbSBhbmQgdGhlIHZhbGlkIGNvbnRlbnRzIG9mIHRoZSBidWZmZXIgaGF2ZSBiZWVuXG4gICAgICAgICAqIGNvcGllZCBpbnRvIGl0LiBFYWNoIGNoYXJhY3RlciA8aT5jPC9pPiBpbiB0aGUgcmVzdWx0aW5nIHN0cmluZyBpc1xuICAgICAgICAgKiBjb25zdHJ1Y3RlZCBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgPGk+YjwvaT4gaW4gdGhlIGJ5dGVcbiAgICAgICAgICogYXJyYXkgc3VjaCB0aGF0OlxuICAgICAgICAgKiA8YmxvY2txdW90ZT48cHJlPlxuICAgICAgICAgKiAgICAgYyA9PSAoY2hhcikoKChoaWJ5dGUgJmFtcDsgMHhmZikgJmx0OyZsdDsgOCkgfCAoYiAmYW1wOyAweGZmKSlcbiAgICAgICAgICogPC9wcmU+PC9ibG9ja3F1b3RlPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCBkb2VzIG5vdCBwcm9wZXJseSBjb252ZXJ0IGJ5dGVzIGludG8gY2hhcmFjdGVycy5cbiAgICAgICAgICogQXMgb2YgSkRLJm5ic3A7MS4xLCB0aGUgcHJlZmVycmVkIHdheSB0byBkbyB0aGlzIGlzIHZpYSB0aGVcbiAgICAgICAgICogPGNvZGU+dG9TdHJpbmcoU3RyaW5nIGVuYyk8L2NvZGU+IG1ldGhvZCwgd2hpY2ggdGFrZXMgYW4gZW5jb2RpbmctbmFtZVxuICAgICAgICAgKiBhcmd1bWVudCwgb3IgdGhlIDxjb2RlPnRvU3RyaW5nKCk8L2NvZGU+IG1ldGhvZCwgd2hpY2ggdXNlcyB0aGVcbiAgICAgICAgICogcGxhdGZvcm0ncyBkZWZhdWx0IGNoYXJhY3RlciBlbmNvZGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAgICAgaGlieXRlICAgIHRoZSBoaWdoIGJ5dGUgb2YgZWFjaCByZXN1bHRpbmcgVW5pY29kZSBjaGFyYWN0ZXIuXG4gICAgICAgICAqIEByZXR1cm4gICAgIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mIHRoZSBvdXRwdXQgc3RyZWFtLCBhcyBhIHN0cmluZy5cbiAgICAgICAgICogQHNlZSAgICAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW0jc2l6ZSgpXG4gICAgICAgICAqIEBzZWUgICAgICAgIGphdmEuaW8uQnl0ZUFycmF5T3V0cHV0U3RyZWFtI3RvU3RyaW5nKFN0cmluZylcbiAgICAgICAgICogQHNlZSAgICAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW0jdG9TdHJpbmcoKVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQERlcHJlY2F0ZWRcbiAgICAgICAgdG9TdHJpbmdfbnVtYmVyKGhpYnl0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmcodGhpcy5idWYgLyosIGhpYnl0ZSwgMCwgdGhpcy5jb3VudCovKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zaW5nIGEgPHR0PkJ5dGVBcnJheU91dHB1dFN0cmVhbTwvdHQ+IGhhcyBubyBlZmZlY3QuIFRoZSBtZXRob2RzIGluXG4gICAgICAgICAqIHRoaXMgY2xhc3MgY2FuIGJlIGNhbGxlZCBhZnRlciB0aGUgc3RyZWFtIGhhcyBiZWVuIGNsb3NlZCB3aXRob3V0XG4gICAgICAgICAqIGdlbmVyYXRpbmcgYW4gPHR0PklPRXhjZXB0aW9uPC90dD4uXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIElPRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypwcml2YXRlKi8gdmFyIE1vZGUkMjtcbiAgICAoZnVuY3Rpb24gKE1vZGUpIHtcbiAgICAgICAgTW9kZVtNb2RlW1wiQUxQSEFcIl0gPSAwXSA9IFwiQUxQSEFcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiTE9XRVJcIl0gPSAxXSA9IFwiTE9XRVJcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiTUlYRURcIl0gPSAyXSA9IFwiTUlYRURcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiUFVOQ1RcIl0gPSAzXSA9IFwiUFVOQ1RcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiQUxQSEFfU0hJRlRcIl0gPSA0XSA9IFwiQUxQSEFfU0hJRlRcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiUFVOQ1RfU0hJRlRcIl0gPSA1XSA9IFwiUFVOQ1RfU0hJRlRcIjtcbiAgICB9KShNb2RlJDIgfHwgKE1vZGUkMiA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogSW5kaXJlY3RseSBhY2Nlc3MgdGhlIGdsb2JhbCBCaWdJbnQgY29uc3RydWN0b3IsIGl0XG4gICAgICogYWxsb3dzIGJyb3dzZXJzIHRoYXQgZG9lc24ndCBzdXBwb3J0IEJpZ0ludCB0byBydW5cbiAgICAgKiB0aGUgbGlicmFyeSB3aXRob3V0IGJyZWFraW5nIGR1ZSB0byBcInVuZGVmaW5lZCBCaWdJbnRcIlxuICAgICAqIGVycm9ycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRCaWdJbnRDb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93WydCaWdJbnQnXSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFsnQmlnSW50J10gfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZlsnQmlnSW50J10gfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3Qgc2VhcmNoIGdsb2JhbHMgZm9yIEJpZ0ludCEnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzdG9yZSB0aGUgQmlnSW50IGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGxldCBCaWdJbnRlZ2VyO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIGJpZ2ludCB2YWx1ZS4gSXQgYWxsb3dzIGJyb3dzZXJzXG4gICAgICogdGhhdCBkb2Vzbid0IHN1cHBvcnQgQmlnSW50IHRvIHJ1biB0aGUgcmVzdCBvZiB0aGUgbGlicmFyeVxuICAgICAqIGJ5IG5vdCBkaXJlY3RseSBhY2Nlc3NpbmcgdGhlIEJpZ0ludCBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCaWdJbnQobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgQmlnSW50ZWdlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIEJpZ0ludGVnZXIgPSBnZXRCaWdJbnRDb25zdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCaWdJbnRlZ2VyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBpcyBub3Qgc3VwcG9ydGVkIScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnRlZ2VyKG51bSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEVYUDkwMCgpIHtcbiAgICAgICAgLy8gaW4gSmF2YSAtIGFycmF5IHdpdGggbGVuZ3RoID0gMTZcbiAgICAgICAgbGV0IEVYUDkwMCA9IFtdO1xuICAgICAgICBFWFA5MDBbMF0gPSBjcmVhdGVCaWdJbnQoMSk7XG4gICAgICAgIGxldCBuaW5lSHVuZHJlZCA9IGNyZWF0ZUJpZ0ludCg5MDApO1xuICAgICAgICBFWFA5MDBbMV0gPSBuaW5lSHVuZHJlZDtcbiAgICAgICAgLy8gaW4gSmF2YSAtIGFycmF5IHdpdGggbGVuZ3RoID0gMTZcbiAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMjsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIEVYUDkwMFtpXSA9IEVYUDkwMFtpIC0gMV0gKiBuaW5lSHVuZHJlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRVhQOTAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiA8cD5UaGlzIGNsYXNzIGNvbnRhaW5zIHRoZSBtZXRob2RzIGZvciBkZWNvZGluZyB0aGUgUERGNDE3IGNvZGV3b3Jkcy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNJVEEgTGFiIChrZXZpbi5vc3VsbGl2YW5Ac2l0YS5hZXJvKVxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIge1xuICAgICAgICAvLyAgIHByaXZhdGUgRGVjb2RlZEJpdFN0cmVhbVBhcnNlcigpIHtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcGFyYW0gZWNMZXZlbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZShjb2Rld29yZHMsIGVjTGV2ZWwpIHtcbiAgICAgICAgICAgIC8vIHBhc3MgZW5jb2RpbmcgdG8gcmVzdWx0ICh3aWxsIGJlIHVzZWQgZm9yIGRlY29kZSBzeW1ib2xzIGluIGJ5dGUgbW9kZSlcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcignJyk7XG4gICAgICAgICAgICAvLyBsZXQgZW5jb2Rpbmc6IENoYXJzZXQgPSBTdGFuZGFyZENoYXJzZXRzLklTT184ODU5XzE7XG4gICAgICAgICAgICBsZXQgZW5jb2RpbmcgPSBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbm90ZSB0aGUgbmV4dCBjb21tYW5kIGlzIHNwZWNpZmljIGZyb20gdGhpcyBUeXBlU2NyaXB0IGxpYnJhcnlcbiAgICAgICAgICAgICAqIGJlY2F1c2UgVFMgY2FuJ3QgcHJvcGVybHkgY2FzdCBzb21lIHZhbHVlcyB0byBjaGFyIGFuZFxuICAgICAgICAgICAgICogY29udmVydCBpdCB0byBzdHJpbmcgbGF0ZXIgY29ycmVjdGx5IGR1ZSB0byBlbmNvZGluZ1xuICAgICAgICAgICAgICogZGlmZmVyZW5jZXMgZnJvbSBKYXZhIHZlcnNpb24uIEFzIHJlcG9ydGVkIGhlcmU6XG4gICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20venhpbmctanMvbGlicmFyeS9wdWxsLzI2NC9maWxlcyNyMzgyODMxNTkzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlc3VsdC5lbmFibGVEZWNvZGluZyhlbmNvZGluZyk7XG4gICAgICAgICAgICAvLyBHZXQgY29tcGFjdGlvbiBtb2RlXG4gICAgICAgICAgICBsZXQgY29kZUluZGV4ID0gMTtcbiAgICAgICAgICAgIGxldCBjb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcbiAgICAgICAgICAgIGxldCByZXN1bHRNZXRhZGF0YSA9IG5ldyBQREY0MTdSZXN1bHRNZXRhZGF0YSgpO1xuICAgICAgICAgICAgd2hpbGUgKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi50ZXh0Q29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0hfNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5ieXRlQ29tcGFjdGlvbihjb2RlLCBjb2Rld29yZHMsIGVuY29kaW5nLCBjb2RlSW5kZXgsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoLyooY2hhcikqLyBjb2Rld29yZHNbY29kZUluZGV4KytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1FUklDX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5udW1lcmljQ29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5FQ0lfQ0hBUlNFVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGFyc2V0RUNJID0gQ2hhcmFjdGVyU2V0RUNJLmdldENoYXJhY3RlclNldEVDSUJ5VmFsdWUoY29kZXdvcmRzW2NvZGVJbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmNvZGluZyA9IENoYXJzZXQuZm9yTmFtZShjaGFyc2V0RUNJLmdldE5hbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuRUNJX0dFTkVSQUxfUFVSUE9TRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbid0IGRvIGFueXRoaW5nIHdpdGggZ2VuZXJpYyBFQ0k7IHNraXAgaXRzIDIgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuRUNJX1VTRVJfREVGSU5FRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbid0IGRvIGFueXRoaW5nIHdpdGggdXNlciBFQ0k7IHNraXAgaXRzIDEgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5kZWNvZGVNYWNyb0Jsb2NrKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHRNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBub3Qgc2VlIHRoZXNlIG91dHNpZGUgYSBtYWNybyBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0byB0ZXh0IGNvbXBhY3Rpb24uIER1cmluZyB0ZXN0aW5nIG51bWVyb3VzIGJhcmNvZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcHBlYXJlZCB0byBiZSBtaXNzaW5nIHRoZSBzdGFydGluZyBtb2RlLiBJbiB0aGVzZSBjYXNlcyBkZWZhdWx0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byB0ZXh0IGNvbXBhY3Rpb24gc2VlbXMgdG8gd29yay5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlSW5kZXggPCBjb2Rld29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRlY29kZXJSZXN1bHQgPSBuZXcgRGVjb2RlclJlc3VsdChudWxsLCByZXN1bHQudG9TdHJpbmcoKSwgbnVsbCwgZWNMZXZlbCk7XG4gICAgICAgICAgICBkZWNvZGVyUmVzdWx0LnNldE90aGVyKHJlc3VsdE1ldGFkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVyUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW50XG4gICAgICAgICAqIEBwYXJhbSBwYXJhbTFcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcGFyYW0gaW50XG4gICAgICAgICAqIEBwYXJhbSBjb2RlSW5kZXhcbiAgICAgICAgICogQHBhcmFtIFBERjQxN1Jlc3VsdE1ldGFkYXRhXG4gICAgICAgICAqIEBwYXJhbSByZXN1bHRNZXRhZGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQFN1cHByZXNzV2FybmluZ3MoXCJkZXByZWNhdGlvblwiKVxuICAgICAgICBzdGF0aWMgZGVjb2RlTWFjcm9CbG9jayhjb2Rld29yZHMsIGNvZGVJbmRleCwgcmVzdWx0TWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmIChjb2RlSW5kZXggKyBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUyA+IGNvZGV3b3Jkc1swXSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIG11c3QgaGF2ZSBhdCBsZWFzdCB0d28gYnl0ZXMgbGVmdCBmb3IgdGhlIHNlZ21lbnQgaW5kZXhcbiAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZWdtZW50SW5kZXhBcnJheSA9IG5ldyBJbnQzMkFycmF5KERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1CRVJfT0ZfU0VRVUVOQ0VfQ09ERVdPUkRTKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUzsgaSsrLCBjb2RlSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRJbmRleEFycmF5W2ldID0gY29kZXdvcmRzW2NvZGVJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRTZWdtZW50SW5kZXgoSW50ZWdlci5wYXJzZUludChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuZGVjb2RlQmFzZTkwMHRvQmFzZTEwKHNlZ21lbnRJbmRleEFycmF5LCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUykpKTtcbiAgICAgICAgICAgIGxldCBmaWxlSWQgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4LCBmaWxlSWQpO1xuICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0RmlsZUlkKGZpbGVJZC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGxldCBvcHRpb25hbEZpZWxkc1N0YXJ0ID0gLTE7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmRzW2NvZGVJbmRleF0gPT09IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25hbEZpZWxkc1N0YXJ0ID0gY29kZUluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb2RlSW5kZXggPCBjb2Rld29yZHNbMF0pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGV3b3Jkc1tjb2RlSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2Rld29yZHNbY29kZUluZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9GSUxFX05BTUU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlTmFtZSA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi50ZXh0Q29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCArIDEsIGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0RmlsZU5hbWUoZmlsZU5hbWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9TRU5ERVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZW5kZXIgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIudGV4dENvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBzZW5kZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRTZW5kZXIoc2VuZGVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfQUREUkVTU0VFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkcmVzc2VlID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4ICsgMSwgYWRkcmVzc2VlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0QWRkcmVzc2VlKGFkZHJlc3NlZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX1NFR01FTlRfQ09VTlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZWdtZW50Q291bnQgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIubnVtZXJpY0NvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBzZWdtZW50Q291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRTZWdtZW50Q291bnQoSW50ZWdlci5wYXJzZUludChzZWdtZW50Q291bnQudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfVElNRV9TVEFNUDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpbWVzdGFtcCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5udW1lcmljQ29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCArIDEsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldFRpbWVzdGFtcChMb25nLnBhcnNlTG9uZyh0aW1lc3RhbXAudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfQ0hFQ0tTVU06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGVja3N1bSA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5udW1lcmljQ29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCArIDEsIGNoZWNrc3VtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0Q2hlY2tzdW0oSW50ZWdlci5wYXJzZUludChjaGVja3N1bS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9GSUxFX1NJWkU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlU2l6ZSA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5udW1lcmljQ29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCArIDEsIGZpbGVTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0RmlsZVNpemUoTG9uZy5wYXJzZUxvbmcoZmlsZVNpemUudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0TGFzdFNlZ21lbnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvcHkgb3B0aW9uYWwgZmllbGRzIHRvIGFkZGl0aW9uYWwgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKG9wdGlvbmFsRmllbGRzU3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9wdGlvbmFsRmllbGRzTGVuZ3RoID0gY29kZUluZGV4IC0gb3B0aW9uYWxGaWVsZHNTdGFydDtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0TWV0YWRhdGEuaXNMYXN0U2VnbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBpbmNsdWRlIHRlcm1pbmF0b3JcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxGaWVsZHNMZW5ndGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0T3B0aW9uYWxEYXRhKEFycmF5cy5jb3B5T2ZSYW5nZShjb2Rld29yZHMsIG9wdGlvbmFsRmllbGRzU3RhcnQsIG9wdGlvbmFsRmllbGRzU3RhcnQgKyBvcHRpb25hbEZpZWxkc0xlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGV4dCBDb21wYWN0aW9uIG1vZGUgKHNlZSA1LjQuMS41KSBwZXJtaXRzIGFsbCBwcmludGFibGUgQVNDSUkgY2hhcmFjdGVycyB0byBiZVxuICAgICAgICAgKiBlbmNvZGVkLCBpLmUuIHZhbHVlcyAzMiAtIDEyNiBpbmNsdXNpdmUgaW4gYWNjb3JkYW5jZSB3aXRoIElTTy9JRUMgNjQ2IChJUlYpLCBhc1xuICAgICAgICAgKiB3ZWxsIGFzIHNlbGVjdGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3JkcyBUaGUgYXJyYXkgb2YgY29kZXdvcmRzIChkYXRhICsgZXJyb3IpXG4gICAgICAgICAqIEBwYXJhbSBjb2RlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggaW50byB0aGUgY29kZXdvcmQgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSByZXN1bHQgICAgVGhlIGRlY29kZWQgZGF0YSBpcyBhcHBlbmRlZCB0byB0aGUgcmVzdWx0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBuZXh0IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIDIgY2hhcmFjdGVyIHBlciBjb2Rld29yZFxuICAgICAgICAgICAgbGV0IHRleHRDb21wYWN0aW9uRGF0YSA9IG5ldyBJbnQzMkFycmF5KChjb2Rld29yZHNbMF0gLSBjb2RlSW5kZXgpICogMik7XG4gICAgICAgICAgICAvLyBVc2VkIHRvIGhvbGQgdGhlIGJ5dGUgY29tcGFjdGlvbiB2YWx1ZSBpZiB0aGVyZSBpcyBhIG1vZGUgc2hpZnRcbiAgICAgICAgICAgIGxldCBieXRlQ29tcGFjdGlvbkRhdGEgPSBuZXcgSW50MzJBcnJheSgoY29kZXdvcmRzWzBdIC0gY29kZUluZGV4KSAqIDIpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBlbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICgoY29kZUluZGV4IDwgY29kZXdvcmRzWzBdKSAmJiAhZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRDb21wYWN0aW9uRGF0YVtpbmRleF0gPSBjb2RlIC8gMzA7XG4gICAgICAgICAgICAgICAgICAgIHRleHRDb21wYWN0aW9uRGF0YVtpbmRleCArIDFdID0gY29kZSAlIDMwO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWluaXRpYWxpemUgdGV4dCBjb21wYWN0aW9uIG1vZGUgdG8gYWxwaGEgc3ViIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29tcGFjdGlvbkRhdGFbaW5kZXgrK10gPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1FUklDX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19DT05UUk9MX0JMT0NLOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X1RFUk1JTkFUT1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIE1vZGUgU2hpZnQgY29kZXdvcmQgOTEzIHNoYWxsIGNhdXNlIGEgdGVtcG9yYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIGZyb20gVGV4dCBDb21wYWN0aW9uIG1vZGUgdG8gQnl0ZSBDb21wYWN0aW9uIG1vZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzd2l0Y2ggc2hhbGwgYmUgaW4gZWZmZWN0IGZvciBvbmx5IHRoZSBuZXh0IGNvZGV3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIHdoaWNoIHRoZSBtb2RlIHNoYWxsIHJldmVydCB0byB0aGUgcHJldmFpbGluZyBzdWItbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBUZXh0IENvbXBhY3Rpb24gbW9kZS4gQ29kZXdvcmQgOTEzIGlzIG9ubHkgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gVGV4dCBDb21wYWN0aW9uIG1vZGU7IGl0cyB1c2UgaXMgZGVzY3JpYmVkIGluIDUuNC4yLjQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbXBhY3Rpb25EYXRhW2luZGV4XSA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVDb21wYWN0aW9uRGF0YVtpbmRleF0gPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuZGVjb2RlVGV4dENvbXBhY3Rpb24odGV4dENvbXBhY3Rpb25EYXRhLCBieXRlQ29tcGFjdGlvbkRhdGEsIGluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFRleHQgQ29tcGFjdGlvbiBtb2RlIGluY2x1ZGVzIGFsbCB0aGUgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcnNcbiAgICAgICAgICogKGkuZS4gdmFsdWVzIGZyb20gMzIgdG8gMTI2KSBhbmQgdGhyZWUgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzOiBIVCBvciB0YWJcbiAgICAgICAgICogKDk6IGUpLCBMRiBvciBsaW5lIGZlZWQgKDEwOiBlKSwgYW5kIENSIG9yIGNhcnJpYWdlXG4gICAgICAgICAqIHJldHVybiAoMTM6IGUpLiBUaGUgVGV4dCBDb21wYWN0aW9uIG1vZGUgYWxzbyBpbmNsdWRlcyB2YXJpb3VzIGxhdGNoXG4gICAgICAgICAqIGFuZCBzaGlmdCBjaGFyYWN0ZXJzIHdoaWNoIGFyZSB1c2VkIGV4Y2x1c2l2ZWx5IHdpdGhpbiB0aGUgbW9kZS4gVGhlIFRleHRcbiAgICAgICAgICogQ29tcGFjdGlvbiBtb2RlIGVuY29kZXMgdXAgdG8gMiBjaGFyYWN0ZXJzIHBlciBjb2Rld29yZC4gVGhlIGNvbXBhY3Rpb24gcnVsZXNcbiAgICAgICAgICogZm9yIGNvbnZlcnRpbmcgZGF0YSBpbnRvIFBERjQxNyBjb2Rld29yZHMgYXJlIGRlZmluZWQgaW4gNS40LjIuMi4gVGhlIHN1Yi1tb2RlXG4gICAgICAgICAqIHN3aXRjaGVzIGFyZSBkZWZpbmVkIGluIDUuNC4yLjMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0ZXh0Q29tcGFjdGlvbkRhdGEgVGhlIHRleHQgY29tcGFjdGlvbiBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUNvbXBhY3Rpb25EYXRhIFRoZSBieXRlIGNvbXBhY3Rpb24gZGF0YSBpZiB0aGVyZVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcyBhIG1vZGUgc2hpZnQuXG4gICAgICAgICAqIEBwYXJhbSBsZW5ndGggICAgICAgICAgICAgVGhlIHNpemUgb2YgdGhlIHRleHQgY29tcGFjdGlvbiBhbmQgYnl0ZSBjb21wYWN0aW9uIGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSByZXN1bHQgICAgICAgICAgICAgVGhlIGRlY29kZWQgZGF0YSBpcyBhcHBlbmRlZCB0byB0aGUgcmVzdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZVRleHRDb21wYWN0aW9uKHRleHRDb21wYWN0aW9uRGF0YSwgYnl0ZUNvbXBhY3Rpb25EYXRhLCBsZW5ndGgsIHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gQmVnaW5uaW5nIGZyb20gYW4gaW5pdGlhbCBzdGF0ZSBvZiB0aGUgQWxwaGEgc3ViLW1vZGVcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGNvbXBhY3Rpb24gbW9kZSBmb3IgUERGNDE3IGluIGVmZmVjdCBhdCB0aGUgc3RhcnQgb2YgZWFjaCBzeW1ib2wgc2hhbGwgYWx3YXlzIGJlIFRleHRcbiAgICAgICAgICAgIC8vIENvbXBhY3Rpb24gbW9kZSBBbHBoYSBzdWItbW9kZSAoYWxwaGFiZXRpYzogdXBwZXJjYXNlKS4gQSBsYXRjaCBjb2Rld29yZCBmcm9tIGFub3RoZXIgbW9kZSB0byB0aGUgVGV4dFxuICAgICAgICAgICAgLy8gQ29tcGFjdGlvbiBtb2RlIHNoYWxsIGFsd2F5cyBzd2l0Y2ggdG8gdGhlIFRleHQgQ29tcGFjdGlvbiBBbHBoYSBzdWItbW9kZS5cbiAgICAgICAgICAgIGxldCBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgbGV0IHByaW9yVG9TaGlmdE1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBzdWJNb2RlQ2ggPSB0ZXh0Q29tcGFjdGlvbkRhdGFbaV07XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gLypjaGFyKi8gJyc7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQyLkFMUEhBOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxwaGEgKGFscGhhYmV0aWM6IHVwcGVyY2FzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCAyNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwcGVyIGNhc2UgQWxwaGEgQ2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogNjUgPSAnQScgQVNDSUkgLT4gdGhlcmUgaXMgYnl0ZSBjb2RlIG9mIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gLyooY2hhcikoJ0EnICsgc3ViTW9kZUNoKSAqLyBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgc3ViTW9kZUNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5MTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuTE9XRVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLk1JWEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hpZnQgdG8gcHVuY3R1YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yVG9TaGlmdE1vZGUgPSBzdWJNb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5QVU5DVF9TSElGVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGJ5dGVDb21wYWN0aW9uRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQyLkxPV0VSOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG93ZXIgKGFscGhhYmV0aWM6IGxvd2VyY2FzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCAyNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gLyooY2hhcikoJ2EnICsgc3ViTW9kZUNoKSovIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBzdWJNb2RlQ2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlQ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkFTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hpZnQgdG8gYWxwaGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yVG9TaGlmdE1vZGUgPSBzdWJNb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5BTFBIQV9TSElGVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuTUlYRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUFM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGlmdCB0byBwdW5jdHVhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JUb1NoaWZ0TW9kZSA9IHN1Yk1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLlBVTkNUX1NISUZUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIERvZXMgdGhpcyBuZWVkIHRvIHVzZSB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZW5jb2Rpbmc/IFNlZSBvdGhlciBvY2N1cnJlbmNlcyBiZWxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGJ5dGVDb21wYWN0aW9uRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQyLk1JWEVEOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWl4ZWQgKHB1bmN0dWF0aW9uOiBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk1vZGVDaCA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1JWEVEX0NIQVJTW3N1Yk1vZGVDaF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1Yk1vZGVDaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuUFVOQ1Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkxMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5MT1dFUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5BTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUFM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGlmdCB0byBwdW5jdHVhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JUb1NoaWZ0TW9kZSA9IHN1Yk1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLlBVTkNUX1NISUZUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKC8qKGNoYXIpKi8gYnl0ZUNvbXBhY3Rpb25EYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDIuUFVOQ1Q6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdW5jdHVhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk1vZGVDaCA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QVU5DVF9DSEFSU1tzdWJNb2RlQ2hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlQ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUEFMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5BTFBIQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGJ5dGVDb21wYWN0aW9uRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQyLkFMUEhBX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBzdWItbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IHByaW9yVG9TaGlmdE1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViTW9kZUNoIDwgMjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IC8qKGNoYXIpKCdBJyArIHN1Yk1vZGVDaCkqLyBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgc3ViTW9kZUNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDIuUFVOQ1RfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHN1Yi1tb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gcHJpb3JUb1NoaWZ0TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUEFMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUFVOQ1RfQ0hBUlNbc3ViTW9kZUNoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBBTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBTIGJlZm9yZSBTaGlmdC10by1CeXRlIGlzIHVzZWQgYXMgYSBwYWRkaW5nIGNoYXJhY3RlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSA1LjQuMi40IG9mIHRoZSBzcGVjaWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKC8qKGNoYXIpKi8gYnl0ZUNvbXBhY3Rpb25EYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgKGNoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgZGVjb2RlZCBjaGFyYWN0ZXIgdG8gcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoY2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ5dGUgQ29tcGFjdGlvbiBtb2RlIChzZWUgNS40LjMpIHBlcm1pdHMgYWxsIDI1NiBwb3NzaWJsZSA4LWJpdCBieXRlIHZhbHVlcyB0byBiZSBlbmNvZGVkLlxuICAgICAgICAgKiBUaGlzIGluY2x1ZGVzIGFsbCBBU0NJSSBjaGFyYWN0ZXJzIHZhbHVlIDAgdG8gMTI3IGluY2x1c2l2ZSBhbmQgcHJvdmlkZXMgZm9yIGludGVybmF0aW9uYWxcbiAgICAgICAgICogY2hhcmFjdGVyIHNldCBzdXBwb3J0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbW9kZSAgICAgIFRoZSBieXRlIGNvbXBhY3Rpb24gbW9kZSBpLmUuIDkwMSBvciA5MjRcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3JkcyBUaGUgYXJyYXkgb2YgY29kZXdvcmRzIChkYXRhICsgZXJyb3IpXG4gICAgICAgICAqIEBwYXJhbSBlbmNvZGluZyAgQ3VycmVudGx5IGFjdGl2ZSBjaGFyYWN0ZXIgZW5jb2RpbmdcbiAgICAgICAgICogQHBhcmFtIGNvZGVJbmRleCBUaGUgY3VycmVudCBpbmRleCBpbnRvIHRoZSBjb2Rld29yZCBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHJlc3VsdCAgICBUaGUgZGVjb2RlZCBkYXRhIGlzIGFwcGVuZGVkIHRvIHRoZSByZXN1bHQuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIG5leHQgaW5kZXggaW50byB0aGUgY29kZXdvcmQgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgLyppbnQqLyBieXRlQ29tcGFjdGlvbihtb2RlLCBjb2Rld29yZHMsIGVuY29kaW5nLCBjb2RlSW5kZXgsIHJlc3VsdCkge1xuICAgICAgICAgICAgbGV0IGRlY29kZWRCeXRlcyA9IG5ldyBCeXRlQXJyYXlPdXRwdXRTdHJlYW0oKTtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAvKmxvbmcqLyAwO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBCeXRlIENvbXBhY3Rpb24gY2hhcmFjdGVycyB0byBiZSBlbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCBhIG11bHRpcGxlIG9mIDZcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJ5dGVDb21wYWN0ZWRDb2Rld29yZHMgPSBuZXcgSW50MzJBcnJheSg2KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRDb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjb2RlSW5kZXggPCBjb2Rld29yZHNbMF0pICYmICFlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVDb21wYWN0ZWRDb2Rld29yZHNbY291bnQrK10gPSBuZXh0Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhc2UgOTAwXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDkwMCAqIHZhbHVlICsgbmV4dENvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwZXJoYXBzIGl0IHNob3VsZCBiZSBvayB0byBjaGVjayBvbmx5IG5leHRDb2RlID49IFRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5leHRDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0hfNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X1RFUk1JTkFUT1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ICUgNSA9PT0gMCkgJiYgKGNvdW50ID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlY29kZSBldmVyeSA1IGNvZGV3b3Jkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBCYXNlIDI1NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiAvKmludCovID0gMDsgaiA8IDY7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEBub3RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSmF2YVNjcmlwdCBzdG9yZXMgbnVtYmVycyBhcyA2NCBiaXRzIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIGJ1dCBhbGwgYml0d2lzZSBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgb24gMzIgYml0cyBiaW5hcnkgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTbyB0aGUgbmV4dCBiaXR3aXNlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgZG9uZSB3aXRoIHNpbXBsZSBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZEJ5dGVzLndyaXRlKC8qKGJ5dGUpKi8gTnVtYmVyKGNyZWF0ZUJpZ0ludCh2YWx1ZSkgPj4gY3JlYXRlQmlnSW50KDggKiAoNSAtIGopKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBlbmQgb2YgYWxsIGNvZGV3b3JkcyBpcyByZWFjaGVkIHRoZSBsYXN0IGNvZGV3b3JkIG5lZWRzIHRvIGJlIGFkZGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlSW5kZXggPT09IGNvZGV3b3Jkc1swXSAmJiBuZXh0Q29kZSA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUNvbXBhY3RlZENvZGV3b3Jkc1tjb3VudCsrXSA9IG5leHRDb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIEJ5dGUgQ29tcGFjdGlvbiBtb2RlIGlzIGludm9rZWQgd2l0aCBjb2Rld29yZCA5MDEsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBsYXN0IGdyb3VwIG9mIGNvZGV3b3JkcyBpcyBpbnRlcnByZXRlZCBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBvbmUgYnl0ZSBwZXIgY29kZXdvcmQsIHdpdGhvdXQgY29tcGFjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRCeXRlcy53cml0ZSgvKihieXRlKSovIGJ5dGVDb21wYWN0ZWRDb2Rld29yZHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBCeXRlIENvbXBhY3Rpb24gY2hhcmFjdGVycyB0byBiZSBlbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGFuIGludGVnZXIgbXVsdGlwbGUgb2YgNlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29kZUluZGV4IDwgY29kZXdvcmRzWzBdICYmICFlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXNlIDkwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gOTAwICogdmFsdWUgKyBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19DT05UUk9MX0JMT0NLOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb3VudCAlIDUgPT09IDApICYmIChjb3VudCA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVjb2RlIGV2ZXJ5IDUgY29kZXdvcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBCYXNlIDI1NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEBub3RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSmF2YVNjcmlwdCBzdG9yZXMgbnVtYmVycyBhcyA2NCBiaXRzIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIGJ1dCBhbGwgYml0d2lzZSBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgb24gMzIgYml0cyBiaW5hcnkgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTbyB0aGUgbmV4dCBiaXR3aXNlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgZG9uZSB3aXRoIHNpbXBsZSBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqIC8qaW50Ki8gPSAwOyBqIDwgNjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRCeXRlcy53cml0ZSgvKihieXRlKSovIE51bWJlcihjcmVhdGVCaWdJbnQodmFsdWUpID4+IGNyZWF0ZUJpZ0ludCg4ICogKDUgLSBqKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmcuZGVjb2RlKGRlY29kZWRCeXRlcy50b0J5dGVBcnJheSgpLCBlbmNvZGluZykpO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTnVtZXJpYyBDb21wYWN0aW9uIG1vZGUgKHNlZSA1LjQuNCkgcGVybWl0cyBlZmZpY2llbnQgZW5jb2Rpbmcgb2YgbnVtZXJpYyBkYXRhIHN0cmluZ3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb2Rld29yZHMgVGhlIGFycmF5IG9mIGNvZGV3b3JkcyAoZGF0YSArIGVycm9yKVxuICAgICAgICAgKiBAcGFyYW0gY29kZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gcmVzdWx0ICAgIFRoZSBkZWNvZGVkIGRhdGEgaXMgYXBwZW5kZWQgdG8gdGhlIHJlc3VsdC5cbiAgICAgICAgICogQHJldHVybiBUaGUgbmV4dCBpbmRleCBpbnRvIHRoZSBjb2Rld29yZCBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBudW1lcmljQ29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCAvKmludCovLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgZW5kID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbnVtZXJpY0NvZGV3b3JkcyA9IG5ldyBJbnQzMkFycmF5KERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQVhfTlVNRVJJQ19DT0RFV09SRFMpO1xuICAgICAgICAgICAgd2hpbGUgKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSAmJiAhZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlSW5kZXggPT09IGNvZGV3b3Jkc1swXSkge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29kZSA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCkge1xuICAgICAgICAgICAgICAgICAgICBudW1lcmljQ29kZXdvcmRzW2NvdW50XSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSF82OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X0NPTlRST0xfQkxPQ0s6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoY291bnQgJSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFYX05VTUVSSUNfQ09ERVdPUkRTID09PSAwIHx8IGNvZGUgPT09IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1FUklDX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCB8fCBlbmQpICYmIGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZS1pbnZva2luZyBOdW1lcmljIENvbXBhY3Rpb24gbW9kZSAoYnkgdXNpbmcgY29kZXdvcmQgOTAyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIGluIE51bWVyaWMgQ29tcGFjdGlvbiBtb2RlKSBzZXJ2ZXMgIHRvIHRlcm1pbmF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBOdW1lcmljIENvbXBhY3Rpb24gbW9kZSBncm91cGluZyBhcyBkZXNjcmliZWQgaW4gNS40LjQuMixcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZW4gdG8gc3RhcnQgYSBuZXcgb25lIGdyb3VwaW5nLlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5kZWNvZGVCYXNlOTAwdG9CYXNlMTAobnVtZXJpY0NvZGV3b3JkcywgY291bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2RlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgYSBsaXN0IG9mIE51bWVyaWMgQ29tcGFjdGVkIGNvZGV3b3JkcyBmcm9tIEJhc2UgOTAwIHRvIEJhc2UgMTAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb2Rld29yZHMgVGhlIGFycmF5IG9mIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcGFyYW0gY291bnQgICAgIFRoZSBudW1iZXIgb2YgY29kZXdvcmRzXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGRlY29kZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgTnVtZXJpYyBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFWEFNUExFXG4gICAgICAgICAqIEVuY29kZSB0aGUgZmlmdGVlbiBkaWdpdCBudW1lcmljIHN0cmluZyAwMDAyMTMyOTgxNzQwMDBcbiAgICAgICAgICogUHJlZml4IHRoZSBudW1lcmljIHN0cmluZyB3aXRoIGEgMSBhbmQgc2V0IHRoZSBpbml0aWFsIHZhbHVlIG9mXG4gICAgICAgICAqIHQgPSAxIDAwMCAyMTMgMjk4IDE3NCAwMDBcbiAgICAgICAgICogQ2FsY3VsYXRlIGNvZGV3b3JkIDBcbiAgICAgICAgICogZDAgPSAxIDAwMCAyMTMgMjk4IDE3NCAwMDAgbW9kIDkwMCA9IDIwMFxuICAgICAgICAgKlxuICAgICAgICAgKiB0ID0gMSAwMDAgMjEzIDI5OCAxNzQgMDAwIGRpdiA5MDAgPSAxIDExMSAzNDggMTA5IDA4MlxuICAgICAgICAgKiBDYWxjdWxhdGUgY29kZXdvcmQgMVxuICAgICAgICAgKiBkMSA9IDEgMTExIDM0OCAxMDkgMDgyIG1vZCA5MDAgPSAyODJcbiAgICAgICAgICpcbiAgICAgICAgICogdCA9IDEgMTExIDM0OCAxMDkgMDgyIGRpdiA5MDAgPSAxIDIzNCA4MzEgMjMyXG4gICAgICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCAyXG4gICAgICAgICAqIGQyID0gMSAyMzQgODMxIDIzMiBtb2QgOTAwID0gNjMyXG4gICAgICAgICAqXG4gICAgICAgICAqIHQgPSAxIDIzNCA4MzEgMjMyIGRpdiA5MDAgPSAxIDM3MiAwMzRcbiAgICAgICAgICogQ2FsY3VsYXRlIGNvZGV3b3JkIDNcbiAgICAgICAgICogZDMgPSAxIDM3MiAwMzQgbW9kIDkwMCA9IDQzNFxuICAgICAgICAgKlxuICAgICAgICAgKiB0ID0gMSAzNzIgMDM0IGRpdiA5MDAgPSAxIDUyNFxuICAgICAgICAgKiBDYWxjdWxhdGUgY29kZXdvcmQgNFxuICAgICAgICAgKiBkNCA9IDEgNTI0IG1vZCA5MDAgPSA2MjRcbiAgICAgICAgICpcbiAgICAgICAgICogdCA9IDEgNTI0IGRpdiA5MDAgPSAxXG4gICAgICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCA1XG4gICAgICAgICAqIGQ1ID0gMSBtb2QgOTAwID0gMVxuICAgICAgICAgKiB0ID0gMSBkaXYgOTAwID0gMFxuICAgICAgICAgKiBDb2Rld29yZCBzZXF1ZW5jZSBpczogMSwgNjI0LCA0MzQsIDYzMiwgMjgyLCAyMDBcbiAgICAgICAgICpcbiAgICAgICAgICogRGVjb2RlIHRoZSBhYm92ZSBjb2Rld29yZHMgaW52b2x2ZXNcbiAgICAgICAgICogICAxIHggOTAwIHBvd2VyIG9mIDUgKyA2MjQgeCA5MDAgcG93ZXIgb2YgNCArIDQzNCB4IDkwMCBwb3dlciBvZiAzICtcbiAgICAgICAgICogNjMyIHggOTAwIHBvd2VyIG9mIDIgKyAyODIgeCA5MDAgcG93ZXIgb2YgMSArIDIwMCB4IDkwMCBwb3dlciBvZiAwID0gMTAwMDIxMzI5ODE3NDAwMFxuICAgICAgICAgKlxuICAgICAgICAgKiBSZW1vdmUgbGVhZGluZyAxID0+ICBSZXN1bHQgaXMgMDAwMjEzMjk4MTc0MDAwXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlQmFzZTkwMHRvQmFzZTEwKGNvZGV3b3JkcywgY291bnQpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBjcmVhdGVCaWdJbnQoMCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuRVhQOTAwW2NvdW50IC0gaSAtIDFdICogY3JlYXRlQmlnSW50KGNvZGV3b3Jkc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0U3RyaW5nID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0U3RyaW5nLmNoYXJBdCgwKSAhPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFN0cmluZy5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIID0gOTAwO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCA9IDkwMTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0ggPSA5MDI7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzYgPSA5MjQ7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkVDSV9VU0VSX0RFRklORUQgPSA5MjU7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkVDSV9HRU5FUkFMX1BVUlBPU0UgPSA5MjY7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkVDSV9DSEFSU0VUID0gOTI3O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSyA9IDkyODtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEID0gOTIzO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfVEVSTUlOQVRPUiA9IDkyMjtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERSA9IDkxMztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFYX05VTUVSSUNfQ09ERVdPUkRTID0gMTU7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9GSUxFX05BTUUgPSAwO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfU0VHTUVOVF9DT1VOVCA9IDE7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9USU1FX1NUQU1QID0gMjtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX1NFTkRFUiA9IDM7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9BRERSRVNTRUUgPSA0O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfRklMRV9TSVpFID0gNTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0NIRUNLU1VNID0gNjtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUEwgPSAyNTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTEwgPSAyNztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQVMgPSAyNztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUwgPSAyODtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQUwgPSAyODtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUFMgPSAyOTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUEFMID0gMjk7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBVTkNUX0NIQVJTID0gJzs8PkBbXFxcXF1fYH4hXFxyXFx0LDpcXG4tLiQvXCJ8KigpP3t9XFwnJztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUlYRURfQ0hBUlMgPSAnMDEyMzQ1Njc4OSZcXHJcXHQsOiMtLiQvKyUqPV4nO1xuICAgIC8qKlxuICAgICAqIFRhYmxlIGNvbnRhaW5pbmcgdmFsdWVzIGZvciB0aGUgZXhwb25lbnQgb2YgOTAwLlxuICAgICAqIFRoaXMgaXMgdXNlZCBpbiB0aGUgbnVtZXJpYyBjb21wYWN0aW9uIGRlY29kZSBhbGdvcml0aG0uXG4gICAgICovXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkVYUDkwMCA9IGdldEJpZ0ludENvbnN0cnVjdG9yKCkgPyBnZXRFWFA5MDAoKSA6IFtdO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1CRVJfT0ZfU0VRVUVOQ0VfQ09ERVdPUkRTID0gMjtcblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0O1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbjtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkZvcm1hdHRlcjtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkxpc3Q7XG4gICAgLyoqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBQREY0MTdTY2FubmluZ0RlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQFRPRE8gZG9uJ3QgcGFzcyBpbiBtaW5Db2Rld29yZFdpZHRoIGFuZCBtYXhDb2Rld29yZFdpZHRoLCBwYXNzIGluIGJhcmNvZGUgY29sdW1ucyBmb3Igc3RhcnQgYW5kIHN0b3AgcGF0dGVyblxuICAgICAgICAgKlxuICAgICAgICAgKiBjb2x1bW5zLiBUaGF0IHdheSB3aWR0aCBjYW4gYmUgZGVkdWN0ZWQgZnJvbSB0aGUgcGF0dGVybiBjb2x1bW4uXG4gICAgICAgICAqIFRoaXMgYXBwcm9hY2ggYWxzbyBhbGxvd3MgdG8gZGV0ZWN0IG1vcmUgZGV0YWlscyBhYm91dCB0aGUgYmFyY29kZSwgZS5nLiBpZiBhIGJhciB0eXBlICh3aGl0ZSBvciBibGFjaykgaXMgd2lkZXJcbiAgICAgICAgICogdGhhbiBpdCBzaG91bGQgYmUuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgc2Nhbm5lciB1c2VkIGEgYmFkIGJsYWNrcG9pbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBCaXRNYXRyaXhcbiAgICAgICAgICogQHBhcmFtIGltYWdlXG4gICAgICAgICAqIEBwYXJhbSBSZXN1bHRQb2ludFxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VUb3BMZWZ0XG4gICAgICAgICAqIEBwYXJhbSBSZXN1bHRQb2ludFxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VCb3R0b21MZWZ0XG4gICAgICAgICAqIEBwYXJhbSBSZXN1bHRQb2ludFxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VUb3BSaWdodFxuICAgICAgICAgKiBAcGFyYW0gUmVzdWx0UG9pbnRcbiAgICAgICAgICogQHBhcmFtIGltYWdlQm90dG9tUmlnaHRcbiAgICAgICAgICogQHBhcmFtIGludFxuICAgICAgICAgKiBAcGFyYW0gbWluQ29kZXdvcmRXaWR0aFxuICAgICAgICAgKiBAcGFyYW0gaW50XG4gICAgICAgICAqIEBwYXJhbSBtYXhDb2Rld29yZFdpZHRoXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZShpbWFnZSwgaW1hZ2VUb3BMZWZ0LCBpbWFnZUJvdHRvbUxlZnQsIGltYWdlVG9wUmlnaHQsIGltYWdlQm90dG9tUmlnaHQsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpIHtcbiAgICAgICAgICAgIGxldCBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveChpbWFnZSwgaW1hZ2VUb3BMZWZ0LCBpbWFnZUJvdHRvbUxlZnQsIGltYWdlVG9wUmlnaHQsIGltYWdlQm90dG9tUmlnaHQpO1xuICAgICAgICAgICAgbGV0IGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4gPSBudWxsO1xuICAgICAgICAgICAgbGV0IHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBkZXRlY3Rpb25SZXN1bHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBmaXJzdFBhc3MgLypib29sZWFuKi8gPSB0cnVlOzsgZmlyc3RQYXNzID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VUb3BMZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFJvd0luZGljYXRvckNvbHVtbiA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRSb3dJbmRpY2F0b3JDb2x1bW4oaW1hZ2UsIGJvdW5kaW5nQm94LCBpbWFnZVRvcExlZnQsIHRydWUsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VUb3BSaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldFJvd0luZGljYXRvckNvbHVtbihpbWFnZSwgYm91bmRpbmdCb3gsIGltYWdlVG9wUmlnaHQsIGZhbHNlLCBtaW5Db2Rld29yZFdpZHRoLCBtYXhDb2Rld29yZFdpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLm1lcmdlKGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4sIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0aW9uUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgTm90Rm91bmRFeGNlcHRpb24uZ2V0Tm90Rm91bmRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0Qm94ID0gZGV0ZWN0aW9uUmVzdWx0LmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0UGFzcyAmJiByZXN1bHRCb3ggIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Qm94LmdldE1pblkoKSA8IGJvdW5kaW5nQm94LmdldE1pblkoKSB8fCByZXN1bHRCb3guZ2V0TWF4WSgpID4gYm91bmRpbmdCb3guZ2V0TWF4WSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBib3VuZGluZ0JveCA9IHJlc3VsdEJveDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdC5zZXRCb3VuZGluZ0JveChib3VuZGluZ0JveCk7XG4gICAgICAgICAgICBsZXQgbWF4QmFyY29kZUNvbHVtbiA9IGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSArIDE7XG4gICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHQuc2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKDAsIGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4pO1xuICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0LnNldERldGVjdGlvblJlc3VsdENvbHVtbihtYXhCYXJjb2RlQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbik7XG4gICAgICAgICAgICBsZXQgbGVmdFRvUmlnaHQgPSBsZWZ0Um93SW5kaWNhdG9yQ29sdW1uICE9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBiYXJjb2RlQ29sdW1uQ291bnQgLyppbnQqLyA9IDE7IGJhcmNvZGVDb2x1bW5Db3VudCA8PSBtYXhCYXJjb2RlQ29sdW1uOyBiYXJjb2RlQ29sdW1uQ291bnQrKykge1xuICAgICAgICAgICAgICAgIGxldCBiYXJjb2RlQ29sdW1uID0gbGVmdFRvUmlnaHQgPyBiYXJjb2RlQ29sdW1uQ291bnQgOiBtYXhCYXJjb2RlQ29sdW1uIC0gYmFyY29kZUNvbHVtbkNvdW50O1xuICAgICAgICAgICAgICAgIGlmIChkZXRlY3Rpb25SZXN1bHQuZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4pICE9PSAvKiBudWxsICovIHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgYmUgdGhlIGNhc2UgZm9yIHRoZSBvcHBvc2l0ZSByb3cgaW5kaWNhdG9yIGNvbHVtbiwgd2hpY2ggZG9lc24ndCBuZWVkIHRvIGJlIGRlY29kZWQgYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uO1xuICAgICAgICAgICAgICAgIGlmIChiYXJjb2RlQ29sdW1uID09PSAwIHx8IGJhcmNvZGVDb2x1bW4gPT09IG1heEJhcmNvZGVDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uID0gbmV3IERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbihib3VuZGluZ0JveCwgYmFyY29kZUNvbHVtbiA9PT0gMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHRDb2x1bW4gPSBuZXcgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0LnNldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uLCBkZXRlY3Rpb25SZXN1bHRDb2x1bW4pO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydENvbHVtbiA9IC0xO1xuICAgICAgICAgICAgICAgIGxldCBwcmV2aW91c1N0YXJ0Q29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBzdGFydCBhdCBhIHJvdyBmb3Igd2hpY2ggd2Uga25vdyB0aGUgc3RhcnQgcG9zaXRpb24sIHRoZW4gZGV0ZWN0IHVwd2FyZHMgYW5kIGRvd253YXJkcyBmcm9tIHRoZXJlLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGltYWdlUm93IC8qaW50Ki8gPSBib3VuZGluZ0JveC5nZXRNaW5ZKCk7IGltYWdlUm93IDw9IGJvdW5kaW5nQm94LmdldE1heFkoKTsgaW1hZ2VSb3crKykge1xuICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbiA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRTdGFydENvbHVtbihkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4sIGltYWdlUm93LCBsZWZ0VG9SaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydENvbHVtbiA8IDAgfHwgc3RhcnRDb2x1bW4gPiBib3VuZGluZ0JveC5nZXRNYXhYKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1N0YXJ0Q29sdW1uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBwcmV2aW91c1N0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5kZXRlY3RDb2Rld29yZChpbWFnZSwgYm91bmRpbmdCb3guZ2V0TWluWCgpLCBib3VuZGluZ0JveC5nZXRNYXhYKCksIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3csIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uLnNldENvZGV3b3JkKGltYWdlUm93LCBjb2Rld29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1N0YXJ0Q29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5Db2Rld29yZFdpZHRoID0gTWF0aC5taW4obWluQ29kZXdvcmRXaWR0aCwgY29kZXdvcmQuZ2V0V2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhDb2Rld29yZFdpZHRoID0gTWF0aC5tYXgobWF4Q29kZXdvcmRXaWR0aCwgY29kZXdvcmQuZ2V0V2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNyZWF0ZURlY29kZXJSZXN1bHQoZGV0ZWN0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxlZnRSb3dJbmRpY2F0b3JDb2x1bW5cbiAgICAgICAgICogQHBhcmFtIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBtZXJnZShsZWZ0Um93SW5kaWNhdG9yQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbikge1xuICAgICAgICAgICAgaWYgKGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCAmJiByaWdodFJvd0luZGljYXRvckNvbHVtbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYmFyY29kZU1ldGFkYXRhID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldEJhcmNvZGVNZXRhZGF0YShsZWZ0Um93SW5kaWNhdG9yQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbik7XG4gICAgICAgICAgICBpZiAoYmFyY29kZU1ldGFkYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBib3VuZGluZ0JveCA9IEJvdW5kaW5nQm94Lm1lcmdlKFBERjQxN1NjYW5uaW5nRGVjb2Rlci5hZGp1c3RCb3VuZGluZ0JveChsZWZ0Um93SW5kaWNhdG9yQ29sdW1uKSwgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmFkanVzdEJvdW5kaW5nQm94KHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERldGVjdGlvblJlc3VsdChiYXJjb2RlTWV0YWRhdGEsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvd0luZGljYXRvckNvbHVtblxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYWRqdXN0Qm91bmRpbmdCb3gocm93SW5kaWNhdG9yQ29sdW1uKSB7XG4gICAgICAgICAgICBpZiAocm93SW5kaWNhdG9yQ29sdW1uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByb3dIZWlnaHRzID0gcm93SW5kaWNhdG9yQ29sdW1uLmdldFJvd0hlaWdodHMoKTtcbiAgICAgICAgICAgIGlmIChyb3dIZWlnaHRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtYXhSb3dIZWlnaHQgPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0TWF4KHJvd0hlaWdodHMpO1xuICAgICAgICAgICAgbGV0IG1pc3NpbmdTdGFydFJvd3MgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93SGVpZ2h0IC8qaW50Ki8gb2Ygcm93SGVpZ2h0cykge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdTdGFydFJvd3MgKz0gbWF4Um93SGVpZ2h0IC0gcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChyb3dIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb2Rld29yZHMgPSByb3dJbmRpY2F0b3JDb2x1bW4uZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgLyppbnQqLyA9IDA7IG1pc3NpbmdTdGFydFJvd3MgPiAwICYmIGNvZGV3b3Jkc1tyb3ddID09IG51bGw7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ1N0YXJ0Um93cy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1pc3NpbmdFbmRSb3dzID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyAvKmludCovID0gcm93SGVpZ2h0cy5sZW5ndGggLSAxOyByb3cgPj0gMDsgcm93LS0pIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nRW5kUm93cyArPSBtYXhSb3dIZWlnaHQgLSByb3dIZWlnaHRzW3Jvd107XG4gICAgICAgICAgICAgICAgaWYgKHJvd0hlaWdodHNbcm93XSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgcm93IC8qaW50Ki8gPSBjb2Rld29yZHMubGVuZ3RoIC0gMTsgbWlzc2luZ0VuZFJvd3MgPiAwICYmIGNvZGV3b3Jkc1tyb3ddID09IG51bGw7IHJvdy0tKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ0VuZFJvd3MtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3dJbmRpY2F0b3JDb2x1bW4uZ2V0Qm91bmRpbmdCb3goKS5hZGRNaXNzaW5nUm93cyhtaXNzaW5nU3RhcnRSb3dzLCBtaXNzaW5nRW5kUm93cywgcm93SW5kaWNhdG9yQ29sdW1uLmlzTGVmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0TWF4KHZhbHVlcykge1xuICAgICAgICAgICAgbGV0IG1heFZhbHVlID0gLTE7XG4gICAgICAgICAgICBmb3IgKGxldCB2YWx1ZSAvKmludCovIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXgobWF4VmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXhWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0QmFyY29kZU1ldGFkYXRhKGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4sIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uKSB7XG4gICAgICAgICAgICBsZXQgbGVmdEJhcmNvZGVNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChsZWZ0Um93SW5kaWNhdG9yQ29sdW1uID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAobGVmdEJhcmNvZGVNZXRhZGF0YSA9IGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4uZ2V0QmFyY29kZU1ldGFkYXRhKCkpID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiByaWdodFJvd0luZGljYXRvckNvbHVtbi5nZXRCYXJjb2RlTWV0YWRhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByaWdodEJhcmNvZGVNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChyaWdodFJvd0luZGljYXRvckNvbHVtbiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKHJpZ2h0QmFyY29kZU1ldGFkYXRhID0gcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4uZ2V0QmFyY29kZU1ldGFkYXRhKCkpID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdEJhcmNvZGVNZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0QmFyY29kZU1ldGFkYXRhLmdldENvbHVtbkNvdW50KCkgIT09IHJpZ2h0QmFyY29kZU1ldGFkYXRhLmdldENvbHVtbkNvdW50KCkgJiZcbiAgICAgICAgICAgICAgICBsZWZ0QmFyY29kZU1ldGFkYXRhLmdldEVycm9yQ29ycmVjdGlvbkxldmVsKCkgIT09IHJpZ2h0QmFyY29kZU1ldGFkYXRhLmdldEVycm9yQ29ycmVjdGlvbkxldmVsKCkgJiZcbiAgICAgICAgICAgICAgICBsZWZ0QmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCkgIT09IHJpZ2h0QmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZWZ0QmFyY29kZU1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRSb3dJbmRpY2F0b3JDb2x1bW4oaW1hZ2UsIGJvdW5kaW5nQm94LCBzdGFydFBvaW50LCBsZWZ0VG9SaWdodCwgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCkge1xuICAgICAgICAgICAgbGV0IHJvd0luZGljYXRvckNvbHVtbiA9IG5ldyBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4oYm91bmRpbmdCb3gsIGxlZnRUb1JpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5jcmVtZW50ID0gaSA9PT0gMCA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRDb2x1bW4gPSBNYXRoLnRydW5jKE1hdGgudHJ1bmMoc3RhcnRQb2ludC5nZXRYKCkpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbWFnZVJvdyAvKmludCovID0gTWF0aC50cnVuYyhNYXRoLnRydW5jKHN0YXJ0UG9pbnQuZ2V0WSgpKSk7IGltYWdlUm93IDw9IGJvdW5kaW5nQm94LmdldE1heFkoKSAmJlxuICAgICAgICAgICAgICAgICAgICBpbWFnZVJvdyA+PSBib3VuZGluZ0JveC5nZXRNaW5ZKCk7IGltYWdlUm93ICs9IGluY3JlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmQgPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZGV0ZWN0Q29kZXdvcmQoaW1hZ2UsIDAsIGltYWdlLmdldFdpZHRoKCksIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3csIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93SW5kaWNhdG9yQ29sdW1uLnNldENvZGV3b3JkKGltYWdlUm93LCBjb2Rld29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFRvUmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbiA9IGNvZGV3b3JkLmdldFN0YXJ0WCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBjb2Rld29yZC5nZXRFbmRYKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93SW5kaWNhdG9yQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGV0ZWN0aW9uUmVzdWx0XG4gICAgICAgICAqIEBwYXJhbSBCYXJjb2RlVmFsdWVcbiAgICAgICAgICogQHBhcmFtIHBhcmFtMlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW0zXG4gICAgICAgICAqIEBwYXJhbSBiYXJjb2RlTWF0cml4XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhZGp1c3RDb2Rld29yZENvdW50KGRldGVjdGlvblJlc3VsdCwgYmFyY29kZU1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVNYXRyaXgwMSA9IGJhcmNvZGVNYXRyaXhbMF1bMV07XG4gICAgICAgICAgICBsZXQgbnVtYmVyT2ZDb2Rld29yZHMgPSBiYXJjb2RlTWF0cml4MDEuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGxldCBjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMgPSBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkgKlxuICAgICAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlUm93Q291bnQoKSAtXG4gICAgICAgICAgICAgICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldE51bWJlck9mRUNDb2RlV29yZHMoZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVFQ0xldmVsKCkpO1xuICAgICAgICAgICAgaWYgKG51bWJlck9mQ29kZXdvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMgPCAxIHx8IGNhbGN1bGF0ZWROdW1iZXJPZkNvZGV3b3JkcyA+IFBERjQxN0NvbW1vbi5NQVhfQ09ERVdPUkRTX0lOX0JBUkNPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgTm90Rm91bmRFeGNlcHRpb24uZ2V0Tm90Rm91bmRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYXJjb2RlTWF0cml4MDEuc2V0VmFsdWUoY2FsY3VsYXRlZE51bWJlck9mQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG51bWJlck9mQ29kZXdvcmRzWzBdICE9PSBjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FsY3VsYXRlZCBvbmUgaXMgbW9yZSByZWxpYWJsZSBhcyBpdCBpcyBkZXJpdmVkIGZyb20gdGhlIHJvdyBpbmRpY2F0b3IgY29sdW1uc1xuICAgICAgICAgICAgICAgIGJhcmNvZGVNYXRyaXgwMS5zZXRWYWx1ZShjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGV0ZWN0aW9uUmVzdWx0XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNyZWF0ZURlY29kZXJSZXN1bHQoZGV0ZWN0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICBsZXQgYmFyY29kZU1hdHJpeCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5jcmVhdGVCYXJjb2RlTWF0cml4KGRldGVjdGlvblJlc3VsdCk7XG4gICAgICAgICAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuYWRqdXN0Q29kZXdvcmRDb3VudChkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVNYXRyaXgpO1xuICAgICAgICAgICAgbGV0IGVyYXN1cmVzIC8qQ29sbGVjdGlvbjxJbnRlZ2VyPiovID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICBsZXQgY29kZXdvcmRzID0gbmV3IEludDMyQXJyYXkoZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVSb3dDb3VudCgpICogZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpKTtcbiAgICAgICAgICAgIGxldCBhbWJpZ3VvdXNJbmRleFZhbHVlc0xpc3QgPSAvKkxpc3Q8aW50W10+Ki8gW107XG4gICAgICAgICAgICBsZXQgYW1iaWd1b3VzSW5kZXhlc0xpc3QgPSAvKkNvbGxlY3Rpb248SW50ZWdlcj4qLyBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyAvKmludCovID0gMDsgcm93IDwgZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVSb3dDb3VudCgpOyByb3crKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbHVtbiAvKmludCovID0gMDsgY29sdW1uIDwgZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gYmFyY29kZU1hdHJpeFtyb3ddW2NvbHVtbiArIDFdLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZEluZGV4ID0gcm93ICogZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpICsgY29sdW1uO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJhc3VyZXMucHVzaChjb2Rld29yZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRJbmRleF0gPSB2YWx1ZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbWJpZ3VvdXNJbmRleGVzTGlzdC5wdXNoKGNvZGV3b3JkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW1iaWd1b3VzSW5kZXhWYWx1ZXNMaXN0LnB1c2godmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhbWJpZ3VvdXNJbmRleFZhbHVlcyA9IG5ldyBBcnJheShhbWJpZ3VvdXNJbmRleFZhbHVlc0xpc3QubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBhbWJpZ3VvdXNJbmRleFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFtYmlndW91c0luZGV4VmFsdWVzW2ldID0gYW1iaWd1b3VzSW5kZXhWYWx1ZXNMaXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5jcmVhdGVEZWNvZGVyUmVzdWx0RnJvbUFtYmlndW91c1ZhbHVlcyhkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUVDTGV2ZWwoKSwgY29kZXdvcmRzLCBQREY0MTdDb21tb24udG9JbnRBcnJheShlcmFzdXJlcyksIFBERjQxN0NvbW1vbi50b0ludEFycmF5KGFtYmlndW91c0luZGV4ZXNMaXN0KSwgYW1iaWd1b3VzSW5kZXhWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBkZWFscyB3aXRoIHRoZSBmYWN0LCB0aGF0IHRoZSBkZWNvZGluZyBwcm9jZXNzIGRvZXNuJ3QgYWx3YXlzIHlpZWxkIGEgc2luZ2xlIG1vc3QgbGlrZWx5IHZhbHVlLiBUaGVcbiAgICAgICAgICogY3VycmVudCBlcnJvciBjb3JyZWN0aW9uIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgZGVhbCB3aXRoIGVyYXN1cmVzIHZlcnkgd2VsbCwgc28gaXQncyBiZXR0ZXIgdG8gcHJvdmlkZSBhIHZhbHVlXG4gICAgICAgICAqIGZvciB0aGVzZSBhbWJpZ3VvdXMgY29kZXdvcmRzIGluc3RlYWQgb2YgdHJlYXRpbmcgaXQgYXMgYW4gZXJhc3VyZS4gVGhlIHByb2JsZW0gaXMgdGhhdCB3ZSBkb24ndCBrbm93IHdoaWNoIG9mXG4gICAgICAgICAqIHRoZSBhbWJpZ3VvdXMgdmFsdWVzIHRvIGNob29zZS4gV2UgdHJ5IGRlY29kZSB1c2luZyB0aGUgZmlyc3QgdmFsdWUsIGFuZCBpZiB0aGF0IGZhaWxzLCB3ZSB1c2UgYW5vdGhlciBvZiB0aGVcbiAgICAgICAgICogYW1iaWd1b3VzIHZhbHVlcyBhbmQgdHJ5IHRvIGRlY29kZSBhZ2Fpbi4gVGhpcyB1c3VhbGx5IG9ubHkgaGFwcGVucyBvbiB2ZXJ5IGhhcmQgdG8gcmVhZCBhbmQgZGVjb2RlIGJhcmNvZGVzLFxuICAgICAgICAgKiBzbyBkZWNvZGluZyB0aGUgbm9ybWFsIGJhcmNvZGVzIGlzIG5vdCBhZmZlY3RlZCBieSB0aGlzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZXJhc3VyZUFycmF5IGNvbnRhaW5zIHRoZSBpbmRleGVzIG9mIGVyYXN1cmVzXG4gICAgICAgICAqIEBwYXJhbSBhbWJpZ3VvdXNJbmRleGVzIGFycmF5IHdpdGggdGhlIGluZGV4ZXMgdGhhdCBoYXZlIG1vcmUgdGhhbiBvbmUgbW9zdCBsaWtlbHkgdmFsdWVcbiAgICAgICAgICogQHBhcmFtIGFtYmlndW91c0luZGV4VmFsdWVzIHR3byBkaW1lbnNpb25hbCBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBhbWJpZ3VvdXMgdmFsdWVzLiBUaGUgZmlyc3QgZGltZW5zaW9uIG11c3RcbiAgICAgICAgICogYmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBhbWJpZ3VvdXNJbmRleGVzIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjcmVhdGVEZWNvZGVyUmVzdWx0RnJvbUFtYmlndW91c1ZhbHVlcyhlY0xldmVsLCBjb2Rld29yZHMsIGVyYXN1cmVBcnJheSwgYW1iaWd1b3VzSW5kZXhlcywgYW1iaWd1b3VzSW5kZXhWYWx1ZXMpIHtcbiAgICAgICAgICAgIGxldCBhbWJpZ3VvdXNJbmRleENvdW50ID0gbmV3IEludDMyQXJyYXkoYW1iaWd1b3VzSW5kZXhlcy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IHRyaWVzID0gMTAwO1xuICAgICAgICAgICAgd2hpbGUgKHRyaWVzLS0gPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IGFtYmlndW91c0luZGV4Q291bnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2FtYmlndW91c0luZGV4ZXNbaV1dID0gYW1iaWd1b3VzSW5kZXhWYWx1ZXNbaV1bYW1iaWd1b3VzSW5kZXhDb3VudFtpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQREY0MTdTY2FubmluZ0RlY29kZXIuZGVjb2RlQ29kZXdvcmRzKGNvZGV3b3JkcywgZWNMZXZlbCwgZXJhc3VyZUFycmF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaWdub3JlZCA9IGVyciBpbnN0YW5jZW9mIENoZWNrc3VtRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYW1iaWd1b3VzSW5kZXhDb3VudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb24uZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgYW1iaWd1b3VzSW5kZXhDb3VudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW1iaWd1b3VzSW5kZXhDb3VudFtpXSA8IGFtYmlndW91c0luZGV4VmFsdWVzW2ldLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtYmlndW91c0luZGV4Q291bnRbaV0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW1iaWd1b3VzSW5kZXhDb3VudFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gYW1iaWd1b3VzSW5kZXhDb3VudC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb24uZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb24uZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjcmVhdGVCYXJjb2RlTWF0cml4KGRldGVjdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgLy8gbGV0IGJhcmNvZGVNYXRyaXg6IEJhcmNvZGVWYWx1ZVtdW10gPVxuICAgICAgICAgICAgLy8gbmV3IEJhcmNvZGVWYWx1ZVtkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZVJvd0NvdW50KCldW2RldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSArIDJdO1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVNYXRyaXggPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZVJvd0NvdW50KCkgfSwgKCkgPT4gbmV3IEFycmF5KGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSArIDIpKTtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyAvKmludCovID0gMDsgcm93IDwgYmFyY29kZU1hdHJpeC5sZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uIC8qaW50Ki8gPSAwOyBjb2x1bW4gPCBiYXJjb2RlTWF0cml4W3Jvd10ubGVuZ3RoOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgICAgICAgICBiYXJjb2RlTWF0cml4W3Jvd11bY29sdW1uXSA9IG5ldyBCYXJjb2RlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY29sdW1uID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGRldGVjdGlvblJlc3VsdENvbHVtbiAvKkRldGVjdGlvblJlc3VsdENvbHVtbiovIG9mIGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW5zKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0aW9uUmVzdWx0Q29sdW1uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmQgLypDb2Rld29yZCovIG9mIGRldGVjdGlvblJlc3VsdENvbHVtbi5nZXRDb2Rld29yZHMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcm93TnVtYmVyID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd051bWJlciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dOdW1iZXIgPj0gYmFyY29kZU1hdHJpeC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgbW9yZSByb3dzIHRoYW4gdGhlIGJhcmNvZGUgbWV0YWRhdGEgYWxsb3dzIGZvciwgaWdub3JlIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlTWF0cml4W3Jvd051bWJlcl1bY29sdW1uXS5zZXRWYWx1ZShjb2Rld29yZC5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sdW1uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFyY29kZU1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNWYWxpZEJhcmNvZGVDb2x1bW4oZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFyY29kZUNvbHVtbiA+PSAwICYmIGJhcmNvZGVDb2x1bW4gPD0gZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0U3RhcnRDb2x1bW4oZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlQ29sdW1uLCBpbWFnZVJvdywgbGVmdFRvUmlnaHQpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSBsZWZ0VG9SaWdodCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmlzVmFsaWRCYXJjb2RlQ29sdW1uKGRldGVjdGlvblJlc3VsdCwgYmFyY29kZUNvbHVtbiAtIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZCA9IGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbiAtIG9mZnNldCkuZ2V0Q29kZXdvcmQoaW1hZ2VSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFRvUmlnaHQgPyBjb2Rld29yZC5nZXRFbmRYKCkgOiBjb2Rld29yZC5nZXRTdGFydFgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGV3b3JkID0gZGV0ZWN0aW9uUmVzdWx0LmdldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uKS5nZXRDb2Rld29yZE5lYXJieShpbWFnZVJvdyk7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0VG9SaWdodCA/IGNvZGV3b3JkLmdldFN0YXJ0WCgpIDogY29kZXdvcmQuZ2V0RW5kWCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFBERjQxN1NjYW5uaW5nRGVjb2Rlci5pc1ZhbGlkQmFyY29kZUNvbHVtbihkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4gLSBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmQgPSBkZXRlY3Rpb25SZXN1bHQuZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4gLSBvZmZzZXQpLmdldENvZGV3b3JkTmVhcmJ5KGltYWdlUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRUb1JpZ2h0ID8gY29kZXdvcmQuZ2V0RW5kWCgpIDogY29kZXdvcmQuZ2V0U3RhcnRYKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2tpcHBlZENvbHVtbnMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKFBERjQxN1NjYW5uaW5nRGVjb2Rlci5pc1ZhbGlkQmFyY29kZUNvbHVtbihkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4gLSBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgYmFyY29kZUNvbHVtbiAtPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcHJldmlvdXNSb3dDb2Rld29yZCAvKkNvZGV3b3JkKi8gb2YgZGV0ZWN0aW9uUmVzdWx0LmdldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uKS5nZXRDb2Rld29yZHMoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNSb3dDb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGxlZnRUb1JpZ2h0ID8gcHJldmlvdXNSb3dDb2Rld29yZC5nZXRFbmRYKCkgOiBwcmV2aW91c1Jvd0NvZGV3b3JkLmdldFN0YXJ0WCgpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZENvbHVtbnMgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJldmlvdXNSb3dDb2Rld29yZC5nZXRFbmRYKCkgLSBwcmV2aW91c1Jvd0NvZGV3b3JkLmdldFN0YXJ0WCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwcGVkQ29sdW1ucysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxlZnRUb1JpZ2h0ID8gZGV0ZWN0aW9uUmVzdWx0LmdldEJvdW5kaW5nQm94KCkuZ2V0TWluWCgpIDogZGV0ZWN0aW9uUmVzdWx0LmdldEJvdW5kaW5nQm94KCkuZ2V0TWF4WCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZXRlY3RDb2Rld29yZChpbWFnZSwgbWluQ29sdW1uLCBtYXhDb2x1bW4sIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3csIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpIHtcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmFkanVzdENvZGV3b3JkU3RhcnRDb2x1bW4oaW1hZ2UsIG1pbkNvbHVtbiwgbWF4Q29sdW1uLCBsZWZ0VG9SaWdodCwgc3RhcnRDb2x1bW4sIGltYWdlUm93KTtcbiAgICAgICAgICAgIC8vIHdlIHVzdWFsbHkga25vdyBmYWlybHkgZXhhY3Qgbm93IGhvdyBsb25nIGEgY29kZXdvcmQgaXMuIFdlIHNob3VsZCBwcm92aWRlIG1pbmltdW0gYW5kIG1heGltdW0gZXhwZWN0ZWQgbGVuZ3RoXG4gICAgICAgICAgICAvLyBhbmQgdHJ5IHRvIGFkanVzdCB0aGUgcmVhZCBwaXhlbHMsIGUuZy4gcmVtb3ZlIHNpbmdsZSBwaXhlbCBlcnJvcnMgb3IgdHJ5IHRvIGN1dCBvZmYgZXhjZWVkaW5nIHBpeGVscy5cbiAgICAgICAgICAgIC8vIG1pbiBhbmQgbWF4Q29kZXdvcmRXaWR0aCBzaG91bGQgbm90IGJlIHVzZWQgYXMgdGhleSBhcmUgY2FsY3VsYXRlZCBmb3IgdGhlIHdob2xlIGJhcmNvZGUgYW4gY2FuIGJlIGluYWNjdXJhdGVcbiAgICAgICAgICAgIC8vIGZvciB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgICAgbGV0IG1vZHVsZUJpdENvdW50ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldE1vZHVsZUJpdENvdW50KGltYWdlLCBtaW5Db2x1bW4sIG1heENvbHVtbiwgbGVmdFRvUmlnaHQsIHN0YXJ0Q29sdW1uLCBpbWFnZVJvdyk7XG4gICAgICAgICAgICBpZiAobW9kdWxlQml0Q291bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVuZENvbHVtbjtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZEJpdENvdW50ID0gTWF0aFV0aWxzLnN1bShtb2R1bGVCaXRDb3VudCk7XG4gICAgICAgICAgICBpZiAobGVmdFRvUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW4gPSBzdGFydENvbHVtbiArIGNvZGV3b3JkQml0Q291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgbW9kdWxlQml0Q291bnQubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0bXBDb3VudCA9IG1vZHVsZUJpdENvdW50W2ldO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVCaXRDb3VudFtpXSA9IG1vZHVsZUJpdENvdW50W21vZHVsZUJpdENvdW50Lmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlQml0Q291bnRbbW9kdWxlQml0Q291bnQubGVuZ3RoIC0gMSAtIGldID0gdG1wQ291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZENvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gZW5kQ29sdW1uIC0gY29kZXdvcmRCaXRDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IGNoZWNrIGZvciB3aWR0aCBhbmQgY29ycmVjdGlvbiBvZiBibGFjayBhbmQgd2hpdGUgYmFyc1xuICAgICAgICAgICAgLy8gdXNlIHN0YXJ0IChhbmQgbWF5YmUgc3RvcCBwYXR0ZXJuKSB0byBkZXRlcm1pbmUgaWYgYmxhY2sgYmFycyBhcmUgd2lkZXIgdGhhbiB3aGl0ZSBiYXJzLiBJZiBzbywgYWRqdXN0LlxuICAgICAgICAgICAgLy8gc2hvdWxkIHByb2JhYmx5IGRvbmUgb25seSBmb3IgY29kZXdvcmRzIHdpdGggYSBsb3QgbW9yZSB0aGFuIDE3IGJpdHMuXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGZpeGVzIDEwLTEucG5nLCB3aGljaCBoYXMgd2lkZSBibGFjayBiYXJzIGFuZCBzbWFsbCB3aGl0ZSBiYXJzXG4gICAgICAgICAgICAvLyAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgbW9kdWxlQml0Q291bnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgbW9kdWxlQml0Q291bnRbaV0tLTtcbiAgICAgICAgICAgIC8vICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICAgICAgICBtb2R1bGVCaXRDb3VudFtpXSsrO1xuICAgICAgICAgICAgLy8gICAgICB9XG4gICAgICAgICAgICAvLyAgICB9XG4gICAgICAgICAgICAvLyBXZSBjb3VsZCBhbHNvIHVzZSB0aGUgd2lkdGggb2Ygc3Vycm91bmRpbmcgY29kZXdvcmRzIGZvciBtb3JlIGFjY3VyYXRlIHJlc3VsdHMsIGJ1dCB0aGlzIHNlZW1zXG4gICAgICAgICAgICAvLyBzdWZmaWNpZW50IGZvciBub3dcbiAgICAgICAgICAgIGlmICghUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNoZWNrQ29kZXdvcmRTa2V3KGNvZGV3b3JkQml0Q291bnQsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY291bGQgdHJ5IHRvIHVzZSB0aGUgc3RhcnRYIGFuZCBlbmRYIHBvc2l0aW9uIG9mIHRoZSBjb2Rld29yZCBpbiB0aGUgc2FtZSBjb2x1bW4gaW4gdGhlIHByZXZpb3VzIHJvdyxcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGJpdCBjb3VudCBmcm9tIGl0IGFuZCBub3JtYWxpemUgaXQgdG8gOC4gVGhpcyB3b3VsZCBoZWxwIHdpdGggc2luZ2xlIHBpeGVsIGVycm9ycy5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkZWNvZGVkVmFsdWUgPSBQREY0MTdDb2Rld29yZERlY29kZXIuZ2V0RGVjb2RlZFZhbHVlKG1vZHVsZUJpdENvdW50KTtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IFBERjQxN0NvbW1vbi5nZXRDb2Rld29yZChkZWNvZGVkVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvZGV3b3JkID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2Rld29yZChzdGFydENvbHVtbiwgZW5kQ29sdW1uLCBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXIoZGVjb2RlZFZhbHVlKSwgY29kZXdvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRNb2R1bGVCaXRDb3VudChpbWFnZSwgbWluQ29sdW1uLCBtYXhDb2x1bW4sIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3cpIHtcbiAgICAgICAgICAgIGxldCBpbWFnZUNvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgbGV0IG1vZHVsZUJpdENvdW50ID0gbmV3IEludDMyQXJyYXkoOCk7XG4gICAgICAgICAgICBsZXQgbW9kdWxlTnVtYmVyID0gMDtcbiAgICAgICAgICAgIGxldCBpbmNyZW1lbnQgPSBsZWZ0VG9SaWdodCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c1BpeGVsVmFsdWUgPSBsZWZ0VG9SaWdodDtcbiAgICAgICAgICAgIHdoaWxlICgobGVmdFRvUmlnaHQgPyBpbWFnZUNvbHVtbiA8IG1heENvbHVtbiA6IGltYWdlQ29sdW1uID49IG1pbkNvbHVtbikgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGVOdW1iZXIgPCBtb2R1bGVCaXRDb3VudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGltYWdlQ29sdW1uLCBpbWFnZVJvdykgPT09IHByZXZpb3VzUGl4ZWxWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVCaXRDb3VudFttb2R1bGVOdW1iZXJdKys7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlQ29sdW1uICs9IGluY3JlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU51bWJlcisrO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1BpeGVsVmFsdWUgPSAhcHJldmlvdXNQaXhlbFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2R1bGVOdW1iZXIgPT09IG1vZHVsZUJpdENvdW50Lmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICgoaW1hZ2VDb2x1bW4gPT09IChsZWZ0VG9SaWdodCA/IG1heENvbHVtbiA6IG1pbkNvbHVtbikpICYmXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU51bWJlciA9PT0gbW9kdWxlQml0Q291bnQubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlQml0Q291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0TnVtYmVyT2ZFQ0NvZGVXb3JkcyhiYXJjb2RlRUNMZXZlbCkge1xuICAgICAgICAgICAgcmV0dXJuIDIgPDwgYmFyY29kZUVDTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFkanVzdENvZGV3b3JkU3RhcnRDb2x1bW4oaW1hZ2UsIG1pbkNvbHVtbiwgbWF4Q29sdW1uLCBsZWZ0VG9SaWdodCwgY29kZXdvcmRTdGFydENvbHVtbiwgaW1hZ2VSb3cpIHtcbiAgICAgICAgICAgIGxldCBjb3JyZWN0ZWRTdGFydENvbHVtbiA9IGNvZGV3b3JkU3RhcnRDb2x1bW47XG4gICAgICAgICAgICBsZXQgaW5jcmVtZW50ID0gbGVmdFRvUmlnaHQgPyAtMSA6IDE7XG4gICAgICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgbm8gYmxhY2sgcGl4ZWxzIGJlZm9yZSB0aGUgc3RhcnQgY29sdW1uLiBJZiB0aGVyZSBhcmUsIHRoZW4gd2UgbmVlZCB0byBzdGFydCBlYXJsaWVyLlxuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgICAgIHdoaWxlICgobGVmdFRvUmlnaHQgPyBjb3JyZWN0ZWRTdGFydENvbHVtbiA+PSBtaW5Db2x1bW4gOiBjb3JyZWN0ZWRTdGFydENvbHVtbiA8IG1heENvbHVtbikgJiZcbiAgICAgICAgICAgICAgICAgICAgbGVmdFRvUmlnaHQgPT09IGltYWdlLmdldChjb3JyZWN0ZWRTdGFydENvbHVtbiwgaW1hZ2VSb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb2Rld29yZFN0YXJ0Q29sdW1uIC0gY29ycmVjdGVkU3RhcnRDb2x1bW4pID4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLkNPREVXT1JEX1NLRVdfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGV3b3JkU3RhcnRDb2x1bW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29ycmVjdGVkU3RhcnRDb2x1bW4gKz0gaW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmNyZW1lbnQgPSAtaW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIGxlZnRUb1JpZ2h0ID0gIWxlZnRUb1JpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3RlZFN0YXJ0Q29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaGVja0NvZGV3b3JkU2tldyhjb2Rld29yZFNpemUsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW5Db2Rld29yZFdpZHRoIC0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLkNPREVXT1JEX1NLRVdfU0laRSA8PSBjb2Rld29yZFNpemUgJiZcbiAgICAgICAgICAgICAgICBjb2Rld29yZFNpemUgPD0gbWF4Q29kZXdvcmRXaWR0aCArIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5DT0RFV09SRF9TS0VXX1NJWkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uLFxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlQ29kZXdvcmRzKGNvZGV3b3JkcywgZWNMZXZlbCwgZXJhc3VyZXMpIHtcbiAgICAgICAgICAgIGlmIChjb2Rld29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbnVtRUNDb2Rld29yZHMgPSAxIDw8IChlY0xldmVsICsgMSk7XG4gICAgICAgICAgICBsZXQgY29ycmVjdGVkRXJyb3JzQ291bnQgPSBQREY0MTdTY2FubmluZ0RlY29kZXIuY29ycmVjdEVycm9ycyhjb2Rld29yZHMsIGVyYXN1cmVzLCBudW1FQ0NvZGV3b3Jkcyk7XG4gICAgICAgICAgICBQREY0MTdTY2FubmluZ0RlY29kZXIudmVyaWZ5Q29kZXdvcmRDb3VudChjb2Rld29yZHMsIG51bUVDQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIC8vIERlY29kZSB0aGUgY29kZXdvcmRzXG4gICAgICAgICAgICBsZXQgZGVjb2RlclJlc3VsdCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5kZWNvZGUoY29kZXdvcmRzLCAnJyArIGVjTGV2ZWwpO1xuICAgICAgICAgICAgZGVjb2RlclJlc3VsdC5zZXRFcnJvcnNDb3JyZWN0ZWQoY29ycmVjdGVkRXJyb3JzQ291bnQpO1xuICAgICAgICAgICAgZGVjb2RlclJlc3VsdC5zZXRFcmFzdXJlcyhlcmFzdXJlcy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkdpdmVuIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIHJlY2VpdmVkLCBwb3NzaWJseSBjb3JydXB0ZWQgYnkgZXJyb3JzLCBhdHRlbXB0cyB0b1xuICAgICAgICAgKiBjb3JyZWN0IHRoZSBlcnJvcnMgaW4tcGxhY2UuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29kZXdvcmRzICAgZGF0YSBhbmQgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHNcbiAgICAgICAgICogQHBhcmFtIGVyYXN1cmVzIHBvc2l0aW9ucyBvZiBhbnkga25vd24gZXJhc3VyZXNcbiAgICAgICAgICogQHBhcmFtIG51bUVDQ29kZXdvcmRzIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3JkcyB0aGF0IGFyZSBhdmFpbGFibGUgaW4gY29kZXdvcmRzXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNvcnJlY3RFcnJvcnMoY29kZXdvcmRzLCBlcmFzdXJlcywgbnVtRUNDb2Rld29yZHMpIHtcbiAgICAgICAgICAgIGlmIChlcmFzdXJlcyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgZXJhc3VyZXMubGVuZ3RoID4gbnVtRUNDb2Rld29yZHMgLyAyICsgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLk1BWF9FUlJPUlMgfHxcbiAgICAgICAgICAgICAgICBudW1FQ0NvZGV3b3JkcyA8IDAgfHxcbiAgICAgICAgICAgICAgICBudW1FQ0NvZGV3b3JkcyA+IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5NQVhfRUNfQ09ERVdPUkRTKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9vIG1hbnkgZXJyb3JzIG9yIEVDIENvZGV3b3JkcyBpcyBjb3JydXB0ZWRcbiAgICAgICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbi5nZXRDaGVja3N1bUluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmVycm9yQ29ycmVjdGlvbi5kZWNvZGUoY29kZXdvcmRzLCBudW1FQ0NvZGV3b3JkcywgZXJhc3VyZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZnkgdGhhdCBhbGwgaXMgT0sgd2l0aCB0aGUgY29kZXdvcmQgYXJyYXkuXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgdmVyaWZ5Q29kZXdvcmRDb3VudChjb2Rld29yZHMsIG51bUVDQ29kZXdvcmRzKSB7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmRzLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBDb2Rld29yZCBhcnJheSBzaXplIHNob3VsZCBiZSBhdCBsZWFzdCA0IGFsbG93aW5nIGZvclxuICAgICAgICAgICAgICAgIC8vIENvdW50IENXLCBBdCBsZWFzdCBvbmUgRGF0YSBDVywgRXJyb3IgQ29ycmVjdGlvbiBDVywgRXJyb3IgQ29ycmVjdGlvbiBDV1xuICAgICAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGNvZGV3b3JkLCB0aGUgU3ltYm9sIExlbmd0aCBEZXNjcmlwdG9yLCBzaGFsbCBhbHdheXMgZW5jb2RlIHRoZSB0b3RhbCBudW1iZXIgb2YgZGF0YVxuICAgICAgICAgICAgLy8gY29kZXdvcmRzIGluIHRoZSBzeW1ib2wsIGluY2x1ZGluZyB0aGUgU3ltYm9sIExlbmd0aCBEZXNjcmlwdG9yIGl0c2VsZiwgZGF0YSBjb2Rld29yZHMgYW5kIHBhZFxuICAgICAgICAgICAgLy8gY29kZXdvcmRzLCBidXQgZXhjbHVkaW5nIHRoZSBudW1iZXIgb2YgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHMuXG4gICAgICAgICAgICBsZXQgbnVtYmVyT2ZDb2Rld29yZHMgPSBjb2Rld29yZHNbMF07XG4gICAgICAgICAgICBpZiAobnVtYmVyT2ZDb2Rld29yZHMgPiBjb2Rld29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVtYmVyT2ZDb2Rld29yZHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSAtIDggKEFsbG93IGZvciBhdCBsZWFzdCBsZXZlbCAzIEVycm9yIENvcnJlY3Rpb24gKDggRXJyb3IgQ29kZXdvcmRzKVxuICAgICAgICAgICAgICAgIGlmIChudW1FQ0NvZGV3b3JkcyA8IGNvZGV3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzWzBdID0gY29kZXdvcmRzLmxlbmd0aCAtIG51bUVDQ29kZXdvcmRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRCaXRDb3VudEZvckNvZGV3b3JkKGNvZGV3b3JkKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkoOCk7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNWYWx1ZSA9IDA7XG4gICAgICAgICAgICBsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGNvZGV3b3JkICYgMHgxKSAhPT0gcHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gY29kZXdvcmQgJiAweDE7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbaV0rKztcbiAgICAgICAgICAgICAgICBjb2Rld29yZCA+Pj0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldENvZGV3b3JkQnVja2V0TnVtYmVyKGNvZGV3b3JkKSB7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmQgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXJfSW50MzJBcnJheShjb2Rld29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2Rld29yZEJ1Y2tldE51bWJlcl9udW1iZXIoY29kZXdvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRDb2Rld29yZEJ1Y2tldE51bWJlcl9udW1iZXIoY29kZXdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXIoUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldEJpdENvdW50Rm9yQ29kZXdvcmQoY29kZXdvcmQpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXJfSW50MzJBcnJheShtb2R1bGVCaXRDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIChtb2R1bGVCaXRDb3VudFswXSAtIG1vZHVsZUJpdENvdW50WzJdICsgbW9kdWxlQml0Q291bnRbNF0gLSBtb2R1bGVCaXRDb3VudFs2XSArIDkpICUgOTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgdG9TdHJpbmcoYmFyY29kZU1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIoKTtcbiAgICAgICAgICAgIC8vIHRyeSAobGV0IGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIoKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcm93IC8qaW50Ki8gPSAwOyByb3cgPCBiYXJjb2RlTWF0cml4Lmxlbmd0aDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCdSb3cgJTJkOiAnLCByb3cpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbHVtbiAvKmludCovID0gMDsgY29sdW1uIDwgYmFyY29kZU1hdHJpeFtyb3ddLmxlbmd0aDsgY29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJhcmNvZGVWYWx1ZSA9IGJhcmNvZGVNYXRyaXhbcm93XVtjb2x1bW5dO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFyY29kZVZhbHVlLmdldFZhbHVlKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCcgICAgICAgICcsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnJTRkKCUyZCknLCBiYXJjb2RlVmFsdWUuZ2V0VmFsdWUoKVswXSwgYmFyY29kZVZhbHVlLmdldENvbmZpZGVuY2UoYmFyY29kZVZhbHVlLmdldFZhbHVlKClbMF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCclbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci50b1N0cmluZygpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qZmluYWwqLyBQREY0MTdTY2FubmluZ0RlY29kZXIuQ09ERVdPUkRfU0tFV19TSVpFID0gMjtcbiAgICAvKmZpbmFsKi8gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLk1BWF9FUlJPUlMgPSAzO1xuICAgIC8qZmluYWwqLyBQREY0MTdTY2FubmluZ0RlY29kZXIuTUFYX0VDX0NPREVXT1JEUyA9IDUxMjtcbiAgICAvKmZpbmFsKi8gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmVycm9yQ29ycmVjdGlvbiA9IG5ldyBFcnJvckNvcnJlY3Rpb24oKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTWFwO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaW1wbGVtZW50YXRpb24gY2FuIGRldGVjdCBhbmQgZGVjb2RlIFBERjQxNyBjb2RlcyBpbiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgUERGNDE3UmVhZGVyIHtcbiAgICAgICAgLy8gcHJpdmF0ZSBzdGF0aWMgLypmaW5hbCBSZXN1bHRbXSovIEVNUFRZX1JFU1VMVF9BUlJBWTogUmVzdWx0W10gPSBuZXcgUmVzdWx0KFswXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2NhdGVzIGFuZCBkZWNvZGVzIGEgUERGNDE3IGNvZGUgaW4gYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gYSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb250ZW50IGVuY29kZWQgYnkgdGhlIFBERjQxNyBjb2RlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgYSBQREY0MTcgY29kZSBjYW5ub3QgYmUgZm91bmQsXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgUERGNDE3IGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGUoaW1hZ2UsIGhpbnRzID0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFBERjQxN1JlYWRlci5kZWNvZGUoaW1hZ2UsIGhpbnRzLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0Lmxlbmd0aCA9PT0gMCB8fCByZXN1bHRbMF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IE5vdEZvdW5kRXhjZXB0aW9uLmdldE5vdEZvdW5kSW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBCaW5hcnlCaXRtYXBcbiAgICAgICAgICogQHBhcmFtIGltYWdlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIC8vICAgQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZU11bHRpcGxlKGltYWdlLCBoaW50cyA9IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBERjQxN1JlYWRlci5kZWNvZGUoaW1hZ2UsIGhpbnRzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBGb3JtYXRFeGNlcHRpb24gfHwgaWdub3JlZCBpbnN0YW5jZW9mIENoZWNrc3VtRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IE5vdEZvdW5kRXhjZXB0aW9uLmdldE5vdEZvdW5kSW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgaWdub3JlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlXG4gICAgICAgICAqIEBwYXJhbSBoaW50c1xuICAgICAgICAgKiBAcGFyYW0gbXVsdGlwbGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbsOfXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGUoaW1hZ2UsIGhpbnRzLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgY29uc3QgZGV0ZWN0b3JSZXN1bHQgPSBEZXRlY3RvciQzLmRldGVjdE11bHRpcGxlKGltYWdlLCBoaW50cywgbXVsdGlwbGUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludHMgb2YgZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVyUmVzdWx0ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmRlY29kZShkZXRlY3RvclJlc3VsdC5nZXRCaXRzKCksIHBvaW50c1s0XSwgcG9pbnRzWzVdLCBwb2ludHNbNl0sIHBvaW50c1s3XSwgUERGNDE3UmVhZGVyLmdldE1pbkNvZGV3b3JkV2lkdGgocG9pbnRzKSwgUERGNDE3UmVhZGVyLmdldE1heENvZGV3b3JkV2lkdGgocG9pbnRzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFJlc3VsdChkZWNvZGVyUmVzdWx0LmdldFRleHQoKSwgZGVjb2RlclJlc3VsdC5nZXRSYXdCeXRlcygpLCB1bmRlZmluZWQsIHBvaW50cywgQmFyY29kZUZvcm1hdCQxLlBERl80MTcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OX0xFVkVMLCBkZWNvZGVyUmVzdWx0LmdldEVDTGV2ZWwoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGRmNDE3UmVzdWx0TWV0YWRhdGEgPSBkZWNvZGVyUmVzdWx0LmdldE90aGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBkZjQxN1Jlc3VsdE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLlBERjQxN19FWFRSQV9NRVRBREFUQSwgcGRmNDE3UmVzdWx0TWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzLm1hcCh4ID0+IHgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRNYXhXaWR0aChwMSwgcDIpIHtcbiAgICAgICAgICAgIGlmIChwMSA9PSBudWxsIHx8IHAyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnRydW5jKE1hdGguYWJzKHAxLmdldFgoKSAtIHAyLmdldFgoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRNaW5XaWR0aChwMSwgcDIpIHtcbiAgICAgICAgICAgIGlmIChwMSA9PSBudWxsIHx8IHAyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC50cnVuYyhNYXRoLmFicyhwMS5nZXRYKCkgLSBwMi5nZXRYKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0TWF4Q29kZXdvcmRXaWR0aChwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1heChNYXRoLm1heChQREY0MTdSZWFkZXIuZ2V0TWF4V2lkdGgocFswXSwgcFs0XSksIFBERjQxN1JlYWRlci5nZXRNYXhXaWR0aChwWzZdLCBwWzJdKSAqIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX0NPREVXT1JEIC9cbiAgICAgICAgICAgICAgICBQREY0MTdDb21tb24uTU9EVUxFU19JTl9TVE9QX1BBVFRFUk4pLCBNYXRoLm1heChQREY0MTdSZWFkZXIuZ2V0TWF4V2lkdGgocFsxXSwgcFs1XSksIFBERjQxN1JlYWRlci5nZXRNYXhXaWR0aChwWzddLCBwWzNdKSAqIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX0NPREVXT1JEIC9cbiAgICAgICAgICAgICAgICBQREY0MTdDb21tb24uTU9EVUxFU19JTl9TVE9QX1BBVFRFUk4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldE1pbkNvZGV3b3JkV2lkdGgocCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5taW4oTWF0aC5taW4oUERGNDE3UmVhZGVyLmdldE1pbldpZHRoKHBbMF0sIHBbNF0pLCBQREY0MTdSZWFkZXIuZ2V0TWluV2lkdGgocFs2XSwgcFsyXSkgKiBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRCAvXG4gICAgICAgICAgICAgICAgUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fU1RPUF9QQVRURVJOKSwgTWF0aC5taW4oUERGNDE3UmVhZGVyLmdldE1pbldpZHRoKHBbMV0sIHBbNV0pLCBQREY0MTdSZWFkZXIuZ2V0TWluV2lkdGgocFs3XSwgcFszXSkgKiBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRCAvXG4gICAgICAgICAgICAgICAgUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fU1RPUF9QQVRURVJOKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgbmVlZHMgdG8gYmUgcmVzZXRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBSZWFkZXJFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cbiAgICBSZWFkZXJFeGNlcHRpb24ua2luZCA9ICdSZWFkZXJFeGNlcHRpb24nO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xuICAgIC8qKlxuICAgICAqIE11bHRpRm9ybWF0UmVhZGVyIGlzIGEgY29udmVuaWVuY2UgY2xhc3MgYW5kIHRoZSBtYWluIGVudHJ5IHBvaW50IGludG8gdGhlIGxpYnJhcnkgZm9yIG1vc3QgdXNlcy5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IGF0dGVtcHRzIHRvIGRlY29kZSBhbGwgYmFyY29kZSBmb3JtYXRzIHRoYXQgdGhlIGxpYnJhcnkgc3VwcG9ydHMuIE9wdGlvbmFsbHksIHlvdVxuICAgICAqIGNhbiBwcm92aWRlIGEgaGludHMgb2JqZWN0IHRvIHJlcXVlc3QgZGlmZmVyZW50IGJlaGF2aW9yLCBmb3IgZXhhbXBsZSBvbmx5IGRlY29kaW5nIFFSIGNvZGVzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIE11bHRpRm9ybWF0UmVhZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSB2ZXJib3NlIGlmICd0cnVlJyBsb2dzIHdpbGwgYmUgZHVtcGVkIHRvIGNvbnNvbGUsIG90aGVyd2lzZSBoaWRkZW4uXG4gICAgICAgICAqIEBwYXJhbSBoaW50cyBUaGUgaGludHMgdG8gdXNlLCBjbGVhcmluZyB0aGUgcHJldmlvdXMgc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcih2ZXJib3NlLCBoaW50cykge1xuICAgICAgICAgICAgdGhpcy52ZXJib3NlID0gKHZlcmJvc2UgPT09IHRydWUpO1xuICAgICAgICAgICAgaWYgKGhpbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIaW50cyhoaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgdmVyc2lvbiBvZiBkZWNvZGUgaG9ub3JzIHRoZSBpbnRlbnQgb2YgUmVhZGVyLmRlY29kZShCaW5hcnlCaXRtYXApIGluIHRoYXQgaXRcbiAgICAgICAgICogcGFzc2VzIG51bGwgYXMgYSBoaW50IHRvIHRoZSBkZWNvZGVycy4gSG93ZXZlciwgdGhhdCBtYWtlcyBpdCBpbmVmZmljaWVudCB0byBjYWxsIHJlcGVhdGVkbHkuXG4gICAgICAgICAqIFVzZSBzZXRIaW50cygpIGZvbGxvd2VkIGJ5IGRlY29kZVdpdGhTdGF0ZSgpIGZvciBjb250aW51b3VzIHNjYW4gYXBwbGljYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgVGhlIHBpeGVsIGRhdGEgdG8gZGVjb2RlXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGNvbnRlbnRzIG9mIHRoZSBpbWFnZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIEFueSBlcnJvcnMgd2hpY2ggb2NjdXJyZWRcbiAgICAgICAgICovXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgLy8gcHVibGljIGRlY29kZShpbWFnZTogQmluYXJ5Qml0bWFwKTogUmVzdWx0IHtcbiAgICAgICAgLy8gICBzZXRIaW50cyhudWxsKVxuICAgICAgICAvLyAgIHJldHVybiBkZWNvZGVJbnRlcm5hbChpbWFnZSlcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlIGFuIGltYWdlIHVzaW5nIHRoZSBoaW50cyBwcm92aWRlZC4gRG9lcyBub3QgaG9ub3IgZXhpc3Rpbmcgc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBUaGUgcGl4ZWwgZGF0YSB0byBkZWNvZGVcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIFRoZSBoaW50cyB0byB1c2UsIGNsZWFyaW5nIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgICAgICAgICogQHJldHVybiBUaGUgY29udGVudHMgb2YgdGhlIGltYWdlXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gQW55IGVycm9ycyB3aGljaCBvY2N1cnJlZFxuICAgICAgICAgKi9cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBkZWNvZGUoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgICAgICBpZiAoaGludHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhpbnRzKGhpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUludGVybmFsKGltYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlIGFuIGltYWdlIHVzaW5nIHRoZSBzdGF0ZSBzZXQgdXAgYnkgY2FsbGluZyBzZXRIaW50cygpIHByZXZpb3VzbHkuIENvbnRpbnVvdXMgc2NhblxuICAgICAgICAgKiBjbGllbnRzIHdpbGwgZ2V0IGEgPGI+bGFyZ2U8L2I+IHNwZWVkIGluY3JlYXNlIGJ5IHVzaW5nIHRoaXMgaW5zdGVhZCBvZiBkZWNvZGUoKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlIFRoZSBwaXhlbCBkYXRhIHRvIGRlY29kZVxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBjb250ZW50cyBvZiB0aGUgaW1hZ2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBBbnkgZXJyb3JzIHdoaWNoIG9jY3VycmVkXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVXaXRoU3RhdGUoaW1hZ2UpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBzZXQgdXAgdGhlIGRlZmF1bHQgc3RhdGUgc28gd2UgZG9uJ3QgY3Jhc2hcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRlcnMgPT09IG51bGwgfHwgdGhpcy5yZWFkZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhpbnRzKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlSW50ZXJuYWwoaW1hZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhZGRzIHN0YXRlIHRvIHRoZSBNdWx0aUZvcm1hdFJlYWRlci4gQnkgc2V0dGluZyB0aGUgaGludHMgb25jZSwgc3Vic2VxdWVudCBjYWxsc1xuICAgICAgICAgKiB0byBkZWNvZGVXaXRoU3RhdGUoaW1hZ2UpIGNhbiByZXVzZSB0aGUgc2FtZSBzZXQgb2YgcmVhZGVycyB3aXRob3V0IHJlYWxsb2NhdGluZyBtZW1vcnkuIFRoaXNcbiAgICAgICAgICogaXMgaW1wb3J0YW50IGZvciBwZXJmb3JtYW5jZSBpbiBjb250aW51b3VzIHNjYW4gY2xpZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIFRoZSBzZXQgb2YgaGludHMgdG8gdXNlIGZvciBzdWJzZXF1ZW50IGNhbGxzIHRvIGRlY29kZShpbWFnZSlcbiAgICAgICAgICovXG4gICAgICAgIHNldEhpbnRzKGhpbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmhpbnRzID0gaGludHM7XG4gICAgICAgICAgICBjb25zdCB0cnlIYXJkZXIgPSAhaXNOdWxsT3JVbmRlZmluZWQoaGludHMpXG4gICAgICAgICAgICAgICAgJiYgaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuVFJZX0hBUkRFUikgPT09IHRydWU7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRzID0gaXNOdWxsT3JVbmRlZmluZWQoaGludHMpID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlBPU1NJQkxFX0ZPUk1BVFMpO1xuICAgICAgICAgICAgY29uc3QgcmVhZGVycyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChmb3JtYXRzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZE9uZURSZWFkZXIgPSBmb3JtYXRzLnNvbWUoZiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuVVBDX0EgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5VUENfRSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdCQxLkVBTl8xMyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdCQxLkVBTl84IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuQ09EQUJBUiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdCQxLkNPREVfMzkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5DT0RFXzkzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuQ09ERV8xMjggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5JVEYgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5SU1NfMTQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5SU1NfRVhQQU5ERUQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFB1dCAxRCByZWFkZXJzIHVwZnJvbnQgaW4gXCJub3JtYWxcIiBtb2RlXG4gICAgICAgICAgICAgICAgaWYgKGFkZE9uZURSZWFkZXIgJiYgIXRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IE11bHRpRm9ybWF0T25lRFJlYWRlcihoaW50cywgdGhpcy52ZXJib3NlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5RUl9DT0RFKSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IFFSQ29kZVJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLkRBVEFfTUFUUklYKSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IERhdGFNYXRyaXhSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5BWlRFQykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBBenRlY1JlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLlBERl80MTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgUERGNDE3UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiAoZm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0Lk1BWElDT0RFKSkge1xuICAgICAgICAgICAgICAgIC8vICAgIHJlYWRlcnMucHVzaChuZXcgTWF4aUNvZGVSZWFkZXIoKSlcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gQXQgZW5kIGluIFwidHJ5IGhhcmRlclwiIG1vZGVcbiAgICAgICAgICAgICAgICBpZiAoYWRkT25lRFJlYWRlciAmJiB0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdE9uZURSZWFkZXIoaGludHMsIHRoaXMudmVyYm9zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICghdHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRPbmVEUmVhZGVyKGhpbnRzLCB0aGlzLnZlcmJvc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBRUkNvZGVSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBEYXRhTWF0cml4UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgQXp0ZWNSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBQREY0MTdSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgLy8gcmVhZGVycy5wdXNoKG5ldyBNYXhpQ29kZVJlYWRlcigpKVxuICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdE9uZURSZWFkZXIoaGludHMsIHRoaXMudmVyYm9zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVycyA9IHJlYWRlcnM7IC8vIC50b0FycmF5KG5ldyBSZWFkZXJbcmVhZGVycy5zaXplKCldKVxuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5yZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlSW50ZXJuYWwoaW1hZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRlcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVhZGVyRXhjZXB0aW9uKCdObyByZWFkZXJzIHdoZXJlIHNlbGVjdGVkLCBub3RoaW5nIGNhbiBiZSByZWFkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5yZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5aW5nIHRvIGRlY29kZSB3aXRoICR7cmVhZGVyfSByZWFkZXIuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5kZWNvZGUoaW1hZ2UsIHRoaXMuaGludHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgUmVhZGVyRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBCYWQgRXhjZXB0aW9uLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbignTm8gTXVsdGlGb3JtYXQgUmVhZGVycyB3ZXJlIGFibGUgdG8gZGV0ZWN0IHRoZSBjb2RlLicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyIGV4dGVuZHMgQnJvd3NlckNvZGVSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihoaW50cyA9IG51bGwsIHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPSA1MDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBNdWx0aUZvcm1hdFJlYWRlcigpO1xuICAgICAgICAgICAgcmVhZGVyLnNldEhpbnRzKGhpbnRzKTtcbiAgICAgICAgICAgIHN1cGVyKHJlYWRlciwgdGltZUJldHdlZW5TY2Fuc01pbGxpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0ZSBkZWNvZGVCaXRtYXAgdG8gY2FsbCBkZWNvZGVXaXRoU3RhdGUsIHdoaWNoIHdpbGwgcGF5XG4gICAgICAgICAqIGF0dGVudGlvbiB0byB0aGUgaGludHMgc2V0IGluIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlQml0bWFwKGJpbmFyeUJpdG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLmRlY29kZVdpdGhTdGF0ZShiaW5hcnlCaXRtYXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICpcbiAgICAgKiBRUiBDb2RlIHJlYWRlciB0byB1c2UgZnJvbSBicm93c2VyLlxuICAgICAqL1xuICAgIGNsYXNzIEJyb3dzZXJQREY0MTdSZWFkZXIgZXh0ZW5kcyBCcm93c2VyQ29kZVJlYWRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJyb3dzZXJQREY0MTdSZWFkZXIuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZUJldHdlZW5TY2Fuc01pbGxpcz01MDBdIHRoZSB0aW1lIGRlbGF5IGJldHdlZW4gc3Vic2VxdWVudCBkZWNvZGUgdHJpZXNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPSA1MDApIHtcbiAgICAgICAgICAgIHN1cGVyKG5ldyBQREY0MTdSZWFkZXIoKSwgdGltZUJldHdlZW5TY2Fuc01pbGxpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBNb3ZpbmcgdG8gQHp4aW5nL2Jyb3dzZXJcbiAgICAgKlxuICAgICAqIFFSIENvZGUgcmVhZGVyIHRvIHVzZSBmcm9tIGJyb3dzZXIuXG4gICAgICovXG4gICAgY2xhc3MgQnJvd3NlclFSQ29kZVJlYWRlciBleHRlbmRzIEJyb3dzZXJDb2RlUmVhZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlclFSQ29kZVJlYWRlci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lQmV0d2VlblNjYW5zTWlsbGlzPTUwMF0gdGhlIHRpbWUgZGVsYXkgYmV0d2VlbiBzdWJzZXF1ZW50IGRlY29kZSB0cmllc1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IodGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IDUwMCkge1xuICAgICAgICAgICAgc3VwZXIobmV3IFFSQ29kZVJlYWRlcigpLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbiAgICAvKipcbiAgICAgKiBUaGVzZSBhcmUgYSBzZXQgb2YgaGludHMgdGhhdCB5b3UgbWF5IHBhc3MgdG8gV3JpdGVycyB0byBzcGVjaWZ5IHRoZWlyIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKi9cbiAgICB2YXIgRW5jb2RlSGludFR5cGU7XG4gICAgKGZ1bmN0aW9uIChFbmNvZGVIaW50VHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoYXQgZGVncmVlIG9mIGVycm9yIGNvcnJlY3Rpb24gdG8gdXNlLCBmb3IgZXhhbXBsZSBpbiBRUiBDb2Rlcy5cbiAgICAgICAgICogVHlwZSBkZXBlbmRzIG9uIHRoZSBlbmNvZGVyLiBGb3IgZXhhbXBsZSBmb3IgUVIgY29kZXMgaXQncyB0eXBlXG4gICAgICAgICAqIHtAbGluayBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZWNvZGVyLkVycm9yQ29ycmVjdGlvbkxldmVsIEVycm9yQ29ycmVjdGlvbkxldmVsfS5cbiAgICAgICAgICogRm9yIEF6dGVjIGl0IGlzIG9mIHR5cGUge0BsaW5rIEludGVnZXJ9LCByZXByZXNlbnRpbmcgdGhlIG1pbmltYWwgcGVyY2VudGFnZSBvZiBlcnJvciBjb3JyZWN0aW9uIHdvcmRzLlxuICAgICAgICAgKiBGb3IgUERGNDE3IGl0IGlzIG9mIHR5cGUge0BsaW5rIEludGVnZXJ9LCB2YWxpZCB2YWx1ZXMgYmVpbmcgMCB0byA4LlxuICAgICAgICAgKiBJbiBhbGwgY2FzZXMsIGl0IGNhbiBhbHNvIGJlIGEge0BsaW5rIFN0cmluZ30gcmVwcmVzZW50YXRpb24gb2YgdGhlIGRlc2lyZWQgdmFsdWUgYXMgd2VsbC5cbiAgICAgICAgICogTm90ZTogYW4gQXp0ZWMgc3ltYm9sIHNob3VsZCBoYXZlIGEgbWluaW11bSBvZiAyNSUgRUMgd29yZHMuXG4gICAgICAgICAqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIkVSUk9SX0NPUlJFQ1RJT05cIl0gPSAwXSA9IFwiRVJST1JfQ09SUkVDVElPTlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoYXQgY2hhcmFjdGVyIGVuY29kaW5nIHRvIHVzZSB3aGVyZSBhcHBsaWNhYmxlICh0eXBlIHtAbGluayBTdHJpbmd9KVxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJDSEFSQUNURVJfU0VUXCJdID0gMV0gPSBcIkNIQVJBQ1RFUl9TRVRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbWF0cml4IHNoYXBlIGZvciBEYXRhIE1hdHJpeCAodHlwZSB7QGxpbmsgY29tLmdvb2dsZS56eGluZy5kYXRhbWF0cml4LmVuY29kZXIuU3ltYm9sU2hhcGVIaW50fSlcbiAgICAgICAgICovXG4gICAgICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiREFUQV9NQVRSSVhfU0hBUEVcIl0gPSAyXSA9IFwiREFUQV9NQVRSSVhfU0hBUEVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBhIG1pbmltdW0gYmFyY29kZSBzaXplICh0eXBlIHtAbGluayBEaW1lbnNpb259KS4gT25seSBhcHBsaWNhYmxlIHRvIERhdGEgTWF0cml4IG5vdy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgdXNlIHdpZHRoL2hlaWdodCBwYXJhbXMgaW5cbiAgICAgICAgICoge0BsaW5rIGNvbS5nb29nbGUuenhpbmcuZGF0YW1hdHJpeC5EYXRhTWF0cml4V3JpdGVyI2VuY29kZShTdHJpbmcsIEJhcmNvZGVGb3JtYXQsIGludCwgaW50KX1cbiAgICAgICAgICovXG4gICAgICAgIC8qQERlcHJlY2F0ZWQqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIk1JTl9TSVpFXCJdID0gM10gPSBcIk1JTl9TSVpFXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgYSBtYXhpbXVtIGJhcmNvZGUgc2l6ZSAodHlwZSB7QGxpbmsgRGltZW5zaW9ufSkuIE9ubHkgYXBwbGljYWJsZSB0byBEYXRhIE1hdHJpeCBub3cuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHdpdGhvdXQgcmVwbGFjZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIC8qQERlcHJlY2F0ZWQqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIk1BWF9TSVpFXCJdID0gNF0gPSBcIk1BWF9TSVpFXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgbWFyZ2luLCBpbiBwaXhlbHMsIHRvIHVzZSB3aGVuIGdlbmVyYXRpbmcgdGhlIGJhcmNvZGUuIFRoZSBtZWFuaW5nIGNhbiB2YXJ5XG4gICAgICAgICAqIGJ5IGZvcm1hdDsgZm9yIGV4YW1wbGUgaXQgY29udHJvbHMgbWFyZ2luIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGJhcmNvZGUgaG9yaXpvbnRhbGx5IGZvclxuICAgICAgICAgKiBtb3N0IDFEIGZvcm1hdHMuIChUeXBlIHtAbGluayBJbnRlZ2VyfSwgb3Ige0BsaW5rIFN0cmluZ30gcmVwcmVzZW50YXRpb24gb2YgdGhlIGludGVnZXIgdmFsdWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJNQVJHSU5cIl0gPSA1XSA9IFwiTUFSR0lOXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0byB1c2UgY29tcGFjdCBtb2RlIGZvciBQREY0MTcgKHR5cGUge0BsaW5rIEJvb2xlYW59LCBvciBcInRydWVcIiBvciBcImZhbHNlXCJcbiAgICAgICAgICoge0BsaW5rIFN0cmluZ30gdmFsdWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJQREY0MTdfQ09NUEFDVFwiXSA9IDZdID0gXCJQREY0MTdfQ09NUEFDVFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoYXQgY29tcGFjdGlvbiBtb2RlIHRvIHVzZSBmb3IgUERGNDE3ICh0eXBlXG4gICAgICAgICAqIHtAbGluayBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5lbmNvZGVyLkNvbXBhY3Rpb24gQ29tcGFjdGlvbn0gb3Ige0BsaW5rIFN0cmluZ30gdmFsdWUgb2Ygb25lIG9mIGl0c1xuICAgICAgICAgKiBlbnVtIHZhbHVlcykuXG4gICAgICAgICAqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIlBERjQxN19DT01QQUNUSU9OXCJdID0gN10gPSBcIlBERjQxN19DT01QQUNUSU9OXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgZm9yIFBERjQxNyAodHlwZVxuICAgICAgICAgKiB7QGxpbmsgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZW5jb2Rlci5EaW1lbnNpb25zIERpbWVuc2lvbnN9KS5cbiAgICAgICAgICovXG4gICAgICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiUERGNDE3X0RJTUVOU0lPTlNcIl0gPSA4XSA9IFwiUERGNDE3X0RJTUVOU0lPTlNcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGxheWVycyBmb3IgYW4gQXp0ZWMgY29kZS5cbiAgICAgICAgICogQSBuZWdhdGl2ZSBudW1iZXIgKC0xLCAtMiwgLTMsIC00KSBzcGVjaWZpZXMgYSBjb21wYWN0IEF6dGVjIGNvZGUuXG4gICAgICAgICAqIDAgaW5kaWNhdGVzIHRvIHVzZSB0aGUgbWluaW11bSBudW1iZXIgb2YgbGF5ZXJzICh0aGUgZGVmYXVsdCkuXG4gICAgICAgICAqIEEgcG9zaXRpdmUgbnVtYmVyICgxLCAyLCAuLiAzMikgc3BlY2lmaWVzIGEgbm9ybWFsIChub24tY29tcGFjdCkgQXp0ZWMgY29kZS5cbiAgICAgICAgICogKFR5cGUge0BsaW5rIEludGVnZXJ9LCBvciB7QGxpbmsgU3RyaW5nfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW50ZWdlciB2YWx1ZSkuXG4gICAgICAgICAqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIkFaVEVDX0xBWUVSU1wiXSA9IDldID0gXCJBWlRFQ19MQVlFUlNcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgZXhhY3QgdmVyc2lvbiBvZiBRUiBjb2RlIHRvIGJlIGVuY29kZWQuXG4gICAgICAgICAqIChUeXBlIHtAbGluayBJbnRlZ2VyfSwgb3Ige0BsaW5rIFN0cmluZ30gcmVwcmVzZW50YXRpb24gb2YgdGhlIGludGVnZXIgdmFsdWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJRUl9WRVJTSU9OXCJdID0gMTBdID0gXCJRUl9WRVJTSU9OXCI7XG4gICAgfSkoRW5jb2RlSGludFR5cGUgfHwgKEVuY29kZUhpbnRUeXBlID0ge30pKTtcbiAgICB2YXIgRW5jb2RlSGludFR5cGUkMSA9IEVuY29kZUhpbnRUeXBlO1xuXG4gICAgLyoqXG4gICAgICogPHA+SW1wbGVtZW50cyBSZWVkLVNvbG9tb24gZW5jb2RpbmcsIGFzIHRoZSBuYW1lIGltcGxpZXMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIFdpbGxpYW0gUnVja2xpZGdlXG4gICAgICovXG4gICAgY2xhc3MgUmVlZFNvbG9tb25FbmNvZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVlZCBzb2xvbW9uIGVycm9yLWNvcnJlY3RpbmcgZW5jb2RpbmcgY29uc3RydWN0b3IgaXMgY3JlYXRlZCBieVxuICAgICAgICAgKiBwYXNzaW5nIGFzIEdhbG9pcyBGaWVsZCB3aXRoIG9mIHNpemUgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBjb2RlXG4gICAgICAgICAqIHdvcmRzIChzeW1ib2xzKSBpbiB0aGUgYWxwaGFiZXQgKHRoZSBudW1iZXIgb2YgdmFsdWVzIGluIGVhY2hcbiAgICAgICAgICogZWxlbWVudCBvZiBhcnJheXMgdGhhdCBhcmUgZW5jb2RlZC9kZWNvZGVkKS5cbiAgICAgICAgICogQHBhcmFtIGZpZWxkIEEgZ2Fsb2lzIGZpZWxkIHdpdGggYSBudW1iZXIgb2YgZWxlbWVudHMgZXF1YWwgdG8gdGhlIHNpemVcbiAgICAgICAgICogb2YgdGhlIGFscGhhYmV0IG9mIHN5bWJvbHMgdG8gZW5jb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoZmllbGQpIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkR2VuZXJhdG9ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRHZW5lcmF0b3JzLnB1c2gobmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIEludDMyQXJyYXkuZnJvbShbMV0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRHZW5lcmF0b3IoZGVncmVlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZEdlbmVyYXRvcnMgPSB0aGlzLmNhY2hlZEdlbmVyYXRvcnM7XG4gICAgICAgICAgICBpZiAoZGVncmVlID49IGNhY2hlZEdlbmVyYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RHZW5lcmF0b3IgPSBjYWNoZWRHZW5lcmF0b3JzW2NhY2hlZEdlbmVyYXRvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSBjYWNoZWRHZW5lcmF0b3JzLmxlbmd0aDsgZCA8PSBkZWdyZWU7IGQrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0R2VuZXJhdG9yID0gbGFzdEdlbmVyYXRvci5tdWx0aXBseShuZXcgR2VuZXJpY0dGUG9seShmaWVsZCwgSW50MzJBcnJheS5mcm9tKFsxLCBmaWVsZC5leHAoZCAtIDEgKyBmaWVsZC5nZXRHZW5lcmF0b3JCYXNlKCkpXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkR2VuZXJhdG9ycy5wdXNoKG5leHRHZW5lcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdG9yID0gbmV4dEdlbmVyYXRvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkR2VuZXJhdG9yc1tkZWdyZWVdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5FbmNvZGUgYSBzZXF1ZW5jZSBvZiBjb2RlIHdvcmRzIChzeW1ib2xzKSB1c2luZyBSZWVkLVNvbG9tb24gdG8gYWxsb3cgZGVjb2RlcnNcbiAgICAgICAgICogdG8gZGV0ZWN0IGFuZCBjb3JyZWN0IGVycm9ycyB0aGF0IG1heSBoYXZlIGJlZW4gaW50cm9kdWNlZCB3aGVuIHRoZSByZXN1bHRpbmdcbiAgICAgICAgICogZGF0YSBpcyBzdG9yZWQgb3IgdHJhbnNtaXR0ZWQuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdG9FbmNvZGUgYXJyYXkgdXNlZCBmb3IgYm90aCBhbmQgb3V0cHV0LiBDYWxsZXIgaW5pdGlhbGl6ZXMgdGhlIGFycmF5IHdpdGhcbiAgICAgICAgICogdGhlIGNvZGUgd29yZHMgKHN5bWJvbHMpIHRvIGJlIGVuY29kZWQgZm9sbG93ZWQgYnkgZW1wdHkgZWxlbWVudHMgYWxsb2NhdGVkIHRvIG1ha2VcbiAgICAgICAgICogc3BhY2UgZm9yIGVycm9yLWNvcnJlY3Rpb24gY29kZSB3b3JkcyBpbiB0aGUgZW5jb2RlZCBvdXRwdXQuIFRoZSBhcnJheSBjb250YWluc1xuICAgICAgICAgKiB0aGUgZW5jZG9kZWQgb3V0cHV0IHdoZW4gZW5jb2RlIHJldHVybnMuIENvZGUgd29yZHMgYXJlIGVuY29kZWQgYXMgbnVtYmVycyBmcm9tXG4gICAgICAgICAqIDAgdG8gbi0xLCB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgcG9zc2libGUgY29kZSB3b3JkcyAoc3ltYm9scyksIGFzIGRldGVybWluZWRcbiAgICAgICAgICogYnkgdGhlIHNpemUgb2YgdGhlIEdhbG9pcyBGaWVsZCBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0gZWNCeXRlcyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHJlc2VydmVkIGluIHRoZSBhcnJheSAoZmlyc3QgcGFyYW1ldGVyKVxuICAgICAgICAgKiB0byBzdG9yZSBlcnJvci1jb3JyZWN0aW9uIGNvZGUgd29yZHMuIFRodXMsIHRoZSBudW1iZXIgb2YgY29kZSB3b3JkcyAoc3ltYm9scylcbiAgICAgICAgICogdG8gZW5jb2RlIGluIHRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGh1cyB0b0VuY29kZS5sZW5ndGggLSBlY0J5dGVzLlxuICAgICAgICAgKiBOb3RlLCB0aGUgdXNlIG9mIFwiYnl0ZXNcIiBpbiB0aGUgbmFtZSBvZiB0aGlzIHBhcmFtZXRlciBpcyBtaXNsZWFkaW5nLCBhcyB0aGVyZSBtYXlcbiAgICAgICAgICogYmUgbW9yZSBvciBmZXdlciB0aGFuIDI1NiBzeW1ib2xzIGJlaW5nIGVuY29kZWQsIGFzIGRldGVybWluZWQgYnkgdGhlIG51bWJlciBvZlxuICAgICAgICAgKiBlbGVtZW50cyBpbiB0aGUgR2Fsb2lzIEZpZWxkIHBhc3NlZCBhcyBhIGNvbnN0cnVjdG9yIHRvIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiB0aHJvd24gaW4gcmVzcG9uc2UgdG8gdmFsaWRhdGlvbiBlcnJyb3MuXG4gICAgICAgICAqL1xuICAgICAgICBlbmNvZGUodG9FbmNvZGUsIGVjQnl0ZXMgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKGVjQnl0ZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdObyBlcnJvciBjb3JyZWN0aW9uIGJ5dGVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhQnl0ZXMgPSB0b0VuY29kZS5sZW5ndGggLSBlY0J5dGVzO1xuICAgICAgICAgICAgaWYgKGRhdGFCeXRlcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTm8gZGF0YSBieXRlcyBwcm92aWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gdGhpcy5idWlsZEdlbmVyYXRvcihlY0J5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm9Db2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShkYXRhQnl0ZXMpO1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0b0VuY29kZSwgMCwgaW5mb0NvZWZmaWNpZW50cywgMCwgZGF0YUJ5dGVzKTtcbiAgICAgICAgICAgIGxldCBpbmZvID0gbmV3IEdlbmVyaWNHRlBvbHkodGhpcy5maWVsZCwgaW5mb0NvZWZmaWNpZW50cyk7XG4gICAgICAgICAgICBpbmZvID0gaW5mby5tdWx0aXBseUJ5TW9ub21pYWwoZWNCeXRlcywgMSk7XG4gICAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSBpbmZvLmRpdmlkZShnZW5lcmF0b3IpWzFdO1xuICAgICAgICAgICAgY29uc3QgY29lZmZpY2llbnRzID0gcmVtYWluZGVyLmdldENvZWZmaWNpZW50cygpO1xuICAgICAgICAgICAgY29uc3QgbnVtWmVyb0NvZWZmaWNpZW50cyA9IGVjQnl0ZXMgLSBjb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1aZXJvQ29lZmZpY2llbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b0VuY29kZVtkYXRhQnl0ZXMgKyBpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvZWZmaWNpZW50cywgMCwgdG9FbmNvZGUsIGRhdGFCeXRlcyArIG51bVplcm9Db2VmZmljaWVudHMsIGNvZWZmaWNpZW50cy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBTYXRvcnUgVGFrYWJheWFzaGlcbiAgICAgKiBAYXV0aG9yIERhbmllbCBTd2l0a2luXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBNYXNrVXRpbCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBtYXNrIHBlbmFsdHkgcnVsZSAxIGFuZCByZXR1cm4gdGhlIHBlbmFsdHkuIEZpbmQgcmVwZXRpdGl2ZSBjZWxscyB3aXRoIHRoZSBzYW1lIGNvbG9yIGFuZFxuICAgICAgICAgKiBnaXZlIHBlbmFsdHkgdG8gdGhlbS4gRXhhbXBsZTogMDAwMDAgb3IgMTExMTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwbHlNYXNrUGVuYWx0eVJ1bGUxKG1hdHJpeCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMUludGVybmFsKG1hdHJpeCwgdHJ1ZSkgKyBNYXNrVXRpbC5hcHBseU1hc2tQZW5hbHR5UnVsZTFJbnRlcm5hbChtYXRyaXgsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgbWFzayBwZW5hbHR5IHJ1bGUgMiBhbmQgcmV0dXJuIHRoZSBwZW5hbHR5LiBGaW5kIDJ4MiBibG9ja3Mgd2l0aCB0aGUgc2FtZSBjb2xvciBhbmQgZ2l2ZVxuICAgICAgICAgKiBwZW5hbHR5IHRvIHRoZW0uIFRoaXMgaXMgYWN0dWFsbHkgZXF1aXZhbGVudCB0byB0aGUgc3BlYydzIHJ1bGUsIHdoaWNoIGlzIHRvIGZpbmQgTXhOIGJsb2NrcyBhbmQgZ2l2ZSBhXG4gICAgICAgICAqIHBlbmFsdHkgcHJvcG9ydGlvbmFsIHRvIChNLTEpeChOLTEpLCBiZWNhdXNlIHRoaXMgaXMgdGhlIG51bWJlciBvZiAyeDIgYmxvY2tzIGluc2lkZSBzdWNoIGEgYmxvY2suXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwbHlNYXNrUGVuYWx0eVJ1bGUyKG1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IHBlbmFsdHkgPSAwO1xuICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBtYXRyaXguZ2V0QXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gbWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBtYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodCAtIDE7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5WSA9IGFycmF5W3ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGggLSAxOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcnJheVlbeF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gYXJyYXlZW3ggKyAxXSAmJiB2YWx1ZSA9PT0gYXJyYXlbeSArIDFdW3hdICYmIHZhbHVlID09PSBhcnJheVt5ICsgMV1beCArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5hbHR5Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWFza1V0aWwuTjIgKiBwZW5hbHR5O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBtYXNrIHBlbmFsdHkgcnVsZSAzIGFuZCByZXR1cm4gdGhlIHBlbmFsdHkuIEZpbmQgY29uc2VjdXRpdmUgcnVucyBvZiAxOjE6MzoxOjE6NFxuICAgICAgICAgKiBzdGFydGluZyB3aXRoIGJsYWNrLCBvciA0OjE6MTozOjE6MSBzdGFydGluZyB3aXRoIHdoaXRlLCBhbmQgZ2l2ZSBwZW5hbHR5IHRvIHRoZW0uICBJZiB3ZVxuICAgICAgICAgKiBmaW5kIHBhdHRlcm5zIGxpa2UgMDAwMDEwMTExMDEwMDAwLCB3ZSBnaXZlIHBlbmFsdHkgb25jZS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBseU1hc2tQZW5hbHR5UnVsZTMobWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgbnVtUGVuYWx0aWVzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheVkgPSBhcnJheVt5XTsgLy8gV2UgY2FuIGF0IGxlYXN0IG9wdGltaXplIHRoaXMgYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIGlmICh4ICsgNiA8IHdpZHRoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVlbeF0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgMV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgMl0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgM10gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgNF0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgNV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgNl0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChNYXNrVXRpbC5pc1doaXRlSG9yaXpvbnRhbChhcnJheVksIHggLSA0LCB4KSB8fCBNYXNrVXRpbC5pc1doaXRlSG9yaXpvbnRhbChhcnJheVksIHggKyA3LCB4ICsgMTEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtUGVuYWx0aWVzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgKyA2IDwgaGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVt5XVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbeSArIDFdW3hdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVt5ICsgMl1beF0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyAzXVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbeSArIDRdW3hdID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVt5ICsgNV1beF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyA2XVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKE1hc2tVdGlsLmlzV2hpdGVWZXJ0aWNhbChhcnJheSwgeCwgeSAtIDQsIHkpIHx8IE1hc2tVdGlsLmlzV2hpdGVWZXJ0aWNhbChhcnJheSwgeCwgeSArIDcsIHkgKyAxMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1QZW5hbHRpZXMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW1QZW5hbHRpZXMgKiBNYXNrVXRpbC5OMztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNXaGl0ZUhvcml6b250YWwocm93QXJyYXksIGZyb20gLyppbnQqLywgdG8gLyppbnQqLykge1xuICAgICAgICAgICAgZnJvbSA9IE1hdGgubWF4KGZyb20sIDApO1xuICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgcm93QXJyYXkubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyb3dBcnJheVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGlzV2hpdGVWZXJ0aWNhbChhcnJheSwgY29sIC8qaW50Ki8sIGZyb20gLyppbnQqLywgdG8gLyppbnQqLykge1xuICAgICAgICAgICAgZnJvbSA9IE1hdGgubWF4KGZyb20sIDApO1xuICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheVtpXVtjb2xdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgbWFzayBwZW5hbHR5IHJ1bGUgNCBhbmQgcmV0dXJuIHRoZSBwZW5hbHR5LiBDYWxjdWxhdGUgdGhlIHJhdGlvIG9mIGRhcmsgY2VsbHMgYW5kIGdpdmVcbiAgICAgICAgICogcGVuYWx0eSBpZiB0aGUgcmF0aW8gaXMgZmFyIGZyb20gNTAlLiBJdCBnaXZlcyAxMCBwZW5hbHR5IGZvciA1JSBkaXN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBseU1hc2tQZW5hbHR5UnVsZTQobWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgbnVtRGFya0NlbGxzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5WSA9IGFycmF5W3ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXlZW3hdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1EYXJrQ2VsbHMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG51bVRvdGFsQ2VsbHMgPSBtYXRyaXguZ2V0SGVpZ2h0KCkgKiBtYXRyaXguZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpdmVQZXJjZW50VmFyaWFuY2VzID0gTWF0aC5mbG9vcihNYXRoLmFicyhudW1EYXJrQ2VsbHMgKiAyIC0gbnVtVG90YWxDZWxscykgKiAxMCAvIG51bVRvdGFsQ2VsbHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZpdmVQZXJjZW50VmFyaWFuY2VzICogTWFza1V0aWwuTjQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgbWFzayBiaXQgZm9yIFwiZ2V0TWFza1BhdHRlcm5cIiBhdCBcInhcIiBhbmQgXCJ5XCIuIFNlZSA4Ljggb2YgSklTWDA1MTA6MjAwNCBmb3IgbWFza1xuICAgICAgICAgKiBwYXR0ZXJuIGNvbmRpdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0RGF0YU1hc2tCaXQobWFza1BhdHRlcm4gLyppbnQqLywgeCAvKmludCovLCB5IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGxldCBpbnRlcm1lZGlhdGU7IC8qaW50Ki9cbiAgICAgICAgICAgIGxldCB0ZW1wOyAvKmludCovXG4gICAgICAgICAgICBzd2l0Y2ggKG1hc2tQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSAoeSArIHgpICYgMHgxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9IHkgJiAweDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0geCAlIDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gKHkgKyB4KSAlIDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gKE1hdGguZmxvb3IoeSAvIDIpICsgTWF0aC5mbG9vcih4IC8gMykpICYgMHgxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSB5ICogeDtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gKHRlbXAgJiAweDEpICsgKHRlbXAgJSAzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0geSAqIHg7XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9ICgodGVtcCAmIDB4MSkgKyAodGVtcCAlIDMpKSAmIDB4MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0geSAqIHg7XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9ICgodGVtcCAlIDMpICsgKCh5ICsgeCkgJiAweDEpKSAmIDB4MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignSW52YWxpZCBtYXNrIHBhdHRlcm46ICcgKyBtYXNrUGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJtZWRpYXRlID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGFwcGx5TWFza1BlbmFsdHlSdWxlMS4gV2UgbmVlZCB0aGlzIGZvciBkb2luZyB0aGlzIGNhbGN1bGF0aW9uIGluIGJvdGhcbiAgICAgICAgICogdmVydGljYWwgYW5kIGhvcml6b250YWwgb3JkZXJzIHJlc3BlY3RpdmVseS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBseU1hc2tQZW5hbHR5UnVsZTFJbnRlcm5hbChtYXRyaXgsIGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgbGV0IHBlbmFsdHkgPSAwO1xuICAgICAgICAgICAgY29uc3QgaUxpbWl0ID0gaXNIb3Jpem9udGFsID8gbWF0cml4LmdldEhlaWdodCgpIDogbWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBqTGltaXQgPSBpc0hvcml6b250YWwgPyBtYXRyaXguZ2V0V2lkdGgoKSA6IG1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlMaW1pdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG51bVNhbWVCaXRDZWxscyA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZCaXQgPSAtMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGpMaW1pdDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IGlzSG9yaXpvbnRhbCA/IGFycmF5W2ldW2pdIDogYXJyYXlbal1baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXQgPT09IHByZXZCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVNhbWVCaXRDZWxscysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bVNhbWVCaXRDZWxscyA+PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuYWx0eSArPSBNYXNrVXRpbC5OMSArIChudW1TYW1lQml0Q2VsbHMgLSA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVNhbWVCaXRDZWxscyA9IDE7IC8vIEluY2x1ZGUgdGhlIGNlbGwgaXRzZWxmLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkJpdCA9IGJpdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobnVtU2FtZUJpdENlbGxzID49IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuYWx0eSArPSBNYXNrVXRpbC5OMSArIChudW1TYW1lQml0Q2VsbHMgLSA1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGVuYWx0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQZW5hbHR5IHdlaWdodHMgZnJvbSBzZWN0aW9uIDYuOC4yLjFcbiAgICBNYXNrVXRpbC5OMSA9IDM7XG4gICAgTWFza1V0aWwuTjIgPSAzO1xuICAgIE1hc2tVdGlsLk4zID0gNDA7XG4gICAgTWFza1V0aWwuTjQgPSAxMDtcblxuICAgIC8qKlxuICAgICAqIEpBVkFQT1JUOiBUaGUgb3JpZ2luYWwgY29kZSB3YXMgYSAyRCBhcnJheSBvZiBpbnRzLCBidXQgc2luY2UgaXQgb25seSBldmVyIGdldHMgYXNzaWduZWRcbiAgICAgKiAtMSwgMCwgYW5kIDEsIEknbSBnb2luZyB0byB1c2UgbGVzcyBtZW1vcnkgYW5kIGdvIHdpdGggYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIEJ5dGVNYXRyaXgge1xuICAgICAgICBjb25zdHJ1Y3Rvcih3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBBcnJheShoZWlnaHQpOyAvLyBbaGVpZ2h0XVt3aWR0aF1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGdldCh4IC8qaW50Ki8sIHkgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNbeV1beF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gYW4gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gYXMgYnl0ZXMsIGluIHJvdy1tYWpvciBvcmRlci4gYXJyYXlbeV1beF0gcmVwcmVzZW50cyBwb2ludCAoeCx5KVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogcHJlZmZlciB0byBsZXQgdHdvIG1ldGhvZHMgaW5zdGVhZCBvZiBvdmVycmlkZSB0byBhdm9pZCB0eXBlIGNvbXBhcmlzb24gaW5zaWRlXG4gICAgICAgIHNldE51bWJlcih4IC8qaW50Ki8sIHkgLyppbnQqLywgdmFsdWUgLypieXRlfGludCovKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVzW3ldW3hdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHVibGljIHNldCh4OiBudW1iZXIgLyppbnQqLywgeTogbnVtYmVyIC8qaW50Ki8sIHZhbHVlOiBudW1iZXIgLyppbnQqLyk6IHZvaWQge1xuICAgICAgICAvLyAgIGJ5dGVzW3ldW3hdID0gKGJ5dGUpIHZhbHVlXG4gICAgICAgIC8vIH1cbiAgICAgICAgc2V0Qm9vbGVhbih4IC8qaW50Ki8sIHkgLyppbnQqLywgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNbeV1beF0gPSAvKihieXRlKSAqLyAodmFsdWUgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXIodmFsdWUgLypieXRlKi8pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYUJ5dGUgb2YgdGhpcy5ieXRlcykge1xuICAgICAgICAgICAgICAgIEFycmF5cy5maWxsKGFCeXRlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBCeXRlTWF0cml4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0gbztcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoICE9PSBvdGhlci53aWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gb3RoZXIuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDAsIGhlaWdodCA9IHRoaXMuaGVpZ2h0OyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlc1kgPSB0aGlzLmJ5dGVzW3ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQnl0ZXNZID0gb3RoZXIuYnl0ZXNbeV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDAsIHdpZHRoID0gdGhpcy53aWR0aDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzWVt4XSAhPT0gb3RoZXJCeXRlc1lbeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcigpOyAvLyAoMiAqIHdpZHRoICogaGVpZ2h0ICsgMilcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwLCBoZWlnaHQgPSB0aGlzLmhlaWdodDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXNZID0gdGhpcy5ieXRlc1t5XTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMCwgd2lkdGggPSB0aGlzLndpZHRoOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJ5dGVzWVt4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyAwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnIDEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igc2F0b3J1eEBnb29nbGUuY29tIChTYXRvcnUgVGFrYWJheWFzaGkpIC0gY3JlYXRvclxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pIC0gcG9ydGVkIGZyb20gQysrXG4gICAgICovXG4gICAgY2xhc3MgUVJDb2RlIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLm1hc2tQYXR0ZXJuID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TW9kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RUNMZXZlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmVyc2lvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TWFza1BhdHRlcm4oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXNrUGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICBnZXRNYXRyaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7IC8vICgyMDApXG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKCc8PFxcbicpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnIG1vZGU6ICcpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0aGlzLm1vZGUgPyB0aGlzLm1vZGUudG9TdHJpbmcoKSA6ICdudWxsJyk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdcXG4gZWNMZXZlbDogJyk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMuZWNMZXZlbCA/IHRoaXMuZWNMZXZlbC50b1N0cmluZygpIDogJ251bGwnKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbiB2ZXJzaW9uOiAnKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGhpcy52ZXJzaW9uID8gdGhpcy52ZXJzaW9uLnRvU3RyaW5nKCkgOiAnbnVsbCcpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuIG1hc2tQYXR0ZXJuOiAnKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGhpcy5tYXNrUGF0dGVybi50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbiBtYXRyaXg6XFxuJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0aGlzLm1hdHJpeC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbiBtYXRyaXg6IG51bGxcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJz4+XFxuJyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TW9kZSh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RUNMZXZlbCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5lY0xldmVsID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHNldE1hc2tQYXR0ZXJuKHZhbHVlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMubWFza1BhdHRlcm4gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRNYXRyaXgodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubWF0cml4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgXCJtYXNrX3BhdHRlcm5cIiBpcyB2YWxpZC5cbiAgICAgICAgc3RhdGljIGlzVmFsaWRNYXNrUGF0dGVybihtYXNrUGF0dGVybiAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFza1BhdHRlcm4gPj0gMCAmJiBtYXNrUGF0dGVybiA8IFFSQ29kZS5OVU1fTUFTS19QQVRURVJOUztcbiAgICAgICAgfVxuICAgIH1cbiAgICBRUkNvZGUuTlVNX01BU0tfUEFUVEVSTlMgPSA4O1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFdyaXRlckV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIFdyaXRlckV4Y2VwdGlvbi5raW5kID0gJ1dyaXRlckV4Y2VwdGlvbic7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHNhdG9ydXhAZ29vZ2xlLmNvbSAoU2F0b3J1IFRha2FiYXlhc2hpKSAtIGNyZWF0b3JcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKSAtIHBvcnRlZCBmcm9tIEMrK1xuICAgICAqL1xuICAgIGNsYXNzIE1hdHJpeFV0aWwge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgYWxsIGNlbGxzIHRvIC0xIChUWVBFU0NSSVBUUE9SVDogMjU1KS4gIC0xIChUWVBFU0NSSVBUUE9SVDogMjU1KSBtZWFucyB0aGF0IHRoZSBjZWxsIGlzIGVtcHR5IChub3Qgc2V0IHlldCkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEpBVkFQT1JUOiBXZSBzaG91bGRuJ3QgbmVlZCB0byBkbyB0aGlzIGF0IGFsbC4gVGhlIGNvZGUgc2hvdWxkIGJlIHJld3JpdHRlbiB0byBiZWdpbiBlbmNvZGluZ1xuICAgICAgICAvLyB3aXRoIHRoZSBCeXRlTWF0cml4IGluaXRpYWxpemVkIGFsbCB0byB6ZXJvLlxuICAgICAgICBzdGF0aWMgY2xlYXJNYXRyaXgobWF0cml4KSB7XG4gICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogd2UgdXNlIFVpbnRBcnJheSBzZSBjaGFuZ2VkIGhlcmUgZnJvbSAtMSB0byAyNTVcbiAgICAgICAgICAgIG1hdHJpeC5jbGVhcigvKihieXRlKSAqLyAvKi0xKi8gMjU1KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCAyRCBtYXRyaXggb2YgUVIgQ29kZSBmcm9tIFwiZGF0YUJpdHNcIiB3aXRoIFwiZWNMZXZlbFwiLCBcInZlcnNpb25cIiBhbmQgXCJnZXRNYXNrUGF0dGVyblwiLiBPblxuICAgICAgICAvLyBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwibWF0cml4XCIgYW5kIHJldHVybiB0cnVlLlxuICAgICAgICBzdGF0aWMgYnVpbGRNYXRyaXgoZGF0YUJpdHMsIGVjTGV2ZWwsIHZlcnNpb24sIG1hc2tQYXR0ZXJuIC8qaW50Ki8sIG1hdHJpeCkge1xuICAgICAgICAgICAgTWF0cml4VXRpbC5jbGVhck1hdHJpeChtYXRyaXgpO1xuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZEJhc2ljUGF0dGVybnModmVyc2lvbiwgbWF0cml4KTtcbiAgICAgICAgICAgIC8vIFR5cGUgaW5mb3JtYXRpb24gYXBwZWFyIHdpdGggYW55IHZlcnNpb24uXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVHlwZUluZm8oZWNMZXZlbCwgbWFza1BhdHRlcm4sIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBWZXJzaW9uIGluZm8gYXBwZWFyIGlmIHZlcnNpb24gPj0gNy5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwubWF5YmVFbWJlZFZlcnNpb25JbmZvKHZlcnNpb24sIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBEYXRhIHNob3VsZCBiZSBlbWJlZGRlZCBhdCBlbmQuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkRGF0YUJpdHMoZGF0YUJpdHMsIG1hc2tQYXR0ZXJuLCBtYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVtYmVkIGJhc2ljIHBhdHRlcm5zLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeCBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgIC8vIFRoZSBiYXNpYyBwYXR0ZXJucyBhcmU6XG4gICAgICAgIC8vIC0gUG9zaXRpb24gZGV0ZWN0aW9uIHBhdHRlcm5zXG4gICAgICAgIC8vIC0gVGltaW5nIHBhdHRlcm5zXG4gICAgICAgIC8vIC0gRGFyayBkb3QgYXQgdGhlIGxlZnQgYm90dG9tIGNvcm5lclxuICAgICAgICAvLyAtIFBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMsIGlmIG5lZWQgYmVcbiAgICAgICAgc3RhdGljIGVtYmVkQmFzaWNQYXR0ZXJucyh2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIC8vIExldCdzIGdldCBzdGFydGVkIHdpdGggZW1iZWRkaW5nIGJpZyBzcXVhcmVzIGF0IGNvcm5lcnMuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuc0FuZFNlcGFyYXRvcnMobWF0cml4KTtcbiAgICAgICAgICAgIC8vIFRoZW4sIGVtYmVkIHRoZSBkYXJrIGRvdCBhdCB0aGUgbGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZERhcmtEb3RBdExlZnRCb3R0b21Db3JuZXIobWF0cml4KTtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMgYXBwZWFyIGlmIHZlcnNpb24gPj0gMi5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwubWF5YmVFbWJlZFBvc2l0aW9uQWRqdXN0bWVudFBhdHRlcm5zKHZlcnNpb24sIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBUaW1pbmcgcGF0dGVybnMgc2hvdWxkIGJlIGVtYmVkZGVkIGFmdGVyIHBvc2l0aW9uIGFkai4gcGF0dGVybnMuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVGltaW5nUGF0dGVybnMobWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWJlZCB0eXBlIGluZm9ybWF0aW9uLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeC5cbiAgICAgICAgc3RhdGljIGVtYmVkVHlwZUluZm8oZWNMZXZlbCwgbWFza1BhdHRlcm4gLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlSW5mb0JpdHMgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIE1hdHJpeFV0aWwubWFrZVR5cGVJbmZvQml0cyhlY0xldmVsLCBtYXNrUGF0dGVybiwgdHlwZUluZm9CaXRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzaXplID0gdHlwZUluZm9CaXRzLmdldFNpemUoKTsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIFBsYWNlIGJpdHMgaW4gTFNCIHRvIE1TQiBvcmRlci4gIExTQiAobGVhc3Qgc2lnbmlmaWNhbnQgYml0KSBpcyB0aGUgbGFzdCB2YWx1ZSBpblxuICAgICAgICAgICAgICAgIC8vIFwidHlwZUluZm9CaXRzXCIuXG4gICAgICAgICAgICAgICAgY29uc3QgYml0ID0gdHlwZUluZm9CaXRzLmdldCh0eXBlSW5mb0JpdHMuZ2V0U2l6ZSgpIC0gMSAtIGkpO1xuICAgICAgICAgICAgICAgIC8vIFR5cGUgaW5mbyBiaXRzIGF0IHRoZSBsZWZ0IHRvcCBjb3JuZXIuIFNlZSA4Ljkgb2YgSklTWDA1MTA6MjAwNCAocC40NikuXG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBNYXRyaXhVdGlsLlRZUEVfSU5GT19DT09SRElOQVRFU1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB4MSA9IGNvb3JkaW5hdGVzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkxID0gY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4oeDEsIHkxLCBiaXQpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgOCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4MiA9IG1hdHJpeC5nZXRXaWR0aCgpIC0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gODtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4oeDIsIHkyLCBiaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4MiA9IDg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gbWF0cml4LmdldEhlaWdodCgpIC0gNyArIChpIC0gOCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKHgyLCB5MiwgYml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1iZWQgdmVyc2lvbiBpbmZvcm1hdGlvbiBpZiBuZWVkIGJlLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeCBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgIC8vIFNlZSA4LjEwIG9mIEpJU1gwNTEwOjIwMDQgKHAuNDcpIGZvciBob3cgdG8gZW1iZWQgdmVyc2lvbiBpbmZvcm1hdGlvbi5cbiAgICAgICAgc3RhdGljIG1heWJlRW1iZWRWZXJzaW9uSW5mbyh2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSA8IDcpIHsgLy8gVmVyc2lvbiBpbmZvIGlzIG5lY2Vzc2FyeSBpZiB2ZXJzaW9uID49IDcuXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBEb24ndCBuZWVkIHZlcnNpb24gaW5mby5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb25JbmZvQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgTWF0cml4VXRpbC5tYWtlVmVyc2lvbkluZm9CaXRzKHZlcnNpb24sIHZlcnNpb25JbmZvQml0cyk7XG4gICAgICAgICAgICBsZXQgYml0SW5kZXggPSA2ICogMyAtIDE7IC8vIEl0IHdpbGwgZGVjcmVhc2UgZnJvbSAxNyB0byAwLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZSBiaXRzIGluIExTQiAobGVhc3Qgc2lnbmlmaWNhbnQgYml0KSB0byBNU0Igb3JkZXIuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IHZlcnNpb25JbmZvQml0cy5nZXQoYml0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiaXRJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKGksIG1hdHJpeC5nZXRIZWlnaHQoKSAtIDExICsgaiwgYml0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmlnaHQgYm90dG9tIGNvcm5lci5cbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4obWF0cml4LmdldEhlaWdodCgpIC0gMTEgKyBqLCBpLCBiaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbWJlZCBcImRhdGFCaXRzXCIgdXNpbmcgXCJnZXRNYXNrUGF0dGVyblwiLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeCBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgIC8vIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMsIGl0IHNraXBzIG1hc2tpbmcgcHJvY2VzcyBpZiBcImdldE1hc2tQYXR0ZXJuXCIgaXMgLTEoVFlQRVNDUklQVFBPUlQ6IDI1NSkuXG4gICAgICAgIC8vIFNlZSA4Ljcgb2YgSklTWDA1MTA6MjAwNCAocC4zOCkgZm9yIGhvdyB0byBlbWJlZCBkYXRhIGJpdHMuXG4gICAgICAgIHN0YXRpYyBlbWJlZERhdGFCaXRzKGRhdGFCaXRzLCBtYXNrUGF0dGVybiAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCBiaXRJbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgZGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICAvLyBTdGFydCBmcm9tIHRoZSByaWdodCBib3R0b20gY2VsbC5cbiAgICAgICAgICAgIGxldCB4ID0gbWF0cml4LmdldFdpZHRoKCkgLSAxO1xuICAgICAgICAgICAgbGV0IHkgPSBtYXRyaXguZ2V0SGVpZ2h0KCkgLSAxO1xuICAgICAgICAgICAgd2hpbGUgKHggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB0aGUgdmVydGljYWwgdGltaW5nIHBhdHRlcm4uXG4gICAgICAgICAgICAgICAgaWYgKHggPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgeCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoeSA+PSAwICYmIHkgPCBtYXRyaXguZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHh4ID0geCAtIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBjZWxsIGlmIGl0J3Mgbm90IGVtcHR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFNYXRyaXhVdGlsLmlzRW1wdHkobWF0cml4LmdldCh4eCwgeSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdEluZGV4IDwgZGF0YUJpdHMuZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0ID0gZGF0YUJpdHMuZ2V0KGJpdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2JpdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFkZGluZyBiaXQuIElmIHRoZXJlIGlzIG5vIGJpdCBsZWZ0LCB3ZSdsbCBmaWxsIHRoZSBsZWZ0IGNlbGxzIHdpdGggMCwgYXMgZGVzY3JpYmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gOC40Ljkgb2YgSklTWDA1MTA6MjAwNCAocC4gMjQpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBtYXNraW5nIGlmIG1hc2tfcGF0dGVybiBpcyAtMSAoVFlQRVNDUklQVFBPUlQ6IDI1NSkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1BhdHRlcm4gIT09IDI1NSAmJiBNYXNrVXRpbC5nZXREYXRhTWFza0JpdChtYXNrUGF0dGVybiwgeHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0ID0gIWJpdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKHh4LCB5LCBiaXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAtZGlyZWN0aW9uOyAvLyBSZXZlcnNlIHRoZSBkaXJlY3Rpb24uXG4gICAgICAgICAgICAgICAgeSArPSBkaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgeCAtPSAyOyAvLyBNb3ZlIHRvIHRoZSBsZWZ0LlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWxsIGJpdHMgc2hvdWxkIGJlIGNvbnN1bWVkLlxuICAgICAgICAgICAgaWYgKGJpdEluZGV4ICE9PSBkYXRhQml0cy5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdOb3QgYWxsIGJpdHMgY29uc3VtZWQ6ICcgKyBiaXRJbmRleCArICcvJyArIGRhdGFCaXRzLmdldFNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgc2V0IChvbmU6IHRvKSBpbiB0aGUgXCJ2YWx1ZVwiLiBUaGUgbW9zdFxuICAgICAgICAvLyBzaWduaWZpY2FudCBiaXQgaXMgcG9zaXRpb24gMzIuIElmIHRoZXJlIGlzIG5vIGJpdCBzZXQsIHJldHVybiAwLiBFeGFtcGxlczpcbiAgICAgICAgLy8gLSBmaW5kTVNCU2V0KDApID0+IDBcbiAgICAgICAgLy8gLSBmaW5kTVNCU2V0KDEpID0+IDFcbiAgICAgICAgLy8gLSBmaW5kTVNCU2V0KDI1NSkgPT4gOFxuICAgICAgICBzdGF0aWMgZmluZE1TQlNldCh2YWx1ZSAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gMzIgLSBJbnRlZ2VyLm51bWJlck9mTGVhZGluZ1plcm9zKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgQkNIIChCb3NlLUNoYXVkaHVyaS1Ib2NxdWVuZ2hlbSkgY29kZSBmb3IgXCJ2YWx1ZVwiIHVzaW5nIHBvbHlub21pYWwgXCJwb2x5XCIuIFRoZSBCQ0hcbiAgICAgICAgLy8gY29kZSBpcyB1c2VkIGZvciBlbmNvZGluZyB0eXBlIGluZm9ybWF0aW9uIGFuZCB2ZXJzaW9uIGluZm9ybWF0aW9uLlxuICAgICAgICAvLyBFeGFtcGxlOiBDYWxjdWxhdGlvbiBvZiB2ZXJzaW9uIGluZm9ybWF0aW9uIG9mIDcuXG4gICAgICAgIC8vIGYoeCkgaXMgY3JlYXRlZCBmcm9tIDcuXG4gICAgICAgIC8vICAgLSA3ID0gMDAwMTExIGluIDYgYml0c1xuICAgICAgICAvLyAgIC0gZih4KSA9IHheMiArIHheMSArIHheMFxuICAgICAgICAvLyBnKHgpIGlzIGdpdmVuIGJ5IHRoZSBzdGFuZGFyZCAocC4gNjcpXG4gICAgICAgIC8vICAgLSBnKHgpID0geF4xMiArIHheMTEgKyB4XjEwICsgeF45ICsgeF44ICsgeF41ICsgeF4yICsgMVxuICAgICAgICAvLyBNdWx0aXBseSBmKHgpIGJ5IHheKDE4IC0gNilcbiAgICAgICAgLy8gICAtIGYnKHgpID0gZih4KSAqIHheKDE4IC0gNilcbiAgICAgICAgLy8gICAtIGYnKHgpID0geF4xNCArIHheMTMgKyB4XjEyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcmVtYWluZGVyIG9mIGYnKHgpIC8gZyh4KVxuICAgICAgICAvLyAgICAgICAgIHheMlxuICAgICAgICAvLyAgICAgICAgIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXG4gICAgICAgIC8vICAgZyh4KSApeF4xNCArIHheMTMgKyB4XjEyXG4gICAgICAgIC8vICAgICAgICAgeF4xNCArIHheMTMgKyB4XjEyICsgeF4xMSArIHheMTAgKyB4XjcgKyB4XjQgKyB4XjJcbiAgICAgICAgLy8gICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHheMTEgKyB4XjEwICsgeF43ICsgeF40ICsgeF4yXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSByZW1haW5kZXIgaXMgeF4xMSArIHheMTAgKyB4XjcgKyB4XjQgKyB4XjJcbiAgICAgICAgLy8gRW5jb2RlIGl0IGluIGJpbmFyeTogMTEwMDEwMDEwMTAwXG4gICAgICAgIC8vIFRoZSByZXR1cm4gdmFsdWUgaXMgMHhjOTQgKDExMDAgMTAwMSAwMTAwKVxuICAgICAgICAvL1xuICAgICAgICAvLyBTaW5jZSBhbGwgY29lZmZpY2llbnRzIGluIHRoZSBwb2x5bm9taWFscyBhcmUgMSBvciAwLCB3ZSBjYW4gZG8gdGhlIGNhbGN1bGF0aW9uIGJ5IGJpdFxuICAgICAgICAvLyBvcGVyYXRpb25zLiBXZSBkb24ndCBjYXJlIGlmIGNvZWZmaWNpZW50cyBhcmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUuXG4gICAgICAgIHN0YXRpYyBjYWxjdWxhdGVCQ0hDb2RlKHZhbHVlIC8qaW50Ki8sIHBvbHkgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKHBvbHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCcwIHBvbHlub21pYWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHBvbHkgaXMgXCIxIDExMTEgMDAxMCAwMTAxXCIgKHZlcnNpb24gaW5mbyBwb2x5KSwgbXNiU2V0SW5Qb2x5IGlzIDEzLiBXZSdsbCBzdWJ0cmFjdCAxXG4gICAgICAgICAgICAvLyBmcm9tIDEzIHRvIG1ha2UgaXQgMTIuXG4gICAgICAgICAgICBjb25zdCBtc2JTZXRJblBvbHkgPSBNYXRyaXhVdGlsLmZpbmRNU0JTZXQocG9seSk7XG4gICAgICAgICAgICB2YWx1ZSA8PD0gbXNiU2V0SW5Qb2x5IC0gMTtcbiAgICAgICAgICAgIC8vIERvIHRoZSBkaXZpc2lvbiBidXNpbmVzcyB1c2luZyBleGNsdXNpdmUtb3Igb3BlcmF0aW9ucy5cbiAgICAgICAgICAgIHdoaWxlIChNYXRyaXhVdGlsLmZpbmRNU0JTZXQodmFsdWUpID49IG1zYlNldEluUG9seSkge1xuICAgICAgICAgICAgICAgIHZhbHVlIF49IHBvbHkgPDwgKE1hdHJpeFV0aWwuZmluZE1TQlNldCh2YWx1ZSkgLSBtc2JTZXRJblBvbHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IHRoZSBcInZhbHVlXCIgaXMgdGhlIHJlbWFpbmRlciAoaS5lLiB0aGUgQkNIIGNvZGUpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBiaXQgdmVjdG9yIG9mIHR5cGUgaW5mb3JtYXRpb24uIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW4gXCJiaXRzXCIgYW5kIHJldHVybiB0cnVlLlxuICAgICAgICAvLyBFbmNvZGUgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCBhbmQgbWFzayBwYXR0ZXJuLiBTZWUgOC45IG9mXG4gICAgICAgIC8vIEpJU1gwNTEwOjIwMDQgKHAuNDUpIGZvciBkZXRhaWxzLlxuICAgICAgICBzdGF0aWMgbWFrZVR5cGVJbmZvQml0cyhlY0xldmVsLCBtYXNrUGF0dGVybiAvKmludCovLCBiaXRzKSB7XG4gICAgICAgICAgICBpZiAoIVFSQ29kZS5pc1ZhbGlkTWFza1BhdHRlcm4obWFza1BhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignSW52YWxpZCBtYXNrIHBhdHRlcm4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGVJbmZvID0gKGVjTGV2ZWwuZ2V0Qml0cygpIDw8IDMpIHwgbWFza1BhdHRlcm47XG4gICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHModHlwZUluZm8sIDUpO1xuICAgICAgICAgICAgY29uc3QgYmNoQ29kZSA9IE1hdHJpeFV0aWwuY2FsY3VsYXRlQkNIQ29kZSh0eXBlSW5mbywgTWF0cml4VXRpbC5UWVBFX0lORk9fUE9MWSk7XG4gICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMoYmNoQ29kZSwgMTApO1xuICAgICAgICAgICAgY29uc3QgbWFza0JpdHMgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIG1hc2tCaXRzLmFwcGVuZEJpdHMoTWF0cml4VXRpbC5UWVBFX0lORk9fTUFTS19QQVRURVJOLCAxNSk7XG4gICAgICAgICAgICBiaXRzLnhvcihtYXNrQml0cyk7XG4gICAgICAgICAgICBpZiAoYml0cy5nZXRTaXplKCkgIT09IDE1KSB7IC8vIEp1c3QgaW4gY2FzZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdzaG91bGQgbm90IGhhcHBlbiBidXQgd2UgZ290OiAnICsgYml0cy5nZXRTaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2UgYml0IHZlY3RvciBvZiB2ZXJzaW9uIGluZm9ybWF0aW9uLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwiYml0c1wiIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAgICAgLy8gU2VlIDguMTAgb2YgSklTWDA1MTA6MjAwNCAocC40NSkgZm9yIGRldGFpbHMuXG4gICAgICAgIHN0YXRpYyBtYWtlVmVyc2lvbkluZm9CaXRzKHZlcnNpb24sIGJpdHMpIHtcbiAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSwgNik7XG4gICAgICAgICAgICBjb25zdCBiY2hDb2RlID0gTWF0cml4VXRpbC5jYWxjdWxhdGVCQ0hDb2RlKHZlcnNpb24uZ2V0VmVyc2lvbk51bWJlcigpLCBNYXRyaXhVdGlsLlZFUlNJT05fSU5GT19QT0xZKTtcbiAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhiY2hDb2RlLCAxMik7XG4gICAgICAgICAgICBpZiAoYml0cy5nZXRTaXplKCkgIT09IDE4KSB7IC8vIEp1c3QgaW4gY2FzZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdzaG91bGQgbm90IGhhcHBlbiBidXQgd2UgZ290OiAnICsgYml0cy5nZXRTaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIFwidmFsdWVcIiBpcyBlbXB0eS5cbiAgICAgICAgc3RhdGljIGlzRW1wdHkodmFsdWUgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSAyNTU7IC8vIC0xXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVtYmVkVGltaW5nUGF0dGVybnMobWF0cml4KSB7XG4gICAgICAgICAgICAvLyAtOCBpcyBmb3Igc2tpcHBpbmcgcG9zaXRpb24gZGV0ZWN0aW9uIHBhdHRlcm5zICg3OiBzaXplKSwgYW5kIHR3byBob3Jpem9udGFsL3ZlcnRpY2FsXG4gICAgICAgICAgICAvLyBzZXBhcmF0aW9uIHBhdHRlcm5zICgxOiBzaXplKS4gVGh1cywgOCA9IDcgKyAxLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDg7IGkgPCBtYXRyaXguZ2V0V2lkdGgoKSAtIDg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IChpICsgMSkgJSAyO1xuICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZS5cbiAgICAgICAgICAgICAgICBpZiAoTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoaSwgNikpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXROdW1iZXIoaSwgNiwgYml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVmVydGljYWwgbGluZS5cbiAgICAgICAgICAgICAgICBpZiAoTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoNiwgaSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXROdW1iZXIoNiwgaSwgYml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1iZWQgdGhlIGxvbmVseSBkYXJrIGRvdCBhdCBsZWZ0IGJvdHRvbSBjb3JuZXIuIEpJU1gwNTEwOjIwMDQgKHAuNDYpXG4gICAgICAgIHN0YXRpYyBlbWJlZERhcmtEb3RBdExlZnRCb3R0b21Db3JuZXIobWF0cml4KSB7XG4gICAgICAgICAgICBpZiAobWF0cml4LmdldCg4LCBtYXRyaXguZ2V0SGVpZ2h0KCkgLSA4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdHJpeC5zZXROdW1iZXIoOCwgbWF0cml4LmdldEhlaWdodCgpIC0gOCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVtYmVkSG9yaXpvbnRhbFNlcGFyYXRpb25QYXR0ZXJuKHhTdGFydCAvKmludCovLCB5U3RhcnQgLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDg7ICsreCkge1xuICAgICAgICAgICAgICAgIGlmICghTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoeFN0YXJ0ICsgeCwgeVN0YXJ0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKHhTdGFydCArIHgsIHlTdGFydCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVtYmVkVmVydGljYWxTZXBhcmF0aW9uUGF0dGVybih4U3RhcnQgLyppbnQqLywgeVN0YXJ0IC8qaW50Ki8sIG1hdHJpeCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA3OyArK3kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU1hdHJpeFV0aWwuaXNFbXB0eShtYXRyaXguZ2V0KHhTdGFydCwgeVN0YXJ0ICsgeSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0cml4LnNldE51bWJlcih4U3RhcnQsIHlTdGFydCArIHksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlbWJlZFBvc2l0aW9uQWRqdXN0bWVudFBhdHRlcm4oeFN0YXJ0IC8qaW50Ki8sIHlTdGFydCAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTsgKyt5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVyblkgPSBNYXRyaXhVdGlsLlBPU0lUSU9OX0FESlVTVE1FTlRfUEFUVEVSTlt5XTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDU7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKHhTdGFydCArIHgsIHlTdGFydCArIHksIHBhdHRlcm5ZW3hdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuKHhTdGFydCAvKmludCovLCB5U3RhcnQgLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDc7ICsreSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5ZID0gTWF0cml4VXRpbC5QT1NJVElPTl9ERVRFQ1RJT05fUEFUVEVSTlt5XTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDc7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKHhTdGFydCArIHgsIHlTdGFydCArIHksIHBhdHRlcm5ZW3hdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1iZWQgcG9zaXRpb24gZGV0ZWN0aW9uIHBhdHRlcm5zIGFuZCBzdXJyb3VuZGluZyB2ZXJ0aWNhbC9ob3Jpem9udGFsIHNlcGFyYXRvcnMuXG4gICAgICAgIHN0YXRpYyBlbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybnNBbmRTZXBhcmF0b3JzKG1hdHJpeCkge1xuICAgICAgICAgICAgLy8gRW1iZWQgdGhyZWUgYmlnIHNxdWFyZXMgYXQgY29ybmVycy5cbiAgICAgICAgICAgIGNvbnN0IHBkcFdpZHRoID0gTWF0cml4VXRpbC5QT1NJVElPTl9ERVRFQ1RJT05fUEFUVEVSTlswXS5sZW5ndGg7XG4gICAgICAgICAgICAvLyBMZWZ0IHRvcCBjb3JuZXIuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuKDAsIDAsIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybihtYXRyaXguZ2V0V2lkdGgoKSAtIHBkcFdpZHRoLCAwLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gTGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybigwLCBtYXRyaXguZ2V0V2lkdGgoKSAtIHBkcFdpZHRoLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gRW1iZWQgaG9yaXpvbnRhbCBzZXBhcmF0aW9uIHBhdHRlcm5zIGFyb3VuZCB0aGUgc3F1YXJlcy5cbiAgICAgICAgICAgIGNvbnN0IGhzcFdpZHRoID0gODtcbiAgICAgICAgICAgIC8vIExlZnQgdG9wIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRIb3Jpem9udGFsU2VwYXJhdGlvblBhdHRlcm4oMCwgaHNwV2lkdGggLSAxLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gUmlnaHQgdG9wIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRIb3Jpem9udGFsU2VwYXJhdGlvblBhdHRlcm4obWF0cml4LmdldFdpZHRoKCkgLSBoc3BXaWR0aCwgaHNwV2lkdGggLSAxLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gTGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZEhvcml6b250YWxTZXBhcmF0aW9uUGF0dGVybigwLCBtYXRyaXguZ2V0V2lkdGgoKSAtIGhzcFdpZHRoLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gRW1iZWQgdmVydGljYWwgc2VwYXJhdGlvbiBwYXR0ZXJucyBhcm91bmQgdGhlIHNxdWFyZXMuXG4gICAgICAgICAgICBjb25zdCB2c3BTaXplID0gNztcbiAgICAgICAgICAgIC8vIExlZnQgdG9wIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRWZXJ0aWNhbFNlcGFyYXRpb25QYXR0ZXJuKHZzcFNpemUsIDAsIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFZlcnRpY2FsU2VwYXJhdGlvblBhdHRlcm4obWF0cml4LmdldEhlaWdodCgpIC0gdnNwU2l6ZSAtIDEsIDAsIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVmVydGljYWxTZXBhcmF0aW9uUGF0dGVybih2c3BTaXplLCBtYXRyaXguZ2V0SGVpZ2h0KCkgLSB2c3BTaXplLCBtYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVtYmVkIHBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMgaWYgbmVlZCBiZS5cbiAgICAgICAgc3RhdGljIG1heWJlRW1iZWRQb3NpdGlvbkFkanVzdG1lbnRQYXR0ZXJucyh2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSA8IDIpIHsgLy8gVGhlIHBhdHRlcm5zIGFwcGVhciBpZiB2ZXJzaW9uID49IDJcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHZlcnNpb24uZ2V0VmVyc2lvbk51bWJlcigpIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk5fQ09PUkRJTkFURV9UQUJMRVtpbmRleF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpICE9PSBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoeSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IGNvb3JkaW5hdGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggPj0gMCAmJiBNYXRyaXhVdGlsLmlzRW1wdHkobWF0cml4LmdldCh4LCB5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2VsbCBpcyB1bnNldCwgd2UgZW1iZWQgdGhlIHBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybiBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0yIGlzIG5lY2Vzc2FyeSBzaW5jZSB0aGUgeC95IGNvb3JkaW5hdGVzIHBvaW50IHRvIHRoZSBjZW50ZXIgb2YgdGhlIHBhdHRlcm4sIG5vdCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZWZ0IHRvcCBjb3JuZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uQWRqdXN0bWVudFBhdHRlcm4oeCAtIDIsIHkgLSAyLCBtYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIE1hdHJpeFV0aWwuUE9TSVRJT05fREVURUNUSU9OX1BBVFRFUk4gPSBBcnJheS5mcm9tKFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMCwgMCwgMCwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDEsIDEsIDEsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAxLCAxLCAxLCAwLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMSwgMSwgMSwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDAsIDAsIDAsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxLCAxLCAxXSksXG4gICAgXSk7XG4gICAgTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk4gPSBBcnJheS5mcm9tKFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMCwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDEsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAwLCAwLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMSwgMV0pLFxuICAgIF0pO1xuICAgIC8vIEZyb20gQXBwZW5kaXggRS4gVGFibGUgMSwgSklTMDUxMFg6MjAwNCAoNzE6IHApLiBUaGUgdGFibGUgd2FzIGRvdWJsZS1jaGVja2VkIGJ5IGtvbWF0c3UuXG4gICAgTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk5fQ09PUkRJTkFURV9UQUJMRSA9IEFycmF5LmZyb20oW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWy0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMTgsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDIyLCAtMSwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgLTEsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCAtMSwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyMiwgMzgsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjQsIDQyLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0NiwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTAsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OCwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDQ2LCA2NiwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0OCwgNzAsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NiwgODIsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI4LCA1MCwgNzIsIDk0LCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCA5OCwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTQsIDgwLCAxMDYsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OCwgODQsIDExMCwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIDkwLCAxMTgsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MCwgNzQsIDk4LCAxMjIsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzAsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU2LCA4MiwgMTA4LCAxMzQsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzgsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDIsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgMTE4LCAxNDYsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzIsIDU4LCA4NCwgMTEwLCAxMzYsIDE2Ml0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1NCwgODIsIDExMCwgMTM4LCAxNjZdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXSksXG4gICAgXSk7XG4gICAgLy8gVHlwZSBpbmZvIGNlbGxzIGF0IHRoZSBsZWZ0IHRvcCBjb3JuZXIuXG4gICAgTWF0cml4VXRpbC5UWVBFX0lORk9fQ09PUkRJTkFURVMgPSBBcnJheS5mcm9tKFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCAwXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzgsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzgsIDVdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCA3XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzcsIDhdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs1LCA4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDhdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCA4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzAsIDhdKSxcbiAgICBdKTtcbiAgICAvLyBGcm9tIEFwcGVuZGl4IEQgaW4gSklTWDA1MTA6MjAwNCAocC4gNjcpXG4gICAgTWF0cml4VXRpbC5WRVJTSU9OX0lORk9fUE9MWSA9IDB4MWYyNTsgLy8gMSAxMTExIDAwMTAgMDEwMVxuICAgIC8vIEZyb20gQXBwZW5kaXggQyBpbiBKSVNYMDUxMDoyMDA0IChwLjY1KS5cbiAgICBNYXRyaXhVdGlsLlRZUEVfSU5GT19QT0xZID0gMHg1Mzc7XG4gICAgTWF0cml4VXRpbC5UWVBFX0lORk9fTUFTS19QQVRURVJOID0gMHg1NDEyO1xuXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZW5jb2RlciB7Ki9cbiAgICBjbGFzcyBCbG9ja1BhaXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihkYXRhQnl0ZXMsIGVycm9yQ29ycmVjdGlvbkJ5dGVzKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFCeXRlcyA9IGRhdGFCeXRlcztcbiAgICAgICAgICAgIHRoaXMuZXJyb3JDb3JyZWN0aW9uQnl0ZXMgPSBlcnJvckNvcnJlY3Rpb25CeXRlcztcbiAgICAgICAgfVxuICAgICAgICBnZXREYXRhQnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RXJyb3JDb3JyZWN0aW9uQnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvcnJlY3Rpb25CeXRlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qaW1wb3J0IGphdmEuaW8uVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbjsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbjsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHNhdG9ydXhAZ29vZ2xlLmNvbSAoU2F0b3J1IFRha2FiYXlhc2hpKSAtIGNyZWF0b3JcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKSAtIHBvcnRlZCBmcm9tIEMrK1xuICAgICAqL1xuICAgIGNsYXNzIEVuY29kZXIge1xuICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogY2hhbmdlZCB0byBVVEY4LCB0aGUgZGVmYXVsdCBmb3IganNcbiAgICAgICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAgICAgLy8gVGhlIG1hc2sgcGVuYWx0eSBjYWxjdWxhdGlvbiBpcyBjb21wbGljYXRlZC4gIFNlZSBUYWJsZSAyMSBvZiBKSVNYMDUxMDoyMDA0IChwLjQ1KSBmb3IgZGV0YWlscy5cbiAgICAgICAgLy8gQmFzaWNhbGx5IGl0IGFwcGxpZXMgZm91ciBydWxlcyBhbmQgc3VtbWF0ZSBhbGwgcGVuYWx0aWVzLlxuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlTWFza1BlbmFsdHkobWF0cml4KSB7XG4gICAgICAgICAgICByZXR1cm4gTWFza1V0aWwuYXBwbHlNYXNrUGVuYWx0eVJ1bGUxKG1hdHJpeClcbiAgICAgICAgICAgICAgICArIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMihtYXRyaXgpXG4gICAgICAgICAgICAgICAgKyBNYXNrVXRpbC5hcHBseU1hc2tQZW5hbHR5UnVsZTMobWF0cml4KVxuICAgICAgICAgICAgICAgICsgTWFza1V0aWwuYXBwbHlNYXNrUGVuYWx0eVJ1bGU0KG1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBjb250ZW50IHRleHQgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSBlY0xldmVsIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwgdG8gdXNlXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIFFSQ29kZX0gcmVwcmVzZW50aW5nIHRoZSBlbmNvZGVkIFFSIGNvZGVcbiAgICAgICAgICogQHRocm93cyBXcml0ZXJFeGNlcHRpb24gaWYgZW5jb2RpbmcgY2FuJ3Qgc3VjY2VlZCwgYmVjYXVzZSBvZiBmb3IgZXhhbXBsZSBpbnZhbGlkIGNvbnRlbnRcbiAgICAgICAgICogICBvciBjb25maWd1cmF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgc3RhdGljIGVuY29kZShjb250ZW50OiBzdHJpbmcsIGVjTGV2ZWw6IEVycm9yQ29ycmVjdGlvbkxldmVsKTogUVJDb2RlIC8qdGhyb3dzIFdyaXRlckV4Y2VwdGlvbiovIHtcbiAgICAgICAgLy8gICByZXR1cm4gZW5jb2RlKGNvbnRlbnQsIGVjTGV2ZWwsIG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgc3RhdGljIGVuY29kZShjb250ZW50LCBlY0xldmVsLCBoaW50cyA9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGF0IGNoYXJhY3RlciBlbmNvZGluZyBoYXMgYmVlbiBzcGVjaWZpZWQgYnkgdGhlIGNhbGxlciwgaWYgYW55XG4gICAgICAgICAgICBsZXQgZW5jb2RpbmcgPSBFbmNvZGVyLkRFRkFVTFRfQllURV9NT0RFX0VOQ09ESU5HO1xuICAgICAgICAgICAgY29uc3QgaGFzRW5jb2RpbmdIaW50ID0gaGludHMgIT09IG51bGwgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5DSEFSQUNURVJfU0VUKTtcbiAgICAgICAgICAgIGlmIChoYXNFbmNvZGluZ0hpbnQpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLkNIQVJBQ1RFUl9TRVQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQaWNrIGFuIGVuY29kaW5nIG1vZGUgYXBwcm9wcmlhdGUgZm9yIHRoZSBjb250ZW50LiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBhdHRlbXB0IHRvIHVzZVxuICAgICAgICAgICAgLy8gbXVsdGlwbGUgbW9kZXMgLyBzZWdtZW50cyBldmVuIGlmIHRoYXQgd2VyZSBtb3JlIGVmZmljaWVudC4gVHdvdWxkIGJlIG5pY2UuXG4gICAgICAgICAgICBjb25zdCBtb2RlID0gdGhpcy5jaG9vc2VNb2RlKGNvbnRlbnQsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBzdG9yZSB0aGUgaGVhZGVyIGluZm9ybWF0aW9uLCBsaWtlIG1vZGUgYW5kXG4gICAgICAgICAgICAvLyBsZW5ndGgsIGFzIHdlbGwgYXMgXCJoZWFkZXJcIiBzZWdtZW50cyBsaWtlIGFuIEVDSSBzZWdtZW50LlxuICAgICAgICAgICAgY29uc3QgaGVhZGVyQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgLy8gQXBwZW5kIEVDSSBzZWdtZW50IGlmIGFwcGxpY2FibGVcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBNb2RlJDEuQllURSAmJiAoaGFzRW5jb2RpbmdIaW50IHx8IEVuY29kZXIuREVGQVVMVF9CWVRFX01PREVfRU5DT0RJTkcgIT09IGVuY29kaW5nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVjaSA9IENoYXJhY3RlclNldEVDSS5nZXRDaGFyYWN0ZXJTZXRFQ0lCeU5hbWUoZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChlY2kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVDSShlY2ksIGhlYWRlckJpdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIChXaXRoIEVDSSBpbiBwbGFjZSwpIFdyaXRlIHRoZSBtb2RlIG1hcmtlclxuICAgICAgICAgICAgdGhpcy5hcHBlbmRNb2RlSW5mbyhtb2RlLCBoZWFkZXJCaXRzKTtcbiAgICAgICAgICAgIC8vIENvbGxlY3QgZGF0YSB3aXRoaW4gdGhlIG1haW4gc2VnbWVudCwgc2VwYXJhdGVseSwgdG8gY291bnQgaXRzIHNpemUgaWYgbmVlZGVkLiBEb24ndCBhZGQgaXQgdG9cbiAgICAgICAgICAgIC8vIG1haW4gcGF5bG9hZCB5ZXQuXG4gICAgICAgICAgICBjb25zdCBkYXRhQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRCeXRlcyhjb250ZW50LCBtb2RlLCBkYXRhQml0cywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgbGV0IHZlcnNpb247XG4gICAgICAgICAgICBpZiAoaGludHMgIT09IG51bGwgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5RUl9WRVJTSU9OKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuUVJfVkVSU0lPTikudG9TdHJpbmcoKSwgMTApO1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSBWZXJzaW9uJDEuZ2V0VmVyc2lvbkZvck51bWJlcih2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRzTmVlZGVkID0gdGhpcy5jYWxjdWxhdGVCaXRzTmVlZGVkKG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2lsbEZpdChiaXRzTmVlZGVkLCB2ZXJzaW9uLCBlY0xldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdEYXRhIHRvbyBiaWcgZm9yIHJlcXVlc3RlZCB2ZXJzaW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IHRoaXMucmVjb21tZW5kVmVyc2lvbihlY0xldmVsLCBtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJBbmREYXRhQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgaGVhZGVyQW5kRGF0YUJpdHMuYXBwZW5kQml0QXJyYXkoaGVhZGVyQml0cyk7XG4gICAgICAgICAgICAvLyBGaW5kIFwibGVuZ3RoXCIgb2YgbWFpbiBzZWdtZW50IGFuZCB3cml0ZSBpdFxuICAgICAgICAgICAgY29uc3QgbnVtTGV0dGVycyA9IG1vZGUgPT09IE1vZGUkMS5CWVRFID8gZGF0YUJpdHMuZ2V0U2l6ZUluQnl0ZXMoKSA6IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRMZW5ndGhJbmZvKG51bUxldHRlcnMsIHZlcnNpb24sIG1vZGUsIGhlYWRlckFuZERhdGFCaXRzKTtcbiAgICAgICAgICAgIC8vIFB1dCBkYXRhIHRvZ2V0aGVyIGludG8gdGhlIG92ZXJhbGwgcGF5bG9hZFxuICAgICAgICAgICAgaGVhZGVyQW5kRGF0YUJpdHMuYXBwZW5kQml0QXJyYXkoZGF0YUJpdHMpO1xuICAgICAgICAgICAgY29uc3QgZWNCbG9ja3MgPSB2ZXJzaW9uLmdldEVDQmxvY2tzRm9yTGV2ZWwoZWNMZXZlbCk7XG4gICAgICAgICAgICBjb25zdCBudW1EYXRhQnl0ZXMgPSB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkgLSBlY0Jsb2Nrcy5nZXRUb3RhbEVDQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAvLyBUZXJtaW5hdGUgdGhlIGJpdHMgcHJvcGVybHkuXG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZUJpdHMobnVtRGF0YUJ5dGVzLCBoZWFkZXJBbmREYXRhQml0cyk7XG4gICAgICAgICAgICAvLyBJbnRlcmxlYXZlIGRhdGEgYml0cyB3aXRoIGVycm9yIGNvcnJlY3Rpb24gY29kZS5cbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQml0cyA9IHRoaXMuaW50ZXJsZWF2ZVdpdGhFQ0J5dGVzKGhlYWRlckFuZERhdGFCaXRzLCB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCksIG51bURhdGFCeXRlcywgZWNCbG9ja3MuZ2V0TnVtQmxvY2tzKCkpO1xuICAgICAgICAgICAgY29uc3QgcXJDb2RlID0gbmV3IFFSQ29kZSgpO1xuICAgICAgICAgICAgcXJDb2RlLnNldEVDTGV2ZWwoZWNMZXZlbCk7XG4gICAgICAgICAgICBxckNvZGUuc2V0TW9kZShtb2RlKTtcbiAgICAgICAgICAgIHFyQ29kZS5zZXRWZXJzaW9uKHZlcnNpb24pO1xuICAgICAgICAgICAgLy8gIENob29zZSB0aGUgbWFzayBwYXR0ZXJuIGFuZCBzZXQgdG8gXCJxckNvZGVcIi5cbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpO1xuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IEJ5dGVNYXRyaXgoZGltZW5zaW9uLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgY29uc3QgbWFza1BhdHRlcm4gPSB0aGlzLmNob29zZU1hc2tQYXR0ZXJuKGZpbmFsQml0cywgZWNMZXZlbCwgdmVyc2lvbiwgbWF0cml4KTtcbiAgICAgICAgICAgIHFyQ29kZS5zZXRNYXNrUGF0dGVybihtYXNrUGF0dGVybik7XG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgbWF0cml4IGFuZCBzZXQgaXQgdG8gXCJxckNvZGVcIi5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuYnVpbGRNYXRyaXgoZmluYWxCaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXNrUGF0dGVybiwgbWF0cml4KTtcbiAgICAgICAgICAgIHFyQ29kZS5zZXRNYXRyaXgobWF0cml4KTtcbiAgICAgICAgICAgIHJldHVybiBxckNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY2lkZXMgdGhlIHNtYWxsZXN0IHZlcnNpb24gb2YgUVIgY29kZSB0aGF0IHdpbGwgY29udGFpbiBhbGwgb2YgdGhlIHByb3ZpZGVkIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgV3JpdGVyRXhjZXB0aW9uIGlmIHRoZSBkYXRhIGNhbm5vdCBmaXQgaW4gYW55IHZlcnNpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyByZWNvbW1lbmRWZXJzaW9uKGVjTGV2ZWwsIG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzKSB7XG4gICAgICAgICAgICAvLyBIYXJkIHBhcnQ6IG5lZWQgdG8ga25vdyB2ZXJzaW9uIHRvIGtub3cgaG93IG1hbnkgYml0cyBsZW5ndGggdGFrZXMuIEJ1dCBuZWVkIHRvIGtub3cgaG93IG1hbnlcbiAgICAgICAgICAgIC8vIGJpdHMgaXQgdGFrZXMgdG8ga25vdyB2ZXJzaW9uLiBGaXJzdCB3ZSB0YWtlIGEgZ3Vlc3MgYXQgdmVyc2lvbiBieSBhc3N1bWluZyB2ZXJzaW9uIHdpbGwgYmVcbiAgICAgICAgICAgIC8vIHRoZSBtaW5pbXVtLCAxOlxuICAgICAgICAgICAgY29uc3QgcHJvdmlzaW9uYWxCaXRzTmVlZGVkID0gdGhpcy5jYWxjdWxhdGVCaXRzTmVlZGVkKG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzLCBWZXJzaW9uJDEuZ2V0VmVyc2lvbkZvck51bWJlcigxKSk7XG4gICAgICAgICAgICBjb25zdCBwcm92aXNpb25hbFZlcnNpb24gPSB0aGlzLmNob29zZVZlcnNpb24ocHJvdmlzaW9uYWxCaXRzTmVlZGVkLCBlY0xldmVsKTtcbiAgICAgICAgICAgIC8vIFVzZSB0aGF0IGd1ZXNzIHRvIGNhbGN1bGF0ZSB0aGUgcmlnaHQgdmVyc2lvbi4gSSBhbSBzdGlsbCBub3Qgc3VyZSB0aGlzIHdvcmtzIGluIDEwMCUgb2YgY2FzZXMuXG4gICAgICAgICAgICBjb25zdCBiaXRzTmVlZGVkID0gdGhpcy5jYWxjdWxhdGVCaXRzTmVlZGVkKG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzLCBwcm92aXNpb25hbFZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hvb3NlVmVyc2lvbihiaXRzTmVlZGVkLCBlY0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlQml0c05lZWRlZChtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cywgdmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlckJpdHMuZ2V0U2l6ZSgpICsgbW9kZS5nZXRDaGFyYWN0ZXJDb3VudEJpdHModmVyc2lvbikgKyBkYXRhQml0cy5nZXRTaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIGNvZGUgcG9pbnQgb2YgdGhlIHRhYmxlIHVzZWQgaW4gYWxwaGFudW1lcmljIG1vZGUgb3JcbiAgICAgICAgICogIC0xIGlmIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgY29kZSBpbiB0aGUgdGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0QWxwaGFudW1lcmljQ29kZShjb2RlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChjb2RlIDwgRW5jb2Rlci5BTFBIQU5VTUVSSUNfVEFCTEUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVuY29kZXIuQUxQSEFOVU1FUklDX1RBQkxFW2NvZGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIHB1YmxpYyBzdGF0aWMgY2hvb3NlTW9kZShjb250ZW50OiBzdHJpbmcpOiBNb2RlIHtcbiAgICAgICAgLy8gICByZXR1cm4gY2hvb3NlTW9kZShjb250ZW50LCBudWxsKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hvb3NlIHRoZSBiZXN0IG1vZGUgYnkgZXhhbWluaW5nIHRoZSBjb250ZW50LiBOb3RlIHRoYXQgJ2VuY29kaW5nJyBpcyB1c2VkIGFzIGEgaGludDtcbiAgICAgICAgICogaWYgaXQgaXMgU2hpZnRfSklTLCBhbmQgdGhlIGlucHV0IGlzIG9ubHkgZG91YmxlLWJ5dGUgS2FuamksIHRoZW4gd2UgcmV0dXJuIHtAbGluayBNb2RlI0tBTkpJfS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjaG9vc2VNb2RlKGNvbnRlbnQsIGVuY29kaW5nID0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKENoYXJhY3RlclNldEVDSS5TSklTLmdldE5hbWUoKSA9PT0gZW5jb2RpbmcgJiYgdGhpcy5pc09ubHlEb3VibGVCeXRlS2FuamkoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBDaG9vc2UgS2FuamkgbW9kZSBpZiBhbGwgaW5wdXQgYXJlIGRvdWJsZS1ieXRlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICByZXR1cm4gTW9kZSQxLktBTkpJO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhhc051bWVyaWMgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBoYXNBbHBoYW51bWVyaWMgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBjb250ZW50Lmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGNvbnRlbnQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChFbmNvZGVyLmlzRGlnaXQoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTnVtZXJpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZ2V0QWxwaGFudW1lcmljQ29kZShjLmNoYXJDb2RlQXQoMCkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNBbHBoYW51bWVyaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUkMS5CWVRFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNBbHBoYW51bWVyaWMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTW9kZSQxLkFMUEhBTlVNRVJJQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNOdW1lcmljKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUkMS5OVU1FUklDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1vZGUkMS5CWVRFO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpc09ubHlEb3VibGVCeXRlS2FuamkoY29udGVudCkge1xuICAgICAgICAgICAgbGV0IGJ5dGVzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBieXRlcyA9IFN0cmluZ0VuY29kaW5nLmVuY29kZShjb250ZW50LCBDaGFyYWN0ZXJTZXRFQ0kuU0pJUyk7IC8vIGNvbnRlbnQuZ2V0Qnl0ZXMoXCJTaGlmdF9KSVNcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBieXRlc1tpXSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgaWYgKChieXRlMSA8IDB4ODEgfHwgYnl0ZTEgPiAweDlGKSAmJiAoYnl0ZTEgPCAweEUwIHx8IGJ5dGUxID4gMHhFQikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaG9vc2VNYXNrUGF0dGVybihiaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCBtaW5QZW5hbHR5ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7IC8vIExvd2VyIHBlbmFsdHkgaXMgYmV0dGVyLlxuICAgICAgICAgICAgbGV0IGJlc3RNYXNrUGF0dGVybiA9IC0xO1xuICAgICAgICAgICAgLy8gV2UgdHJ5IGFsbCBtYXNrIHBhdHRlcm5zIHRvIGNob29zZSB0aGUgYmVzdCBvbmUuXG4gICAgICAgICAgICBmb3IgKGxldCBtYXNrUGF0dGVybiA9IDA7IG1hc2tQYXR0ZXJuIDwgUVJDb2RlLk5VTV9NQVNLX1BBVFRFUk5TOyBtYXNrUGF0dGVybisrKSB7XG4gICAgICAgICAgICAgICAgTWF0cml4VXRpbC5idWlsZE1hdHJpeChiaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXNrUGF0dGVybiwgbWF0cml4KTtcbiAgICAgICAgICAgICAgICBsZXQgcGVuYWx0eSA9IHRoaXMuY2FsY3VsYXRlTWFza1BlbmFsdHkobWF0cml4KTtcbiAgICAgICAgICAgICAgICBpZiAocGVuYWx0eSA8IG1pblBlbmFsdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluUGVuYWx0eSA9IHBlbmFsdHk7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXNrUGF0dGVybiA9IG1hc2tQYXR0ZXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiZXN0TWFza1BhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNob29zZVZlcnNpb24obnVtSW5wdXRCaXRzIC8qaW50Ki8sIGVjTGV2ZWwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHZlcnNpb25OdW0gPSAxOyB2ZXJzaW9uTnVtIDw9IDQwOyB2ZXJzaW9uTnVtKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbiQxLmdldFZlcnNpb25Gb3JOdW1iZXIodmVyc2lvbk51bSk7XG4gICAgICAgICAgICAgICAgaWYgKEVuY29kZXIud2lsbEZpdChudW1JbnB1dEJpdHMsIHZlcnNpb24sIGVjTGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0RhdGEgdG9vIGJpZycpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIG51bWJlciBvZiBpbnB1dCBiaXRzIHdpbGwgZml0IGluIGEgY29kZSB3aXRoIHRoZSBzcGVjaWZpZWQgdmVyc2lvbiBhbmRcbiAgICAgICAgICogZXJyb3IgY29ycmVjdGlvbiBsZXZlbC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyB3aWxsRml0KG51bUlucHV0Qml0cyAvKmludCovLCB2ZXJzaW9uLCBlY0xldmVsKSB7XG4gICAgICAgICAgICAvLyBJbiB0aGUgZm9sbG93aW5nIGNvbW1lbnRzLCB3ZSB1c2UgbnVtYmVycyBvZiBWZXJzaW9uIDctSC5cbiAgICAgICAgICAgIC8vIG51bUJ5dGVzID0gMTk2XG4gICAgICAgICAgICBjb25zdCBudW1CeXRlcyA9IHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIC8vIGdldE51bUVDQnl0ZXMgPSAxMzBcbiAgICAgICAgICAgIGNvbnN0IGVjQmxvY2tzID0gdmVyc2lvbi5nZXRFQ0Jsb2Nrc0ZvckxldmVsKGVjTGV2ZWwpO1xuICAgICAgICAgICAgY29uc3QgbnVtRWNCeXRlcyA9IGVjQmxvY2tzLmdldFRvdGFsRUNDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIC8vIGdldE51bURhdGFCeXRlcyA9IDE5NiAtIDEzMCA9IDY2XG4gICAgICAgICAgICBjb25zdCBudW1EYXRhQnl0ZXMgPSBudW1CeXRlcyAtIG51bUVjQnl0ZXM7XG4gICAgICAgICAgICBjb25zdCB0b3RhbElucHV0Qnl0ZXMgPSAobnVtSW5wdXRCaXRzICsgNykgLyA4O1xuICAgICAgICAgICAgcmV0dXJuIG51bURhdGFCeXRlcyA+PSB0b3RhbElucHV0Qnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlcm1pbmF0ZSBiaXRzIGFzIGRlc2NyaWJlZCBpbiA4LjQuOCBhbmQgOC40Ljkgb2YgSklTWDA1MTA6MjAwNCAocC4yNCkuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgdGVybWluYXRlQml0cyhudW1EYXRhQnl0ZXMgLyppbnQqLywgYml0cykge1xuICAgICAgICAgICAgY29uc3QgY2FwYWNpdHkgPSBudW1EYXRhQnl0ZXMgKiA4O1xuICAgICAgICAgICAgaWYgKGJpdHMuZ2V0U2l6ZSgpID4gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdkYXRhIGJpdHMgY2Fubm90IGZpdCBpbiB0aGUgUVIgQ29kZScgKyBiaXRzLmdldFNpemUoKSArICcgPiAnICtcbiAgICAgICAgICAgICAgICAgICAgY2FwYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0ICYmIGJpdHMuZ2V0U2l6ZSgpIDwgY2FwYWNpdHk7ICsraSkge1xuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0ZXJtaW5hdGlvbiBiaXRzLiBTZWUgOC40Ljggb2YgSklTWDA1MTA6MjAwNCAocC4yNCkgZm9yIGRldGFpbHMuXG4gICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBieXRlIGlzbid0IDgtYml0IGFsaWduZWQsIHdlJ2xsIGFkZCBwYWRkaW5nIGJpdHMuXG4gICAgICAgICAgICBjb25zdCBudW1CaXRzSW5MYXN0Qnl0ZSA9IGJpdHMuZ2V0U2l6ZSgpICYgMHgwNztcbiAgICAgICAgICAgIGlmIChudW1CaXRzSW5MYXN0Qnl0ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbnVtQml0c0luTGFzdEJ5dGU7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSBzcGFjZSwgd2UnbGwgZmlsbCB0aGUgc3BhY2Ugd2l0aCBwYWRkaW5nIHBhdHRlcm5zIGRlZmluZWQgaW4gOC40LjkgKHAuMjQpLlxuICAgICAgICAgICAgY29uc3QgbnVtUGFkZGluZ0J5dGVzID0gbnVtRGF0YUJ5dGVzIC0gYml0cy5nZXRTaXplSW5CeXRlcygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QYWRkaW5nQnl0ZXM7ICsraSkge1xuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cygoaSAmIDB4MDEpID09PSAwID8gMHhFQyA6IDB4MTEsIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpdHMuZ2V0U2l6ZSgpICE9PSBjYXBhY2l0eSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0JpdHMgc2l6ZSBkb2VzIG5vdCBlcXVhbCBjYXBhY2l0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgbnVtYmVyIG9mIGRhdGEgYnl0ZXMgYW5kIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGJ5dGVzIGZvciBibG9jayBpZCBcImJsb2NrSURcIi4gU3RvcmVcbiAgICAgICAgICogdGhlIHJlc3VsdCBpbiBcIm51bURhdGFCeXRlc0luQmxvY2tcIiwgYW5kIFwibnVtRUNCeXRlc0luQmxvY2tcIi4gU2VlIHRhYmxlIDEyIGluIDguNS4xIG9mXG4gICAgICAgICAqIEpJU1gwNTEwOjIwMDQgKHAuMzApXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0TnVtRGF0YUJ5dGVzQW5kTnVtRUNCeXRlc0ZvckJsb2NrSUQobnVtVG90YWxCeXRlcyAvKmludCovLCBudW1EYXRhQnl0ZXMgLyppbnQqLywgbnVtUlNCbG9ja3MgLyppbnQqLywgYmxvY2tJRCAvKmludCovLCBudW1EYXRhQnl0ZXNJbkJsb2NrLCBudW1FQ0J5dGVzSW5CbG9jaykge1xuICAgICAgICAgICAgaWYgKGJsb2NrSUQgPj0gbnVtUlNCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdCbG9jayBJRCB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG51bVJzQmxvY2tzSW5Hcm91cDIgPSAxOTYgJSA1ID0gMVxuICAgICAgICAgICAgY29uc3QgbnVtUnNCbG9ja3NJbkdyb3VwMiA9IG51bVRvdGFsQnl0ZXMgJSBudW1SU0Jsb2NrcztcbiAgICAgICAgICAgIC8vIG51bVJzQmxvY2tzSW5Hcm91cDEgPSA1IC0gMSA9IDRcbiAgICAgICAgICAgIGNvbnN0IG51bVJzQmxvY2tzSW5Hcm91cDEgPSBudW1SU0Jsb2NrcyAtIG51bVJzQmxvY2tzSW5Hcm91cDI7XG4gICAgICAgICAgICAvLyBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgPSAxOTYgLyA1ID0gMzlcbiAgICAgICAgICAgIGNvbnN0IG51bVRvdGFsQnl0ZXNJbkdyb3VwMSA9IE1hdGguZmxvb3IobnVtVG90YWxCeXRlcyAvIG51bVJTQmxvY2tzKTtcbiAgICAgICAgICAgIC8vIG51bVRvdGFsQnl0ZXNJbkdyb3VwMiA9IDM5ICsgMSA9IDQwXG4gICAgICAgICAgICBjb25zdCBudW1Ub3RhbEJ5dGVzSW5Hcm91cDIgPSBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgKyAxO1xuICAgICAgICAgICAgLy8gbnVtRGF0YUJ5dGVzSW5Hcm91cDEgPSA2NiAvIDUgPSAxM1xuICAgICAgICAgICAgY29uc3QgbnVtRGF0YUJ5dGVzSW5Hcm91cDEgPSBNYXRoLmZsb29yKG51bURhdGFCeXRlcyAvIG51bVJTQmxvY2tzKTtcbiAgICAgICAgICAgIC8vIG51bURhdGFCeXRlc0luR3JvdXAyID0gMTMgKyAxID0gMTRcbiAgICAgICAgICAgIGNvbnN0IG51bURhdGFCeXRlc0luR3JvdXAyID0gbnVtRGF0YUJ5dGVzSW5Hcm91cDEgKyAxO1xuICAgICAgICAgICAgLy8gbnVtRWNCeXRlc0luR3JvdXAxID0gMzkgLSAxMyA9IDI2XG4gICAgICAgICAgICBjb25zdCBudW1FY0J5dGVzSW5Hcm91cDEgPSBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgLSBudW1EYXRhQnl0ZXNJbkdyb3VwMTtcbiAgICAgICAgICAgIC8vIG51bUVjQnl0ZXNJbkdyb3VwMiA9IDQwIC0gMTQgPSAyNlxuICAgICAgICAgICAgY29uc3QgbnVtRWNCeXRlc0luR3JvdXAyID0gbnVtVG90YWxCeXRlc0luR3JvdXAyIC0gbnVtRGF0YUJ5dGVzSW5Hcm91cDI7XG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2tzLlxuICAgICAgICAgICAgLy8gMjYgPSAyNlxuICAgICAgICAgICAgaWYgKG51bUVjQnl0ZXNJbkdyb3VwMSAhPT0gbnVtRWNCeXRlc0luR3JvdXAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignRUMgYnl0ZXMgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDUgPSA0ICsgMS5cbiAgICAgICAgICAgIGlmIChudW1SU0Jsb2NrcyAhPT0gbnVtUnNCbG9ja3NJbkdyb3VwMSArIG51bVJzQmxvY2tzSW5Hcm91cDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdSUyBibG9ja3MgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDE5NiA9ICgxMyArIDI2KSAqIDQgKyAoMTQgKyAyNikgKiAxXG4gICAgICAgICAgICBpZiAobnVtVG90YWxCeXRlcyAhPT1cbiAgICAgICAgICAgICAgICAoKG51bURhdGFCeXRlc0luR3JvdXAxICsgbnVtRWNCeXRlc0luR3JvdXAxKSAqXG4gICAgICAgICAgICAgICAgICAgIG51bVJzQmxvY2tzSW5Hcm91cDEpICtcbiAgICAgICAgICAgICAgICAgICAgKChudW1EYXRhQnl0ZXNJbkdyb3VwMiArIG51bUVjQnl0ZXNJbkdyb3VwMikgKlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtUnNCbG9ja3NJbkdyb3VwMikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdUb3RhbCBieXRlcyBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSUQgPCBudW1Sc0Jsb2Nrc0luR3JvdXAxKSB7XG4gICAgICAgICAgICAgICAgbnVtRGF0YUJ5dGVzSW5CbG9ja1swXSA9IG51bURhdGFCeXRlc0luR3JvdXAxO1xuICAgICAgICAgICAgICAgIG51bUVDQnl0ZXNJbkJsb2NrWzBdID0gbnVtRWNCeXRlc0luR3JvdXAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbnVtRGF0YUJ5dGVzSW5CbG9ja1swXSA9IG51bURhdGFCeXRlc0luR3JvdXAyO1xuICAgICAgICAgICAgICAgIG51bUVDQnl0ZXNJbkJsb2NrWzBdID0gbnVtRWNCeXRlc0luR3JvdXAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcmxlYXZlIFwiYml0c1wiIHdpdGggY29ycmVzcG9uZGluZyBlcnJvciBjb3JyZWN0aW9uIGJ5dGVzLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluXG4gICAgICAgICAqIFwicmVzdWx0XCIuIFRoZSBpbnRlcmxlYXZlIHJ1bGUgaXMgY29tcGxpY2F0ZWQuIFNlZSA4LjYgb2YgSklTWDA1MTA6MjAwNCAocC4zNykgZm9yIGRldGFpbHMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgaW50ZXJsZWF2ZVdpdGhFQ0J5dGVzKGJpdHMsIG51bVRvdGFsQnl0ZXMgLyppbnQqLywgbnVtRGF0YUJ5dGVzIC8qaW50Ki8sIG51bVJTQmxvY2tzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIC8vIFwiYml0c1wiIG11c3QgaGF2ZSBcImdldE51bURhdGFCeXRlc1wiIGJ5dGVzIG9mIGRhdGEuXG4gICAgICAgICAgICBpZiAoYml0cy5nZXRTaXplSW5CeXRlcygpICE9PSBudW1EYXRhQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdOdW1iZXIgb2YgYml0cyBhbmQgZGF0YSBieXRlcyBkb2VzIG5vdCBtYXRjaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAxLiAgRGl2aWRlIGRhdGEgYnl0ZXMgaW50byBibG9ja3MgYW5kIGdlbmVyYXRlIGVycm9yIGNvcnJlY3Rpb24gYnl0ZXMgZm9yIHRoZW0uIFdlJ2xsXG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgZGl2aWRlZCBkYXRhIGJ5dGVzIGJsb2NrcyBhbmQgZXJyb3IgY29ycmVjdGlvbiBieXRlcyBibG9ja3MgaW50byBcImJsb2Nrc1wiLlxuICAgICAgICAgICAgbGV0IGRhdGFCeXRlc09mZnNldCA9IDA7XG4gICAgICAgICAgICBsZXQgbWF4TnVtRGF0YUJ5dGVzID0gMDtcbiAgICAgICAgICAgIGxldCBtYXhOdW1FY0J5dGVzID0gMDtcbiAgICAgICAgICAgIC8vIFNpbmNlLCB3ZSBrbm93IHRoZSBudW1iZXIgb2YgcmVlZHNvbG1vbiBibG9ja3MsIHdlIGNhbiBpbml0aWFsaXplIHRoZSB2ZWN0b3Igd2l0aCB0aGUgbnVtYmVyLlxuICAgICAgICAgICAgY29uc3QgYmxvY2tzID0gbmV3IEFycmF5KCk7IC8vIG5ldyBBcnJheTxCbG9ja1BhaXI+KG51bVJTQmxvY2tzKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1SU0Jsb2NrczsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtRGF0YUJ5dGVzSW5CbG9jayA9IG5ldyBJbnQzMkFycmF5KDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bUVjQnl0ZXNJbkJsb2NrID0gbmV3IEludDMyQXJyYXkoMSk7XG4gICAgICAgICAgICAgICAgRW5jb2Rlci5nZXROdW1EYXRhQnl0ZXNBbmROdW1FQ0J5dGVzRm9yQmxvY2tJRChudW1Ub3RhbEJ5dGVzLCBudW1EYXRhQnl0ZXMsIG51bVJTQmxvY2tzLCBpLCBudW1EYXRhQnl0ZXNJbkJsb2NrLCBudW1FY0J5dGVzSW5CbG9jayk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IG51bURhdGFCeXRlc0luQmxvY2tbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICAgICAgYml0cy50b0J5dGVzKDggKiBkYXRhQnl0ZXNPZmZzZXQsIGRhdGFCeXRlcywgMCwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZWNCeXRlcyA9IEVuY29kZXIuZ2VuZXJhdGVFQ0J5dGVzKGRhdGFCeXRlcywgbnVtRWNCeXRlc0luQmxvY2tbMF0pO1xuICAgICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKG5ldyBCbG9ja1BhaXIoZGF0YUJ5dGVzLCBlY0J5dGVzKSk7XG4gICAgICAgICAgICAgICAgbWF4TnVtRGF0YUJ5dGVzID0gTWF0aC5tYXgobWF4TnVtRGF0YUJ5dGVzLCBzaXplKTtcbiAgICAgICAgICAgICAgICBtYXhOdW1FY0J5dGVzID0gTWF0aC5tYXgobWF4TnVtRWNCeXRlcywgZWNCeXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGRhdGFCeXRlc09mZnNldCArPSBudW1EYXRhQnl0ZXNJbkJsb2NrWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bURhdGFCeXRlcyAhPT0gZGF0YUJ5dGVzT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignRGF0YSBieXRlcyBkb2VzIG5vdCBtYXRjaCBvZmZzZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgLy8gRmlyc3QsIHBsYWNlIGRhdGEgYmxvY2tzLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhOdW1EYXRhQnl0ZXM7ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmxvY2sgb2YgYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFCeXRlcyA9IGJsb2NrLmdldERhdGFCeXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGRhdGFCeXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRCaXRzKGRhdGFCeXRlc1tpXSwgOCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVuLCBwbGFjZSBlcnJvciBjb3JyZWN0aW9uIGJsb2Nrcy5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TnVtRWNCeXRlczsgKytpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBibG9jayBvZiBibG9ja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNCeXRlcyA9IGJsb2NrLmdldEVycm9yQ29ycmVjdGlvbkJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgZWNCeXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRCaXRzKGVjQnl0ZXNbaV0sIDgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bVRvdGFsQnl0ZXMgIT09IHJlc3VsdC5nZXRTaXplSW5CeXRlcygpKSB7IC8vIFNob3VsZCBiZSBzYW1lLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0ludGVybGVhdmluZyBlcnJvcjogJyArIG51bVRvdGFsQnl0ZXMgKyAnIGFuZCAnICtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmdldFNpemVJbkJ5dGVzKCkgKyAnIGRpZmZlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdlbmVyYXRlRUNCeXRlcyhkYXRhQnl0ZXMsIG51bUVjQnl0ZXNJbkJsb2NrIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IG51bURhdGFCeXRlcyA9IGRhdGFCeXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB0b0VuY29kZSA9IG5ldyBJbnQzMkFycmF5KG51bURhdGFCeXRlcyArIG51bUVjQnl0ZXNJbkJsb2NrKTsgLy8gaW50W251bURhdGFCeXRlcyArIG51bUVjQnl0ZXNJbkJsb2NrXVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYXRhQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRvRW5jb2RlW2ldID0gZGF0YUJ5dGVzW2ldICYgMHhGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldyBSZWVkU29sb21vbkVuY29kZXIoR2VuZXJpY0dGLlFSX0NPREVfRklFTERfMjU2KS5lbmNvZGUodG9FbmNvZGUsIG51bUVjQnl0ZXNJbkJsb2NrKTtcbiAgICAgICAgICAgIGNvbnN0IGVjQnl0ZXMgPSBuZXcgVWludDhBcnJheShudW1FY0J5dGVzSW5CbG9jayk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVjQnl0ZXNJbkJsb2NrOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlY0J5dGVzW2ldID0gLyooYnl0ZSkgKi8gdG9FbmNvZGVbbnVtRGF0YUJ5dGVzICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWNCeXRlcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kIG1vZGUgaW5mby4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcImJpdHNcIi5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBlbmRNb2RlSW5mbyhtb2RlLCBiaXRzKSB7XG4gICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMobW9kZS5nZXRCaXRzKCksIDQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmQgbGVuZ3RoIGluZm8uIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW4gXCJiaXRzXCIuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwZW5kTGVuZ3RoSW5mbyhudW1MZXR0ZXJzIC8qaW50Ki8sIHZlcnNpb24sIG1vZGUsIGJpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bUJpdHMgPSBtb2RlLmdldENoYXJhY3RlckNvdW50Qml0cyh2ZXJzaW9uKTtcbiAgICAgICAgICAgIGlmIChudW1MZXR0ZXJzID49ICgxIDw8IG51bUJpdHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbihudW1MZXR0ZXJzICsgJyBpcyBiaWdnZXIgdGhhbiAnICsgKCgxIDw8IG51bUJpdHMpIC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bUxldHRlcnMsIG51bUJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmQgXCJieXRlc1wiIGluIFwibW9kZVwiIG1vZGUgKGVuY29kaW5nKSBpbnRvIFwiYml0c1wiLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwiYml0c1wiLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFwcGVuZEJ5dGVzKGNvbnRlbnQsIG1vZGUsIGJpdHMsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5OVU1FUklDOlxuICAgICAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZE51bWVyaWNCeXRlcyhjb250ZW50LCBiaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuQUxQSEFOVU1FUklDOlxuICAgICAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZEFscGhhbnVtZXJpY0J5dGVzKGNvbnRlbnQsIGJpdHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5CWVRFOlxuICAgICAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZDhCaXRCeXRlcyhjb250ZW50LCBiaXRzLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLktBTkpJOlxuICAgICAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZEthbmppQnl0ZXMoY29udGVudCwgYml0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0ludmFsaWQgbW9kZTogJyArIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXREaWdpdChzaW5nbGVDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5nbGVDaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSAtIDQ4O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpc0RpZ2l0KHNpbmdsZUNoYXJhY3Rlcikge1xuICAgICAgICAgICAgY29uc3QgY24gPSBFbmNvZGVyLmdldERpZ2l0KHNpbmdsZUNoYXJhY3Rlcik7XG4gICAgICAgICAgICByZXR1cm4gY24gPj0gMCAmJiBjbiA8PSA5O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhcHBlbmROdW1lcmljQnl0ZXMoY29udGVudCwgYml0cykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bTEgPSBFbmNvZGVyLmdldERpZ2l0KGNvbnRlbnQuY2hhckF0KGkpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIHRocmVlIG51bWVyaWMgbGV0dGVycyBpbiB0ZW4gYml0cy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtMiA9IEVuY29kZXIuZ2V0RGlnaXQoY29udGVudC5jaGFyQXQoaSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtMyA9IEVuY29kZXIuZ2V0RGlnaXQoY29udGVudC5jaGFyQXQoaSArIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bTEgKiAxMDAgKyBudW0yICogMTAgKyBudW0zLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSArIDEgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIHR3byBudW1lcmljIGxldHRlcnMgaW4gc2V2ZW4gYml0cy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtMiA9IEVuY29kZXIuZ2V0RGlnaXQoY29udGVudC5jaGFyQXQoaSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bTEgKiAxMCArIG51bTIsIDcpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmNvZGUgb25lIG51bWVyaWMgbGV0dGVyIGluIGZvdXIgYml0cy5cbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bTEsIDQpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhcHBlbmRBbHBoYW51bWVyaWNCeXRlcyhjb250ZW50LCBiaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZTEgPSBFbmNvZGVyLmdldEFscGhhbnVtZXJpY0NvZGUoY29udGVudC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZTEgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUyID0gRW5jb2Rlci5nZXRBbHBoYW51bWVyaWNDb2RlKGNvbnRlbnQuY2hhckNvZGVBdChpICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZTIgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIHR3byBhbHBoYW51bWVyaWMgbGV0dGVycyBpbiAxMSBiaXRzLlxuICAgICAgICAgICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMoY29kZTEgKiA0NSArIGNvZGUyLCAxMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuY29kZSBvbmUgYWxwaGFudW1lcmljIGxldHRlciBpbiBzaXggYml0cy5cbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGNvZGUxLCA2KTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYXBwZW5kOEJpdEJ5dGVzKGNvbnRlbnQsIGJpdHMsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICBsZXQgYnl0ZXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gU3RyaW5nRW5jb2RpbmcuZW5jb2RlKGNvbnRlbnQsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoICh1ZWUgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24odWVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBieXRlcy5sZW5ndGg7IGkgIT09IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhiLCA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRocm93cyBXcml0ZXJFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBlbmRLYW5qaUJ5dGVzKGNvbnRlbnQsIGJpdHMpIHtcbiAgICAgICAgICAgIGxldCBieXRlcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBTdHJpbmdFbmNvZGluZy5lbmNvZGUoY29udGVudCwgQ2hhcmFjdGVyU2V0RUNJLlNKSVMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHVlZSAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbih1ZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGUxID0gYnl0ZXNbaV0gJiAweEZGO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gYnl0ZXNbaSArIDFdICYgMHhGRjtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gKChieXRlMSA8PCA4KSAmIDB4RkZGRkZGRkYpIHwgYnl0ZTI7XG4gICAgICAgICAgICAgICAgbGV0IHN1YnRyYWN0ZWQgPSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA+PSAweDgxNDAgJiYgY29kZSA8PSAweDlmZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHJhY3RlZCA9IGNvZGUgLSAweDgxNDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPj0gMHhlMDQwICYmIGNvZGUgPD0gMHhlYmJmKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0ZWQgPSBjb2RlIC0gMHhjMTQwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3VidHJhY3RlZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZWQgPSAoKHN1YnRyYWN0ZWQgPj4gOCkgKiAweGMwKSArIChzdWJ0cmFjdGVkICYgMHhmZik7XG4gICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGVuY29kZWQsIDEzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYXBwZW5kRUNJKGVjaSwgYml0cykge1xuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKE1vZGUkMS5FQ0kuZ2V0Qml0cygpLCA0KTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgY29ycmVjdCBmb3IgdmFsdWVzIHVwIHRvIDEyNywgd2hpY2ggaXMgYWxsIHdlIG5lZWQgbm93LlxuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGVjaS5nZXRWYWx1ZSgpLCA4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGUgb3JpZ2luYWwgdGFibGUgaXMgZGVmaW5lZCBpbiB0aGUgdGFibGUgNSBvZiBKSVNYMDUxMDoyMDA0IChwLjE5KS5cbiAgICBFbmNvZGVyLkFMUEhBTlVNRVJJQ19UQUJMRSA9IEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgICAgICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgICAgICAgMzYsIC0xLCAtMSwgLTEsIDM3LCAzOCwgLTEsIC0xLCAtMSwgLTEsIDM5LCA0MCwgLTEsIDQxLCA0MiwgNDMsXG4gICAgICAgIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDQ0LCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gICAgICAgIC0xLCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LFxuICAgICAgICAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgICBdKTtcbiAgICBFbmNvZGVyLkRFRkFVTFRfQllURV9NT0RFX0VOQ09ESU5HID0gQ2hhcmFjdGVyU2V0RUNJLlVURjguZ2V0TmFtZSgpOyAvLyBcIklTTy04ODU5LTFcIlxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICovXG4gICAgY2xhc3MgQnJvd3NlclFSQ29kZVN2Z1dyaXRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgYW5kIHJlbmRlcnMgYSBRUkNvZGUgU1ZHIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb250ZW50c1xuICAgICAgICAgKiBAcGFyYW0gd2lkdGhcbiAgICAgICAgICogQHBhcmFtIGhlaWdodFxuICAgICAgICAgKiBAcGFyYW0gaGludHNcbiAgICAgICAgICovXG4gICAgICAgIHdyaXRlKGNvbnRlbnRzLCB3aWR0aCwgaGVpZ2h0LCBoaW50cyA9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdGb3VuZCBlbXB0eSBjb250ZW50cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgKGZvcm1hdCAhPSBCYXJjb2RlRm9ybWF0LlFSX0NPREUpIHtcbiAgICAgICAgICAgIC8vICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIkNhbiBvbmx5IGVuY29kZSBRUl9DT0RFLCBidXQgZ290IFwiICsgZm9ybWF0KVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMCB8fCBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUmVxdWVzdGVkIGRpbWVuc2lvbnMgYXJlIHRvbyBzbWFsbDogJyArIHdpZHRoICsgJ3gnICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsLkw7XG4gICAgICAgICAgICBsZXQgcXVpZXRab25lID0gQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5RVUlFVF9aT05FX1NJWkU7XG4gICAgICAgICAgICBpZiAoaGludHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsLmZyb21TdHJpbmcoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuRVJST1JfQ09SUkVDVElPTikudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLk1BUkdJTikpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVpZXRab25lID0gTnVtYmVyLnBhcnNlSW50KGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLk1BUkdJTikudG9TdHJpbmcoKSwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBFbmNvZGVyLmVuY29kZShjb250ZW50cywgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIGhpbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJlc3VsdChjb2RlLCB3aWR0aCwgaGVpZ2h0LCBxdWlldFpvbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIHRoZSByZXN1bHQgYW5kIHRoZW4gYXBwZW5kcyBpdCB0byB0aGUgRE9NLlxuICAgICAgICAgKi9cbiAgICAgICAgd3JpdGVUb0RvbShjb250YWluZXJFbGVtZW50LCBjb250ZW50cywgd2lkdGgsIGhlaWdodCwgaGludHMgPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRhaW5lckVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdmdFbGVtZW50ID0gdGhpcy53cml0ZShjb250ZW50cywgd2lkdGgsIGhlaWdodCwgaGludHMpO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lckVsZW1lbnQpXG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChzdmdFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm90ZSB0aGF0IHRoZSBpbnB1dCBtYXRyaXggdXNlcyAwID09IHdoaXRlLCAxID09IGJsYWNrLlxuICAgICAgICAgKiBUaGUgb3V0cHV0IG1hdHJpeCB1c2VzIDAgPT0gYmxhY2ssIDI1NSA9PSB3aGl0ZSAoaS5lLiBhbiA4IGJpdCBncmV5c2NhbGUgYml0bWFwKS5cbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlclJlc3VsdChjb2RlLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgcXVpZXRab25lIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gY29kZS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlucHV0V2lkdGggPSBpbnB1dC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRIZWlnaHQgPSBpbnB1dC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHFyV2lkdGggPSBpbnB1dFdpZHRoICsgKHF1aWV0Wm9uZSAqIDIpO1xuICAgICAgICAgICAgY29uc3QgcXJIZWlnaHQgPSBpbnB1dEhlaWdodCArIChxdWlldFpvbmUgKiAyKTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dFdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHFyV2lkdGgpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0SGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBxckhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBtdWx0aXBsZSA9IE1hdGgubWluKE1hdGguZmxvb3Iob3V0cHV0V2lkdGggLyBxcldpZHRoKSwgTWF0aC5mbG9vcihvdXRwdXRIZWlnaHQgLyBxckhlaWdodCkpO1xuICAgICAgICAgICAgLy8gUGFkZGluZyBpbmNsdWRlcyBib3RoIHRoZSBxdWlldCB6b25lIGFuZCB0aGUgZXh0cmEgd2hpdGUgcGl4ZWxzIHRvIGFjY29tbW9kYXRlIHRoZSByZXF1ZXN0ZWRcbiAgICAgICAgICAgIC8vIGRpbWVuc2lvbnMuIEZvciBleGFtcGxlLCBpZiBpbnB1dCBpcyAyNXgyNSB0aGUgUVIgd2lsbCBiZSAzM3gzMyBpbmNsdWRpbmcgdGhlIHF1aWV0IHpvbmUuXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdGVkIHNpemUgaXMgMjAweDE2MCwgdGhlIG11bHRpcGxlIHdpbGwgYmUgNCwgZm9yIGEgUVIgb2YgMTMyeDEzMi4gVGhlc2Ugd2lsbFxuICAgICAgICAgICAgLy8gaGFuZGxlIGFsbCB0aGUgcGFkZGluZyBmcm9tIDEwMHgxMDAgKHRoZSBhY3R1YWwgUVIpIHVwIHRvIDIwMHgxNjAuXG4gICAgICAgICAgICBjb25zdCBsZWZ0UGFkZGluZyA9IE1hdGguZmxvb3IoKG91dHB1dFdpZHRoIC0gKGlucHV0V2lkdGggKiBtdWx0aXBsZSkpIC8gMik7XG4gICAgICAgICAgICBjb25zdCB0b3BQYWRkaW5nID0gTWF0aC5mbG9vcigob3V0cHV0SGVpZ2h0IC0gKGlucHV0SGVpZ2h0ICogbXVsdGlwbGUpKSAvIDIpO1xuICAgICAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IHRoaXMuY3JlYXRlU1ZHRWxlbWVudChvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGlucHV0WSA9IDAsIG91dHB1dFkgPSB0b3BQYWRkaW5nOyBpbnB1dFkgPCBpbnB1dEhlaWdodDsgaW5wdXRZKyssIG91dHB1dFkgKz0gbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSB0aGUgY29udGVudHMgb2YgdGhpcyByb3cgb2YgdGhlIGJhcmNvZGVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbnB1dFggPSAwLCBvdXRwdXRYID0gbGVmdFBhZGRpbmc7IGlucHV0WCA8IGlucHV0V2lkdGg7IGlucHV0WCsrLCBvdXRwdXRYICs9IG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5nZXQoaW5wdXRYLCBpbnB1dFkpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdmdSZWN0RWxlbWVudCA9IHRoaXMuY3JlYXRlU3ZnUmVjdEVsZW1lbnQob3V0cHV0WCwgb3V0cHV0WSwgbXVsdGlwbGUsIG11bHRpcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnUmVjdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN2Z0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBTVkcgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHcgU1ZHJ3Mgd2lkdGggYXR0cmlidXRlXG4gICAgICAgICAqIEBwYXJhbSBoIFNWRydzIGhlaWdodCBhdHRyaWJ1dGVcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNWR0VsZW1lbnQodywgaCkge1xuICAgICAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhCcm93c2VyUVJDb2RlU3ZnV3JpdGVyLlNWR19OUywgJ3N2ZycpO1xuICAgICAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0Jywgdy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgaC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJldHVybiBzdmdFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgU1ZHIHJlY3QgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHggRWxlbWVudCdzIHggY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0geSBFbGVtZW50J3MgeSBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSB3IEVsZW1lbnQncyB3aWR0aCBhdHRyaWJ1dGVcbiAgICAgICAgICogQHBhcmFtIGggRWxlbWVudCdzIGhlaWdodCBhdHRyaWJ1dGVcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVN2Z1JlY3RFbGVtZW50KHgsIHksIHcsIGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5TVkdfTlMsICdyZWN0Jyk7XG4gICAgICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JywgeC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLCB5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0Jywgdy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgaC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnIzAwMDAwMCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5RVUlFVF9aT05FX1NJWkUgPSA0O1xuICAgIC8qKlxuICAgICAqIFNWRyBtYXJrdXAgTmFtZVNwYWNlXG4gICAgICovXG4gICAgQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5TVkdfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG4gICAgLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0IHJlbmRlcnMgYSBRUiBDb2RlIGFzIGEgQml0TWF0cml4IDJEIGFycmF5IG9mIGdyZXlzY2FsZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIFFSQ29kZVdyaXRlciB7XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgLy8gcHVibGljIGVuY29kZShjb250ZW50czogc3RyaW5nLCBmb3JtYXQ6IEJhcmNvZGVGb3JtYXQsIHdpZHRoOiBudW1iZXIgLyppbnQqLywgaGVpZ2h0OiBudW1iZXIgLyppbnQqLyk6IEJpdE1hdHJpeFxuICAgICAgICAvLyAgICAgLyp0aHJvd3MgV3JpdGVyRXhjZXB0aW9uICovIHtcbiAgICAgICAgLy8gICByZXR1cm4gZW5jb2RlKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBlbmNvZGUoY29udGVudHMsIGZvcm1hdCwgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIGhpbnRzKSB7XG4gICAgICAgICAgICBpZiAoY29udGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRm91bmQgZW1wdHkgY29udGVudHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgIT09IEJhcmNvZGVGb3JtYXQkMS5RUl9DT0RFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ2FuIG9ubHkgZW5jb2RlIFFSX0NPREUsIGJ1dCBnb3QgJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2lkdGggPCAwIHx8IGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKGBSZXF1ZXN0ZWQgZGltZW5zaW9ucyBhcmUgdG9vIHNtYWxsOiAke3dpZHRofXgke2hlaWdodH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsLkw7XG4gICAgICAgICAgICBsZXQgcXVpZXRab25lID0gUVJDb2RlV3JpdGVyLlFVSUVUX1pPTkVfU0laRTtcbiAgICAgICAgICAgIGlmIChoaW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLkVSUk9SX0NPUlJFQ1RJT04pKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ29ycmVjdGlvbkxldmVsID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuZnJvbVN0cmluZyhoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuTUFSR0lOKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWlldFpvbmUgPSBOdW1iZXIucGFyc2VJbnQoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuTUFSR0lOKS50b1N0cmluZygpLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29kZSA9IEVuY29kZXIuZW5jb2RlKGNvbnRlbnRzLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgaGludHMpO1xuICAgICAgICAgICAgcmV0dXJuIFFSQ29kZVdyaXRlci5yZW5kZXJSZXN1bHQoY29kZSwgd2lkdGgsIGhlaWdodCwgcXVpZXRab25lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIGlucHV0IG1hdHJpeCB1c2VzIDAgPT0gd2hpdGUsIDEgPT0gYmxhY2ssIHdoaWxlIHRoZSBvdXRwdXQgbWF0cml4IHVzZXNcbiAgICAgICAgLy8gMCA9PSBibGFjaywgMjU1ID09IHdoaXRlIChpLmUuIGFuIDggYml0IGdyZXlzY2FsZSBiaXRtYXApLlxuICAgICAgICBzdGF0aWMgcmVuZGVyUmVzdWx0KGNvZGUsIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBxdWlldFpvbmUgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBjb2RlLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5wdXRXaWR0aCA9IGlucHV0LmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dEhlaWdodCA9IGlucHV0LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgY29uc3QgcXJXaWR0aCA9IGlucHV0V2lkdGggKyAocXVpZXRab25lICogMik7XG4gICAgICAgICAgICBjb25zdCBxckhlaWdodCA9IGlucHV0SGVpZ2h0ICsgKHF1aWV0Wm9uZSAqIDIpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0V2lkdGggPSBNYXRoLm1heCh3aWR0aCwgcXJXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHFySGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IG11bHRpcGxlID0gTWF0aC5taW4oTWF0aC5mbG9vcihvdXRwdXRXaWR0aCAvIHFyV2lkdGgpLCBNYXRoLmZsb29yKG91dHB1dEhlaWdodCAvIHFySGVpZ2h0KSk7XG4gICAgICAgICAgICAvLyBQYWRkaW5nIGluY2x1ZGVzIGJvdGggdGhlIHF1aWV0IHpvbmUgYW5kIHRoZSBleHRyYSB3aGl0ZSBwaXhlbHMgdG8gYWNjb21tb2RhdGUgdGhlIHJlcXVlc3RlZFxuICAgICAgICAgICAgLy8gZGltZW5zaW9ucy4gRm9yIGV4YW1wbGUsIGlmIGlucHV0IGlzIDI1eDI1IHRoZSBRUiB3aWxsIGJlIDMzeDMzIGluY2x1ZGluZyB0aGUgcXVpZXQgem9uZS5cbiAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0ZWQgc2l6ZSBpcyAyMDB4MTYwLCB0aGUgbXVsdGlwbGUgd2lsbCBiZSA0LCBmb3IgYSBRUiBvZiAxMzJ4MTMyLiBUaGVzZSB3aWxsXG4gICAgICAgICAgICAvLyBoYW5kbGUgYWxsIHRoZSBwYWRkaW5nIGZyb20gMTAweDEwMCAodGhlIGFjdHVhbCBRUikgdXAgdG8gMjAweDE2MC5cbiAgICAgICAgICAgIGNvbnN0IGxlZnRQYWRkaW5nID0gTWF0aC5mbG9vcigob3V0cHV0V2lkdGggLSAoaW5wdXRXaWR0aCAqIG11bHRpcGxlKSkgLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcFBhZGRpbmcgPSBNYXRoLmZsb29yKChvdXRwdXRIZWlnaHQgLSAoaW5wdXRIZWlnaHQgKiBtdWx0aXBsZSkpIC8gMik7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBuZXcgQml0TWF0cml4KG91dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5wdXRZID0gMCwgb3V0cHV0WSA9IHRvcFBhZGRpbmc7IGlucHV0WSA8IGlucHV0SGVpZ2h0OyBpbnB1dFkrKywgb3V0cHV0WSArPSBtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBjb250ZW50cyBvZiB0aGlzIHJvdyBvZiB0aGUgYmFyY29kZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlucHV0WCA9IDAsIG91dHB1dFggPSBsZWZ0UGFkZGluZzsgaW5wdXRYIDwgaW5wdXRXaWR0aDsgaW5wdXRYKyssIG91dHB1dFggKz0gbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmdldChpbnB1dFgsIGlucHV0WSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXRSZWdpb24ob3V0cHV0WCwgb3V0cHV0WSwgbXVsdGlwbGUsIG11bHRpcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUVJDb2RlV3JpdGVyLlFVSUVUX1pPTkVfU0laRSA9IDQ7XG5cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGZhY3RvcnkgY2xhc3Mgd2hpY2ggZmluZHMgdGhlIGFwcHJvcHJpYXRlIFdyaXRlciBzdWJjbGFzcyBmb3IgdGhlIEJhcmNvZGVGb3JtYXRcbiAgICAgKiByZXF1ZXN0ZWQgYW5kIGVuY29kZXMgdGhlIGJhcmNvZGUgd2l0aCB0aGUgc3VwcGxpZWQgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIE11bHRpRm9ybWF0V3JpdGVyIHtcbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICAvLyBwdWJsaWMgZW5jb2RlKGNvbnRlbnRzOiBzdHJpbmcsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogQmFyY29kZUZvcm1hdCxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG51bWJlciAvKmludCovLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG51bWJlciAvKmludCovKTogQml0TWF0cml4IC8qdGhyb3dzIFdyaXRlckV4Y2VwdGlvbiAqLyB7XG4gICAgICAgIC8vICAgcmV0dXJuIGVuY29kZShjb250ZW50cywgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBudWxsKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZW5jb2RlKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBoaW50cykge1xuICAgICAgICAgICAgbGV0IHdyaXRlcjtcbiAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkVBTl84OlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IEVBTjhXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuVVBDX0U6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgVVBDRVdyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5FQU5fMTM6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgRUFOMTNXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuVVBDX0E6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgVVBDQVdyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgQmFyY29kZUZvcm1hdCQxLlFSX0NPREU6XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlciA9IG5ldyBRUkNvZGVXcml0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfMzk6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgQ29kZTM5V3JpdGVyKClcbiAgICAgICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfOTM6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgQ29kZTkzV3JpdGVyKClcbiAgICAgICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfMTI4OlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IENvZGUxMjhXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuSVRGOlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IElURldyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5QREZfNDE3OlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IFBERjQxN1dyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5DT0RBQkFSOlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IENvZGFCYXJXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuREFUQV9NQVRSSVg6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgRGF0YU1hdHJpeFdyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5BWlRFQzpcbiAgICAgICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBBenRlY1dyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ05vIGVuY29kZXIgYXZhaWxhYmxlIGZvciBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyLmVuY29kZShjb250ZW50cywgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBoaW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0IGV4dGVuZHMgTHVtaW5hbmNlU291cmNlIGFyb3VuZCBhbiBhcnJheSBvZiBZVVYgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBjYW1lcmEgZHJpdmVyLFxuICAgICAqIHdpdGggdGhlIG9wdGlvbiB0byBjcm9wIHRvIGEgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgZnVsbCBkYXRhLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGV4Y2x1ZGVcbiAgICAgKiBzdXBlcmZsdW91cyBwaXhlbHMgYXJvdW5kIHRoZSBwZXJpbWV0ZXIgYW5kIHNwZWVkIHVwIGRlY29kaW5nLlxuICAgICAqXG4gICAgICogSXQgd29ya3MgZm9yIGFueSBwaXhlbCBmb3JtYXQgd2hlcmUgdGhlIFkgY2hhbm5lbCBpcyBwbGFuYXIgYW5kIGFwcGVhcnMgZmlyc3QsIGluY2x1ZGluZ1xuICAgICAqIFlDYkNyXzQyMF9TUCBhbmQgWUNiQ3JfNDIyX1NQLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKi9cbiAgICBjbGFzcyBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UgZXh0ZW5kcyBMdW1pbmFuY2VTb3VyY2Uge1xuICAgICAgICBjb25zdHJ1Y3Rvcih5dXZEYXRhLCBkYXRhV2lkdGggLyppbnQqLywgZGF0YUhlaWdodCAvKmludCovLCBsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgcmV2ZXJzZUhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy55dXZEYXRhID0geXV2RGF0YTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVdpZHRoID0gZGF0YVdpZHRoO1xuICAgICAgICAgICAgdGhpcy5kYXRhSGVpZ2h0ID0gZGF0YUhlaWdodDtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBkYXRhV2lkdGggfHwgdG9wICsgaGVpZ2h0ID4gZGF0YUhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0Nyb3AgcmVjdGFuZ2xlIGRvZXMgbm90IGZpdCB3aXRoaW4gaW1hZ2UgZGF0YS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXZlcnNlSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZUhvcml6b250YWwod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBnZXRSb3coeSAvKmludCovLCByb3cpIHtcbiAgICAgICAgICAgIGlmICh5IDwgMCB8fCB5ID49IHRoaXMuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdSZXF1ZXN0ZWQgcm93IGlzIG91dHNpZGUgdGhlIGltYWdlOiAnICsgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGlmIChyb3cgPT09IG51bGwgfHwgcm93ID09PSB1bmRlZmluZWQgfHwgcm93Lmxlbmd0aCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9ICh5ICsgdGhpcy50b3ApICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHRoaXMueXV2RGF0YSwgb2Zmc2V0LCByb3csIDAsIHdpZHRoKTtcbiAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBnZXRNYXRyaXgoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2FsbGVyIGFza3MgZm9yIHRoZSBlbnRpcmUgdW5kZXJseWluZyBpbWFnZSwgc2F2ZSB0aGUgY29weSBhbmQgZ2l2ZSB0aGVtIHRoZVxuICAgICAgICAgICAgLy8gb3JpZ2luYWwgZGF0YS4gVGhlIGRvY3Mgc3BlY2lmaWNhbGx5IHdhcm4gdGhhdCByZXN1bHQubGVuZ3RoIG11c3QgYmUgaWdub3JlZC5cbiAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gdGhpcy5kYXRhV2lkdGggJiYgaGVpZ2h0ID09PSB0aGlzLmRhdGFIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55dXZEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJlYSA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGFyZWEpO1xuICAgICAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gdGhpcy50b3AgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDtcbiAgICAgICAgICAgIC8vIElmIHRoZSB3aWR0aCBtYXRjaGVzIHRoZSBmdWxsIHdpZHRoIG9mIHRoZSB1bmRlcmx5aW5nIGRhdGEsIHBlcmZvcm0gYSBzaW5nbGUgY29weS5cbiAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gdGhpcy5kYXRhV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHRoaXMueXV2RGF0YSwgaW5wdXRPZmZzZXQsIG1hdHJpeCwgMCwgYXJlYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjb3B5IG9uZSBjcm9wcGVkIHJvdyBhdCBhIHRpbWUuXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0T2Zmc2V0ID0geSAqIHdpZHRoO1xuICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkodGhpcy55dXZEYXRhLCBpbnB1dE9mZnNldCwgbWF0cml4LCBvdXRwdXRPZmZzZXQsIHdpZHRoKTtcbiAgICAgICAgICAgICAgICBpbnB1dE9mZnNldCArPSB0aGlzLmRhdGFXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBpc0Nyb3BTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGNyb3AobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlKHRoaXMueXV2RGF0YSwgdGhpcy5kYXRhV2lkdGgsIHRoaXMuZGF0YUhlaWdodCwgdGhpcy5sZWZ0ICsgbGVmdCwgdGhpcy50b3AgKyB0b3AsIHdpZHRoLCBoZWlnaHQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJUaHVtYm5haWwoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSAvIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSAvIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxzID0gbmV3IEludDMyQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgeXV2ID0gdGhpcy55dXZEYXRhO1xuICAgICAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gdGhpcy50b3AgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRPZmZzZXQgPSB5ICogd2lkdGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyZXkgPSB5dXZbaW5wdXRPZmZzZXQgKyB4ICogUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlLlRIVU1CTkFJTF9TQ0FMRV9GQUNUT1JdICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW291dHB1dE9mZnNldCArIHhdID0gMHhGRjAwMDAwMCB8IChncmV5ICogMHgwMDAxMDEwMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlucHV0T2Zmc2V0ICs9IHRoaXMuZGF0YVdpZHRoICogUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlLlRIVU1CTkFJTF9TQ0FMRV9GQUNUT1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGl4ZWxzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHdpZHRoIG9mIGltYWdlIGZyb20ge0BsaW5rICNyZW5kZXJUaHVtYm5haWwoKX1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRodW1ibmFpbFdpZHRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSAvIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGhlaWdodCBvZiBpbWFnZSBmcm9tIHtAbGluayAjcmVuZGVyVGh1bWJuYWlsKCl9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaHVtYm5haWxIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWlnaHQoKSAvIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICB9XG4gICAgICAgIHJldmVyc2VIb3Jpem9udGFsKHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCB5dXZEYXRhID0gdGhpcy55dXZEYXRhO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDAsIHJvd1N0YXJ0ID0gdGhpcy50b3AgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDsgeSA8IGhlaWdodDsgeSsrLCByb3dTdGFydCArPSB0aGlzLmRhdGFXaWR0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pZGRsZSA9IHJvd1N0YXJ0ICsgd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHgxID0gcm93U3RhcnQsIHgyID0gcm93U3RhcnQgKyB3aWR0aCAtIDE7IHgxIDwgbWlkZGxlOyB4MSsrLCB4Mi0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSB5dXZEYXRhW3gxXTtcbiAgICAgICAgICAgICAgICAgICAgeXV2RGF0YVt4MV0gPSB5dXZEYXRhW3gyXTtcbiAgICAgICAgICAgICAgICAgICAgeXV2RGF0YVt4Ml0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnZlcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SID0gMjtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGhlbHAgZGVjb2RlIGltYWdlcyBmcm9tIGZpbGVzIHdoaWNoIGFycml2ZSBhcyBSR0IgZGF0YSBmcm9tXG4gICAgICogYW4gQVJHQiBwaXhlbCBhcnJheS4gSXQgZG9lcyBub3Qgc3VwcG9ydCByb3RhdGlvbi5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBCZXRhbWlub3NcbiAgICAgKi9cbiAgICBjbGFzcyBSR0JMdW1pbmFuY2VTb3VyY2UgZXh0ZW5kcyBMdW1pbmFuY2VTb3VyY2Uge1xuICAgICAgICBjb25zdHJ1Y3RvcihsdW1pbmFuY2VzLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgZGF0YVdpZHRoIC8qaW50Ki8sIGRhdGFIZWlnaHQgLyppbnQqLywgbGVmdCAvKmludCovLCB0b3AgLyppbnQqLykge1xuICAgICAgICAgICAgc3VwZXIod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmRhdGFXaWR0aCA9IGRhdGFXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuZGF0YUhlaWdodCA9IGRhdGFIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgICAgICBpZiAobHVtaW5hbmNlcy5CWVRFU19QRVJfRUxFTUVOVCA9PT0gNCkgeyAvLyBJbnQzMkFycmF5XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGx1bWluYW5jZXNVaW50OEFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHNpemUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IHNpemU7IG9mZnNldCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0gbHVtaW5hbmNlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gKHBpeGVsID4+IDE2KSAmIDB4ZmY7IC8vIHJlZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBnMiA9IChwaXhlbCA+PiA3KSAmIDB4MWZlOyAvLyAyICogZ3JlZW5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IHBpeGVsICYgMHhmZjsgLy8gYmx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgZ3JlZW4tZmF2b3VyaW5nIGF2ZXJhZ2UgY2hlYXBseVxuICAgICAgICAgICAgICAgICAgICBsdW1pbmFuY2VzVWludDhBcnJheVtvZmZzZXRdID0gLyooYnl0ZSkgKi8gKChyICsgZzIgKyBiKSAvIDQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sdW1pbmFuY2VzID0gbHVtaW5hbmNlc1VpbnQ4QXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmx1bWluYW5jZXMgPSBsdW1pbmFuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gZGF0YVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhV2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGRhdGFIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHRvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgKyB3aWR0aCA+IHRoaXMuZGF0YVdpZHRoIHx8IHRoaXMudG9wICsgaGVpZ2h0ID4gdGhpcy5kYXRhSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ3JvcCByZWN0YW5nbGUgZG9lcyBub3QgZml0IHdpdGhpbiBpbWFnZSBkYXRhLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0Um93KHkgLyppbnQqLywgcm93KSB7XG4gICAgICAgICAgICBpZiAoeSA8IDAgfHwgeSA+PSB0aGlzLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUmVxdWVzdGVkIHJvdyBpcyBvdXRzaWRlIHRoZSBpbWFnZTogJyArIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBpZiAocm93ID09PSBudWxsIHx8IHJvdyA9PT0gdW5kZWZpbmVkIHx8IHJvdy5sZW5ndGggPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHJvdyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoeSArIHRoaXMudG9wKSAqIHRoaXMuZGF0YVdpZHRoICsgdGhpcy5sZWZ0O1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0aGlzLmx1bWluYW5jZXMsIG9mZnNldCwgcm93LCAwLCB3aWR0aCk7XG4gICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0TWF0cml4KCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNhbGxlciBhc2tzIGZvciB0aGUgZW50aXJlIHVuZGVybHlpbmcgaW1hZ2UsIHNhdmUgdGhlIGNvcHkgYW5kIGdpdmUgdGhlbSB0aGVcbiAgICAgICAgICAgIC8vIG9yaWdpbmFsIGRhdGEuIFRoZSBkb2NzIHNwZWNpZmljYWxseSB3YXJuIHRoYXQgcmVzdWx0Lmxlbmd0aCBtdXN0IGJlIGlnbm9yZWQuXG4gICAgICAgICAgICBpZiAod2lkdGggPT09IHRoaXMuZGF0YVdpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5kYXRhSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubHVtaW5hbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBVaW50OENsYW1wZWRBcnJheShhcmVhKTtcbiAgICAgICAgICAgIGxldCBpbnB1dE9mZnNldCA9IHRoaXMudG9wICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7XG4gICAgICAgICAgICAvLyBJZiB0aGUgd2lkdGggbWF0Y2hlcyB0aGUgZnVsbCB3aWR0aCBvZiB0aGUgdW5kZXJseWluZyBkYXRhLCBwZXJmb3JtIGEgc2luZ2xlIGNvcHkuXG4gICAgICAgICAgICBpZiAod2lkdGggPT09IHRoaXMuZGF0YVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0aGlzLmx1bWluYW5jZXMsIGlucHV0T2Zmc2V0LCBtYXRyaXgsIDAsIGFyZWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgY29weSBvbmUgY3JvcHBlZCByb3cgYXQgYSB0aW1lLlxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dE9mZnNldCA9IHkgKiB3aWR0aDtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHRoaXMubHVtaW5hbmNlcywgaW5wdXRPZmZzZXQsIG1hdHJpeCwgb3V0cHV0T2Zmc2V0LCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgaW5wdXRPZmZzZXQgKz0gdGhpcy5kYXRhV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgaXNDcm9wU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBjcm9wKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJHQkx1bWluYW5jZVNvdXJjZSh0aGlzLmx1bWluYW5jZXMsIHdpZHRoLCBoZWlnaHQsIHRoaXMuZGF0YVdpZHRoLCB0aGlzLmRhdGFIZWlnaHQsIHRoaXMubGVmdCArIGxlZnQsIHRoaXMudG9wICsgdG9wKTtcbiAgICAgICAgfVxuICAgICAgICBpbnZlcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSnVzdCB0byBtYWtlIGEgc2hvcnRjdXQgYmV0d2VlbiBKYXZhIGNvZGUgYW5kIFRTIGNvZGUuXG4gICAgICovXG4gICAgY2xhc3MgQ2hhcnNldCBleHRlbmRzIENoYXJhY3RlclNldEVDSSB7XG4gICAgICAgIHN0YXRpYyBmb3JOYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENoYXJhY3RlclNldEVDSUJ5TmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEp1c3QgdG8gbWFrZSBhIHNob3J0Y3V0IGJldHdlZW4gSmF2YSBjb2RlIGFuZCBUUyBjb2RlLlxuICAgICAqL1xuICAgIGNsYXNzIFN0YW5kYXJkQ2hhcnNldHMge1xuICAgIH1cbiAgICBTdGFuZGFyZENoYXJzZXRzLklTT184ODU5XzEgPSBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xO1xuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLyoqXG4gICAgICogQXp0ZWMgMkQgY29kZSByZXByZXNlbnRhdGlvblxuICAgICAqXG4gICAgICogQGF1dGhvciBSdXN0YW0gQWJkdWxsYWV2XG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBBenRlY0NvZGUge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QGNvZGUgdHJ1ZX0gaWYgY29tcGFjdCBpbnN0ZWFkIG9mIGZ1bGwgbW9kZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNDb21wYWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFjdDtcbiAgICAgICAgfVxuICAgICAgICBzZXRDb21wYWN0KGNvbXBhY3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gc2l6ZSBpbiBwaXhlbHMgKHdpZHRoIGFuZCBoZWlnaHQpXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTaXplKHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGxldmVsc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzO1xuICAgICAgICB9XG4gICAgICAgIHNldExheWVycyhsYXllcnMpIHtcbiAgICAgICAgICAgIHRoaXMubGF5ZXJzID0gbGF5ZXJzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBkYXRhIGNvZGV3b3Jkc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29kZVdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29kZVdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIHNldENvZGVXb3Jkcyhjb2RlV29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZVdvcmRzID0gY29kZVdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBzeW1ib2wgaW1hZ2VcbiAgICAgICAgICovXG4gICAgICAgIGdldE1hdHJpeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICBzZXRNYXRyaXgobWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIENvbGxlY3Rpb25zIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaW5nbGV0b25MaXN0KFQpIG1ldGhvZCBpcyB1c2VkIHRvIHJldHVybiBhbiBpbW11dGFibGUgbGlzdCBjb250YWluaW5nIG9ubHkgdGhlIHNwZWNpZmllZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgc2luZ2xldG9uTGlzdChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gW2l0ZW1dO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWluKENvbGxlY3Rpb248PyBleHRlbmRzIFQ+LCBDb21wYXJhdG9yPD8gc3VwZXIgVD4pIG1ldGhvZCBpcyB1c2VkIHRvIHJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IG9mIHRoZSBnaXZlbiBjb2xsZWN0aW9uLCBhY2NvcmRpbmcgdG8gdGhlIG9yZGVyIGluZHVjZWQgYnkgdGhlIHNwZWNpZmllZCBjb21wYXJhdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG1pbihjb2xsZWN0aW9uLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5zb3J0KGNvbXBhcmF0b3IpWzBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgY2xhc3MgVG9rZW4ge1xuICAgICAgICBjb25zdHJ1Y3RvcihwcmV2aW91cykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIGdldFByZXZpb3VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgU2ltcGxlVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByZXZpb3VzLCB2YWx1ZSwgYml0Q291bnQpIHtcbiAgICAgICAgICAgIHN1cGVyKHByZXZpb3VzKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuYml0Q291bnQgPSBiaXRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQE92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRUbyhiaXRBcnJheSwgdGV4dCkge1xuICAgICAgICAgICAgYml0QXJyYXkuYXBwZW5kQml0cyh0aGlzLnZhbHVlLCB0aGlzLmJpdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBhZGQodmFsdWUsIGJpdENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVRva2VuKHRoaXMsIHZhbHVlLCBiaXRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkQmluYXJ5U2hpZnQoc3RhcnQsIGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgLy8gbm8tb3AgY2FuJ3QgYmluYXJ5IHNoaWZ0IGEgc2ltcGxlIHRva2VuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FkZEJpbmFyeVNoaWZ0IG9uIFNpbXBsZVRva2VuLCB0aGlzIHNpbXBseSByZXR1cm5zIGEgY29weSBvZiB0aGlzIHRva2VuJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVRva2VuKHRoaXMsIHN0YXJ0LCBieXRlQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAT3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZSAmICgoMSA8PCB0aGlzLmJpdENvdW50KSAtIDEpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMSA8PCB0aGlzLmJpdENvdW50O1xuICAgICAgICAgICAgcmV0dXJuICc8JyArIEludGVnZXIudG9CaW5hcnlTdHJpbmcodmFsdWUgfCAoMSA8PCB0aGlzLmJpdENvdW50KSkuc3Vic3RyaW5nKDEpICsgJz4nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIEJpbmFyeVNoaWZ0VG9rZW4gZXh0ZW5kcyBTaW1wbGVUb2tlbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByZXZpb3VzLCBiaW5hcnlTaGlmdFN0YXJ0LCBiaW5hcnlTaGlmdEJ5dGVDb3VudCkge1xuICAgICAgICAgICAgc3VwZXIocHJldmlvdXMsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlTaGlmdFN0YXJ0ID0gYmluYXJ5U2hpZnRTdGFydDtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPSBiaW5hcnlTaGlmdEJ5dGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQE92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRUbyhiaXRBcnJheSwgdGV4dCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCAoaSA9PT0gMzEgJiYgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCA8PSA2MikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCBhIGhlYWRlciBiZWZvcmUgdGhlIGZpcnN0IGNoYXJhY3RlciwgYW5kIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgMzEgd2hlbiB0aGUgdG90YWwgYnl0ZSBjb2RlIGlzIDw9IDYyXG4gICAgICAgICAgICAgICAgICAgIGJpdEFycmF5LmFwcGVuZEJpdHMoMzEsIDUpOyAvLyBCSU5BUllfU0hJRlRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPiA2Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYml0QXJyYXkuYXBwZW5kQml0cyh0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50IC0gMzEsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAxIDw9IGJpbmFyeVNoaWZ0Qnl0ZUNvZGUgPD0gNjJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdEFycmF5LmFwcGVuZEJpdHMoTWF0aC5taW4odGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCwgMzEpLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMyIDw9IGJpbmFyeVNoaWZ0Q291bnQgPD0gNjIgYW5kIGkgPT0gMzFcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdEFycmF5LmFwcGVuZEJpdHModGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCAtIDMxLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiaXRBcnJheS5hcHBlbmRCaXRzKHRleHRbdGhpcy5iaW5hcnlTaGlmdFN0YXJ0ICsgaV0sIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZEJpbmFyeVNoaWZ0KHN0YXJ0LCBieXRlQ291bnQpIHtcbiAgICAgICAgICAgIC8vIGludCBiaXRDb3VudCA9IChieXRlQ291bnQgKiA4KSArIChieXRlQ291bnQgPD0gMzEgPyAxMCA6IGJ5dGVDb3VudCA8PSA2MiA/IDIwIDogMjEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlTaGlmdFRva2VuKHRoaXMsIHN0YXJ0LCBieXRlQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAT3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICc8JyArIHRoaXMuYmluYXJ5U2hpZnRTdGFydCArICc6OicgKyAodGhpcy5iaW5hcnlTaGlmdFN0YXJ0ICsgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCAtIDEpICsgJz4nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQmluYXJ5U2hpZnQodG9rZW4sIHN0YXJ0LCBieXRlQ291bnQpIHtcbiAgICAgICAgLy8gaW50IGJpdENvdW50ID0gKGJ5dGVDb3VudCAqIDgpICsgKGJ5dGVDb3VudCA8PSAzMSA/IDEwIDogYnl0ZUNvdW50IDw9IDYyID8gMjAgOiAyMSk7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5U2hpZnRUb2tlbih0b2tlbiwgc3RhcnQsIGJ5dGVDb3VudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZCh0b2tlbiwgdmFsdWUsIGJpdENvdW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlVG9rZW4odG9rZW4sIHZhbHVlLCBiaXRDb3VudCk7XG4gICAgfVxuXG4gICAgY29uc3QgLypmaW5hbCovIE1PREVfTkFNRVMgPSBbXG4gICAgICAgICdVUFBFUicsXG4gICAgICAgICdMT1dFUicsXG4gICAgICAgICdESUdJVCcsXG4gICAgICAgICdNSVhFRCcsXG4gICAgICAgICdQVU5DVCdcbiAgICBdO1xuICAgIGNvbnN0IC8qZmluYWwqLyBNT0RFX1VQUEVSID0gMDsgLy8gNSBiaXRzXG4gICAgY29uc3QgLypmaW5hbCovIE1PREVfTE9XRVIgPSAxOyAvLyA1IGJpdHNcbiAgICBjb25zdCAvKmZpbmFsKi8gTU9ERV9ESUdJVCA9IDI7IC8vIDQgYml0c1xuICAgIGNvbnN0IC8qZmluYWwqLyBNT0RFX01JWEVEID0gMzsgLy8gNSBiaXRzXG4gICAgY29uc3QgLypmaW5hbCovIE1PREVfUFVOQ1QgPSA0OyAvLyA1IGJpdHNcbiAgICBjb25zdCBFTVBUWV9UT0tFTiA9IG5ldyBTaW1wbGVUb2tlbihudWxsLCAwLCAwKTtcblxuICAgIC8vIFRoZSBMYXRjaCBUYWJsZSBzaG93cywgZm9yIGVhY2ggcGFpciBvZiBNb2RlcywgdGhlIG9wdGltYWwgbWV0aG9kIGZvclxuICAgIC8vIGdldHRpbmcgZnJvbSBvbmUgbW9kZSB0byBhbm90aGVyLiAgSW4gdGhlIHdvcnN0IHBvc3NpYmxlIGNhc2UsIHRoaXMgY2FuXG4gICAgLy8gYmUgdXAgdG8gMTQgYml0cy4gIEluIHRoZSBiZXN0IHBvc3NpYmxlIGNhc2UsIHdlIGFyZSBhbHJlYWR5IHRoZXJlIVxuICAgIC8vIFRoZSBoaWdoIGhhbGYtd29yZCBvZiBlYWNoIGVudHJ5IGdpdmVzIHRoZSBudW1iZXIgb2YgYml0cy5cbiAgICAvLyBUaGUgbG93IGhhbGYtd29yZCBvZiBlYWNoIGVudHJ5IGFyZSB0aGUgYWN0dWFsIGJpdHMgbmVjZXNzYXJ5IHRvIGNoYW5nZVxuICAgIGNvbnN0IExBVENIX1RBQkxFID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDI4LFxuICAgICAgICAgICAgKDUgPDwgMTYpICsgMzAsXG4gICAgICAgICAgICAoNSA8PCAxNikgKyAyOSxcbiAgICAgICAgICAgICgxMCA8PCAxNikgKyAoMjkgPDwgNSkgKyAzMCAvLyBVUFBFUiAtPiBNSVhFRCAtPiBQVU5DVFxuICAgICAgICBdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgICAgICg5IDw8IDE2KSArICgzMCA8PCA0KSArIDE0LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDMwLFxuICAgICAgICAgICAgKDUgPDwgMTYpICsgMjksXG4gICAgICAgICAgICAoMTAgPDwgMTYpICsgKDI5IDw8IDUpICsgMzAgLy8gTE9XRVIgLT4gTUlYRUQgLT4gUFVOQ1RcbiAgICAgICAgXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgICAgICAoNCA8PCAxNikgKyAxNCxcbiAgICAgICAgICAgICg5IDw8IDE2KSArICgxNCA8PCA1KSArIDI4LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICg5IDw8IDE2KSArICgxNCA8PCA1KSArIDI5LFxuICAgICAgICAgICAgKDE0IDw8IDE2KSArICgxNCA8PCAxMCkgKyAoMjkgPDwgNSkgKyAzMFxuICAgICAgICAgICAgLy8gRElHSVQgLT4gVVBQRVIgLT4gTUlYRUQgLT4gUFVOQ1RcbiAgICAgICAgXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgICAgICAoNSA8PCAxNikgKyAyOSxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDI4LFxuICAgICAgICAgICAgKDEwIDw8IDE2KSArICgyOSA8PCA1KSArIDMwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDMwIC8vIE1JWEVEIC0+IFBVTkNUXG4gICAgICAgIF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAgICAgKDUgPDwgMTYpICsgMzEsXG4gICAgICAgICAgICAoMTAgPDwgMTYpICsgKDMxIDw8IDUpICsgMjgsXG4gICAgICAgICAgICAoMTAgPDwgMTYpICsgKDMxIDw8IDUpICsgMzAsXG4gICAgICAgICAgICAoMTAgPDwgMTYpICsgKDMxIDw8IDUpICsgMjksXG4gICAgICAgICAgICAwXG4gICAgICAgIF0pXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIHN0YXRpY19TSElGVF9UQUJMRShTSElGVF9UQUJMRSkge1xuICAgICAgICBmb3IgKGxldCB0YWJsZSAvKkludDMyQXJyYXkqLyBvZiBTSElGVF9UQUJMRSkge1xuICAgICAgICAgICAgQXJyYXlzLmZpbGwodGFibGUsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBTSElGVF9UQUJMRVtNT0RFX1VQUEVSXVtNT0RFX1BVTkNUXSA9IDA7XG4gICAgICAgIFNISUZUX1RBQkxFW01PREVfTE9XRVJdW01PREVfUFVOQ1RdID0gMDtcbiAgICAgICAgU0hJRlRfVEFCTEVbTU9ERV9MT1dFUl1bTU9ERV9VUFBFUl0gPSAyODtcbiAgICAgICAgU0hJRlRfVEFCTEVbTU9ERV9NSVhFRF1bTU9ERV9QVU5DVF0gPSAwO1xuICAgICAgICBTSElGVF9UQUJMRVtNT0RFX0RJR0lUXVtNT0RFX1BVTkNUXSA9IDA7XG4gICAgICAgIFNISUZUX1RBQkxFW01PREVfRElHSVRdW01PREVfVVBQRVJdID0gMTU7XG4gICAgICAgIHJldHVybiBTSElGVF9UQUJMRTtcbiAgICB9XG4gICAgY29uc3QgLypmaW5hbCovIFNISUZUX1RBQkxFID0gc3RhdGljX1NISUZUX1RBQkxFKEFycmF5cy5jcmVhdGVJbnQzMkFycmF5KDYsIDYpKTsgLy8gbW9kZSBzaGlmdCBjb2RlcywgcGVyIHRhYmxlXG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFN0YXRlIHJlcHJlc2VudHMgYWxsIGluZm9ybWF0aW9uIGFib3V0IGEgc2VxdWVuY2UgbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRoZSBjdXJyZW50IG91dHB1dC5cbiAgICAgKiBOb3RlIHRoYXQgYSBzdGF0ZSBpcyBpbW11dGFibGUuXG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIFN0YXRlIHtcbiAgICAgICAgY29uc3RydWN0b3IodG9rZW4sIG1vZGUsIGJpbmFyeUJ5dGVzLCBiaXRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPSBiaW5hcnlCeXRlcztcbiAgICAgICAgICAgIHRoaXMuYml0Q291bnQgPSBiaXRDb3VudDtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBtYXRjaCB0aGUgdG9rZW5cbiAgICAgICAgICAgIC8vIGludCBiaW5hcnlTaGlmdEJpdENvdW50ID0gKGJpbmFyeVNoaWZ0Qnl0ZUNvdW50ICogOCkgK1xuICAgICAgICAgICAgLy8gICAgKGJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSAwID8gMCA6XG4gICAgICAgICAgICAvLyAgICAgYmluYXJ5U2hpZnRCeXRlQ291bnQgPD0gMzEgPyAxMCA6XG4gICAgICAgICAgICAvLyAgICAgYmluYXJ5U2hpZnRCeXRlQ291bnQgPD0gNjIgPyAyMCA6IDIxKTtcbiAgICAgICAgICAgIC8vIGFzc2VydCB0aGlzLmJpdENvdW50ID09PSB0b2tlbi5nZXRUb3RhbEJpdENvdW50KCkgKyBiaW5hcnlTaGlmdEJpdENvdW50O1xuICAgICAgICB9XG4gICAgICAgIGdldE1vZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlO1xuICAgICAgICB9XG4gICAgICAgIGdldFRva2VuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QmluYXJ5U2hpZnRCeXRlQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXRCaXRDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpdENvdW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdGF0ZSByZXByZXNlbnRpbmcgdGhpcyBzdGF0ZSB3aXRoIGEgbGF0Y2ggdG8gYSAobm90XG4gICAgICAgIC8vIG5lY2Vzc2FyeSBkaWZmZXJlbnQpIG1vZGUsIGFuZCB0aGVuIGEgY29kZS5cbiAgICAgICAgbGF0Y2hBbmRBcHBlbmQobW9kZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGFzc2VydCBiaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gMDtcbiAgICAgICAgICAgIGxldCBiaXRDb3VudCA9IHRoaXMuYml0Q291bnQ7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICAgICAgaWYgKG1vZGUgIT09IHRoaXMubW9kZSkge1xuICAgICAgICAgICAgICAgIGxldCBsYXRjaCA9IExBVENIX1RBQkxFW3RoaXMubW9kZV1bbW9kZV07XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBhZGQodG9rZW4sIGxhdGNoICYgMHhmZmZmLCBsYXRjaCA+PiAxNik7XG4gICAgICAgICAgICAgICAgYml0Q291bnQgKz0gbGF0Y2ggPj4gMTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGF0Y2hNb2RlQml0Q291bnQgPSBtb2RlID09PSBNT0RFX0RJR0lUID8gNCA6IDU7XG4gICAgICAgICAgICB0b2tlbiA9IGFkZCh0b2tlbiwgdmFsdWUsIGxhdGNoTW9kZUJpdENvdW50KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhdGUodG9rZW4sIG1vZGUsIDAsIGJpdENvdW50ICsgbGF0Y2hNb2RlQml0Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdGF0ZSByZXByZXNlbnRpbmcgdGhpcyBzdGF0ZSwgd2l0aCBhIHRlbXBvcmFyeSBzaGlmdFxuICAgICAgICAvLyB0byBhIGRpZmZlcmVudCBtb2RlIHRvIG91dHB1dCBhIHNpbmdsZSB2YWx1ZS5cbiAgICAgICAgc2hpZnRBbmRBcHBlbmQobW9kZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGFzc2VydCBiaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gMCAmJiB0aGlzLm1vZGUgIT09IG1vZGU7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICAgICAgbGV0IHRoaXNNb2RlQml0Q291bnQgPSB0aGlzLm1vZGUgPT09IE1PREVfRElHSVQgPyA0IDogNTtcbiAgICAgICAgICAgIC8vIFNoaWZ0cyBleGlzdCBvbmx5IHRvIFVQUEVSIGFuZCBQVU5DVCwgYm90aCB3aXRoIHRva2VucyBzaXplIDUuXG4gICAgICAgICAgICB0b2tlbiA9IGFkZCh0b2tlbiwgU0hJRlRfVEFCTEVbdGhpcy5tb2RlXVttb2RlXSwgdGhpc01vZGVCaXRDb3VudCk7XG4gICAgICAgICAgICB0b2tlbiA9IGFkZCh0b2tlbiwgdmFsdWUsIDUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZSh0b2tlbiwgdGhpcy5tb2RlLCAwLCB0aGlzLmJpdENvdW50ICsgdGhpc01vZGVCaXRDb3VudCArIDUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdGF0ZSByZXByZXNlbnRpbmcgdGhpcyBzdGF0ZSwgYnV0IGFuIGFkZGl0aW9uYWwgY2hhcmFjdGVyXG4gICAgICAgIC8vIG91dHB1dCBpbiBCaW5hcnkgU2hpZnQgbW9kZS5cbiAgICAgICAgYWRkQmluYXJ5U2hpZnRDaGFyKGluZGV4KSB7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICAgICAgbGV0IG1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICAgICAgICBsZXQgYml0Q291bnQgPSB0aGlzLmJpdENvdW50O1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gTU9ERV9QVU5DVCB8fCB0aGlzLm1vZGUgPT09IE1PREVfRElHSVQpIHtcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQgYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDA7XG4gICAgICAgICAgICAgICAgbGV0IGxhdGNoID0gTEFUQ0hfVEFCTEVbbW9kZV1bTU9ERV9VUFBFUl07XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBhZGQodG9rZW4sIGxhdGNoICYgMHhmZmZmLCBsYXRjaCA+PiAxNik7XG4gICAgICAgICAgICAgICAgYml0Q291bnQgKz0gbGF0Y2ggPj4gMTY7XG4gICAgICAgICAgICAgICAgbW9kZSA9IE1PREVfVVBQRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGVsdGFCaXRDb3VudCA9IHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDAgfHwgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gMzFcbiAgICAgICAgICAgICAgICA/IDE4XG4gICAgICAgICAgICAgICAgOiB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSA2MlxuICAgICAgICAgICAgICAgICAgICA/IDlcbiAgICAgICAgICAgICAgICAgICAgOiA4O1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTdGF0ZSh0b2tlbiwgbW9kZSwgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCArIDEsIGJpdENvdW50ICsgZGVsdGFCaXRDb3VudCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSAyMDQ3ICsgMzEpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc3RyaW5nIGlzIGFzIGxvbmcgYXMgaXQncyBhbGxvd2VkIHRvIGJlLiAgV2Ugc2hvdWxkIGVuZCBpdC5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZW5kQmluYXJ5U2hpZnQoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBzdGF0ZSBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3ZSBhcmUgbm8gbG9uZ2VyIGluXG4gICAgICAgIC8vIEJpbmFyeSBTaGlmdCBtb2RlLlxuICAgICAgICBlbmRCaW5hcnlTaGlmdChpbmRleCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b2tlbiA9IHRoaXMudG9rZW47XG4gICAgICAgICAgICB0b2tlbiA9IGFkZEJpbmFyeVNoaWZ0KHRva2VuLCBpbmRleCAtIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQsIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0IHRva2VuLmdldFRvdGFsQml0Q291bnQoKSA9PT0gdGhpcy5iaXRDb3VudDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhdGUodG9rZW4sIHRoaXMubW9kZSwgMCwgdGhpcy5iaXRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIFwidGhpc1wiIHN0YXRlIGlzIGJldHRlciAoZXF1YWw6IG9yKSB0byBiZSBpbiB0aGFuIFwidGhhdFwiXG4gICAgICAgIC8vIHN0YXRlIHVuZGVyIGFsbCBwb3NzaWJsZSBjaXJjdW1zdGFuY2VzLlxuICAgICAgICBpc0JldHRlclRoYW5PckVxdWFsVG8ob3RoZXIpIHtcbiAgICAgICAgICAgIGxldCBuZXdNb2RlQml0Q291bnQgPSB0aGlzLmJpdENvdW50ICsgKExBVENIX1RBQkxFW3RoaXMubW9kZV1bb3RoZXIubW9kZV0gPj4gMTYpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPCBvdGhlci5iaW5hcnlTaGlmdEJ5dGVDb3VudCkge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBhZGRpdGlvbmFsIEIvUyBlbmNvZGluZyBjb3N0IG9mIG90aGVyLCBpZiBhbnlcbiAgICAgICAgICAgICAgICBuZXdNb2RlQml0Q291bnQgKz1cbiAgICAgICAgICAgICAgICAgICAgU3RhdGUuY2FsY3VsYXRlQmluYXJ5U2hpZnRDb3N0KG90aGVyKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICBTdGF0ZS5jYWxjdWxhdGVCaW5hcnlTaGlmdENvc3QodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID4gb3RoZXIuYmluYXJ5U2hpZnRCeXRlQ291bnQgJiZcbiAgICAgICAgICAgICAgICBvdGhlci5iaW5hcnlTaGlmdEJ5dGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBtYXhpbXVtIHBvc3NpYmxlIGFkZGl0aW9uYWwgY29zdCAoaXQ6IGgpXG4gICAgICAgICAgICAgICAgbmV3TW9kZUJpdENvdW50ICs9IDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld01vZGVCaXRDb3VudCA8PSBvdGhlci5iaXRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICB0b0JpdEFycmF5KHRleHQpIHtcbiAgICAgICAgICAgIC8vIFJldmVyc2UgdGhlIHRva2Vucywgc28gdGhhdCB0aGV5IGFyZSBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZFxuICAgICAgICAgICAgLy8gYmUgb3V0cHV0XG4gICAgICAgICAgICBsZXQgc3ltYm9scyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9rZW4gPSB0aGlzLmVuZEJpbmFyeVNoaWZ0KHRleHQubGVuZ3RoKS50b2tlbjsgdG9rZW4gIT09IG51bGw7IHRva2VuID0gdG9rZW4uZ2V0UHJldmlvdXMoKSkge1xuICAgICAgICAgICAgICAgIHN5bWJvbHMudW5zaGlmdCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYml0QXJyYXkgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIC8vIEFkZCBlYWNoIHRva2VuIHRvIHRoZSByZXN1bHQuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN5bWJvbCBvZiBzeW1ib2xzKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sLmFwcGVuZFRvKGJpdEFycmF5LCB0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFzc2VydCBiaXRBcnJheS5nZXRTaXplKCkgPT09IHRoaXMuYml0Q291bnQ7XG4gICAgICAgICAgICByZXR1cm4gYml0QXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBPdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuZm9ybWF0KCclcyBiaXRzPSVkIGJ5dGVzPSVkJywgTU9ERV9OQU1FU1t0aGlzLm1vZGVdLCB0aGlzLmJpdENvdW50LCB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlQmluYXJ5U2hpZnRDb3N0KHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYmluYXJ5U2hpZnRCeXRlQ291bnQgPiA2Mikge1xuICAgICAgICAgICAgICAgIHJldHVybiAyMTsgLy8gQi9TIHdpdGggZXh0ZW5kZWQgbGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuYmluYXJ5U2hpZnRCeXRlQ291bnQgPiAzMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyMDsgLy8gdHdvIEIvU1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxMDsgLy8gb25lIEIvU1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU3RhdGUuSU5JVElBTF9TVEFURSA9IG5ldyBTdGF0ZShFTVBUWV9UT0tFTiwgTU9ERV9VUFBFUiwgMCwgMCk7XG5cbiAgICBmdW5jdGlvbiBzdGF0aWNfQ0hBUl9NQVAoQ0hBUl9NQVApIHtcbiAgICAgICAgY29uc3Qgc3BhY2VDaGFyQ29kZSA9IFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCcgJyk7XG4gICAgICAgIGNvbnN0IHBvaW50Q2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnLicpO1xuICAgICAgICBjb25zdCBjb21tYUNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJywnKTtcbiAgICAgICAgQ0hBUl9NQVBbTU9ERV9VUFBFUl1bc3BhY2VDaGFyQ29kZV0gPSAxO1xuICAgICAgICBjb25zdCB6VXBwZXJDaGFyQ29kZSA9IFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCdaJyk7XG4gICAgICAgIGNvbnN0IGFVcHBlckNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJ0EnKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IGFVcHBlckNoYXJDb2RlOyBjIDw9IHpVcHBlckNoYXJDb2RlOyBjKyspIHtcbiAgICAgICAgICAgIENIQVJfTUFQW01PREVfVVBQRVJdW2NdID0gYyAtIGFVcHBlckNoYXJDb2RlICsgMjtcbiAgICAgICAgfVxuICAgICAgICBDSEFSX01BUFtNT0RFX0xPV0VSXVtzcGFjZUNoYXJDb2RlXSA9IDE7XG4gICAgICAgIGNvbnN0IHpMb3dlckNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJ3onKTtcbiAgICAgICAgY29uc3QgYUxvd2VyQ2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnYScpO1xuICAgICAgICBmb3IgKGxldCBjID0gYUxvd2VyQ2hhckNvZGU7IGMgPD0gekxvd2VyQ2hhckNvZGU7IGMrKykge1xuICAgICAgICAgICAgQ0hBUl9NQVBbTU9ERV9MT1dFUl1bY10gPSBjIC0gYUxvd2VyQ2hhckNvZGUgKyAyO1xuICAgICAgICB9XG4gICAgICAgIENIQVJfTUFQW01PREVfRElHSVRdW3NwYWNlQ2hhckNvZGVdID0gMTtcbiAgICAgICAgY29uc3QgbmluZUNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJzknKTtcbiAgICAgICAgY29uc3QgemVyb0NoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJzAnKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IHplcm9DaGFyQ29kZTsgYyA8PSBuaW5lQ2hhckNvZGU7IGMrKykge1xuICAgICAgICAgICAgQ0hBUl9NQVBbTU9ERV9ESUdJVF1bY10gPSBjIC0gemVyb0NoYXJDb2RlICsgMjtcbiAgICAgICAgfVxuICAgICAgICBDSEFSX01BUFtNT0RFX0RJR0lUXVtjb21tYUNoYXJDb2RlXSA9IDEyO1xuICAgICAgICBDSEFSX01BUFtNT0RFX0RJR0lUXVtwb2ludENoYXJDb2RlXSA9IDEzO1xuICAgICAgICBjb25zdCBtaXhlZFRhYmxlID0gW1xuICAgICAgICAgICAgJ1xceDAwJyxcbiAgICAgICAgICAgICcgJyxcbiAgICAgICAgICAgICdcXHgwMScsXG4gICAgICAgICAgICAnXFx4MDInLFxuICAgICAgICAgICAgJ1xceDAzJyxcbiAgICAgICAgICAgICdcXHgwNCcsXG4gICAgICAgICAgICAnXFx4MDUnLFxuICAgICAgICAgICAgJ1xceDA2JyxcbiAgICAgICAgICAgICdcXHgwNycsXG4gICAgICAgICAgICAnXFxiJyxcbiAgICAgICAgICAgICdcXHQnLFxuICAgICAgICAgICAgJ1xcbicsXG4gICAgICAgICAgICAnXFx4MGInLFxuICAgICAgICAgICAgJ1xcZicsXG4gICAgICAgICAgICAnXFxyJyxcbiAgICAgICAgICAgICdcXHgxYicsXG4gICAgICAgICAgICAnXFx4MWMnLFxuICAgICAgICAgICAgJ1xceDFkJyxcbiAgICAgICAgICAgICdcXHgxZScsXG4gICAgICAgICAgICAnXFx4MWYnLFxuICAgICAgICAgICAgJ0AnLFxuICAgICAgICAgICAgJ1xcXFwnLFxuICAgICAgICAgICAgJ14nLFxuICAgICAgICAgICAgJ18nLFxuICAgICAgICAgICAgJ2AnLFxuICAgICAgICAgICAgJ3wnLFxuICAgICAgICAgICAgJ34nLFxuICAgICAgICAgICAgJ1xceDdmJ1xuICAgICAgICBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1peGVkVGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIENIQVJfTUFQW01PREVfTUlYRURdW1N0cmluZ1V0aWxzLmdldENoYXJDb2RlKG1peGVkVGFibGVbaV0pXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVuY3RUYWJsZSA9IFtcbiAgICAgICAgICAgICdcXHgwMCcsXG4gICAgICAgICAgICAnXFxyJyxcbiAgICAgICAgICAgICdcXHgwMCcsXG4gICAgICAgICAgICAnXFx4MDAnLFxuICAgICAgICAgICAgJ1xceDAwJyxcbiAgICAgICAgICAgICdcXHgwMCcsXG4gICAgICAgICAgICAnIScsXG4gICAgICAgICAgICAnXFwnJyxcbiAgICAgICAgICAgICcjJyxcbiAgICAgICAgICAgICckJyxcbiAgICAgICAgICAgICclJyxcbiAgICAgICAgICAgICcmJyxcbiAgICAgICAgICAgICdcXCcnLFxuICAgICAgICAgICAgJygnLFxuICAgICAgICAgICAgJyknLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJysnLFxuICAgICAgICAgICAgJywnLFxuICAgICAgICAgICAgJy0nLFxuICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgJy8nLFxuICAgICAgICAgICAgJzonLFxuICAgICAgICAgICAgJzsnLFxuICAgICAgICAgICAgJzwnLFxuICAgICAgICAgICAgJz0nLFxuICAgICAgICAgICAgJz4nLFxuICAgICAgICAgICAgJz8nLFxuICAgICAgICAgICAgJ1snLFxuICAgICAgICAgICAgJ10nLFxuICAgICAgICAgICAgJ3snLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVuY3RUYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKHB1bmN0VGFibGVbaV0pID4gMCkge1xuICAgICAgICAgICAgICAgIENIQVJfTUFQW01PREVfUFVOQ1RdW1N0cmluZ1V0aWxzLmdldENoYXJDb2RlKHB1bmN0VGFibGVbaV0pXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENIQVJfTUFQO1xuICAgIH1cbiAgICBjb25zdCBDSEFSX01BUCA9IHN0YXRpY19DSEFSX01BUChBcnJheXMuY3JlYXRlSW50MzJBcnJheSg1LCAyNTYpKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBwcm9kdWNlcyBuZWFybHkgb3B0aW1hbCBlbmNvZGluZ3Mgb2YgdGV4dCBpbnRvIHRoZSBmaXJzdC1sZXZlbCBvZlxuICAgICAqIGVuY29kaW5nIHVzZWQgYnkgQXp0ZWMgY29kZS5cbiAgICAgKlxuICAgICAqIEl0IHVzZXMgYSBkeW5hbWljIGFsZ29yaXRobS4gIEZvciBlYWNoIHByZWZpeCBvZiB0aGUgc3RyaW5nLCBpdCBkZXRlcm1pbmVzXG4gICAgICogYSBzZXQgb2YgZW5jb2RpbmdzIHRoYXQgY291bGQgbGVhZCB0byB0aGlzIHByZWZpeC4gIFdlIHJlcGVhdGVkbHkgYWRkIGFcbiAgICAgKiBjaGFyYWN0ZXIgYW5kIGdlbmVyYXRlIGEgbmV3IHNldCBvZiBvcHRpbWFsIGVuY29kaW5ncyB1bnRpbCB3ZSBoYXZlIHJlYWRcbiAgICAgKiB0aHJvdWdoIHRoZSBlbnRpcmUgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIEZyYW5rIFllbGxpblxuICAgICAqIEBhdXRob3IgUnVzdGFtIEFiZHVsbGFldlxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgSGlnaExldmVsRW5jb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdGV4dCByZXByZXNlbnRlZCBieSB0aGlzIGVuY29kZXIgZW5jb2RlZCBhcyBhIHtAbGluayBCaXRBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGVuY29kZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNlQ2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnICcpO1xuICAgICAgICAgICAgY29uc3QgbGluZUJyZWFrQ2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnXFxuJyk7XG4gICAgICAgICAgICBsZXQgc3RhdGVzID0gQ29sbGVjdGlvbnMuc2luZ2xldG9uTGlzdChTdGF0ZS5JTklUSUFMX1NUQVRFKTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnRleHQubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhaXJDb2RlO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0Q2hhciA9IGluZGV4ICsgMSA8IHRoaXMudGV4dC5sZW5ndGggPyB0aGlzLnRleHRbaW5kZXggKyAxXSA6IDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnRleHRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJ1xccicpOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckNvZGUgPSBuZXh0Q2hhciA9PT0gbGluZUJyZWFrQ2hhckNvZGUgPyAyIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCcuJyk6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyQ29kZSA9IG5leHRDaGFyID09PSBzcGFjZUNoYXJDb2RlID8gMyA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnLCcpOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckNvZGUgPSBuZXh0Q2hhciA9PT0gc3BhY2VDaGFyQ29kZSA/IDQgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJzonKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJDb2RlID0gbmV4dENoYXIgPT09IHNwYWNlQ2hhckNvZGUgPyA1IDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckNvZGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFpckNvZGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgb25lIG9mIHRoZSBmb3VyIHNwZWNpYWwgUFVOQ1QgcGFpcnMuICBUcmVhdCB0aGVtIHNwZWNpYWxseS5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGEgbmV3IHNldCBvZiBzdGF0ZXMgZm9yIHRoZSB0d28gbmV3IGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcyA9IEhpZ2hMZXZlbEVuY29kZXIudXBkYXRlU3RhdGVMaXN0Rm9yUGFpcihzdGF0ZXMsIGluZGV4LCBwYWlyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBuZXcgc2V0IG9mIHN0YXRlcyBmb3IgdGhlIG5ldyBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcyA9IHRoaXMudXBkYXRlU3RhdGVMaXN0Rm9yQ2hhcihzdGF0ZXMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBhcmUgbGVmdCB3aXRoIGEgc2V0IG9mIHN0YXRlcy4gIEZpbmQgdGhlIHNob3J0ZXN0IG9uZS5cbiAgICAgICAgICAgIGNvbnN0IG1pblN0YXRlID0gQ29sbGVjdGlvbnMubWluKHN0YXRlcywgKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5nZXRCaXRDb3VudCgpIC0gYi5nZXRCaXRDb3VudCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGl0IHRvIGEgYml0IGFycmF5LCBhbmQgcmV0dXJuLlxuICAgICAgICAgICAgcmV0dXJuIG1pblN0YXRlLnRvQml0QXJyYXkodGhpcy50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSB1cGRhdGUgYSBzZXQgb2Ygc3RhdGVzIGZvciBhIG5ldyBjaGFyYWN0ZXIgYnkgdXBkYXRpbmcgZWFjaCBzdGF0ZVxuICAgICAgICAvLyBmb3IgdGhlIG5ldyBjaGFyYWN0ZXIsIG1lcmdpbmcgdGhlIHJlc3VsdHMsIGFuZCB0aGVuIHJlbW92aW5nIHRoZVxuICAgICAgICAvLyBub24tb3B0aW1hbCBzdGF0ZXMuXG4gICAgICAgIHVwZGF0ZVN0YXRlTGlzdEZvckNoYXIoc3RhdGVzLCBpbmRleCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBzdGF0ZSAvKlN0YXRlKi8gb2Ygc3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUZvckNoYXIoc3RhdGUsIGluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEhpZ2hMZXZlbEVuY29kZXIuc2ltcGxpZnlTdGF0ZXMocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gYSBzZXQgb2Ygc3RhdGVzIHRoYXQgcmVwcmVzZW50IHRoZSBwb3NzaWJsZSB3YXlzIG9mIHVwZGF0aW5nIHRoaXNcbiAgICAgICAgLy8gc3RhdGUgZm9yIHRoZSBuZXh0IGNoYXJhY3Rlci4gIFRoZSByZXN1bHRpbmcgc2V0IG9mIHN0YXRlcyBhcmUgYWRkZWQgdG9cbiAgICAgICAgLy8gdGhlIFwicmVzdWx0XCIgbGlzdC5cbiAgICAgICAgdXBkYXRlU3RhdGVGb3JDaGFyKHN0YXRlLCBpbmRleCwgcmVzdWx0KSB7XG4gICAgICAgICAgICBsZXQgY2ggPSAodGhpcy50ZXh0W2luZGV4XSAmIDB4ZmYpO1xuICAgICAgICAgICAgbGV0IGNoYXJJbkN1cnJlbnRUYWJsZSA9IENIQVJfTUFQW3N0YXRlLmdldE1vZGUoKV1bY2hdID4gMDtcbiAgICAgICAgICAgIGxldCBzdGF0ZU5vQmluYXJ5ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IG1vZGUgLyppbnQqLyA9IDA7IG1vZGUgPD0gTU9ERV9QVU5DVDsgbW9kZSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoYXJJbk1vZGUgPSBDSEFSX01BUFttb2RlXVtjaF07XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJJbk1vZGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZU5vQmluYXJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgY3JlYXRlIHN0YXRlTm9CaW5hcnkgdGhlIGZpcnN0IHRpbWUgaXQncyByZXF1aXJlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTm9CaW5hcnkgPSBzdGF0ZS5lbmRCaW5hcnlTaGlmdChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGdlbmVyYXRpbmcgdGhlIGNoYXJhY3RlciBieSBsYXRjaGluZyB0byBpdHMgbW9kZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoYXJJbkN1cnJlbnRUYWJsZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PT0gc3RhdGUuZ2V0TW9kZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09PSBNT0RFX0RJR0lUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGluIHRoZSBjdXJyZW50IHRhYmxlLCB3ZSBkb24ndCB3YW50IHRvIGxhdGNoIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbnkgb3RoZXIgbW9kZSBleGNlcHQgcG9zc2libHkgZGlnaXQgKHdoaWNoIHVzZXMgb25seSA0IGJpdHMpLiAgQW55XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciBsYXRjaCB3b3VsZCBiZSBlcXVhbGx5IHN1Y2Nlc3NmdWwgKmFmdGVyKiB0aGlzIGNoYXJhY3RlciwgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3b3VsZG4ndCBzYXZlIGFueSBiaXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0Y2hTdGF0ZSA9IHN0YXRlTm9CaW5hcnkubGF0Y2hBbmRBcHBlbmQobW9kZSwgY2hhckluTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYXRjaFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgZ2VuZXJhdGluZyB0aGUgY2hhcmFjdGVyIGJ5IHN3aXRjaGluZyB0byBpdHMgbW9kZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGFySW5DdXJyZW50VGFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFNISUZUX1RBQkxFW3N0YXRlLmdldE1vZGUoKV1bbW9kZV0gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQgbmV2ZXIgbWFrZXMgc2Vuc2UgdG8gdGVtcG9yYXJpbHkgc2hpZnQgdG8gYW5vdGhlciBtb2RlIGlmIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyIGV4aXN0cyBpbiB0aGUgY3VycmVudCBtb2RlLiAgVGhhdCBjYW4gbmV2ZXIgc2F2ZSBiaXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hpZnRTdGF0ZSA9IHN0YXRlTm9CaW5hcnkuc2hpZnRBbmRBcHBlbmQobW9kZSwgY2hhckluTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzaGlmdFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5nZXRCaW5hcnlTaGlmdEJ5dGVDb3VudCgpID4gMCB8fFxuICAgICAgICAgICAgICAgIENIQVJfTUFQW3N0YXRlLmdldE1vZGUoKV1bY2hdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBuZXZlciB3b3J0aHdoaWxlIHRvIGdvIGludG8gYmluYXJ5IHNoaWZ0IG1vZGUgaWYgeW91J3JlIG5vdCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gaW4gYmluYXJ5IHNoaWZ0IG1vZGUsIGFuZCB0aGUgY2hhcmFjdGVyIGV4aXN0cyBpbiB5b3VyIGN1cnJlbnQgbW9kZS5cbiAgICAgICAgICAgICAgICAvLyBUaGF0IGNhbiBuZXZlciBzYXZlIGJpdHMgb3ZlciBqdXN0IG91dHB1dHRpbmcgdGhlIGNoYXIgaW4gdGhlIGN1cnJlbnQgbW9kZS5cbiAgICAgICAgICAgICAgICBsZXQgYmluYXJ5U3RhdGUgPSBzdGF0ZS5hZGRCaW5hcnlTaGlmdENoYXIoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpbmFyeVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgdXBkYXRlU3RhdGVMaXN0Rm9yUGFpcihzdGF0ZXMsIGluZGV4LCBwYWlyQ29kZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBzdGF0ZSAvKlN0YXRlKi8gb2Ygc3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUZvclBhaXIoc3RhdGUsIGluZGV4LCBwYWlyQ29kZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpbXBsaWZ5U3RhdGVzKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHVwZGF0ZVN0YXRlRm9yUGFpcihzdGF0ZSwgaW5kZXgsIHBhaXJDb2RlLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZU5vQmluYXJ5ID0gc3RhdGUuZW5kQmluYXJ5U2hpZnQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gUG9zc2liaWxpdHkgMS4gIExhdGNoIHRvIEMuTU9ERV9QVU5DVCwgYW5kIHRoZW4gYXBwZW5kIHRoaXMgY29kZVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhdGVOb0JpbmFyeS5sYXRjaEFuZEFwcGVuZChNT0RFX1BVTkNULCBwYWlyQ29kZSkpO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmdldE1vZGUoKSAhPT0gTU9ERV9QVU5DVCkge1xuICAgICAgICAgICAgICAgIC8vIFBvc3NpYmlsaXR5IDIuICBTaGlmdCB0byBDLk1PREVfUFVOQ1QsIGFuZCB0aGVuIGFwcGVuZCB0aGlzIGNvZGUuXG4gICAgICAgICAgICAgICAgLy8gRXZlcnkgc3RhdGUgZXhjZXB0IEMuTU9ERV9QVU5DVCAoaGFuZGxlZCBhYm92ZSkgY2FuIHNoaWZ0XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhdGVOb0JpbmFyeS5zaGlmdEFuZEFwcGVuZChNT0RFX1BVTkNULCBwYWlyQ29kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhaXJDb2RlID09PSAzIHx8IHBhaXJDb2RlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gYm90aCBjaGFyYWN0ZXJzIGFyZSBpbiBESUdJVFMuICBTb21ldGltZXMgYmV0dGVyIHRvIGp1c3QgYWRkIHR3byBkaWdpdHNcbiAgICAgICAgICAgICAgICBsZXQgZGlnaXRTdGF0ZSA9IHN0YXRlTm9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgLmxhdGNoQW5kQXBwZW5kKE1PREVfRElHSVQsIDE2IC0gcGFpckNvZGUpIC8vIHBlcmlvZCBvciBjb21tYSBpbiBESUdJVFxuICAgICAgICAgICAgICAgICAgICAubGF0Y2hBbmRBcHBlbmQoTU9ERV9ESUdJVCwgMSk7IC8vIHNwYWNlIGluIERJR0lUXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZGlnaXRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZ2V0QmluYXJ5U2hpZnRCeXRlQ291bnQoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBvbmx5IG1ha2VzIHNlbnNlIHRvIGRvIHRoZSBjaGFyYWN0ZXJzIGFzIGJpbmFyeSBpZiB3ZSdyZSBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gaW4gYmluYXJ5IG1vZGUuXG4gICAgICAgICAgICAgICAgbGV0IGJpbmFyeVN0YXRlID0gc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgLmFkZEJpbmFyeVNoaWZ0Q2hhcihpbmRleClcbiAgICAgICAgICAgICAgICAgICAgLmFkZEJpbmFyeVNoaWZ0Q2hhcihpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpbmFyeVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgc2ltcGxpZnlTdGF0ZXMoc3RhdGVzKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5ld1N0YXRlIG9mIHN0YXRlcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb2xkU3RhdGUgb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTdGF0ZS5pc0JldHRlclRoYW5PckVxdWFsVG8obmV3U3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZS5pc0JldHRlclRoYW5PckVxdWFsVG8ob2xkU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRvci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoeCA9PiB4ICE9PSBvbGRTdGF0ZSk7IC8vIHJlbW92ZSBvbGQgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcuYXp0ZWMuZW5jb2RlcjtcbiAgICAvLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24uQml0QXJyYXk7XG4gICAgLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuY29tbW9uLkJpdE1hdHJpeDtcbiAgICAvLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24ucmVlZHNvbG9tb24uR2VuZXJpY0dGO1xuICAgIC8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5yZWVkc29sb21vbi5SZWVkU29sb21vbkVuY29kZXI7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIEF6dGVjIDJEIGJhcmNvZGVzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBSdXN0YW0gQWJkdWxsYWV2XG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBFbmNvZGVyJDEge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gYmluYXJ5IGNvbnRlbnQgYXMgYW4gQXp0ZWMgc3ltYm9sXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIGlucHV0IGRhdGEgc3RyaW5nXG4gICAgICAgICAqIEByZXR1cm4gQXp0ZWMgc3ltYm9sIG1hdHJpeCB3aXRoIG1ldGFkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZW5jb2RlQnl0ZXMoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIEVuY29kZXIkMS5lbmNvZGUoZGF0YSwgRW5jb2RlciQxLkRFRkFVTFRfRUNfUEVSQ0VOVCwgRW5jb2RlciQxLkRFRkFVTFRfQVpURUNfTEFZRVJTKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gYmluYXJ5IGNvbnRlbnQgYXMgYW4gQXp0ZWMgc3ltYm9sXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIGlucHV0IGRhdGEgc3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSBtaW5FQ0NQZXJjZW50IG1pbmltYWwgcGVyY2VudGFnZSBvZiBlcnJvciBjaGVjayB3b3JkcyAoQWNjb3JkaW5nIHRvIElTTy9JRUMgMjQ3Nzg6MjAwOCxcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgYSBtaW5pbXVtIG9mIDIzJSArIDMgd29yZHMgaXMgcmVjb21tZW5kZWQpXG4gICAgICAgICAqIEBwYXJhbSB1c2VyU3BlY2lmaWVkTGF5ZXJzIGlmIG5vbi16ZXJvLCBhIHVzZXItc3BlY2lmaWVkIHZhbHVlIGZvciB0aGUgbnVtYmVyIG9mIGxheWVyc1xuICAgICAgICAgKiBAcmV0dXJuIEF6dGVjIHN5bWJvbCBtYXRyaXggd2l0aCBtZXRhZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kZShkYXRhLCBtaW5FQ0NQZXJjZW50LCB1c2VyU3BlY2lmaWVkTGF5ZXJzKSB7XG4gICAgICAgICAgICAvLyBIaWdoLWxldmVsIGVuY29kZVxuICAgICAgICAgICAgbGV0IGJpdHMgPSBuZXcgSGlnaExldmVsRW5jb2RlcihkYXRhKS5lbmNvZGUoKTtcbiAgICAgICAgICAgIC8vIHN0dWZmIGJpdHMgYW5kIGNob29zZSBzeW1ib2wgc2l6ZVxuICAgICAgICAgICAgbGV0IGVjY0JpdHMgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24oKGJpdHMuZ2V0U2l6ZSgpICogbWluRUNDUGVyY2VudCksIDEwMCkgKyAxMTtcbiAgICAgICAgICAgIGxldCB0b3RhbFNpemVCaXRzID0gYml0cy5nZXRTaXplKCkgKyBlY2NCaXRzO1xuICAgICAgICAgICAgbGV0IGNvbXBhY3Q7XG4gICAgICAgICAgICBsZXQgbGF5ZXJzO1xuICAgICAgICAgICAgbGV0IHRvdGFsQml0c0luTGF5ZXI7XG4gICAgICAgICAgICBsZXQgd29yZFNpemU7XG4gICAgICAgICAgICBsZXQgc3R1ZmZlZEJpdHM7XG4gICAgICAgICAgICBpZiAodXNlclNwZWNpZmllZExheWVycyAhPT0gRW5jb2RlciQxLkRFRkFVTFRfQVpURUNfTEFZRVJTKSB7XG4gICAgICAgICAgICAgICAgY29tcGFjdCA9IHVzZXJTcGVjaWZpZWRMYXllcnMgPCAwO1xuICAgICAgICAgICAgICAgIGxheWVycyA9IE1hdGguYWJzKHVzZXJTcGVjaWZpZWRMYXllcnMpO1xuICAgICAgICAgICAgICAgIGlmIChsYXllcnMgPiAoY29tcGFjdCA/IEVuY29kZXIkMS5NQVhfTkJfQklUU19DT01QQUNUIDogRW5jb2RlciQxLk1BWF9OQl9CSVRTKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFN0cmluZ1V0aWxzLmZvcm1hdCgnSWxsZWdhbCB2YWx1ZSAlcyBmb3IgbGF5ZXJzJywgdXNlclNwZWNpZmllZExheWVycykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3RhbEJpdHNJbkxheWVyID0gRW5jb2RlciQxLnRvdGFsQml0c0luTGF5ZXIobGF5ZXJzLCBjb21wYWN0KTtcbiAgICAgICAgICAgICAgICB3b3JkU2l6ZSA9IEVuY29kZXIkMS5XT1JEX1NJWkVbbGF5ZXJzXTtcbiAgICAgICAgICAgICAgICBsZXQgdXNhYmxlQml0c0luTGF5ZXJzID0gdG90YWxCaXRzSW5MYXllciAtICh0b3RhbEJpdHNJbkxheWVyICUgd29yZFNpemUpO1xuICAgICAgICAgICAgICAgIHN0dWZmZWRCaXRzID0gRW5jb2RlciQxLnN0dWZmQml0cyhiaXRzLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0dWZmZWRCaXRzLmdldFNpemUoKSArIGVjY0JpdHMgPiB1c2FibGVCaXRzSW5MYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRGF0YSB0byBsYXJnZSBmb3IgdXNlciBzcGVjaWZpZWQgbGF5ZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhY3QgJiYgc3R1ZmZlZEJpdHMuZ2V0U2l6ZSgpID4gd29yZFNpemUgKiA2NCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21wYWN0IGZvcm1hdCBvbmx5IGFsbG93cyA2NCBkYXRhIHdvcmRzLCB0aG91Z2ggQzQgY2FuIGhvbGQgbW9yZSB3b3JkcyB0aGFuIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRGF0YSB0byBsYXJnZSBmb3IgdXNlciBzcGVjaWZpZWQgbGF5ZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3b3JkU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgc3R1ZmZlZEJpdHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIFdlIGxvb2sgYXQgdGhlIHBvc3NpYmxlIHRhYmxlIHNpemVzIGluIHRoZSBvcmRlciBDb21wYWN0MSwgQ29tcGFjdDIsIENvbXBhY3QzLFxuICAgICAgICAgICAgICAgIC8vIENvbXBhY3Q0LCBOb3JtYWw0LC4uLiAgTm9ybWFsKGkpIGZvciBpIDwgNCBpc24ndCB0eXBpY2FsbHkgdXNlZCBzaW5jZSBDb21wYWN0KGkrMSlcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGUgc2FtZSBzaXplLCBidXQgaGFzIG1vcmUgZGF0YS5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gRW5jb2RlciQxLk1BWF9OQl9CSVRTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdEYXRhIHRvbyBsYXJnZSBmb3IgYW4gQXp0ZWMgY29kZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3QgPSBpIDw9IDM7XG4gICAgICAgICAgICAgICAgICAgIGxheWVycyA9IGNvbXBhY3QgPyBpICsgMSA6IGk7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsQml0c0luTGF5ZXIgPSBFbmNvZGVyJDEudG90YWxCaXRzSW5MYXllcihsYXllcnMsIGNvbXBhY3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxTaXplQml0cyA+IHRvdGFsQml0c0luTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFtSZV1zdHVmZiB0aGUgYml0cyBpZiB0aGlzIGlzIHRoZSBmaXJzdCBvcHBvcnR1bml0eSwgb3IgaWYgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvcmRTaXplIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHVmZmVkQml0cyA9PSBudWxsIHx8IHdvcmRTaXplICE9PSBFbmNvZGVyJDEuV09SRF9TSVpFW2xheWVyc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRTaXplID0gRW5jb2RlciQxLldPUkRfU0laRVtsYXllcnNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R1ZmZlZEJpdHMgPSBFbmNvZGVyJDEuc3R1ZmZCaXRzKGJpdHMsIHdvcmRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdXNhYmxlQml0c0luTGF5ZXJzID0gdG90YWxCaXRzSW5MYXllciAtICh0b3RhbEJpdHNJbkxheWVyICUgd29yZFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFjdCAmJiBzdHVmZmVkQml0cy5nZXRTaXplKCkgPiB3b3JkU2l6ZSAqIDY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wYWN0IGZvcm1hdCBvbmx5IGFsbG93cyA2NCBkYXRhIHdvcmRzLCB0aG91Z2ggQzQgY2FuIGhvbGQgbW9yZSB3b3JkcyB0aGFuIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHVmZmVkQml0cy5nZXRTaXplKCkgKyBlY2NCaXRzIDw9IHVzYWJsZUJpdHNJbkxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWVzc2FnZUJpdHMgPSBFbmNvZGVyJDEuZ2VuZXJhdGVDaGVja1dvcmRzKHN0dWZmZWRCaXRzLCB0b3RhbEJpdHNJbkxheWVyLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBtb2RlIG1lc3NhZ2VcbiAgICAgICAgICAgIGxldCBtZXNzYWdlU2l6ZUluV29yZHMgPSBzdHVmZmVkQml0cy5nZXRTaXplKCkgLyB3b3JkU2l6ZTtcbiAgICAgICAgICAgIGxldCBtb2RlTWVzc2FnZSA9IEVuY29kZXIkMS5nZW5lcmF0ZU1vZGVNZXNzYWdlKGNvbXBhY3QsIGxheWVycywgbWVzc2FnZVNpemVJbldvcmRzKTtcbiAgICAgICAgICAgIC8vIGFsbG9jYXRlIHN5bWJvbFxuICAgICAgICAgICAgbGV0IGJhc2VNYXRyaXhTaXplID0gKGNvbXBhY3QgPyAxMSA6IDE0KSArIGxheWVycyAqIDQ7IC8vIG5vdCBpbmNsdWRpbmcgYWxpZ25tZW50IGxpbmVzXG4gICAgICAgICAgICBsZXQgYWxpZ25tZW50TWFwID0gbmV3IEludDMyQXJyYXkoYmFzZU1hdHJpeFNpemUpO1xuICAgICAgICAgICAgbGV0IG1hdHJpeFNpemU7XG4gICAgICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGFsaWdubWVudCBtYXJrcyBpbiBjb21wYWN0IG1vZGUsIGFsaWdubWVudE1hcCBpcyBhIG5vLW9wXG4gICAgICAgICAgICAgICAgbWF0cml4U2l6ZSA9IGJhc2VNYXRyaXhTaXplO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBhbGlnbm1lbnRNYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50TWFwW2ldID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhTaXplID0gYmFzZU1hdHJpeFNpemUgKyAxICsgMiAqIEludGVnZXIudHJ1bmNEaXZpc2lvbigoSW50ZWdlci50cnVuY0RpdmlzaW9uKGJhc2VNYXRyaXhTaXplLCAyKSAtIDEpLCAxNSk7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdDZW50ZXIgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24oYmFzZU1hdHJpeFNpemUsIDIpO1xuICAgICAgICAgICAgICAgIGxldCBjZW50ZXIgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IG9yaWdDZW50ZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3T2Zmc2V0ID0gaSArIEludGVnZXIudHJ1bmNEaXZpc2lvbihpLCAxNSk7XG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudE1hcFtvcmlnQ2VudGVyIC0gaSAtIDFdID0gY2VudGVyIC0gbmV3T2Zmc2V0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50TWFwW29yaWdDZW50ZXIgKyBpXSA9IGNlbnRlciArIG5ld09mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1hdHJpeCA9IG5ldyBCaXRNYXRyaXgobWF0cml4U2l6ZSk7XG4gICAgICAgICAgICAvLyBkcmF3IGRhdGEgYml0c1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMCwgcm93T2Zmc2V0ID0gMDsgaSA8IGxheWVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvd1NpemUgPSAobGF5ZXJzIC0gaSkgKiA0ICsgKGNvbXBhY3QgPyA5IDogMTIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogLyppbnQqLyA9IDA7IGogPCByb3dTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbHVtbk9mZnNldCA9IGogKiAyO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrIC8qaW50Ki8gPSAwOyBrIDwgMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZUJpdHMuZ2V0KHJvd09mZnNldCArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChhbGlnbm1lbnRNYXBbaSAqIDIgKyBrXSwgYWxpZ25tZW50TWFwW2kgKiAyICsgal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VCaXRzLmdldChyb3dPZmZzZXQgKyByb3dTaXplICogMiArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChhbGlnbm1lbnRNYXBbaSAqIDIgKyBqXSwgYWxpZ25tZW50TWFwW2Jhc2VNYXRyaXhTaXplIC0gMSAtIGkgKiAyIC0ga10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VCaXRzLmdldChyb3dPZmZzZXQgKyByb3dTaXplICogNCArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChhbGlnbm1lbnRNYXBbYmFzZU1hdHJpeFNpemUgLSAxIC0gaSAqIDIgLSBrXSwgYWxpZ25tZW50TWFwW2Jhc2VNYXRyaXhTaXplIC0gMSAtIGkgKiAyIC0gal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VCaXRzLmdldChyb3dPZmZzZXQgKyByb3dTaXplICogNiArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChhbGlnbm1lbnRNYXBbYmFzZU1hdHJpeFNpemUgLSAxIC0gaSAqIDIgLSBqXSwgYWxpZ25tZW50TWFwW2kgKiAyICsga10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSByb3dTaXplICogODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRyYXcgbW9kZSBtZXNzYWdlXG4gICAgICAgICAgICBFbmNvZGVyJDEuZHJhd01vZGVNZXNzYWdlKG1hdHJpeCwgY29tcGFjdCwgbWF0cml4U2l6ZSwgbW9kZU1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gZHJhdyBhbGlnbm1lbnQgbWFya3NcbiAgICAgICAgICAgIGlmIChjb21wYWN0KSB7XG4gICAgICAgICAgICAgICAgRW5jb2RlciQxLmRyYXdCdWxsc0V5ZShtYXRyaXgsIEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSwgNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBFbmNvZGVyJDEuZHJhd0J1bGxzRXllKG1hdHJpeCwgSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpLCA3KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwLCBqID0gMDsgaSA8IEludGVnZXIudHJ1bmNEaXZpc2lvbihiYXNlTWF0cml4U2l6ZSwgMikgLSAxOyBpICs9IDE1LCBqICs9IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgLyppbnQqLyA9IEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSAmIDE7IGsgPCBtYXRyaXhTaXplOyBrICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpIC0gaiwgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSArIGosIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChrLCBJbnRlZ2VyLnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMikgLSBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoaywgSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpICsgaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYXp0ZWMgPSBuZXcgQXp0ZWNDb2RlKCk7XG4gICAgICAgICAgICBhenRlYy5zZXRDb21wYWN0KGNvbXBhY3QpO1xuICAgICAgICAgICAgYXp0ZWMuc2V0U2l6ZShtYXRyaXhTaXplKTtcbiAgICAgICAgICAgIGF6dGVjLnNldExheWVycyhsYXllcnMpO1xuICAgICAgICAgICAgYXp0ZWMuc2V0Q29kZVdvcmRzKG1lc3NhZ2VTaXplSW5Xb3Jkcyk7XG4gICAgICAgICAgICBhenRlYy5zZXRNYXRyaXgobWF0cml4KTtcbiAgICAgICAgICAgIHJldHVybiBhenRlYztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZHJhd0J1bGxzRXllKG1hdHJpeCwgY2VudGVyLCBzaXplKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgc2l6ZTsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiAvKmludCovID0gY2VudGVyIC0gaTsgaiA8PSBjZW50ZXIgKyBpOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChqLCBjZW50ZXIgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChqLCBjZW50ZXIgKyBpKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgLSBpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgKyBpLCBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRyaXguc2V0KGNlbnRlciAtIHNpemUsIGNlbnRlciAtIHNpemUpO1xuICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgLSBzaXplICsgMSwgY2VudGVyIC0gc2l6ZSk7XG4gICAgICAgICAgICBtYXRyaXguc2V0KGNlbnRlciAtIHNpemUsIGNlbnRlciAtIHNpemUgKyAxKTtcbiAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgc2l6ZSwgY2VudGVyIC0gc2l6ZSk7XG4gICAgICAgICAgICBtYXRyaXguc2V0KGNlbnRlciArIHNpemUsIGNlbnRlciAtIHNpemUgKyAxKTtcbiAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgc2l6ZSwgY2VudGVyICsgc2l6ZSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZW5lcmF0ZU1vZGVNZXNzYWdlKGNvbXBhY3QsIGxheWVycywgbWVzc2FnZVNpemVJbldvcmRzKSB7XG4gICAgICAgICAgICBsZXQgbW9kZU1lc3NhZ2UgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIGlmIChjb21wYWN0KSB7XG4gICAgICAgICAgICAgICAgbW9kZU1lc3NhZ2UuYXBwZW5kQml0cyhsYXllcnMgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICBtb2RlTWVzc2FnZS5hcHBlbmRCaXRzKG1lc3NhZ2VTaXplSW5Xb3JkcyAtIDEsIDYpO1xuICAgICAgICAgICAgICAgIG1vZGVNZXNzYWdlID0gRW5jb2RlciQxLmdlbmVyYXRlQ2hlY2tXb3Jkcyhtb2RlTWVzc2FnZSwgMjgsIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kZU1lc3NhZ2UuYXBwZW5kQml0cyhsYXllcnMgLSAxLCA1KTtcbiAgICAgICAgICAgICAgICBtb2RlTWVzc2FnZS5hcHBlbmRCaXRzKG1lc3NhZ2VTaXplSW5Xb3JkcyAtIDEsIDExKTtcbiAgICAgICAgICAgICAgICBtb2RlTWVzc2FnZSA9IEVuY29kZXIkMS5nZW5lcmF0ZUNoZWNrV29yZHMobW9kZU1lc3NhZ2UsIDQwLCA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2RlTWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZHJhd01vZGVNZXNzYWdlKG1hdHJpeCwgY29tcGFjdCwgbWF0cml4U2l6ZSwgbW9kZU1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGxldCBjZW50ZXIgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMik7XG4gICAgICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGNlbnRlciAtIDMgKyBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KG9mZnNldCwgY2VudGVyIC0gNSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVNZXNzYWdlLmdldChpICsgNykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgNSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KDIwIC0gaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQob2Zmc2V0LCBjZW50ZXIgKyA1KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KDI3IC0gaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyIC0gNSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBjZW50ZXIgLSA1ICsgaSArIEludGVnZXIudHJ1bmNEaXZpc2lvbihpLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVNZXNzYWdlLmdldChpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChvZmZzZXQsIGNlbnRlciAtIDcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlTWVzc2FnZS5nZXQoaSArIDEwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgKyA3LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlTWVzc2FnZS5nZXQoMjkgLSBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChvZmZzZXQsIGNlbnRlciArIDcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlTWVzc2FnZS5nZXQoMzkgLSBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgLSA3LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZW5lcmF0ZUNoZWNrV29yZHMoYml0QXJyYXksIHRvdGFsQml0cywgd29yZFNpemUpIHtcbiAgICAgICAgICAgIC8vIGJpdEFycmF5IGlzIGd1YXJhbnRlZWQgdG8gYmUgYSBtdWx0aXBsZSBvZiB0aGUgd29yZFNpemUsIHNvIG5vIHBhZGRpbmcgbmVlZGVkXG4gICAgICAgICAgICBsZXQgbWVzc2FnZVNpemVJbldvcmRzID0gYml0QXJyYXkuZ2V0U2l6ZSgpIC8gd29yZFNpemU7XG4gICAgICAgICAgICBsZXQgcnMgPSBuZXcgUmVlZFNvbG9tb25FbmNvZGVyKEVuY29kZXIkMS5nZXRHRih3b3JkU2l6ZSkpO1xuICAgICAgICAgICAgbGV0IHRvdGFsV29yZHMgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24odG90YWxCaXRzLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZVdvcmRzID0gRW5jb2RlciQxLmJpdHNUb1dvcmRzKGJpdEFycmF5LCB3b3JkU2l6ZSwgdG90YWxXb3Jkcyk7XG4gICAgICAgICAgICBycy5lbmNvZGUobWVzc2FnZVdvcmRzLCB0b3RhbFdvcmRzIC0gbWVzc2FnZVNpemVJbldvcmRzKTtcbiAgICAgICAgICAgIGxldCBzdGFydFBhZCA9IHRvdGFsQml0cyAlIHdvcmRTaXplO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VCaXRzID0gbmV3IEJpdEFycmF5KCk7XG4gICAgICAgICAgICBtZXNzYWdlQml0cy5hcHBlbmRCaXRzKDAsIHN0YXJ0UGFkKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZVdvcmQgLyo6IGludCovIG9mIEFycmF5LmZyb20obWVzc2FnZVdvcmRzKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VCaXRzLmFwcGVuZEJpdHMobWVzc2FnZVdvcmQsIHdvcmRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlQml0cztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYml0c1RvV29yZHMoc3R1ZmZlZEJpdHMsIHdvcmRTaXplLCB0b3RhbFdvcmRzKSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IG5ldyBJbnQzMkFycmF5KHRvdGFsV29yZHMpO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBzdHVmZmVkQml0cy5nZXRTaXplKCkgLyB3b3JkU2l6ZTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiAvKmludCovID0gMDsgaiA8IHdvcmRTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgfD0gc3R1ZmZlZEJpdHMuZ2V0KGkgKiB3b3JkU2l6ZSArIGopID8gKDEgPDwgd29yZFNpemUgLSBqIC0gMSkgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXNzYWdlW2ldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0R0Yod29yZFNpemUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAod29yZFNpemUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHZW5lcmljR0YuQVpURUNfUEFSQU07XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2VuZXJpY0dGLkFaVEVDX0RBVEFfNjtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHZW5lcmljR0YuQVpURUNfREFUQV84O1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHZW5lcmljR0YuQVpURUNfREFUQV8xMDtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2VuZXJpY0dGLkFaVEVDX0RBVEFfMTI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgd29yZCBzaXplICcgKyB3b3JkU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHN0dWZmQml0cyhiaXRzLCB3b3JkU2l6ZSkge1xuICAgICAgICAgICAgbGV0IG91dCA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgbGV0IG4gPSBiaXRzLmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCBtYXNrID0gKDEgPDwgd29yZFNpemUpIC0gMjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBuOyBpICs9IHdvcmRTaXplKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdvcmQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogLyppbnQqLyA9IDA7IGogPCB3b3JkU2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgaiA+PSBuIHx8IGJpdHMuZ2V0KGkgKyBqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29yZCB8PSAxIDw8ICh3b3JkU2l6ZSAtIDEgLSBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHdvcmQgJiBtYXNrKSA9PT0gbWFzaykge1xuICAgICAgICAgICAgICAgICAgICBvdXQuYXBwZW5kQml0cyh3b3JkICYgbWFzaywgd29yZFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh3b3JkICYgbWFzaykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmFwcGVuZEJpdHMod29yZCB8IDEsIHdvcmRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmFwcGVuZEJpdHMod29yZCwgd29yZFNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHRvdGFsQml0c0luTGF5ZXIobGF5ZXJzLCBjb21wYWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKChjb21wYWN0ID8gODggOiAxMTIpICsgMTYgKiBsYXllcnMpICogbGF5ZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVuY29kZXIkMS5ERUZBVUxUX0VDX1BFUkNFTlQgPSAzMzsgLy8gZGVmYXVsdCBtaW5pbWFsIHBlcmNlbnRhZ2Ugb2YgZXJyb3IgY2hlY2sgd29yZHNcbiAgICBFbmNvZGVyJDEuREVGQVVMVF9BWlRFQ19MQVlFUlMgPSAwO1xuICAgIEVuY29kZXIkMS5NQVhfTkJfQklUUyA9IDMyO1xuICAgIEVuY29kZXIkMS5NQVhfTkJfQklUU19DT01QQUNUID0gNDtcbiAgICBFbmNvZGVyJDEuV09SRF9TSVpFID0gSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgNCwgNiwgNiwgOCwgOCwgOCwgOCwgOCwgOCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLFxuICAgICAgICAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMlxuICAgIF0pO1xuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiBBenRlYyBjb2RlIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0uXG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBBenRlY1dyaXRlciB7XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBlbmNvZGUoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlV2l0aEhpbnRzKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBlbmNvZGVXaXRoSGludHMoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgaGludHMpIHtcbiAgICAgICAgICAgIGxldCBjaGFyc2V0ID0gU3RhbmRhcmRDaGFyc2V0cy5JU09fODg1OV8xO1xuICAgICAgICAgICAgbGV0IGVjY1BlcmNlbnQgPSBFbmNvZGVyJDEuREVGQVVMVF9FQ19QRVJDRU5UO1xuICAgICAgICAgICAgbGV0IGxheWVycyA9IEVuY29kZXIkMS5ERUZBVUxUX0FaVEVDX0xBWUVSUztcbiAgICAgICAgICAgIGlmIChoaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhpbnRzLmhhcyhFbmNvZGVIaW50VHlwZSQxLkNIQVJBQ1RFUl9TRVQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzZXQgPSBDaGFyc2V0LmZvck5hbWUoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuQ0hBUkFDVEVSX1NFVCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoaW50cy5oYXMoRW5jb2RlSGludFR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OKSkge1xuICAgICAgICAgICAgICAgICAgICBlY2NQZXJjZW50ID0gSW50ZWdlci5wYXJzZUludChoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhpbnRzLmhhcyhFbmNvZGVIaW50VHlwZSQxLkFaVEVDX0xBWUVSUykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJzID0gSW50ZWdlci5wYXJzZUludChoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5BWlRFQ19MQVlFUlMpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBenRlY1dyaXRlci5lbmNvZGVMYXllcnMoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgY2hhcnNldCwgZWNjUGVyY2VudCwgbGF5ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZW5jb2RlTGF5ZXJzKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGNoYXJzZXQsIGVjY1BlcmNlbnQsIGxheWVycykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCAhPT0gQmFyY29kZUZvcm1hdCQxLkFaVEVDKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ2FuIG9ubHkgZW5jb2RlIEFaVEVDLCBidXQgZ290ICcgKyBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGF6dGVjID0gRW5jb2RlciQxLmVuY29kZShTdHJpbmdVdGlscy5nZXRCeXRlcyhjb250ZW50cywgY2hhcnNldCksIGVjY1BlcmNlbnQsIGxheWVycyk7XG4gICAgICAgICAgICByZXR1cm4gQXp0ZWNXcml0ZXIucmVuZGVyUmVzdWx0KGF6dGVjLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcmVuZGVyUmVzdWx0KGNvZGUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGNvZGUuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbnB1dFdpZHRoID0gaW5wdXQuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGxldCBpbnB1dEhlaWdodCA9IGlucHV0LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgbGV0IG91dHB1dFdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGlucHV0V2lkdGgpO1xuICAgICAgICAgICAgbGV0IG91dHB1dEhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgaW5wdXRIZWlnaHQpO1xuICAgICAgICAgICAgbGV0IG11bHRpcGxlID0gTWF0aC5taW4ob3V0cHV0V2lkdGggLyBpbnB1dFdpZHRoLCBvdXRwdXRIZWlnaHQgLyBpbnB1dEhlaWdodCk7XG4gICAgICAgICAgICBsZXQgbGVmdFBhZGRpbmcgPSAob3V0cHV0V2lkdGggLSAoaW5wdXRXaWR0aCAqIG11bHRpcGxlKSkgLyAyO1xuICAgICAgICAgICAgbGV0IHRvcFBhZGRpbmcgPSAob3V0cHV0SGVpZ2h0IC0gKGlucHV0SGVpZ2h0ICogbXVsdGlwbGUpKSAvIDI7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gbmV3IEJpdE1hdHJpeChvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGlucHV0WSAvKmludCovID0gMCwgb3V0cHV0WSA9IHRvcFBhZGRpbmc7IGlucHV0WSA8IGlucHV0SGVpZ2h0OyBpbnB1dFkrKywgb3V0cHV0WSArPSBtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBjb250ZW50cyBvZiB0aGlzIHJvdyBvZiB0aGUgYmFyY29kZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlucHV0WCAvKmludCovID0gMCwgb3V0cHV0WCA9IGxlZnRQYWRkaW5nOyBpbnB1dFggPCBpbnB1dFdpZHRoOyBpbnB1dFgrKywgb3V0cHV0WCArPSBtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZ2V0KGlucHV0WCwgaW5wdXRZKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldFJlZ2lvbihvdXRwdXRYLCBvdXRwdXRZLCBtdWx0aXBsZSwgbXVsdGlwbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHMuQWJzdHJhY3RFeHBhbmRlZERlY29kZXIgPSBBYnN0cmFjdEV4cGFuZGVkRGVjb2RlcjtcbiAgICBleHBvcnRzLkFyZ3VtZW50RXhjZXB0aW9uID0gQXJndW1lbnRFeGNlcHRpb247XG4gICAgZXhwb3J0cy5Bcml0aG1ldGljRXhjZXB0aW9uID0gQXJpdGhtZXRpY0V4Y2VwdGlvbjtcbiAgICBleHBvcnRzLkF6dGVjQ29kZSA9IEF6dGVjQ29kZTtcbiAgICBleHBvcnRzLkF6dGVjQ29kZVJlYWRlciA9IEF6dGVjUmVhZGVyO1xuICAgIGV4cG9ydHMuQXp0ZWNDb2RlV3JpdGVyID0gQXp0ZWNXcml0ZXI7XG4gICAgZXhwb3J0cy5BenRlY0RlY29kZXIgPSBEZWNvZGVyO1xuICAgIGV4cG9ydHMuQXp0ZWNEZXRlY3RvciA9IERldGVjdG9yO1xuICAgIGV4cG9ydHMuQXp0ZWNEZXRlY3RvclJlc3VsdCA9IEF6dGVjRGV0ZWN0b3JSZXN1bHQ7XG4gICAgZXhwb3J0cy5BenRlY0VuY29kZXIgPSBFbmNvZGVyJDE7XG4gICAgZXhwb3J0cy5BenRlY0hpZ2hMZXZlbEVuY29kZXIgPSBIaWdoTGV2ZWxFbmNvZGVyO1xuICAgIGV4cG9ydHMuQXp0ZWNQb2ludCA9IFBvaW50O1xuICAgIGV4cG9ydHMuQmFyY29kZUZvcm1hdCA9IEJhcmNvZGVGb3JtYXQkMTtcbiAgICBleHBvcnRzLkJpbmFyaXplciA9IEJpbmFyaXplcjtcbiAgICBleHBvcnRzLkJpbmFyeUJpdG1hcCA9IEJpbmFyeUJpdG1hcDtcbiAgICBleHBvcnRzLkJpdEFycmF5ID0gQml0QXJyYXk7XG4gICAgZXhwb3J0cy5CaXRNYXRyaXggPSBCaXRNYXRyaXg7XG4gICAgZXhwb3J0cy5CaXRTb3VyY2UgPSBCaXRTb3VyY2U7XG4gICAgZXhwb3J0cy5Ccm93c2VyQXp0ZWNDb2RlUmVhZGVyID0gQnJvd3NlckF6dGVjQ29kZVJlYWRlcjtcbiAgICBleHBvcnRzLkJyb3dzZXJCYXJjb2RlUmVhZGVyID0gQnJvd3NlckJhcmNvZGVSZWFkZXI7XG4gICAgZXhwb3J0cy5Ccm93c2VyQ29kZVJlYWRlciA9IEJyb3dzZXJDb2RlUmVhZGVyO1xuICAgIGV4cG9ydHMuQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyID0gQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyO1xuICAgIGV4cG9ydHMuQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyID0gQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyO1xuICAgIGV4cG9ydHMuQnJvd3NlclBERjQxN1JlYWRlciA9IEJyb3dzZXJQREY0MTdSZWFkZXI7XG4gICAgZXhwb3J0cy5Ccm93c2VyUVJDb2RlUmVhZGVyID0gQnJvd3NlclFSQ29kZVJlYWRlcjtcbiAgICBleHBvcnRzLkJyb3dzZXJRUkNvZGVTdmdXcml0ZXIgPSBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyO1xuICAgIGV4cG9ydHMuQ2hhcmFjdGVyU2V0RUNJID0gQ2hhcmFjdGVyU2V0RUNJO1xuICAgIGV4cG9ydHMuQ2hlY2tzdW1FeGNlcHRpb24gPSBDaGVja3N1bUV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLkNvZGUxMjhSZWFkZXIgPSBDb2RlMTI4UmVhZGVyO1xuICAgIGV4cG9ydHMuQ29kZTM5UmVhZGVyID0gQ29kZTM5UmVhZGVyO1xuICAgIGV4cG9ydHMuRGF0YU1hdHJpeERlY29kZWRCaXRTdHJlYW1QYXJzZXIgPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyO1xuICAgIGV4cG9ydHMuRGF0YU1hdHJpeFJlYWRlciA9IERhdGFNYXRyaXhSZWFkZXI7XG4gICAgZXhwb3J0cy5EZWNvZGVIaW50VHlwZSA9IERlY29kZUhpbnRUeXBlJDE7XG4gICAgZXhwb3J0cy5EZWNvZGVyUmVzdWx0ID0gRGVjb2RlclJlc3VsdDtcbiAgICBleHBvcnRzLkRlZmF1bHRHcmlkU2FtcGxlciA9IERlZmF1bHRHcmlkU2FtcGxlcjtcbiAgICBleHBvcnRzLkRldGVjdG9yUmVzdWx0ID0gRGV0ZWN0b3JSZXN1bHQ7XG4gICAgZXhwb3J0cy5FQU4xM1JlYWRlciA9IEVBTjEzUmVhZGVyO1xuICAgIGV4cG9ydHMuRW5jb2RlSGludFR5cGUgPSBFbmNvZGVIaW50VHlwZSQxO1xuICAgIGV4cG9ydHMuRXhjZXB0aW9uID0gRXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuRm9ybWF0RXhjZXB0aW9uID0gRm9ybWF0RXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuR2VuZXJpY0dGID0gR2VuZXJpY0dGO1xuICAgIGV4cG9ydHMuR2VuZXJpY0dGUG9seSA9IEdlbmVyaWNHRlBvbHk7XG4gICAgZXhwb3J0cy5HbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIgPSBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXI7XG4gICAgZXhwb3J0cy5HcmlkU2FtcGxlciA9IEdyaWRTYW1wbGVyO1xuICAgIGV4cG9ydHMuR3JpZFNhbXBsZXJJbnN0YW5jZSA9IEdyaWRTYW1wbGVySW5zdGFuY2U7XG4gICAgZXhwb3J0cy5IVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZSA9IEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlO1xuICAgIGV4cG9ydHMuSHlicmlkQmluYXJpemVyID0gSHlicmlkQmluYXJpemVyO1xuICAgIGV4cG9ydHMuSVRGUmVhZGVyID0gSVRGUmVhZGVyO1xuICAgIGV4cG9ydHMuSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uID0gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuSWxsZWdhbFN0YXRlRXhjZXB0aW9uID0gSWxsZWdhbFN0YXRlRXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UgPSBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZTtcbiAgICBleHBvcnRzLkx1bWluYW5jZVNvdXJjZSA9IEx1bWluYW5jZVNvdXJjZTtcbiAgICBleHBvcnRzLk1hdGhVdGlscyA9IE1hdGhVdGlscztcbiAgICBleHBvcnRzLk11bHRpRm9ybWF0T25lRFJlYWRlciA9IE11bHRpRm9ybWF0T25lRFJlYWRlcjtcbiAgICBleHBvcnRzLk11bHRpRm9ybWF0UmVhZGVyID0gTXVsdGlGb3JtYXRSZWFkZXI7XG4gICAgZXhwb3J0cy5NdWx0aUZvcm1hdFdyaXRlciA9IE11bHRpRm9ybWF0V3JpdGVyO1xuICAgIGV4cG9ydHMuTm90Rm91bmRFeGNlcHRpb24gPSBOb3RGb3VuZEV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLk9uZURSZWFkZXIgPSBPbmVEUmVhZGVyO1xuICAgIGV4cG9ydHMuUERGNDE3RGVjb2RlZEJpdFN0cmVhbVBhcnNlciA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMjtcbiAgICBleHBvcnRzLlBERjQxN0RlY29kZXJFcnJvckNvcnJlY3Rpb24gPSBFcnJvckNvcnJlY3Rpb247XG4gICAgZXhwb3J0cy5QREY0MTdSZWFkZXIgPSBQREY0MTdSZWFkZXI7XG4gICAgZXhwb3J0cy5QREY0MTdSZXN1bHRNZXRhZGF0YSA9IFBERjQxN1Jlc3VsdE1ldGFkYXRhO1xuICAgIGV4cG9ydHMuUGVyc3BlY3RpdmVUcmFuc2Zvcm0gPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybTtcbiAgICBleHBvcnRzLlBsYW5hcllVVkx1bWluYW5jZVNvdXJjZSA9IFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZTtcbiAgICBleHBvcnRzLlFSQ29kZUJ5dGVNYXRyaXggPSBCeXRlTWF0cml4O1xuICAgIGV4cG9ydHMuUVJDb2RlRGF0YU1hc2sgPSBEYXRhTWFzaztcbiAgICBleHBvcnRzLlFSQ29kZURlY29kZWRCaXRTdHJlYW1QYXJzZXIgPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDE7XG4gICAgZXhwb3J0cy5RUkNvZGVEZWNvZGVyRXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBFcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICBleHBvcnRzLlFSQ29kZURlY29kZXJGb3JtYXRJbmZvcm1hdGlvbiA9IEZvcm1hdEluZm9ybWF0aW9uO1xuICAgIGV4cG9ydHMuUVJDb2RlRW5jb2RlciA9IEVuY29kZXI7XG4gICAgZXhwb3J0cy5RUkNvZGVFbmNvZGVyUVJDb2RlID0gUVJDb2RlO1xuICAgIGV4cG9ydHMuUVJDb2RlTWFza1V0aWwgPSBNYXNrVXRpbDtcbiAgICBleHBvcnRzLlFSQ29kZU1hdHJpeFV0aWwgPSBNYXRyaXhVdGlsO1xuICAgIGV4cG9ydHMuUVJDb2RlTW9kZSA9IE1vZGUkMTtcbiAgICBleHBvcnRzLlFSQ29kZVJlYWRlciA9IFFSQ29kZVJlYWRlcjtcbiAgICBleHBvcnRzLlFSQ29kZVZlcnNpb24gPSBWZXJzaW9uJDE7XG4gICAgZXhwb3J0cy5RUkNvZGVXcml0ZXIgPSBRUkNvZGVXcml0ZXI7XG4gICAgZXhwb3J0cy5SR0JMdW1pbmFuY2VTb3VyY2UgPSBSR0JMdW1pbmFuY2VTb3VyY2U7XG4gICAgZXhwb3J0cy5SU1MxNFJlYWRlciA9IFJTUzE0UmVhZGVyO1xuICAgIGV4cG9ydHMuUlNTRXhwYW5kZWRSZWFkZXIgPSBSU1NFeHBhbmRlZFJlYWRlcjtcbiAgICBleHBvcnRzLlJlYWRlckV4Y2VwdGlvbiA9IFJlYWRlckV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLlJlZWRTb2xvbW9uRGVjb2RlciA9IFJlZWRTb2xvbW9uRGVjb2RlcjtcbiAgICBleHBvcnRzLlJlZWRTb2xvbW9uRW5jb2RlciA9IFJlZWRTb2xvbW9uRW5jb2RlcjtcbiAgICBleHBvcnRzLlJlZWRTb2xvbW9uRXhjZXB0aW9uID0gUmVlZFNvbG9tb25FeGNlcHRpb247XG4gICAgZXhwb3J0cy5SZXN1bHQgPSBSZXN1bHQ7XG4gICAgZXhwb3J0cy5SZXN1bHRNZXRhZGF0YVR5cGUgPSBSZXN1bHRNZXRhZGF0YVR5cGUkMTtcbiAgICBleHBvcnRzLlJlc3VsdFBvaW50ID0gUmVzdWx0UG9pbnQ7XG4gICAgZXhwb3J0cy5TdHJpbmdVdGlscyA9IFN0cmluZ1V0aWxzO1xuICAgIGV4cG9ydHMuVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gPSBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLlZpZGVvSW5wdXREZXZpY2UgPSBWaWRlb0lucHV0RGV2aWNlO1xuICAgIGV4cG9ydHMuV2hpdGVSZWN0YW5nbGVEZXRlY3RvciA9IFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3I7XG4gICAgZXhwb3J0cy5Xcml0ZXJFeGNlcHRpb24gPSBXcml0ZXJFeGNlcHRpb247XG4gICAgZXhwb3J0cy5aWGluZ0FycmF5cyA9IEFycmF5cztcbiAgICBleHBvcnRzLlpYaW5nQ2hhcnNldCA9IENoYXJzZXQ7XG4gICAgZXhwb3J0cy5aWGluZ0ludGVnZXIgPSBJbnRlZ2VyO1xuICAgIGV4cG9ydHMuWlhpbmdTdGFuZGFyZENoYXJzZXRzID0gU3RhbmRhcmRDaGFyc2V0cztcbiAgICBleHBvcnRzLlpYaW5nU3RyaW5nQnVpbGRlciA9IFN0cmluZ0J1aWxkZXI7XG4gICAgZXhwb3J0cy5aWGluZ1N0cmluZ0VuY29kaW5nID0gU3RyaW5nRW5jb2Rpbmc7XG4gICAgZXhwb3J0cy5aWGluZ1N5c3RlbSA9IFN5c3RlbTtcbiAgICBleHBvcnRzLmNyZWF0ZUFic3RyYWN0RXhwYW5kZWREZWNvZGVyID0gY3JlYXRlRGVjb2RlcjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJnbG9iYWxUaGlzIiwic2VsZiIsIlpYaW5nIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJvYmoiLCJ1bmRlZmluZWQiLCJleHRlbmRTdGF0aWNzIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJBcnJheSIsImQiLCJiIiwicCIsImhhc093blByb3BlcnR5IiwiX19leHRlbmRzIiwiX18iLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImNyZWF0ZSIsImZpeFByb3RvIiwidGFyZ2V0IiwiZml4U3RhY2siLCJmbiIsImNhcHR1cmVTdGFja1RyYWNlIiwiRXJyb3IiLCJDdXN0b21FcnJvciIsIl9zdXBlciIsIm1lc3NhZ2UiLCJfbmV3VGFyZ2V0IiwiX3RoaXMiLCJjYWxsIiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiRXhjZXB0aW9uIiwiZ2V0S2luZCIsImV4Iiwia2luZCIsIkFyZ3VtZW50RXhjZXB0aW9uIiwiSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIiwiQmluYXJ5Qml0bWFwIiwiYmluYXJpemVyIiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJnZXRCbGFja1JvdyIsInkiLCJyb3ciLCJnZXRCbGFja01hdHJpeCIsIm1hdHJpeCIsImlzQ3JvcFN1cHBvcnRlZCIsImdldEx1bWluYW5jZVNvdXJjZSIsImNyb3AiLCJsZWZ0IiwidG9wIiwid2lkdGgiLCJoZWlnaHQiLCJuZXdTb3VyY2UiLCJjcmVhdGVCaW5hcml6ZXIiLCJpc1JvdGF0ZVN1cHBvcnRlZCIsInJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UiLCJyb3RhdGVDb3VudGVyQ2xvY2t3aXNlNDUiLCJ0b1N0cmluZyIsImUiLCJDaGVja3N1bUV4Y2VwdGlvbiIsImdldENoZWNrc3VtSW5zdGFuY2UiLCJCaW5hcml6ZXIiLCJzb3VyY2UiLCJTeXN0ZW0iLCJhcnJheWNvcHkiLCJzcmMiLCJzcmNQb3MiLCJkZXN0IiwiZGVzdFBvcyIsImxlbmd0aCIsImN1cnJlbnRUaW1lTWlsbGlzIiwiRGF0ZSIsIm5vdyIsIkluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24iLCJBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24iLCJpbmRleCIsIkFycmF5cyIsImZpbGwiLCJhIiwidmFsIiwiaSIsImxlbiIsImZpbGxXaXRoaW4iLCJmcm9tSW5kZXgiLCJ0b0luZGV4IiwicmFuZ2VDaGVjayIsImFycmF5TGVuZ3RoIiwiYXNMaXN0IiwiYXJncyIsInJvd3MiLCJjb2xzIiwiYXJyIiwiZnJvbSIsIm1hcCIsIngiLCJjcmVhdGVJbnQzMkFycmF5IiwiSW50MzJBcnJheSIsImVxdWFscyIsImZpcnN0Iiwic2Vjb25kIiwiaGFzaENvZGUiLCJyZXN1bHQiLCJlbGVtZW50IiwiZmlsbFVpbnQ4QXJyYXkiLCJjb3B5T2YiLCJvcmlnaW5hbCIsIm5ld0xlbmd0aCIsInNsaWNlIiwiY29weU9mVWludDhBcnJheSIsIm5ld0FycmF5IiwiVWludDhBcnJheSIsInNldCIsImNvcHlPZlJhbmdlIiwidG8iLCJjb3B5IiwiYmluYXJ5U2VhcmNoIiwiYXIiLCJlbCIsImNvbXBhcmF0b3IiLCJudW1iZXJDb21wYXJhdG9yIiwibSIsIm4iLCJrIiwiY21wIiwiSW50ZWdlciIsIm51bWJlck9mVHJhaWxpbmdaZXJvcyIsIm51bWJlck9mTGVhZGluZ1plcm9zIiwidG9IZXhTdHJpbmciLCJ0b0JpbmFyeVN0cmluZyIsImludE51bWJlciIsIlN0cmluZyIsInBhcnNlSW50IiwiYml0Q291bnQiLCJ0cnVuY0RpdmlzaW9uIiwiZGl2aWRlbmQiLCJkaXZpc29yIiwiTWF0aCIsInRydW5jIiwibnVtIiwicmFkaXgiLCJNSU5fVkFMVUVfMzJfQklUUyIsIk1BWF9WQUxVRSIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJCaXRBcnJheSIsInNpemUiLCJiaXRzIiwibWFrZUFycmF5IiwiZ2V0U2l6ZSIsImdldFNpemVJbkJ5dGVzIiwiZmxvb3IiLCJlbnN1cmVDYXBhY2l0eSIsIm5ld0JpdHMiLCJnZXQiLCJmbGlwIiwiZ2V0TmV4dFNldCIsImJpdHNPZmZzZXQiLCJjdXJyZW50Qml0cyIsImdldE5leHRVbnNldCIsInNldEJ1bGsiLCJzZXRSYW5nZSIsInN0YXJ0IiwiZW5kIiwiZmlyc3RJbnQiLCJsYXN0SW50IiwiZmlyc3RCaXQiLCJsYXN0Qml0IiwibWFzayIsImNsZWFyIiwibWF4IiwiaXNSYW5nZSIsImFwcGVuZEJpdCIsImJpdCIsImFwcGVuZEJpdHMiLCJudW1CaXRzIiwibnVtQml0c0xlZnQiLCJhcHBlbmRCaXRBcnJheSIsIm90aGVyIiwib3RoZXJTaXplIiwieG9yIiwidG9CeXRlcyIsImJpdE9mZnNldCIsImFycmF5Iiwib2Zmc2V0IiwibnVtQnl0ZXMiLCJ0aGVCeXRlIiwiaiIsImdldEJpdEFycmF5IiwicmV2ZXJzZSIsIm9sZEJpdHNMZW4iLCJsZWZ0T2Zmc2V0IiwiY3VycmVudEludCIsIm5leHRJbnQiLCJvIiwiY2xvbmUiLCJEZWNvZGVIaW50VHlwZSIsIkRlY29kZUhpbnRUeXBlJDEiLCJGb3JtYXRFeGNlcHRpb24iLCJnZXRGb3JtYXRJbnN0YW5jZSIsIkNoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMiLCJDaGFyYWN0ZXJTZXRFQ0kiLCJ2YWx1ZUlkZW50aWZpZXIiLCJ2YWx1ZXNQYXJhbSIsIm90aGVyRW5jb2RpbmdOYW1lcyIsInZhbHVlcyIsIlZBTFVFX0lERU5USUZJRVJfVE9fRUNJIiwiTkFNRV9UT19FQ0kiLCJ2IiwiVkFMVUVTX1RPX0VDSSIsIm90aGVyTmFtZSIsImdldFZhbHVlSWRlbnRpZmllciIsImdldE5hbWUiLCJnZXRWYWx1ZSIsImdldENoYXJhY3RlclNldEVDSUJ5VmFsdWUiLCJjaGFyYWN0ZXJTZXQiLCJnZXRDaGFyYWN0ZXJTZXRFQ0lCeU5hbWUiLCJNYXAiLCJDcDQzNyIsIklTTzg4NTlfMSIsIklTTzg4NTlfMiIsIklTTzg4NTlfMyIsIklTTzg4NTlfNCIsIklTTzg4NTlfNSIsIklTTzg4NTlfNiIsIklTTzg4NTlfNyIsIklTTzg4NTlfOCIsIklTTzg4NTlfOSIsIklTTzg4NTlfMTAiLCJJU084ODU5XzExIiwiSVNPODg1OV8xMyIsIklTTzg4NTlfMTQiLCJJU084ODU5XzE1IiwiSVNPODg1OV8xNiIsIlNKSVMiLCJDcDEyNTAiLCJDcDEyNTEiLCJDcDEyNTIiLCJDcDEyNTYiLCJVbmljb2RlQmlnVW5tYXJrZWQiLCJVVEY4IiwiQVNDSUkiLCJCaWc1IiwiR0IxODAzMCIsIkVVQ19LUiIsIlVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uIiwiU3RyaW5nRW5jb2RpbmciLCJkZWNvZGUiLCJieXRlcyIsImVuY29kaW5nIiwiZW5jb2RpbmdOYW1lIiwiY3VzdG9tRGVjb2RlciIsIlRleHREZWNvZGVyIiwic2hvdWxkRGVjb2RlT25GYWxsYmFjayIsImRlY29kZUZhbGxiYWNrIiwiaXNCcm93c2VyIiwiZW5jb2RlIiwicyIsImN1c3RvbUVuY29kZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZUZhbGxiYWNrIiwid2luZG93IiwiZW5jb2RpbmdDaGFyYWN0ZXJTZXQiLCJpc0RlY29kZUZhbGxiYWNrU3VwcG9ydGVkIiwiaCIsImRlY29kZVVSSUNvbXBvbmVudCIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiVWludDE2QXJyYXkiLCJidWZmZXIiLCJlbmNvZGVkVVJJc3RyaW5nIiwiYnRvYSIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiY2hhckxpc3QiLCJzcGxpdCIsInVpbnRBcnJheSIsInB1c2giLCJjaGFyQ29kZUF0IiwiU3RyaW5nVXRpbHMiLCJjYXN0QXNOb25VdGY4Q2hhciIsImNvZGUiLCJJU084ODU5MSIsImd1ZXNzRW5jb2RpbmciLCJoaW50cyIsIkNIQVJBQ1RFUl9TRVQiLCJjYW5CZUlTTzg4NTkxIiwiY2FuQmVTaGlmdEpJUyIsImNhbkJlVVRGOCIsInV0ZjhCeXRlc0xlZnQiLCJ1dGYyQnl0ZXNDaGFycyIsInV0ZjNCeXRlc0NoYXJzIiwidXRmNEJ5dGVzQ2hhcnMiLCJzamlzQnl0ZXNMZWZ0Iiwic2ppc0thdGFrYW5hQ2hhcnMiLCJzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoIiwic2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCIsInNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGgiLCJzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoIiwiaXNvSGlnaE90aGVyIiwidXRmOGJvbSIsIkFTU1VNRV9TSElGVF9KSVMiLCJTSElGVF9KSVMiLCJQTEFURk9STV9ERUZBVUxUX0VOQ09ESU5HIiwiZm9ybWF0IiwiYXBwZW5kIiwiY2FsbGJhY2siLCJleHAiLCJwMCIsInAxIiwicDIiLCJwMyIsInA0Iiwic3Vic3RyIiwiYmFzZSIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwidG9QcmVjaXNpb24iLCJ0b0V4cG9uZW50aWFsIiwiSlNPTiIsInN0cmluZ2lmeSIsImNoIiwicmVnZXgiLCJyZXBsYWNlIiwiZ2V0Qnl0ZXMiLCJzdHIiLCJnZXRDaGFyQ29kZSIsImdldENoYXJBdCIsImNoYXJDb2RlIiwiR0IyMzEyIiwiRVVDX0pQIiwiU3RyaW5nQnVpbGRlciIsImVuYWJsZURlY29kaW5nIiwiYXBwZW5kQ2hhcnMiLCJjaGFyQXQiLCJkZWxldGVDaGFyQXQiLCJzdWJzdHJpbmciLCJzZXRDaGFyQXQiLCJjIiwic2V0TGVuZ3RoVG9aZXJvIiwiaW5zZXJ0IiwiQml0TWF0cml4Iiwicm93U2l6ZSIsInBhcnNlRnJvbUJvb2xlYW5BcnJheSIsImltYWdlIiwiaW1hZ2VJIiwicGFyc2VGcm9tU3RyaW5nIiwic3RyaW5nUmVwcmVzZW50YXRpb24iLCJzZXRTdHJpbmciLCJ1bnNldFN0cmluZyIsImJpdHNQb3MiLCJyb3dTdGFydFBvcyIsInJvd0xlbmd0aCIsIm5Sb3dzIiwicG9zIiwidW5zZXQiLCJnZXRSb3dTaXplIiwicm93QXJyYXkiLCJnZXRSb3ciLCJzZXRSZWdpb24iLCJyaWdodCIsImJvdHRvbSIsInNldFJvdyIsInJvdGF0ZTE4MCIsInRvcFJvdyIsImJvdHRvbVJvdyIsImdldEVuY2xvc2luZ1JlY3RhbmdsZSIsIngzMiIsInRoZUJpdHMiLCJnZXRUb3BMZWZ0T25CaXQiLCJnZXRCb3R0b21SaWdodE9uQml0IiwiaGFzaCIsImxpbmVTZXBhcmF0b3IiLCJidWlsZFRvU3RyaW5nIiwiTm90Rm91bmRFeGNlcHRpb24iLCJnZXROb3RGb3VuZEluc3RhbmNlIiwiR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyIiwibHVtaW5hbmNlcyIsIkVNUFRZIiwiYnVja2V0cyIsIkxVTUlOQU5DRV9CVUNLRVRTIiwiaW5pdEFycmF5cyIsImxvY2FsTHVtaW5hbmNlcyIsImxvY2FsQnVja2V0cyIsIkxVTUlOQU5DRV9TSElGVCIsImJsYWNrUG9pbnQiLCJlc3RpbWF0ZUJsYWNrUG9pbnQiLCJjZW50ZXIiLCJwaXhlbCIsImdldE1hdHJpeCIsImx1bWluYW5jZVNpemUiLCJVaW50OENsYW1wZWRBcnJheSIsIm51bUJ1Y2tldHMiLCJtYXhCdWNrZXRDb3VudCIsImZpcnN0UGVhayIsImZpcnN0UGVha1NpemUiLCJzZWNvbmRQZWFrIiwic2Vjb25kUGVha1Njb3JlIiwiZGlzdGFuY2VUb0JpZ2dlc3QiLCJzY29yZSIsInRlbXAiLCJiZXN0VmFsbGV5IiwiYmVzdFZhbGxleVNjb3JlIiwiZnJvbUZpcnN0IiwiTFVNSU5BTkNFX0JJVFMiLCJIeWJyaWRCaW5hcml6ZXIiLCJNSU5JTVVNX0RJTUVOU0lPTiIsInN1YldpZHRoIiwiQkxPQ0tfU0laRV9QT1dFUiIsIkJMT0NLX1NJWkVfTUFTSyIsInN1YkhlaWdodCIsImJsYWNrUG9pbnRzIiwiY2FsY3VsYXRlQmxhY2tQb2ludHMiLCJuZXdNYXRyaXgiLCJjYWxjdWxhdGVUaHJlc2hvbGRGb3JCbG9jayIsIm1heFlPZmZzZXQiLCJCTE9DS19TSVpFIiwibWF4WE9mZnNldCIsInlvZmZzZXQiLCJjYXAiLCJ4b2Zmc2V0Iiwic3VtIiwieiIsImJsYWNrUm93IiwiYXZlcmFnZSIsInRocmVzaG9sZEJsb2NrIiwibWluIiwidGhyZXNob2xkIiwic3RyaWRlIiwieXkiLCJ4eCIsIk1JTl9EWU5BTUlDX1JBTkdFIiwiYXZlcmFnZU5laWdoYm9yQmxhY2tQb2ludCIsIkx1bWluYW5jZVNvdXJjZSIsInNvdXJjZVJvdyIsImx1bWluYW5jZSIsIkludmVydGVkTHVtaW5hbmNlU291cmNlIiwiZGVsZWdhdGUiLCJpbnZlcnRlZE1hdHJpeCIsImludmVydCIsIkhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlIiwiY2FudmFzIiwidGVtcENhbnZhc0VsZW1lbnQiLCJtYWtlQnVmZmVyRnJvbUNhbnZhc0ltYWdlRGF0YSIsImltYWdlRGF0YSIsImdldENvbnRleHQiLCJnZXRJbWFnZURhdGEiLCJ0b0dyYXlzY2FsZUJ1ZmZlciIsImRhdGEiLCJpbWFnZUJ1ZmZlciIsImdyYXlzY2FsZUJ1ZmZlciIsImdyYXkiLCJhbHBoYSIsInBpeGVsUiIsInBpeGVsRyIsInBpeGVsQiIsInJvdGF0ZSIsImdldFRlbXBDYW52YXNFbGVtZW50Iiwib3duZXJEb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhbmdsZSIsInRlbXBDb250ZXh0IiwiYW5nbGVSYWRpYW5zIiwiREVHUkVFX1RPX1JBRElBTlMiLCJuZXdXaWR0aCIsImNlaWwiLCJhYnMiLCJjb3MiLCJzaW4iLCJuZXdIZWlnaHQiLCJ0cmFuc2xhdGUiLCJkcmF3SW1hZ2UiLCJQSSIsIlZpZGVvSW5wdXREZXZpY2UiLCJkZXZpY2VJZCIsImxhYmVsIiwiZ3JvdXBJZCIsInRvSlNPTiIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsInJlamVjdGVkIiwiZG9uZSIsInRoZW4iLCJCcm93c2VyQ29kZVJlYWRlciIsInJlYWRlciIsInRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMiLCJfaGludHMiLCJfc3RvcENvbnRpbnVvdXNEZWNvZGUiLCJfc3RvcEFzeW5jRGVjb2RlIiwiX3RpbWVCZXR3ZWVuRGVjb2RpbmdBdHRlbXB0cyIsImhhc05hdmlnYXRvciIsIm5hdmlnYXRvciIsImlzTWVkaWFEZXZpY2VzU3Vwb3J0ZWQiLCJtZWRpYURldmljZXMiLCJjYW5FbnVtZXJhdGVEZXZpY2VzIiwiZW51bWVyYXRlRGV2aWNlcyIsInRpbWVCZXR3ZWVuRGVjb2RpbmdBdHRlbXB0cyIsIm1pbGxpcyIsImxpc3RWaWRlb0lucHV0RGV2aWNlcyIsImRldmljZXMiLCJ2aWRlb0RldmljZXMiLCJkZXZpY2UiLCJpZCIsInZpZGVvRGV2aWNlIiwiZ2V0VmlkZW9JbnB1dERldmljZXMiLCJmaW5kRGV2aWNlQnlJZCIsImZpbmQiLCJkZWNvZGVGcm9tSW5wdXRWaWRlb0RldmljZSIsInZpZGVvU291cmNlIiwiZGVjb2RlT25jZUZyb21WaWRlb0RldmljZSIsInJlc2V0IiwidmlkZW9Db25zdHJhaW50cyIsImZhY2luZ01vZGUiLCJleGFjdCIsImNvbnN0cmFpbnRzIiwidmlkZW8iLCJkZWNvZGVPbmNlRnJvbUNvbnN0cmFpbnRzIiwic3RyZWFtIiwiZ2V0VXNlck1lZGlhIiwiZGVjb2RlT25jZUZyb21TdHJlYW0iLCJhdHRhY2hTdHJlYW1Ub1ZpZGVvIiwiZGVjb2RlT25jZSIsImRlY29kZUZyb21JbnB1dFZpZGVvRGV2aWNlQ29udGludW91c2x5IiwiY2FsbGJhY2tGbiIsImRlY29kZUZyb21WaWRlb0RldmljZSIsImRlY29kZUZyb21Db25zdHJhaW50cyIsImRlY29kZUZyb21TdHJlYW0iLCJkZWNvZGVDb250aW51b3VzbHkiLCJzdG9wQXN5bmNEZWNvZGUiLCJzdG9wQ29udGludW91c0RlY29kZSIsInZpZGVvRWxlbWVudCIsInByZXBhcmVWaWRlb0VsZW1lbnQiLCJhZGRWaWRlb1NvdXJjZSIsInBsYXlWaWRlb09uTG9hZEFzeW5jIiwicGxheVZpZGVvT25Mb2FkIiwidmlkZW9FbmRlZExpc3RlbmVyIiwic3RvcFN0cmVhbXMiLCJ2aWRlb0NhblBsYXlMaXN0ZW5lciIsInRyeVBsYXlWaWRlbyIsImFkZEV2ZW50TGlzdGVuZXIiLCJpc1ZpZGVvUGxheWluZyIsImN1cnJlbnRUaW1lIiwicGF1c2VkIiwiZW5kZWQiLCJyZWFkeVN0YXRlIiwiY29uc29sZSIsIndhcm4iLCJwbGF5IiwiX2EiLCJnZXRNZWRpYUVsZW1lbnQiLCJtZWRpYUVsZW1lbnRJZCIsInR5cGUiLCJtZWRpYUVsZW1lbnQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImRlY29kZUZyb21JbWFnZSIsInVybCIsImRlY29kZUZyb21JbWFnZVVybCIsImRlY29kZUZyb21JbWFnZUVsZW1lbnQiLCJkZWNvZGVGcm9tVmlkZW8iLCJkZWNvZGVGcm9tVmlkZW9VcmwiLCJkZWNvZGVGcm9tVmlkZW9FbGVtZW50IiwiZGVjb2RlRnJvbVZpZGVvQ29udGludW91c2x5IiwiZGVjb2RlRnJvbVZpZGVvVXJsQ29udGludW91c2x5IiwiZGVjb2RlRnJvbVZpZGVvRWxlbWVudENvbnRpbnVvdXNseSIsInByZXBhcmVJbWFnZUVsZW1lbnQiLCJpbWFnZUVsZW1lbnQiLCJ0YXNrIiwiaXNJbWFnZUxvYWRlZCIsIl9kZWNvZGVPbkxvYWRJbWFnZSIsIl9kZWNvZGVGcm9tVmlkZW9FbGVtZW50U2V0dXAiLCJfZGVjb2RlT25Mb2FkVmlkZW8iLCJfZGVjb2RlT25Mb2FkVmlkZW9Db250aW51b3VzbHkiLCJkZWNvZGVUYXNrIiwiaW1hZ2VMb2FkZWRMaXN0ZW5lciIsImltZyIsImNvbXBsZXRlIiwibmF0dXJhbFdpZHRoIiwiaW1hZ2VTb3VyY2UiLCJIVE1MSW1hZ2VFbGVtZW50IiwiSFRNTFZpZGVvRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsInJldHJ5SWZOb3RGb3VuZCIsInJldHJ5SWZDaGVja3N1bU9yRm9ybWF0RXJyb3IiLCJsb29wIiwiaWZOb3RGb3VuZCIsImlzQ2hlY2tzdW1PckZvcm1hdEVycm9yIiwiaWZDaGVja3N1bU9yRm9ybWF0Iiwic2V0VGltZW91dCIsImlzTm90Rm91bmQiLCJiaW5hcnlCaXRtYXAiLCJjcmVhdGVCaW5hcnlCaXRtYXAiLCJkZWNvZGVCaXRtYXAiLCJfaXNIVE1MVmlkZW9FbGVtZW50IiwicG90ZW50aWFsVmlkZW8iLCJ2aWRlb1dpZHRoIiwiZHJhd0ZyYW1lT25DYW52YXMiLCJzcmNFbGVtZW50IiwiZGltZW5zaW9ucyIsImNhbnZhc0VsZW1lbnRDb250ZXh0Iiwic3giLCJzeSIsInNXaWR0aCIsInNIZWlnaHQiLCJ2aWRlb0hlaWdodCIsImR4IiwiZHkiLCJkV2lkdGgiLCJkSGVpZ2h0IiwiY2FwdHVyZUNhbnZhc0NvbnRleHQiLCJkcmF3SW1hZ2VPbkNhbnZhcyIsIm5hdHVyYWxIZWlnaHQiLCJjdHgiLCJnZXRDYXB0dXJlQ2FudmFzQ29udGV4dCIsImdldENhcHR1cmVDYW52YXMiLCJsdW1pbmFuY2VTb3VyY2UiLCJoeWJyaWRCaW5hcml6ZXIiLCJlbGVtIiwiY2FwdHVyZUNhbnZhcyIsImNyZWF0ZUNhcHR1cmVDYW52YXMiLCJfZGVzdHJveUNhcHR1cmVDYW52YXMiLCJjYW52YXNFbGVtZW50Iiwic3R5bGUiLCJnZXRWaWRlb1RyYWNrcyIsImZvckVhY2giLCJ0Iiwic3RvcCIsIl9kZXN0cm95VmlkZW9FbGVtZW50IiwiX2Rlc3Ryb3lJbWFnZUVsZW1lbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidmlkZW9QbGF5aW5nRXZlbnRMaXN0ZW5lciIsImNsZWFuVmlkZW9Tb3VyY2UiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzcmNPYmplY3QiLCJlcnIiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJSZXN1bHQiLCJ0ZXh0IiwicmF3Qnl0ZXMiLCJyZXN1bHRQb2ludHMiLCJ0aW1lc3RhbXAiLCJyZXN1bHRNZXRhZGF0YSIsImdldFRleHQiLCJnZXRSYXdCeXRlcyIsImdldE51bUJpdHMiLCJnZXRSZXN1bHRQb2ludHMiLCJnZXRCYXJjb2RlRm9ybWF0IiwiZ2V0UmVzdWx0TWV0YWRhdGEiLCJwdXRNZXRhZGF0YSIsInB1dEFsbE1ldGFkYXRhIiwibWV0YWRhdGEiLCJhZGRSZXN1bHRQb2ludHMiLCJuZXdQb2ludHMiLCJvbGRQb2ludHMiLCJhbGxQb2ludHMiLCJnZXRUaW1lc3RhbXAiLCJCYXJjb2RlRm9ybWF0IiwiQmFyY29kZUZvcm1hdCQxIiwiUmVzdWx0TWV0YWRhdGFUeXBlIiwiUmVzdWx0TWV0YWRhdGFUeXBlJDEiLCJEZWNvZGVyUmVzdWx0IiwiYnl0ZVNlZ21lbnRzIiwiZWNMZXZlbCIsInN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlciIsInN0cnVjdHVyZWRBcHBlbmRQYXJpdHkiLCJzZXROdW1CaXRzIiwiZ2V0Qnl0ZVNlZ21lbnRzIiwiZ2V0RUNMZXZlbCIsImdldEVycm9yc0NvcnJlY3RlZCIsImVycm9yc0NvcnJlY3RlZCIsInNldEVycm9yc0NvcnJlY3RlZCIsImdldEVyYXN1cmVzIiwiZXJhc3VyZXMiLCJzZXRFcmFzdXJlcyIsImdldE90aGVyIiwic2V0T3RoZXIiLCJoYXNTdHJ1Y3R1cmVkQXBwZW5kIiwiZ2V0U3RydWN0dXJlZEFwcGVuZFBhcml0eSIsImdldFN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlciIsIkFic3RyYWN0R2VuZXJpY0dGIiwiZXhwVGFibGUiLCJsb2ciLCJsb2dUYWJsZSIsImFkZE9yU3VidHJhY3QiLCJHZW5lcmljR0ZQb2x5IiwiZmllbGQiLCJjb2VmZmljaWVudHMiLCJjb2VmZmljaWVudHNMZW5ndGgiLCJmaXJzdE5vblplcm8iLCJnZXRDb2VmZmljaWVudHMiLCJnZXREZWdyZWUiLCJpc1plcm8iLCJnZXRDb2VmZmljaWVudCIsImRlZ3JlZSIsImV2YWx1YXRlQXQiLCJjb2VmZmljaWVudCIsIm11bHRpcGx5Iiwic21hbGxlckNvZWZmaWNpZW50cyIsImxhcmdlckNvZWZmaWNpZW50cyIsInN1bURpZmYiLCJsZW5ndGhEaWZmIiwiZ2V0WmVybyIsImFDb2VmZmljaWVudHMiLCJhTGVuZ3RoIiwiYkNvZWZmaWNpZW50cyIsImJMZW5ndGgiLCJwcm9kdWN0IiwiYUNvZWZmIiwibXVsdGlwbHlTY2FsYXIiLCJzY2FsYXIiLCJtdWx0aXBseUJ5TW9ub21pYWwiLCJkaXZpZGUiLCJxdW90aWVudCIsInJlbWFpbmRlciIsImRlbm9taW5hdG9yTGVhZGluZ1Rlcm0iLCJpbnZlcnNlRGVub21pbmF0b3JMZWFkaW5nVGVybSIsImludmVyc2UiLCJkZWdyZWVEaWZmZXJlbmNlIiwic2NhbGUiLCJ0ZXJtIiwiaXRlcmF0aW9uUXVvdGllbnQiLCJidWlsZE1vbm9taWFsIiwiYWxwaGFQb3dlciIsIkFyaXRobWV0aWNFeGNlcHRpb24iLCJHZW5lcmljR0YiLCJwcmltaXRpdmUiLCJnZW5lcmF0b3JCYXNlIiwiemVybyIsIm9uZSIsImdldE9uZSIsImdldEdlbmVyYXRvckJhc2UiLCJBWlRFQ19EQVRBXzEyIiwiQVpURUNfREFUQV8xMCIsIkFaVEVDX0RBVEFfNiIsIkFaVEVDX1BBUkFNIiwiUVJfQ09ERV9GSUVMRF8yNTYiLCJEQVRBX01BVFJJWF9GSUVMRF8yNTYiLCJBWlRFQ19EQVRBXzgiLCJNQVhJQ09ERV9GSUVMRF82NCIsIlJlZWRTb2xvbW9uRXhjZXB0aW9uIiwiSWxsZWdhbFN0YXRlRXhjZXB0aW9uIiwiUmVlZFNvbG9tb25EZWNvZGVyIiwicmVjZWl2ZWQiLCJ0d29TIiwicG9seSIsInN5bmRyb21lQ29lZmZpY2llbnRzIiwibm9FcnJvciIsImV2YWxSZXN1bHQiLCJzeW5kcm9tZSIsInNpZ21hT21lZ2EiLCJydW5FdWNsaWRlYW5BbGdvcml0aG0iLCJzaWdtYSIsIm9tZWdhIiwiZXJyb3JMb2NhdGlvbnMiLCJmaW5kRXJyb3JMb2NhdGlvbnMiLCJlcnJvck1hZ25pdHVkZXMiLCJmaW5kRXJyb3JNYWduaXR1ZGVzIiwicG9zaXRpb24iLCJSIiwickxhc3QiLCJyIiwidExhc3QiLCJyTGFzdExhc3QiLCJ0TGFzdExhc3QiLCJxIiwiZGx0SW52ZXJzZSIsImRlZ3JlZURpZmYiLCJzaWdtYVRpbGRlQXRaZXJvIiwiZXJyb3JMb2NhdG9yIiwibnVtRXJyb3JzIiwiZXJyb3JFdmFsdWF0b3IiLCJ4aUludmVyc2UiLCJkZW5vbWluYXRvciIsInRlcm1QbHVzMSIsIlRhYmxlIiwiRGVjb2RlciIsImRldGVjdG9yUmVzdWx0IiwiZGRhdGEiLCJnZXRCaXRzIiwicmF3Yml0cyIsImV4dHJhY3RCaXRzIiwiY29ycmVjdGVkQml0cyIsImNvcnJlY3RCaXRzIiwiY29udmVydEJvb2xBcnJheVRvQnl0ZUFycmF5IiwiZ2V0RW5jb2RlZERhdGEiLCJkZWNvZGVyUmVzdWx0IiwiaGlnaExldmVsRGVjb2RlIiwiZW5kSW5kZXgiLCJsYXRjaFRhYmxlIiwiVVBQRVIiLCJzaGlmdFRhYmxlIiwiQklOQVJZIiwicmVhZENvZGUiLCJjaGFyQ291bnQiLCJESUdJVCIsImdldENoYXJhY3RlciIsInN0YXJ0c1dpdGgiLCJnZXRUYWJsZSIsIkxPV0VSIiwiUFVOQ1QiLCJNSVhFRCIsInRhYmxlIiwiVVBQRVJfVEFCTEUiLCJMT1dFUl9UQUJMRSIsIk1JWEVEX1RBQkxFIiwiUFVOQ1RfVEFCTEUiLCJESUdJVF9UQUJMRSIsImdmIiwiY29kZXdvcmRTaXplIiwiZ2V0TmJMYXllcnMiLCJudW1EYXRhQ29kZXdvcmRzIiwiZ2V0TmJEYXRhYmxvY2tzIiwibnVtQ29kZXdvcmRzIiwiZGF0YVdvcmRzIiwicnNEZWNvZGVyIiwic3R1ZmZlZEJpdHMiLCJkYXRhV29yZCIsImNvbXBhY3QiLCJpc0NvbXBhY3QiLCJsYXllcnMiLCJiYXNlTWF0cml4U2l6ZSIsImFsaWdubWVudE1hcCIsInRvdGFsQml0c0luTGF5ZXIiLCJtYXRyaXhTaXplIiwib3JpZ0NlbnRlciIsIm5ld09mZnNldCIsInJvd09mZnNldCIsImxvdyIsImhpZ2giLCJjb2x1bW5PZmZzZXQiLCJzdGFydEluZGV4IiwicmVzIiwicmVhZEJ5dGUiLCJib29sQXJyIiwiYnl0ZUFyciIsIk1hdGhVdGlscyIsInJvdW5kIiwiTmFOIiwiTUlOX1NBRkVfSU5URUdFUiIsImRpc3RhbmNlIiwiYVgiLCJhWSIsImJYIiwiYlkiLCJ4RGlmZiIsInlEaWZmIiwic3FydCIsImNvdW50IiwiRmxvYXQiLCJmbG9hdFRvSW50Qml0cyIsImYiLCJSZXN1bHRQb2ludCIsImdldFgiLCJnZXRZIiwib3RoZXJQb2ludCIsIm9yZGVyQmVzdFBhdHRlcm5zIiwicGF0dGVybnMiLCJ6ZXJvT25lRGlzdGFuY2UiLCJvbmVUd29EaXN0YW5jZSIsInplcm9Ud29EaXN0YW5jZSIsInBvaW50QSIsInBvaW50QiIsInBvaW50QyIsImNyb3NzUHJvZHVjdFoiLCJwYXR0ZXJuMSIsInBhdHRlcm4yIiwiRGV0ZWN0b3JSZXN1bHQiLCJwb2ludHMiLCJnZXRQb2ludHMiLCJBenRlY0RldGVjdG9yUmVzdWx0IiwibmJEYXRhYmxvY2tzIiwibmJMYXllcnMiLCJXaGl0ZVJlY3RhbmdsZURldGVjdG9yIiwiaW5pdFNpemUiLCJJTklUX1NJWkUiLCJoYWxmc2l6ZSIsImxlZnRJbml0IiwicmlnaHRJbml0IiwidXBJbml0IiwiZG93bkluaXQiLCJkZXRlY3QiLCJ1cCIsImRvd24iLCJzaXplRXhjZWVkZWQiLCJhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIiLCJhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIiLCJhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25SaWdodCIsImF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkJvdHRvbSIsImF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkxlZnQiLCJhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Ub3AiLCJyaWdodEJvcmRlck5vdFdoaXRlIiwiY29udGFpbnNCbGFja1BvaW50IiwiYm90dG9tQm9yZGVyTm90V2hpdGUiLCJsZWZ0Qm9yZGVyTm90V2hpdGUiLCJ0b3BCb3JkZXJOb3RXaGl0ZSIsIm1heFNpemUiLCJnZXRCbGFja1BvaW50T25TZWdtZW50IiwiY2VudGVyRWRnZXMiLCJkaXN0IiwieFN0ZXAiLCJ5U3RlcCIsInlpIiwieWoiLCJ6aSIsInpqIiwieGkiLCJ4aiIsInRpIiwidGoiLCJDT1JSIiwiZml4ZWQiLCJob3Jpem9udGFsIiwiR3JpZFNhbXBsZXIiLCJjaGVja0FuZE51ZGdlUG9pbnRzIiwibnVkZ2VkIiwiUGVyc3BlY3RpdmVUcmFuc2Zvcm0iLCJhMTEiLCJhMjEiLCJhMzEiLCJhMTIiLCJhMjIiLCJhMzIiLCJhMTMiLCJhMjMiLCJhMzMiLCJxdWFkcmlsYXRlcmFsVG9RdWFkcmlsYXRlcmFsIiwieDAiLCJ5MCIsIngxIiwieTEiLCJ4MiIsInkyIiwieDMiLCJ5MyIsIngwcCIsInkwcCIsIngxcCIsInkxcCIsIngycCIsInkycCIsIngzcCIsInkzcCIsInFUb1MiLCJxdWFkcmlsYXRlcmFsVG9TcXVhcmUiLCJzVG9RIiwic3F1YXJlVG9RdWFkcmlsYXRlcmFsIiwidGltZXMiLCJ0cmFuc2Zvcm1Qb2ludHMiLCJ0cmFuc2Zvcm1Qb2ludHNXaXRoVmFsdWVzIiwieFZhbHVlcyIsInlWYWx1ZXMiLCJkeDMiLCJkeTMiLCJkeDEiLCJkeDIiLCJkeTEiLCJkeTIiLCJidWlsZEFkam9pbnQiLCJEZWZhdWx0R3JpZFNhbXBsZXIiLCJzYW1wbGVHcmlkIiwiZGltZW5zaW9uWCIsImRpbWVuc2lvblkiLCJwMVRvWCIsInAxVG9ZIiwicDJUb1giLCJwMlRvWSIsInAzVG9YIiwicDNUb1kiLCJwNFRvWCIsInA0VG9ZIiwicDFGcm9tWCIsInAxRnJvbVkiLCJwMkZyb21YIiwicDJGcm9tWSIsInAzRnJvbVgiLCJwM0Zyb21ZIiwicDRGcm9tWCIsInA0RnJvbVkiLCJ0cmFuc2Zvcm0iLCJzYW1wbGVHcmlkV2l0aFRyYW5zZm9ybSIsIkZsb2F0MzJBcnJheSIsImlWYWx1ZSIsImFpb29iZSIsIkdyaWRTYW1wbGVySW5zdGFuY2UiLCJzZXRHcmlkU2FtcGxlciIsIm5ld0dyaWRTYW1wbGVyIiwiZ3JpZFNhbXBsZXIiLCJnZXRJbnN0YW5jZSIsIlBvaW50IiwidG9SZXN1bHRQb2ludCIsIkRldGVjdG9yIiwiRVhQRUNURURfQ09STkVSX0JJVFMiLCJkZXRlY3RNaXJyb3IiLCJpc01pcnJvciIsInBDZW50ZXIiLCJnZXRNYXRyaXhDZW50ZXIiLCJidWxsc0V5ZUNvcm5lcnMiLCJnZXRCdWxsc0V5ZUNvcm5lcnMiLCJleHRyYWN0UGFyYW1ldGVycyIsInNoaWZ0IiwiY29ybmVycyIsImdldE1hdHJpeENvcm5lclBvaW50cyIsIm5iRGF0YUJsb2NrcyIsImlzVmFsaWRQb2ludCIsIm5iQ2VudGVyTGF5ZXJzIiwic2lkZXMiLCJzYW1wbGVMaW5lIiwiZ2V0Um90YXRpb24iLCJwYXJhbWV0ZXJEYXRhIiwic2lkZSIsImNvcnJlY3RlZERhdGEiLCJnZXRDb3JyZWN0ZWRQYXJhbWV0ZXJEYXRhIiwiY29ybmVyQml0cyIsImlkeCIsIm51bUVDQ29kZXdvcmRzIiwicGFyYW1ldGVyV29yZHMiLCJpZ25vcmVkIiwicGluYSIsInBpbmIiLCJwaW5jIiwicGluZCIsImNvbG9yIiwicG91dGEiLCJnZXRGaXJzdERpZmZlcmVudCIsInBvdXRiIiwicG91dGMiLCJwb3V0ZCIsImRpc3RhbmNlUG9pbnQiLCJpc1doaXRlT3JCbGFja1JlY3RhbmdsZSIsInBpbmF4IiwicGluYngiLCJwaW5jeCIsInBpbmR4IiwiZXhwYW5kU3F1YXJlIiwicG9pbnREIiwiY29ybmVyUG9pbnRzIiwiY3giLCJjeSIsImdldERpbWVuc2lvbiIsInRvcExlZnQiLCJ0b3BSaWdodCIsImJvdHRvbVJpZ2h0IiwiYm90dG9tTGVmdCIsInNhbXBsZXIiLCJkaW1lbnNpb24iLCJkaXN0YW5jZVJlc3VsdFBvaW50IiwibW9kdWxlU2l6ZSIsInB4IiwicHkiLCJjb3JyIiwiY0luaXQiLCJnZXRDb2xvciIsImVycm9yIiwiY29sb3JNb2RlbCIsImlNYXgiLCJlcnJSYXRpbyIsImluaXQiLCJpc1ZhbGlkIiwib2xkU2lkZSIsIm5ld1NpZGUiLCJyYXRpbyIsImNlbnRlcngiLCJjZW50ZXJ5IiwicmVzdWx0MCIsInJlc3VsdDIiLCJyZXN1bHQxIiwicmVzdWx0MyIsInJlc3VsdHMiLCJwb2ludCIsIkF6dGVjUmVhZGVyIiwiZXhjZXB0aW9uIiwiZGV0ZWN0b3IiLCJyZXBvcnRGb3VuZFJlc3VsdFBvaW50cyIsIkFaVEVDIiwiQllURV9TRUdNRU5UUyIsIkVSUk9SX0NPUlJFQ1RJT05fTEVWRUwiLCJycGNiIiwiTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0siLCJmb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQiLCJCcm93c2VyQXp0ZWNDb2RlUmVhZGVyIiwiT25lRFJlYWRlciIsImRvRGVjb2RlIiwibmZlIiwidHJ5SGFyZGVyIiwiVFJZX0hBUkRFUiIsInJvdGF0ZWRJbWFnZSIsIm9yaWVudGF0aW9uIiwiT1JJRU5UQVRJT04iLCJyb3dTdGVwIiwibWF4TGluZXMiLCJtaWRkbGUiLCJyb3dTdGVwc0Fib3ZlT3JCZWxvdyIsImlzQWJvdmUiLCJyb3dOdW1iZXIiLCJhdHRlbXB0IiwibmV3SGludHMiLCJoaW50Iiwia2V5IiwiZGVsZXRlIiwiZGVjb2RlUm93IiwicmUiLCJyZWNvcmRQYXR0ZXJuIiwiY291bnRlcnMiLCJudW1Db3VudGVycyIsImlzV2hpdGUiLCJjb3VudGVyUG9zaXRpb24iLCJyZWNvcmRQYXR0ZXJuSW5SZXZlcnNlIiwibnVtVHJhbnNpdGlvbnNMZWZ0IiwibGFzdCIsInBhdHRlcm5NYXRjaFZhcmlhbmNlIiwicGF0dGVybiIsIm1heEluZGl2aWR1YWxWYXJpYW5jZSIsInRvdGFsIiwicGF0dGVybkxlbmd0aCIsIlBPU0lUSVZFX0lORklOSVRZIiwidW5pdEJhcldpZHRoIiwidG90YWxWYXJpYW5jZSIsImNvdW50ZXIiLCJzY2FsZWRQYXR0ZXJuIiwidmFyaWFuY2UiLCJDb2RlMTI4UmVhZGVyIiwiZmluZFN0YXJ0UGF0dGVybiIsInBhdHRlcm5TdGFydCIsImJlc3RWYXJpYW5jZSIsIk1BWF9BVkdfVkFSSUFOQ0UiLCJiZXN0TWF0Y2giLCJzdGFydENvZGUiLCJDT0RFX1NUQVJUX0EiLCJDT0RFX1NUQVJUX0MiLCJDT0RFX1BBVFRFUk5TIiwiTUFYX0lORElWSURVQUxfVkFSSUFOQ0UiLCJkZWNvZGVDb2RlIiwiY29udmVydEZOQzEiLCJBU1NVTUVfR1MxIiwic3RhcnRQYXR0ZXJuSW5mbyIsImN1cnJlbnRSYXdDb2Rlc0luZGV4IiwicmF3Q29kZXMiLCJjb2RlU2V0IiwiQ09ERV9DT0RFX0EiLCJDT0RFX1NUQVJUX0IiLCJDT0RFX0NPREVfQiIsIkNPREVfQ09ERV9DIiwiaXNOZXh0U2hpZnRlZCIsImxhc3RTdGFydCIsIm5leHRTdGFydCIsImxhc3RDb2RlIiwiY2hlY2tzdW1Ub3RhbCIsIm11bHRpcGxpZXIiLCJsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlIiwidXBwZXJNb2RlIiwic2hpZnRVcHBlck1vZGUiLCJ1bnNoaWZ0IiwiQ09ERV9TVE9QIiwicmVkdWNlIiwicHJldmlvdXMiLCJjdXJyZW50IiwiQ09ERV9GTkNfMSIsIkNPREVfRk5DXzIiLCJDT0RFX0ZOQ18zIiwiQ09ERV9GTkNfNF9BIiwiQ09ERV9TSElGVCIsIkNPREVfRk5DXzRfQiIsImxhc3RQYXR0ZXJuU2l6ZSIsInJlc3VsdExlbmd0aCIsInJhd0NvZGVzU2l6ZSIsIkNPREVfMTI4IiwiZ2V0VGltZSIsIkNvZGUzOVJlYWRlciIsInVzaW5nQ2hlY2tEaWdpdCIsImV4dGVuZGVkTW9kZSIsImRlY29kZVJvd1Jlc3VsdCIsInRoZUNvdW50ZXJzIiwiZmluZEFzdGVyaXNrUGF0dGVybiIsImRlY29kZWRDaGFyIiwidG9OYXJyb3dXaWRlUGF0dGVybiIsInBhdHRlcm5Ub0NoYXIiLCJ3aGl0ZVNwYWNlQWZ0ZXJFbmQiLCJBTFBIQUJFVF9TVFJJTkciLCJpbmRleE9mIiwicmVzdWx0U3RyaW5nIiwiZGVjb2RlRXh0ZW5kZWQiLCJDT0RFXzM5IiwiQVNURVJJU0tfRU5DT0RJTkciLCJjb3B5V2l0aGluIiwibWF4TmFycm93Q291bnRlciIsIndpZGVDb3VudGVycyIsIm1pbkNvdW50ZXIiLCJ0b3RhbFdpZGVDb3VudGVyc1dpZHRoIiwiQ0hBUkFDVEVSX0VOQ09ESU5HUyIsImVuY29kZWQiLCJkZWNvZGVkIiwiSVRGUmVhZGVyIiwiYXJndW1lbnRzIiwibmFycm93TGluZVdpZHRoIiwic3RhcnRSYW5nZSIsImRlY29kZVN0YXJ0IiwiZW5kUmFuZ2UiLCJkZWNvZGVFbmQiLCJkZWNvZGVNaWRkbGUiLCJhbGxvd2VkTGVuZ3RocyIsIkFMTE9XRURfTEVOR1RIUyIsIkRFRkFVTFRfQUxMT1dFRF9MRU5HVEhTIiwibGVuZ3RoT0siLCJtYXhBbGxvd2VkTGVuZ3RoIiwicmVzdWx0UmV0dXJuIiwiSVRGIiwicGF5bG9hZFN0YXJ0IiwicGF5bG9hZEVuZCIsImNvdW50ZXJEaWdpdFBhaXIiLCJjb3VudGVyQmxhY2siLCJjb3VudGVyV2hpdGUiLCJ0d29LIiwiZGVjb2RlRGlnaXQiLCJjb3VudGVyRGlnaXQiLCJlbmRTdGFydCIsInNraXBXaGl0ZVNwYWNlIiwic3RhcnRQYXR0ZXJuIiwiZmluZEd1YXJkUGF0dGVybiIsIlNUQVJUX1BBVFRFUk4iLCJ2YWxpZGF0ZVF1aWV0Wm9uZSIsInF1aWV0Q291bnQiLCJlbmRQYXR0ZXJuIiwiRU5EX1BBVFRFUk5fUkVWRVJTRUQiLCJQQVRURVJOUyIsIkFic3RyYWN0VVBDRUFOUmVhZGVyIiwiZGVjb2RlUm93U3RyaW5nQnVmZmVyIiwiZmluZFN0YXJ0R3VhcmRQYXR0ZXJuIiwiZm91bmRTdGFydCIsIlNUQVJUX0VORF9QQVRURVJOIiwicXVpZXRTdGFydCIsImNoZWNrQ2hlY2tzdW0iLCJjaGVja1N0YW5kYXJkVVBDRUFOQ2hlY2tzdW0iLCJjaGVjayIsImdldFN0YW5kYXJkVVBDRUFOQ2hlY2tzdW0iLCJkaWdpdCIsImZpbmRHdWFyZFBhdHRlcm5XaXRob3V0Q291bnRlcnMiLCJ3aGl0ZUZpcnN0IiwiTUlERExFX1BBVFRFUk4iLCJFTkRfUEFUVEVSTiIsIkxfUEFUVEVSTlMiLCJVUENFQU5FeHRlbnNpb241U3VwcG9ydCIsIkNIRUNLX0RJR0lUX0VOQ09ESU5HUyIsImRlY29kZU1pZGRsZUNvdW50ZXJzIiwiZXh0ZW5zaW9uU3RhcnRSYW5nZSIsImV4dGVuc2lvbkRhdGEiLCJwYXJzZUV4dGVuc2lvblN0cmluZyIsImV4dGVuc2lvblJlc3VsdCIsIlVQQ19FQU5fRVhURU5TSU9OIiwibGdQYXR0ZXJuRm91bmQiLCJMX0FORF9HX1BBVFRFUk5TIiwiY2hlY2tEaWdpdCIsImRldGVybWluZUNoZWNrRGlnaXQiLCJleHRlbnNpb25DaGVja3N1bSIsInJhdyIsInBhcnNlRXh0ZW5zaW9uNVN0cmluZyIsIlNVR0dFU1RFRF9QUklDRSIsImN1cnJlbmN5IiwicmF3QW1vdW50IiwidW5pdHNTdHJpbmciLCJodW5kcmVkdGhzIiwiaHVuZHJlZHRoc1N0cmluZyIsIlVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0IiwiY2hlY2tQYXJpdHkiLCJJU1NVRV9OVU1CRVIiLCJVUENFQU5FeHRlbnNpb25TdXBwb3J0IiwiRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4iLCJmaXZlU3VwcG9ydCIsInR3b1N1cHBvcnQiLCJVUENFQU5SZWFkZXIiLCJ3aWR0aHMiLCJyZXZlcnNlZFdpZHRocyIsInN0YXJ0R3VhcmRSYW5nZSIsInJlc3VsdFBvaW50Q2FsbGJhY2siLCJyZXN1bHRQb2ludCIsImJ1ZGVsbG8iLCJxdWlldEVuZCIsImRlY29kZVJlc3VsdCIsImV4dGVuc2lvbkxlbmd0aCIsImlnbm9yZUVycm9yIiwiYWxsb3dlZEV4dGVuc2lvbnMiLCJBTExPV0VEX0VBTl9FWFRFTlNJT05TIiwidmFsaWQiLCJFQU4xM1JlYWRlciIsImRldGVybWluZUZpcnN0RGlnaXQiLCJtaWRkbGVSYW5nZSIsIkVBTl8xMyIsIkZJUlNUX0RJR0lUX0VOQ09ESU5HUyIsIkVBTjhSZWFkZXIiLCJFQU5fOCIsIlVQQ0FSZWFkZXIiLCJlYW4xM1JlYWRlciIsIlVQQ19BIiwibWF5YmVSZXR1cm5SZXN1bHQiLCJ1cGNhUmVzdWx0IiwiVVBDRVJlYWRlciIsImRldGVybWluZU51bVN5c0FuZENoZWNrRGlnaXQiLCJNSURETEVfRU5EX1BBVFRFUk4iLCJjb252ZXJ0VVBDRXRvVVBDQSIsIm51bVN5cyIsIk5VTVNZU19BTkRfQ0hFQ0tfRElHSVRfUEFUVEVSTlMiLCJwcmVmaXgiLCJzdWZmaXgiLCJVUENfRSIsInVwY2UiLCJ1cGNlQ2hhcnMiLCJsYXN0Q2hhciIsIk11bHRpRm9ybWF0VVBDRUFOUmVhZGVyIiwicG9zc2libGVGb3JtYXRzIiwiUE9TU0lCTEVfRk9STUFUUyIsInJlYWRlcnMiLCJlYW4xM01heUJlVVBDQSIsImNhblJldHVyblVQQ0EiLCJpbmNsdWRlcyIsInJlc3VsdFVQQ0EiLCJBYnN0cmFjdFJTU1JlYWRlciIsImRlY29kZUZpbmRlckNvdW50ZXJzIiwiZGF0YUNoYXJhY3RlckNvdW50ZXJzIiwib2RkUm91bmRpbmdFcnJvcnMiLCJldmVuUm91bmRpbmdFcnJvcnMiLCJvZGRDb3VudHMiLCJldmVuQ291bnRzIiwiZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMiLCJnZXREYXRhQ2hhcmFjdGVyQ291bnRlcnMiLCJnZXRPZGRSb3VuZGluZ0Vycm9ycyIsImdldEV2ZW5Sb3VuZGluZ0Vycm9ycyIsImdldE9kZENvdW50cyIsImdldEV2ZW5Db3VudHMiLCJwYXJzZUZpbmRlclZhbHVlIiwiZmluZGVyUGF0dGVybnMiLCJpbmNyZW1lbnQiLCJlcnJvcnMiLCJiaWdnZXN0RXJyb3IiLCJkZWNyZW1lbnQiLCJpc0ZpbmRlclBhdHRlcm4iLCJmaXJzdFR3b1N1bSIsIk1JTl9GSU5ERVJfUEFUVEVSTl9SQVRJTyIsIk1BWF9GSU5ERVJfUEFUVEVSTl9SQVRJTyIsIm1heENvdW50ZXIiLCJEYXRhQ2hhcmFjdGVyIiwiY2hlY2tzdW1Qb3J0aW9uIiwiZ2V0Q2hlY2tzdW1Qb3J0aW9uIiwidGhhdCIsIkZpbmRlclBhdHRlcm4iLCJzdGFydEVuZCIsImdldFN0YXJ0RW5kIiwiUlNTVXRpbHMiLCJnZXRSU1N2YWx1ZSIsIm1heFdpZHRoIiwibm9OYXJyb3ciLCJuYXJyb3dNYXNrIiwiZWxlbWVudHMiLCJiYXIiLCJlbG1XaWR0aCIsInN1YlZhbCIsImNvbWJpbnMiLCJsZXNzVmFsIiwibXh3RWxlbWVudCIsIm1heERlbm9tIiwibWluRGVub20iLCJCaXRBcnJheUJ1aWxkZXIiLCJidWlsZEJpdEFycmF5IiwicGFpcnMiLCJjaGFyTnVtYmVyIiwiZ2V0UmlnaHRDaGFyIiwiYmluYXJ5IiwiYWNjUG9zIiwiZmlyc3RQYWlyIiwiZmlyc3RWYWx1ZSIsImN1cnJlbnRQYWlyIiwibGVmdFZhbHVlIiwiZ2V0TGVmdENoYXIiLCJyaWdodFZhbHVlIiwiQmxvY2tQYXJzZWRSZXN1bHQiLCJmaW5pc2hlZCIsImRlY29kZWRJbmZvcm1hdGlvbiIsImdldERlY29kZWRJbmZvcm1hdGlvbiIsImlzRmluaXNoZWQiLCJEZWNvZGVkT2JqZWN0IiwibmV3UG9zaXRpb24iLCJnZXROZXdQb3NpdGlvbiIsIkRlY29kZWRDaGFyIiwiaXNGTkMxIiwiRk5DMSIsIkRlY29kZWRJbmZvcm1hdGlvbiIsIm5ld1N0cmluZyIsInJlbWFpbmluZ1ZhbHVlIiwicmVtYWluaW5nIiwiZ2V0TmV3U3RyaW5nIiwiaXNSZW1haW5pbmciLCJnZXRSZW1haW5pbmdWYWx1ZSIsIkRlY29kZWROdW1lcmljIiwiZmlyc3REaWdpdCIsInNlY29uZERpZ2l0IiwiZ2V0Rmlyc3REaWdpdCIsImdldFNlY29uZERpZ2l0IiwiaXNGaXJzdERpZ2l0Rk5DMSIsImlzU2Vjb25kRGlnaXRGTkMxIiwiaXNBbnlGTkMxIiwiRmllbGRQYXJzZXIiLCJwYXJzZUZpZWxkc0luR2VuZXJhbFB1cnBvc2UiLCJyYXdJbmZvcm1hdGlvbiIsImZpcnN0VHdvRGlnaXRzIiwiZGF0YUxlbmd0aCIsIlRXT19ESUdJVF9EQVRBX0xFTkdUSCIsIlZBUklBQkxFX0xFTkdUSCIsInByb2Nlc3NWYXJpYWJsZUFJIiwicHJvY2Vzc0ZpeGVkQUkiLCJmaXJzdFRocmVlRGlnaXRzIiwiVEhSRUVfRElHSVRfREFUQV9MRU5HVEgiLCJUSFJFRV9ESUdJVF9QTFVTX0RJR0lUX0RBVEFfTEVOR1RIIiwiZmlyc3RGb3VyRGlnaXRzIiwiRk9VUl9ESUdJVF9EQVRBX0xFTkdUSCIsImFpU2l6ZSIsImZpZWxkU2l6ZSIsImFpIiwicGFyc2VkQUkiLCJ2YXJpYWJsZUZpZWxkU2l6ZSIsIkdlbmVyYWxBcHBJZERlY29kZXIiLCJpbmZvcm1hdGlvbiIsImRlY29kZUFsbENvZGVzIiwiYnVmZiIsImluaXRpYWxQb3NpdGlvbiIsImN1cnJlbnRQb3NpdGlvbiIsImluZm8iLCJkZWNvZGVHZW5lcmFsUHVycG9zZUZpZWxkIiwicGFyc2VkRmllbGRzIiwiaXNTdGlsbE51bWVyaWMiLCJkZWNvZGVOdW1lcmljIiwibnVtZXJpYyIsImV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkiLCJkaWdpdDEiLCJkaWdpdDIiLCJzZXRQb3NpdGlvbiIsImxhc3REZWNvZGVkIiwicGFyc2VCbG9ja3MiLCJnZXRQb3NpdGlvbiIsImlzQWxwaGEiLCJwYXJzZUFscGhhQmxvY2siLCJpc0lzb0llYzY0NiIsInBhcnNlSXNvSWVjNjQ2QmxvY2siLCJwYXJzZU51bWVyaWNCbG9jayIsInBvc2l0aW9uQ2hhbmdlZCIsImlzTnVtZXJpY1RvQWxwaGFOdW1lcmljTGF0Y2giLCJzZXRBbHBoYSIsImluY3JlbWVudFBvc2l0aW9uIiwiaXNTdGlsbElzb0llYzY0NiIsImlzbyIsImRlY29kZUlzb0llYzY0NiIsImlzQWxwaGFPcjY0NlRvTnVtZXJpY0xhdGNoIiwic2V0TnVtZXJpYyIsImlzQWxwaGFUbzY0NlRvQWxwaGFMYXRjaCIsImlzU3RpbGxBbHBoYSIsImRlY29kZUFscGhhbnVtZXJpYyIsInNldElzb0llYzY0NiIsImZpdmVCaXRWYWx1ZSIsInNldmVuQml0VmFsdWUiLCJlaWdodEJpdFZhbHVlIiwic2l4Qml0VmFsdWUiLCJBYnN0cmFjdEV4cGFuZGVkRGVjb2RlciIsImdlbmVyYWxEZWNvZGVyIiwiZ2V0SW5mb3JtYXRpb24iLCJnZXRHZW5lcmFsRGVjb2RlciIsIkFJMDFkZWNvZGVyIiwiZW5jb2RlQ29tcHJlc3NlZEd0aW4iLCJidWYiLCJjdXJyZW50UG9zIiwiZW5jb2RlQ29tcHJlc3NlZEd0aW5XaXRob3V0QUkiLCJpbml0aWFsQnVmZmVyUG9zaXRpb24iLCJjdXJyZW50QmxvY2siLCJhcHBlbmRDaGVja0RpZ2l0IiwiR1RJTl9TSVpFIiwiQUkwMUFuZE90aGVyQUlzIiwicGFyc2VJbmZvcm1hdGlvbiIsImluaXRpYWxHdGluUG9zaXRpb24iLCJmaXJzdEd0aW5EaWdpdCIsIkhFQURFUl9TSVpFIiwiQW55QUlEZWNvZGVyIiwiQUkwMXdlaWdodERlY29kZXIiLCJlbmNvZGVDb21wcmVzc2VkV2VpZ2h0Iiwid2VpZ2h0U2l6ZSIsIm9yaWdpbmFsV2VpZ2h0TnVtZXJpYyIsImFkZFdlaWdodENvZGUiLCJ3ZWlnaHROdW1lcmljIiwiY2hlY2tXZWlnaHQiLCJjdXJyZW50RGl2aXNvciIsIkFJMDEzeDB4RGVjb2RlciIsIldFSUdIVF9TSVpFIiwiQUkwMTMxMDNkZWNvZGVyIiwid2VpZ2h0IiwiQUkwMTMyMHhEZWNvZGVyIiwiQUkwMTM5MnhEZWNvZGVyIiwibGFzdEFJZGlnaXQiLCJMQVNUX0RJR0lUX1NJWkUiLCJBSTAxMzkzeERlY29kZXIiLCJGSVJTVF9USFJFRV9ESUdJVFNfU0laRSIsImdlbmVyYWxJbmZvcm1hdGlvbiIsIkFJMDEzeDB4MXhEZWNvZGVyIiwiZmlyc3RBSWRpZ2l0cyIsImRhdGVDb2RlIiwiREFURV9TSVpFIiwiZW5jb2RlQ29tcHJlc3NlZERhdGUiLCJudW1lcmljRGF0ZSIsImRheSIsIm1vbnRoIiwieWVhciIsImNyZWF0ZURlY29kZXIiLCJmb3VyQml0RW5jb2RhdGlvbk1ldGhvZCIsImZpdmVCaXRFbmNvZGF0aW9uTWV0aG9kIiwic2V2ZW5CaXRFbmNvZGF0aW9uTWV0aG9kIiwiRXhwYW5kZWRQYWlyIiwibGVmdENoYXIiLCJyaWdodENoYXIiLCJmaW5kZXJQYXR0ZXIiLCJtYXlCZUxhc3QiLCJsZWZ0Y2hhciIsInJpZ2h0Y2hhciIsImZpbmRlcnBhdHRlcm4iLCJtYXliZUxhc3QiLCJnZXRGaW5kZXJQYXR0ZXJuIiwibXVzdEJlTGFzdCIsIm8xIiwibzIiLCJlcXVhbHNPck51bGwiLCJFeHBhbmRlZFJvdyIsIndhc1JldmVyc2VkIiwiZ2V0UGFpcnMiLCJnZXRSb3dOdW1iZXIiLCJpc1JldmVyc2VkIiwiaXNFcXVpdmFsZW50Iiwib3RoZXJQYWlycyIsImNoZWNrRXF1YWxpdGl0eSIsInBhaXIxIiwicGFpcjIiLCJlMSIsImUyIiwiZ2V0RmluZGVyUGF0dGVyIiwiUlNTRXhwYW5kZWRSZWFkZXIiLCJ2ZXJib3NlIiwiTUFYX1BBSVJTIiwic3RhcnRGcm9tRXZlbiIsImNvbnN0cnVjdFJlc3VsdCIsImRlY29kZVJvdzJwYWlycyIsInJldHJpZXZlTmV4dFBhaXIiLCJ0cnlTdGFja2VkRGVjb2RlIiwic3RvcmVSb3ciLCJwcyIsImNoZWNrUm93c0Jvb2xlYW4iLCJjaGVja1Jvd3MiLCJjb2xsZWN0ZWRSb3dzIiwiY3VycmVudFJvdyIsImNvbGxlY3RlZFJvdyIsImlzVmFsaWRTZXF1ZW5jZSIsInJzIiwic2VxdWVuY2UiLCJGSU5ERVJfUEFUVEVSTl9TRVFVRU5DRVMiLCJpbnNlcnRQb3MiLCJwcmV2SXNTYW1lIiwibmV4dElzU2FtZSIsImVyb3ciLCJpc1BhcnRpYWxSb3ciLCJyZW1vdmVQYXJ0aWFsUm93cyIsInBwIiwiYWxsRm91bmQiLCJmb3VuZCIsImdldFJvd3MiLCJkZWNvZGVyIiwicmVzdWx0aW5nU3RyaW5nIiwiZmlyc3RQb2ludHMiLCJsYXN0UG9pbnRzIiwiUlNTX0VYUEFOREVEIiwiY2hlY2tDaGFyYWN0ZXIiLCJmaXJzdENoYXJhY3RlciIsImNoZWNrc3VtIiwiY3VycmVudFJpZ2h0Q2hhciIsImNoZWNrQ2hhcmFjdGVyVmFsdWUiLCJnZXROZXh0U2Vjb25kQmFyIiwiaW5pdGlhbFBvcyIsInByZXZpb3VzUGFpcnMiLCJpc09kZFBhdHRlcm4iLCJrZWVwRmluZGluZyIsImZvcmNlZE9mZnNldCIsImZpbmROZXh0UGFpciIsInBhcnNlRm91bmRGaW5kZXJQYXR0ZXJuIiwiZGVjb2RlRGF0YUNoYXJhY3RlciIsImlzRW1wdHlQYWlyIiwibGFzdFBhaXIiLCJzZWFyY2hpbmdFdmVuUGFpciIsInJldmVyc2VDb3VudGVycyIsInRtcCIsIm9kZFBhdHRlcm4iLCJmaXJzdENvdW50ZXIiLCJmaXJzdEVsZW1lbnRTdGFydCIsIkZJTkRFUl9QQVRURVJOUyIsIm51bU1vZHVsZXMiLCJlbGVtZW50V2lkdGgiLCJleHBlY3RlZEVsZW1lbnRXaWR0aCIsImFkanVzdE9kZEV2ZW5Db3VudHMiLCJ3ZWlnaHRSb3dOdW1iZXIiLCJvZGRTdW0iLCJvZGRDaGVja3N1bVBvcnRpb24iLCJpc05vdEExbGVmdCIsIldFSUdIVFMiLCJldmVuQ2hlY2tzdW1Qb3J0aW9uIiwiZ3JvdXAiLCJvZGRXaWRlc3QiLCJTWU1CT0xfV0lERVNUIiwiZXZlbldpZGVzdCIsInZPZGQiLCJ2RXZlbiIsInRFdmVuIiwiRVZFTl9UT1RBTF9TVUJTRVQiLCJnU3VtIiwiR1NVTSIsImV2ZW5TdW0iLCJpbmNyZW1lbnRPZGQiLCJkZWNyZW1lbnRPZGQiLCJpbmNyZW1lbnRFdmVuIiwiZGVjcmVtZW50RXZlbiIsIm1pc21hdGNoIiwib2RkUGFyaXR5QmFkIiwiZXZlblBhcml0eUJhZCIsIkZJTkRFUl9QQVRfQSIsIkZJTkRFUl9QQVRfQiIsIkZJTkRFUl9QQVRfQyIsIkZJTkRFUl9QQVRfRCIsIkZJTkRFUl9QQVRfRSIsIkZJTkRFUl9QQVRfRiIsIlBhaXIiLCJmaW5kZXJQYXR0ZXJuIiwiZ2V0Q291bnQiLCJpbmNyZW1lbnRDb3VudCIsIlJTUzE0UmVhZGVyIiwicG9zc2libGVMZWZ0UGFpcnMiLCJwb3NzaWJsZVJpZ2h0UGFpcnMiLCJsZWZ0UGFpciIsImRlY29kZVBhaXIiLCJhZGRPclRhbGx5IiwicmlnaHRQYWlyIiwicG9zc2libGVQYWlycyIsInBhaXIiLCJzeW1ib2xWYWx1ZSIsImxlZnRQb2ludHMiLCJyaWdodFBvaW50cyIsIlJTU18xNCIsImNoZWNrVmFsdWUiLCJ0YXJnZXRDaGVja1ZhbHVlIiwiZmluZEZpbmRlclBhdHRlcm4iLCJvdXRzaWRlIiwiaW5zaWRlIiwib3V0c2lkZUNoYXIiLCJPVVRTSURFX09ERF9XSURFU1QiLCJPVVRTSURFX0VWRU5fVE9UQUxfU1VCU0VUIiwiT1VUU0lERV9HU1VNIiwiSU5TSURFX09ERF9XSURFU1QiLCJ0T2RkIiwiSU5TSURFX09ERF9UT1RBTF9TVUJTRVQiLCJJTlNJREVfR1NVTSIsInJpZ2h0RmluZGVyUGF0dGVybiIsImZpcnN0SXNCbGFjayIsIk11bHRpRm9ybWF0T25lRFJlYWRlciIsInVzZUNvZGUzOUNoZWNrRGlnaXQiLCJBU1NVTUVfQ09ERV8zOV9DSEVDS19ESUdJVCIsIkJyb3dzZXJCYXJjb2RlUmVhZGVyIiwiRUNCbG9ja3MiLCJlY0NvZGV3b3JkcyIsImVjQmxvY2tzMSIsImVjQmxvY2tzMiIsImVjQmxvY2tzIiwiZ2V0RUNDb2Rld29yZHMiLCJnZXRFQ0Jsb2NrcyIsIkVDQiIsImRhdGFDb2Rld29yZHMiLCJnZXREYXRhQ29kZXdvcmRzIiwiVmVyc2lvbiIsInZlcnNpb25OdW1iZXIiLCJzeW1ib2xTaXplUm93cyIsInN5bWJvbFNpemVDb2x1bW5zIiwiZGF0YVJlZ2lvblNpemVSb3dzIiwiZGF0YVJlZ2lvblNpemVDb2x1bW5zIiwiZWNiQXJyYXkiLCJlY0Jsb2NrIiwidG90YWxDb2Rld29yZHMiLCJnZXRWZXJzaW9uTnVtYmVyIiwiZ2V0U3ltYm9sU2l6ZVJvd3MiLCJnZXRTeW1ib2xTaXplQ29sdW1ucyIsImdldERhdGFSZWdpb25TaXplUm93cyIsImdldERhdGFSZWdpb25TaXplQ29sdW1ucyIsImdldFRvdGFsQ29kZXdvcmRzIiwiZ2V0VmVyc2lvbkZvckRpbWVuc2lvbnMiLCJudW1Sb3dzIiwibnVtQ29sdW1ucyIsInZlcnNpb24iLCJWRVJTSU9OUyIsImJ1aWxkVmVyc2lvbnMiLCJCaXRNYXRyaXhQYXJzZXIiLCJiaXRNYXRyaXgiLCJyZWFkVmVyc2lvbiIsIm1hcHBpbmdCaXRNYXRyaXgiLCJleHRyYWN0RGF0YVJlZ2lvbiIsInJlYWRNYXBwaW5nTWF0cml4IiwiZ2V0VmVyc2lvbiIsInJlYWRDb2Rld29yZHMiLCJJbnQ4QXJyYXkiLCJyZXN1bHRPZmZzZXQiLCJjb2x1bW4iLCJjb3JuZXIxUmVhZCIsImNvcm5lcjJSZWFkIiwiY29ybmVyM1JlYWQiLCJjb3JuZXI0UmVhZCIsInJlYWRDb3JuZXIxIiwicmVhZENvcm5lcjIiLCJyZWFkQ29ybmVyMyIsInJlYWRDb3JuZXI0IiwicmVhZFV0YWgiLCJyZWFkTW9kdWxlIiwiY3VycmVudEJ5dGUiLCJudW1EYXRhUmVnaW9uc1JvdyIsIm51bURhdGFSZWdpb25zQ29sdW1uIiwic2l6ZURhdGFSZWdpb25Sb3ciLCJzaXplRGF0YVJlZ2lvbkNvbHVtbiIsImJpdE1hdHJpeFdpdGhvdXRBbGlnbm1lbnQiLCJkYXRhUmVnaW9uUm93IiwiZGF0YVJlZ2lvblJvd09mZnNldCIsImRhdGFSZWdpb25Db2x1bW4iLCJkYXRhUmVnaW9uQ29sdW1uT2Zmc2V0IiwicmVhZFJvd09mZnNldCIsIndyaXRlUm93T2Zmc2V0IiwicmVhZENvbHVtbk9mZnNldCIsIndyaXRlQ29sdW1uT2Zmc2V0IiwiRGF0YUJsb2NrIiwiY29kZXdvcmRzIiwiZ2V0RGF0YUJsb2NrcyIsInJhd0NvZGV3b3JkcyIsInRvdGFsQmxvY2tzIiwiZWNCbG9ja0FycmF5IiwibnVtUmVzdWx0QmxvY2tzIiwibnVtQmxvY2tDb2Rld29yZHMiLCJsb25nZXJCbG9ja3NUb3RhbENvZGV3b3JkcyIsImxvbmdlckJsb2Nrc051bURhdGFDb2Rld29yZHMiLCJzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyIsInJhd0NvZGV3b3Jkc09mZnNldCIsInNwZWNpYWxWZXJzaW9uIiwibnVtTG9uZ2VyQmxvY2tzIiwiak9mZnNldCIsImlPZmZzZXQiLCJnZXROdW1EYXRhQ29kZXdvcmRzIiwiZ2V0Q29kZXdvcmRzIiwiQml0U291cmNlIiwiYnl0ZU9mZnNldCIsImdldEJpdE9mZnNldCIsImdldEJ5dGVPZmZzZXQiLCJyZWFkQml0cyIsImF2YWlsYWJsZSIsImJpdHNMZWZ0IiwidG9SZWFkIiwiYml0c1RvTm90UmVhZCIsIk1vZGUiLCJEZWNvZGVkQml0U3RyZWFtUGFyc2VyIiwicmVzdWx0VHJhaWxlciIsIm1vZGUiLCJBU0NJSV9FTkNPREUiLCJkZWNvZGVBc2NpaVNlZ21lbnQiLCJDNDBfRU5DT0RFIiwiZGVjb2RlQzQwU2VnbWVudCIsIlRFWFRfRU5DT0RFIiwiZGVjb2RlVGV4dFNlZ21lbnQiLCJBTlNJWDEyX0VOQ09ERSIsImRlY29kZUFuc2lYMTJTZWdtZW50IiwiRURJRkFDVF9FTkNPREUiLCJkZWNvZGVFZGlmYWN0U2VnbWVudCIsIkJBU0UyNTZfRU5DT0RFIiwiZGVjb2RlQmFzZTI1NlNlZ21lbnQiLCJQQURfRU5DT0RFIiwidXBwZXJTaGlmdCIsIm9uZUJ5dGUiLCJjVmFsdWVzIiwiZmlyc3RCeXRlIiwicGFyc2VUd29CeXRlcyIsImNWYWx1ZSIsIkM0MF9CQVNJQ19TRVRfQ0hBUlMiLCJjNDBjaGFyIiwiQzQwX1NISUZUMl9TRVRfQ0hBUlMiLCJURVhUX0JBU0lDX1NFVF9DSEFSUyIsInRleHRDaGFyIiwiVEVYVF9TSElGVDJfU0VUX0NIQVJTIiwiVEVYVF9TSElGVDNfU0VUX0NIQVJTIiwic2Vjb25kQnl0ZSIsImZ1bGxCaXRWYWx1ZSIsImVkaWZhY3RWYWx1ZSIsImNvZGV3b3JkUG9zaXRpb24iLCJkMSIsInVucmFuZG9taXplMjU1U3RhdGUiLCJ1ZWUiLCJyYW5kb21pemVkQmFzZTI1NkNvZGV3b3JkIiwiYmFzZTI1NkNvZGV3b3JkUG9zaXRpb24iLCJwc2V1ZG9SYW5kb21OdW1iZXIiLCJ0ZW1wVmFyaWFibGUiLCJEZWNvZGVyJDEiLCJwYXJzZXIiLCJkYXRhQmxvY2tzIiwidG90YWxCeXRlcyIsImRiIiwicmVzdWx0Qnl0ZXMiLCJkYXRhQmxvY2tzQ291bnQiLCJkYXRhQmxvY2siLCJjb2Rld29yZEJ5dGVzIiwiY29ycmVjdEVycm9ycyIsImNvZGV3b3Jkc0ludHMiLCJEZXRlY3RvciQxIiwicmVjdGFuZ2xlRGV0ZWN0b3IiLCJkZXRlY3RTb2xpZDEiLCJkZXRlY3RTb2xpZDIiLCJjb3JyZWN0VG9wUmlnaHQiLCJzaGlmdFRvTW9kdWxlQ2VudGVyIiwiZGltZW5zaW9uVG9wIiwidHJhbnNpdGlvbnNCZXR3ZWVuIiwiZGltZW5zaW9uUmlnaHQiLCJzaGlmdFBvaW50IiwiZGl2IiwibW92ZUF3YXkiLCJmcm9tWCIsImZyb21ZIiwidHJBQiIsInRyQkMiLCJ0ckNEIiwidHJEQSIsInRyIiwicG9pbnRCcyIsInBvaW50Q3MiLCJ0ckJBIiwidHJUb3AiLCJ0clJpZ2h0IiwicG9pbnRBcyIsImNhbmRpZGF0ZTEiLCJjYW5kaWRhdGUyIiwic3VtYzEiLCJzdW1jMiIsImRpbUgiLCJkaW1WIiwiY2VudGVyWCIsImNlbnRlclkiLCJwb2ludERzIiwidG9YIiwidG9ZIiwic3RlZXAiLCJ5c3RlcCIsInhzdGVwIiwidHJhbnNpdGlvbnMiLCJpbkJsYWNrIiwiaXNCbGFjayIsIkRhdGFNYXRyaXhSZWFkZXIiLCJoYXMiLCJQVVJFX0JBUkNPREUiLCJleHRyYWN0UHVyZUJpdHMiLCJOT19QT0lOVFMiLCJEQVRBX01BVFJJWCIsImxlZnRUb3BCbGFjayIsInJpZ2h0Qm90dG9tQmxhY2siLCJtYXRyaXhXaWR0aCIsIm1hdHJpeEhlaWdodCIsIm51ZGdlIiwiQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyIiwiRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMiLCJFcnJvckNvcnJlY3Rpb25MZXZlbCIsInN0cmluZ1ZhbHVlIiwiRk9SX0JJVFMiLCJGT1JfVkFMVUUiLCJmcm9tU3RyaW5nIiwiTCIsIk0iLCJRIiwiSCIsImZvckJpdHMiLCJGb3JtYXRJbmZvcm1hdGlvbiIsImZvcm1hdEluZm8iLCJlcnJvckNvcnJlY3Rpb25MZXZlbCIsImRhdGFNYXNrIiwibnVtQml0c0RpZmZlcmluZyIsImRlY29kZUZvcm1hdEluZm9ybWF0aW9uIiwibWFza2VkRm9ybWF0SW5mbzEiLCJtYXNrZWRGb3JtYXRJbmZvMiIsImRvRGVjb2RlRm9ybWF0SW5mb3JtYXRpb24iLCJGT1JNQVRfSU5GT19NQVNLX1FSIiwiYmVzdERpZmZlcmVuY2UiLCJiZXN0Rm9ybWF0SW5mbyIsImRlY29kZUluZm8iLCJGT1JNQVRfSU5GT19ERUNPREVfTE9PS1VQIiwidGFyZ2V0SW5mbyIsImJpdHNEaWZmZXJlbmNlIiwiZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwiLCJnZXREYXRhTWFzayIsIkVDQmxvY2tzJDEiLCJlY0NvZGV3b3Jkc1BlckJsb2NrIiwiZ2V0RUNDb2Rld29yZHNQZXJCbG9jayIsImdldE51bUJsb2NrcyIsImdldFRvdGFsRUNDb2Rld29yZHMiLCJFQ0IkMSIsIlZlcnNpb24kMSIsImFsaWdubWVudFBhdHRlcm5DZW50ZXJzIiwiZ2V0QWxpZ25tZW50UGF0dGVybkNlbnRlcnMiLCJnZXREaW1lbnNpb25Gb3JWZXJzaW9uIiwiZ2V0RUNCbG9ja3NGb3JMZXZlbCIsImdldFByb3Zpc2lvbmFsVmVyc2lvbkZvckRpbWVuc2lvbiIsImdldFZlcnNpb25Gb3JOdW1iZXIiLCJkZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24iLCJ2ZXJzaW9uQml0cyIsImJlc3RWZXJzaW9uIiwiVkVSU0lPTl9ERUNPREVfSU5GTyIsInRhcmdldFZlcnNpb24iLCJidWlsZEZ1bmN0aW9uUGF0dGVybiIsIkRhdGFNYXNrVmFsdWVzIiwiRGF0YU1hc2siLCJpc01hc2tlZCIsInVubWFza0JpdE1hdHJpeCIsIkRBVEFfTUFTS18wMDAiLCJEQVRBX01BU0tfMDAxIiwiREFUQV9NQVNLXzAxMCIsIkRBVEFfTUFTS18wMTEiLCJEQVRBX01BU0tfMTAwIiwiREFUQV9NQVNLXzEwMSIsIkRBVEFfTUFTS18xMTAiLCJEQVRBX01BU0tfMTExIiwiQml0TWF0cml4UGFyc2VyJDEiLCJyZWFkRm9ybWF0SW5mb3JtYXRpb24iLCJwYXJzZWRGb3JtYXRJbmZvIiwiZm9ybWF0SW5mb0JpdHMxIiwiY29weUJpdCIsImZvcm1hdEluZm9CaXRzMiIsImpNaW4iLCJwYXJzZWRWZXJzaW9uIiwicHJvdmlzaW9uYWxWZXJzaW9uIiwiaWpNaW4iLCJ0aGVQYXJzZWRWZXJzaW9uIiwiZnVuY3Rpb25QYXR0ZXJuIiwicmVhZGluZ1VwIiwiYml0c1JlYWQiLCJjb2wiLCJyZW1hc2siLCJzZXRNaXJyb3IiLCJtaXJyb3IiLCJEYXRhQmxvY2skMSIsInNob3J0ZXJCbG9ja3NUb3RhbENvZGV3b3JkcyIsImxvbmdlckJsb2Nrc1N0YXJ0QXQiLCJNb2RlVmFsdWVzIiwiTW9kZSQxIiwiY2hhcmFjdGVyQ291bnRCaXRzRm9yVmVyc2lvbnMiLCJnZXRDaGFyYWN0ZXJDb3VudEJpdHMiLCJURVJNSU5BVE9SIiwiTlVNRVJJQyIsIkFMUEhBTlVNRVJJQyIsIlNUUlVDVFVSRURfQVBQRU5EIiwiQllURSIsIkVDSSIsIktBTkpJIiwiRk5DMV9GSVJTVF9QT1NJVElPTiIsIkZOQzFfU0VDT05EX1BPU0lUSU9OIiwiSEFOWkkiLCJEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEiLCJzeW1ib2xTZXF1ZW5jZSIsInBhcml0eURhdGEiLCJjdXJyZW50Q2hhcmFjdGVyU2V0RUNJIiwiZmMxSW5FZmZlY3QiLCJtb2RlQml0cyIsInBhcnNlRUNJVmFsdWUiLCJzdWJzZXQiLCJjb3VudEhhbnppIiwiR0IyMzEyX1NVQlNFVCIsImRlY29kZUhhbnppU2VnbWVudCIsImRlY29kZU51bWVyaWNTZWdtZW50IiwiZGVjb2RlQWxwaGFudW1lcmljU2VnbWVudCIsImRlY29kZUJ5dGVTZWdtZW50IiwiZGVjb2RlS2FuamlTZWdtZW50IiwiaWFlIiwidHdvQnl0ZXMiLCJhc3NlbWJsZWRUd29CeXRlcyIsInJlYWRCeXRlcyIsInRvQWxwaGFOdW1lcmljQ2hhciIsIkFMUEhBTlVNRVJJQ19DSEFSUyIsIm5leHRUd29DaGFyc0JpdHMiLCJ0aHJlZURpZ2l0c0JpdHMiLCJ0d29EaWdpdHNCaXRzIiwiZGlnaXRCaXRzIiwic2Vjb25kVGhpcmRCeXRlcyIsIlFSQ29kZURlY29kZXJNZXRhRGF0YSIsIm1pcnJvcmVkIiwiaXNNaXJyb3JlZCIsImFwcGx5TWlycm9yZWRDb3JyZWN0aW9uIiwiRGVjb2RlciQyIiwiZGVjb2RlQm9vbGVhbkFycmF5IiwiZGVjb2RlQml0TWF0cml4IiwiZGVjb2RlQml0TWF0cml4UGFyc2VyIiwiQWxpZ25tZW50UGF0dGVybiIsInBvc1giLCJwb3NZIiwiZXN0aW1hdGVkTW9kdWxlU2l6ZSIsImFib3V0RXF1YWxzIiwibW9kdWxlU2l6ZURpZmYiLCJjb21iaW5lRXN0aW1hdGUiLCJuZXdNb2R1bGVTaXplIiwiY29tYmluZWRYIiwiY29tYmluZWRZIiwiY29tYmluZWRNb2R1bGVTaXplIiwiQWxpZ25tZW50UGF0dGVybkZpbmRlciIsInN0YXJ0WCIsInN0YXJ0WSIsInBvc3NpYmxlQ2VudGVycyIsImNyb3NzQ2hlY2tTdGF0ZUNvdW50IiwibWF4SiIsIm1pZGRsZUkiLCJzdGF0ZUNvdW50IiwiaUdlbiIsImN1cnJlbnRTdGF0ZSIsImZvdW5kUGF0dGVybkNyb3NzIiwiY29uZmlybWVkIiwiaGFuZGxlUG9zc2libGVDZW50ZXIiLCJjZW50ZXJGcm9tRW5kIiwibWF4VmFyaWFuY2UiLCJjcm9zc0NoZWNrVmVydGljYWwiLCJzdGFydEkiLCJjZW50ZXJKIiwibWF4Q291bnQiLCJvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCIsIm1heEkiLCJzdGF0ZUNvdW50VG90YWwiLCJjZW50ZXJJIiwiaXNOYU4iLCJGaW5kZXJQYXR0ZXJuJDEiLCJnZXRFc3RpbWF0ZWRNb2R1bGVTaXplIiwiY29tYmluZWRDb3VudCIsIkZpbmRlclBhdHRlcm5JbmZvIiwicGF0dGVybkNlbnRlcnMiLCJnZXRCb3R0b21MZWZ0IiwiZ2V0VG9wTGVmdCIsImdldFRvcFJpZ2h0IiwiRmluZGVyUGF0dGVybkZpbmRlciIsImdldEltYWdlIiwiZ2V0UG9zc2libGVDZW50ZXJzIiwicHVyZUJhcmNvZGUiLCJpU2tpcCIsIk1BWF9NT0RVTEVTIiwiTUlOX1NLSVAiLCJoYXNTa2lwcGVkIiwiaGF2ZU11bHRpcGx5Q29uZmlybWVkQ2VudGVycyIsInJvd1NraXAiLCJmaW5kUm93U2tpcCIsInBhdHRlcm5JbmZvIiwic2VsZWN0QmVzdFBhdHRlcm5zIiwidG90YWxNb2R1bGVTaXplIiwiZ2V0Q3Jvc3NDaGVja1N0YXRlQ291bnQiLCJjcm9zc0NoZWNrRGlhZ29uYWwiLCJjcm9zc0NoZWNrSG9yaXpvbnRhbCIsInN0YXJ0SiIsImZpcnN0Q29uZmlybWVkQ2VudGVyIiwiQ0VOVEVSX1FVT1JVTSIsImNvbmZpcm1lZENvdW50IiwidG90YWxEZXZpYXRpb24iLCJzdGFydFNpemUiLCJzcXVhcmUiLCJzdGREZXYiLCJzb3J0IiwiY2VudGVyMSIsImNlbnRlcjIiLCJkQSIsImRCIiwibGltaXQiLCJzcGxpY2UiLCJwb3NzaWJsZUNlbnRlciIsIkRldGVjdG9yJDIiLCJnZXRSZXN1bHRQb2ludENhbGxiYWNrIiwiZmluZGVyIiwicHJvY2Vzc0ZpbmRlclBhdHRlcm5JbmZvIiwiY2FsY3VsYXRlTW9kdWxlU2l6ZSIsImNvbXB1dGVEaW1lbnNpb24iLCJtb2R1bGVzQmV0d2VlbkZQQ2VudGVycyIsImFsaWdubWVudFBhdHRlcm4iLCJib3R0b21SaWdodFgiLCJib3R0b21SaWdodFkiLCJjb3JyZWN0aW9uVG9Ub3BMZWZ0IiwiZXN0QWxpZ25tZW50WCIsImVzdEFsaWdubWVudFkiLCJmaW5kQWxpZ25tZW50SW5SZWdpb24iLCJjcmVhdGVUcmFuc2Zvcm0iLCJkaW1NaW51c1RocmVlIiwic291cmNlQm90dG9tUmlnaHRYIiwic291cmNlQm90dG9tUmlnaHRZIiwidGx0ckNlbnRlcnNEaW1lbnNpb24iLCJ0bGJsQ2VudGVyc0RpbWVuc2lvbiIsImNhbGN1bGF0ZU1vZHVsZVNpemVPbmVXYXkiLCJvdGhlclBhdHRlcm4iLCJtb2R1bGVTaXplRXN0MSIsInNpemVPZkJsYWNrV2hpdGVCbGFja1J1bkJvdGhXYXlzIiwibW9kdWxlU2l6ZUVzdDIiLCJzaXplT2ZCbGFja1doaXRlQmxhY2tSdW4iLCJvdGhlclRvWCIsIm90aGVyVG9ZIiwic3RhdGUiLCJ4TGltaXQiLCJyZWFsWCIsInJlYWxZIiwib3ZlcmFsbEVzdE1vZHVsZVNpemUiLCJhbGxvd2FuY2VGYWN0b3IiLCJhbGxvd2FuY2UiLCJhbGlnbm1lbnRBcmVhTGVmdFgiLCJhbGlnbm1lbnRBcmVhUmlnaHRYIiwiYWxpZ25tZW50QXJlYVRvcFkiLCJhbGlnbm1lbnRBcmVhQm90dG9tWSIsImFsaWdubWVudEZpbmRlciIsIlFSQ29kZVJlYWRlciIsImdldERlY29kZXIiLCJRUl9DT0RFIiwiU1RSVUNUVVJFRF9BUFBFTkRfU0VRVUVOQ0UiLCJTVFJVQ1RVUkVEX0FQUEVORF9QQVJJVFkiLCJudWRnZWRUb29GYXJSaWdodCIsIm51ZGdlZFRvb0ZhckRvd24iLCJQREY0MTdDb21tb24iLCJnZXRCaXRDb3VudFN1bSIsIm1vZHVsZUJpdENvdW50IiwidG9JbnRBcnJheSIsImxpc3QiLCJFTVBUWV9JTlRfQVJSQVkiLCJpbnRlZ2VyIiwiZ2V0Q29kZXdvcmQiLCJzeW1ib2wiLCJTWU1CT0xfVEFCTEUiLCJDT0RFV09SRF9UQUJMRSIsIk5VTUJFUl9PRl9DT0RFV09SRFMiLCJNQVhfQ09ERVdPUkRTX0lOX0JBUkNPREUiLCJNSU5fUk9XU19JTl9CQVJDT0RFIiwiTUFYX1JPV1NfSU5fQkFSQ09ERSIsIk1PRFVMRVNfSU5fQ09ERVdPUkQiLCJNT0RVTEVTX0lOX1NUT1BfUEFUVEVSTiIsIkJBUlNfSU5fTU9EVUxFIiwiUERGNDE3RGV0ZWN0b3JSZXN1bHQiLCJEZXRlY3RvciQzIiwiZGV0ZWN0TXVsdGlwbGUiLCJtdWx0aXBsZSIsImJhcmNvZGVDb29yZGluYXRlcyIsImZvdW5kQmFyY29kZUluUm93IiwidmVydGljZXMiLCJmaW5kVmVydGljZXMiLCJiYXJjb2RlQ29vcmRpbmF0ZSIsIlJPV19TVEVQIiwic3RhcnRSb3ciLCJzdGFydENvbHVtbiIsImNvcHlUb1Jlc3VsdCIsImZpbmRSb3dzV2l0aFBhdHRlcm4iLCJJTkRFWEVTX1NUQVJUX1BBVFRFUk4iLCJTVE9QX1BBVFRFUk4iLCJJTkRFWEVTX1NUT1BfUEFUVEVSTiIsInRtcFJlc3VsdCIsImRlc3RpbmF0aW9uSW5kZXhlcyIsImxvYyIsInByZXZpb3VzUm93TG9jIiwic3RvcFJvdyIsInNraXBwZWRSb3dDb3VudCIsIk1BWF9QQVRURVJOX0RSSUZUIiwiU0tJUFBFRF9ST1dfQ09VTlRfTUFYIiwiQkFSQ09ERV9NSU5fSEVJR0hUIiwicGl4ZWxEcmlmdCIsIk1BWF9QSVhFTF9EUklGVCIsIkluZmluaXR5IiwiTW9kdWx1c1BvbHkiLCJhZGQiLCJzdWJ0cmFjdCIsIm5lZ2F0aXZlIiwibXVsdGlwbHlPdGhlciIsIm5lZ2F0aXZlQ29lZmZpY2llbnRzIiwiTW9kdWx1c0Jhc2UiLCJtb2R1bHVzIiwiTW9kdWx1c0dGIiwiUERGNDE3X0dGIiwiRXJyb3JDb3JyZWN0aW9uIiwiUyIsImV2YWx1YXRpb24iLCJrbm93bkVycm9ycyIsImVyYXN1cmUiLCJlcnJvckxvY2F0b3JEZWdyZWUiLCJmb3JtYWxEZXJpdmF0aXZlQ29lZmZpY2llbnRzIiwiZm9ybWFsRGVyaXZhdGl2ZSIsIm51bWVyYXRvciIsIkJvdW5kaW5nQm94IiwiY29uc3RydWN0b3JfMiIsImNvbnN0cnVjdG9yXzEiLCJsZWZ0VW5zcGVjaWZpZWQiLCJyaWdodFVuc3BlY2lmaWVkIiwibWluWCIsIm1heFgiLCJtaW5ZIiwibWF4WSIsImJvdW5kaW5nQm94IiwiZ2V0Qm90dG9tUmlnaHQiLCJnZXRNaW5YIiwiZ2V0TWF4WCIsImdldE1pblkiLCJnZXRNYXhZIiwibWVyZ2UiLCJsZWZ0Qm94IiwicmlnaHRCb3giLCJhZGRNaXNzaW5nUm93cyIsIm1pc3NpbmdTdGFydFJvd3MiLCJtaXNzaW5nRW5kUm93cyIsImlzTGVmdCIsIm5ld1RvcExlZnQiLCJuZXdCb3R0b21MZWZ0IiwibmV3VG9wUmlnaHQiLCJuZXdCb3R0b21SaWdodCIsIm5ld01pblkiLCJuZXdUb3AiLCJuZXdNYXhZIiwibmV3Qm90dG9tIiwiQmFyY29kZU1ldGFkYXRhIiwiY29sdW1uQ291bnQiLCJyb3dDb3VudFVwcGVyUGFydCIsInJvd0NvdW50TG93ZXJQYXJ0Iiwicm93Q291bnQiLCJnZXRDb2x1bW5Db3VudCIsImdldFJvd0NvdW50IiwiZ2V0Um93Q291bnRVcHBlclBhcnQiLCJnZXRSb3dDb3VudExvd2VyUGFydCIsIkZvcm1hdHRlciIsImZvcm0iLCJEZXRlY3Rpb25SZXN1bHRDb2x1bW4iLCJnZXRDb2Rld29yZE5lYXJieSIsImltYWdlUm93IiwiY29kZXdvcmQiLCJNQVhfTkVBUkJZX0RJU1RBTkNFIiwibmVhckltYWdlUm93IiwiaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgiLCJzZXRDb2Rld29yZCIsImdldEJvdW5kaW5nQm94IiwiZm9ybWF0dGVyIiwiQmFyY29kZVZhbHVlIiwic2V0VmFsdWUiLCJjb25maWRlbmNlIiwibWF4Q29uZmlkZW5jZSIsImVudHJpZXMiLCJlbnRyeSIsImdldEtleSIsImdldENvbmZpZGVuY2UiLCJEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4iLCJfaXNMZWZ0Iiwic2V0Um93TnVtYmVycyIsInNldFJvd051bWJlckFzUm93SW5kaWNhdG9yQ29sdW1uIiwiYWRqdXN0Q29tcGxldGVJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzIiwiYmFyY29kZU1ldGFkYXRhIiwicmVtb3ZlSW5jb3JyZWN0Q29kZXdvcmRzIiwiZmlyc3RSb3ciLCJsYXN0Um93IiwiYmFyY29kZVJvdyIsIm1heFJvd0hlaWdodCIsImN1cnJlbnRSb3dIZWlnaHQiLCJjb2Rld29yZHNSb3ciLCJyb3dEaWZmZXJlbmNlIiwiY2hlY2tlZFJvd3MiLCJjbG9zZVByZXZpb3VzQ29kZXdvcmRGb3VuZCIsImdldFJvd0hlaWdodHMiLCJnZXRCYXJjb2RlTWV0YWRhdGEiLCJhZGp1c3RJbmNvbXBsZXRlSW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyIsImJhcmNvZGVDb2x1bW5Db3VudCIsImJhcmNvZGVSb3dDb3VudFVwcGVyUGFydCIsImJhcmNvZGVSb3dDb3VudExvd2VyUGFydCIsImJhcmNvZGVFQ0xldmVsIiwicm93SW5kaWNhdG9yVmFsdWUiLCJjb2Rld29yZFJvd051bWJlciIsImNvZGV3b3JkUm93IiwiRGV0ZWN0aW9uUmVzdWx0IiwiQURKVVNUX1JPV19OVU1CRVJfU0tJUCIsImRldGVjdGlvblJlc3VsdENvbHVtbnMiLCJnZXREZXRlY3Rpb25SZXN1bHRDb2x1bW5zIiwiYWRqdXN0SW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyIsInVuYWRqdXN0ZWRDb2Rld29yZENvdW50IiwicHJldmlvdXNVbmFkanVzdGVkQ291bnQiLCJhZGp1c3RSb3dOdW1iZXJzQW5kR2V0Q291bnQiLCJkZXRlY3Rpb25SZXN1bHRDb2x1bW4iLCJ1bmFkanVzdGVkQ291bnQiLCJhZGp1c3RSb3dOdW1iZXJzQnlSb3ciLCJiYXJjb2RlQ29sdW1uIiwiaGFzVmFsaWRSb3dOdW1iZXIiLCJhZGp1c3RSb3dOdW1iZXJzIiwiYWRqdXN0Um93TnVtYmVyc0Zyb21Cb3RoUkkiLCJhZGp1c3RSb3dOdW1iZXJzRnJvbUxSSSIsImFkanVzdFJvd051bWJlcnNGcm9tUlJJIiwiTFJJY29kZXdvcmRzIiwiUlJJY29kZXdvcmRzIiwic2V0Um93TnVtYmVyIiwicm93SW5kaWNhdG9yUm93TnVtYmVyIiwiaW52YWxpZFJvd0NvdW50cyIsImFkanVzdFJvd051bWJlcklmVmFsaWQiLCJpc1ZhbGlkUm93TnVtYmVyIiwicHJldmlvdXNDb2x1bW5Db2Rld29yZHMiLCJuZXh0Q29sdW1uQ29kZXdvcmRzIiwib3RoZXJDb2Rld29yZHMiLCJvdGhlckNvZGV3b3JkIiwiYWRqdXN0Um93TnVtYmVyIiwiZ2V0QnVja2V0IiwiZ2V0QmFyY29kZUNvbHVtbkNvdW50IiwiZ2V0QmFyY29kZVJvd0NvdW50IiwiZ2V0QmFyY29kZUVDTGV2ZWwiLCJzZXRCb3VuZGluZ0JveCIsInNldERldGVjdGlvblJlc3VsdENvbHVtbiIsImdldERldGVjdGlvblJlc3VsdENvbHVtbiIsInJvd0luZGljYXRvckNvbHVtbiIsIkNvZGV3b3JkIiwiZW5kWCIsImJ1Y2tldCIsIkJBUkNPREVfUk9XX1VOS05PV04iLCJnZXRTdGFydFgiLCJnZXRFbmRYIiwiUERGNDE3Q29kZXdvcmREZWNvZGVyIiwiaW5pdGlhbGl6ZSIsImN1cnJlbnRTeW1ib2wiLCJjdXJyZW50Qml0IiwiUkFUSU9TX1RBQkxFIiwiZnJvdW5kIiwiYlN5bWJvbFRhYmxlUmVhZHkiLCJnZXREZWNvZGVkVmFsdWUiLCJkZWNvZGVkVmFsdWUiLCJnZXREZWNvZGVkQ29kZXdvcmRWYWx1ZSIsInNhbXBsZUJpdENvdW50cyIsImdldENsb3Nlc3REZWNvZGVkVmFsdWUiLCJiaXRDb3VudFN1bSIsImJpdENvdW50SW5kZXgiLCJzdW1QcmV2aW91c0JpdHMiLCJzYW1wbGVJbmRleCIsImdldEJpdFZhbHVlIiwiYml0Q291bnRSYXRpb3MiLCJiZXN0TWF0Y2hFcnJvciIsInJhdGlvVGFibGVSb3ciLCJkaWZmIiwiUERGNDE3UmVzdWx0TWV0YWRhdGEiLCJzZWdtZW50Q291bnQiLCJmaWxlU2l6ZSIsImdldFNlZ21lbnRJbmRleCIsInNlZ21lbnRJbmRleCIsInNldFNlZ21lbnRJbmRleCIsImdldEZpbGVJZCIsImZpbGVJZCIsInNldEZpbGVJZCIsImdldE9wdGlvbmFsRGF0YSIsIm9wdGlvbmFsRGF0YSIsInNldE9wdGlvbmFsRGF0YSIsImlzTGFzdFNlZ21lbnQiLCJsYXN0U2VnbWVudCIsInNldExhc3RTZWdtZW50IiwiZ2V0U2VnbWVudENvdW50Iiwic2V0U2VnbWVudENvdW50IiwiZ2V0U2VuZGVyIiwic2VuZGVyIiwic2V0U2VuZGVyIiwiZ2V0QWRkcmVzc2VlIiwiYWRkcmVzc2VlIiwic2V0QWRkcmVzc2VlIiwiZ2V0RmlsZU5hbWUiLCJmaWxlTmFtZSIsInNldEZpbGVOYW1lIiwiZ2V0RmlsZVNpemUiLCJzZXRGaWxlU2l6ZSIsImdldENoZWNrc3VtIiwic2V0Q2hlY2tzdW0iLCJzZXRUaW1lc3RhbXAiLCJMb25nIiwicGFyc2VMb25nIiwiTnVsbFBvaW50ZXJFeGNlcHRpb24iLCJPdXRwdXRTdHJlYW0iLCJ3cml0ZUJ5dGVzIiwid3JpdGVCeXRlc09mZnNldCIsIm9mZiIsIndyaXRlIiwiZmx1c2giLCJjbG9zZSIsIk91dE9mTWVtb3J5RXJyb3IiLCJCeXRlQXJyYXlPdXRwdXRTdHJlYW0iLCJtaW5DYXBhY2l0eSIsImdyb3ciLCJvbGRDYXBhY2l0eSIsIm5ld0NhcGFjaXR5Iiwid3JpdGVUbyIsIm91dCIsInRvQnl0ZUFycmF5IiwicGFyYW0iLCJ0b1N0cmluZ192b2lkIiwidG9TdHJpbmdfc3RyaW5nIiwidG9TdHJpbmdfbnVtYmVyIiwiY2hhcnNldE5hbWUiLCJoaWJ5dGUiLCJNb2RlJDIiLCJnZXRCaWdJbnRDb25zdHJ1Y3RvciIsIkJpZ0ludGVnZXIiLCJjcmVhdGVCaWdJbnQiLCJnZXRFWFA5MDAiLCJFWFA5MDAiLCJuaW5lSHVuZHJlZCIsIkRlY29kZWRCaXRTdHJlYW1QYXJzZXIkMiIsImNvZGVJbmRleCIsIlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIIiwidGV4dENvbXBhY3Rpb24iLCJCWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCIsIkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzYiLCJieXRlQ29tcGFjdGlvbiIsIk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREUiLCJOVU1FUklDX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCIsIm51bWVyaWNDb21wYWN0aW9uIiwiRUNJX0NIQVJTRVQiLCJjaGFyc2V0RUNJIiwiRUNJX0dFTkVSQUxfUFVSUE9TRSIsIkVDSV9VU0VSX0RFRklORUQiLCJCRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSyIsImRlY29kZU1hY3JvQmxvY2siLCJCRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQiLCJNQUNST19QREY0MTdfVEVSTUlOQVRPUiIsIk5VTUJFUl9PRl9TRVFVRU5DRV9DT0RFV09SRFMiLCJzZWdtZW50SW5kZXhBcnJheSIsImRlY29kZUJhc2U5MDB0b0Jhc2UxMCIsIm9wdGlvbmFsRmllbGRzU3RhcnQiLCJNQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfRklMRV9OQU1FIiwiTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX1NFTkRFUiIsIk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9BRERSRVNTRUUiLCJNQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfU0VHTUVOVF9DT1VOVCIsIk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9USU1FX1NUQU1QIiwiTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0NIRUNLU1VNIiwiTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0ZJTEVfU0laRSIsIm9wdGlvbmFsRmllbGRzTGVuZ3RoIiwidGV4dENvbXBhY3Rpb25EYXRhIiwiYnl0ZUNvbXBhY3Rpb25EYXRhIiwiZGVjb2RlVGV4dENvbXBhY3Rpb24iLCJzdWJNb2RlIiwiQUxQSEEiLCJwcmlvclRvU2hpZnRNb2RlIiwic3ViTW9kZUNoIiwiTEwiLCJNTCIsIlBTIiwiUFVOQ1RfU0hJRlQiLCJBUyIsIkFMUEhBX1NISUZUIiwiUEwiLCJNSVhFRF9DSEFSUyIsIkFMIiwiUEFMIiwiUFVOQ1RfQ0hBUlMiLCJkZWNvZGVkQnl0ZXMiLCJieXRlQ29tcGFjdGVkQ29kZXdvcmRzIiwibmV4dENvZGUiLCJudW1lcmljQ29kZXdvcmRzIiwiTUFYX05VTUVSSUNfQ09ERVdPUkRTIiwiUERGNDE3U2Nhbm5pbmdEZWNvZGVyIiwiaW1hZ2VUb3BMZWZ0IiwiaW1hZ2VCb3R0b21MZWZ0IiwiaW1hZ2VUb3BSaWdodCIsImltYWdlQm90dG9tUmlnaHQiLCJtaW5Db2Rld29yZFdpZHRoIiwibWF4Q29kZXdvcmRXaWR0aCIsImxlZnRSb3dJbmRpY2F0b3JDb2x1bW4iLCJyaWdodFJvd0luZGljYXRvckNvbHVtbiIsImRldGVjdGlvblJlc3VsdCIsImZpcnN0UGFzcyIsImdldFJvd0luZGljYXRvckNvbHVtbiIsInJlc3VsdEJveCIsIm1heEJhcmNvZGVDb2x1bW4iLCJsZWZ0VG9SaWdodCIsInByZXZpb3VzU3RhcnRDb2x1bW4iLCJnZXRTdGFydENvbHVtbiIsImRldGVjdENvZGV3b3JkIiwiY3JlYXRlRGVjb2RlclJlc3VsdCIsImFkanVzdEJvdW5kaW5nQm94Iiwicm93SGVpZ2h0cyIsImdldE1heCIsInJvd0hlaWdodCIsIm1heFZhbHVlIiwibGVmdEJhcmNvZGVNZXRhZGF0YSIsInJpZ2h0QmFyY29kZU1ldGFkYXRhIiwic3RhcnRQb2ludCIsImFkanVzdENvZGV3b3JkQ291bnQiLCJiYXJjb2RlTWF0cml4IiwiYmFyY29kZU1hdHJpeDAxIiwibnVtYmVyT2ZDb2Rld29yZHMiLCJjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMiLCJnZXROdW1iZXJPZkVDQ29kZVdvcmRzIiwiY3JlYXRlQmFyY29kZU1hdHJpeCIsImFtYmlndW91c0luZGV4VmFsdWVzTGlzdCIsImFtYmlndW91c0luZGV4ZXNMaXN0IiwiY29kZXdvcmRJbmRleCIsImFtYmlndW91c0luZGV4VmFsdWVzIiwiY3JlYXRlRGVjb2RlclJlc3VsdEZyb21BbWJpZ3VvdXNWYWx1ZXMiLCJlcmFzdXJlQXJyYXkiLCJhbWJpZ3VvdXNJbmRleGVzIiwiYW1iaWd1b3VzSW5kZXhDb3VudCIsInRyaWVzIiwiZGVjb2RlQ29kZXdvcmRzIiwiaXNWYWxpZEJhcmNvZGVDb2x1bW4iLCJza2lwcGVkQ29sdW1ucyIsInByZXZpb3VzUm93Q29kZXdvcmQiLCJtaW5Db2x1bW4iLCJtYXhDb2x1bW4iLCJhZGp1c3RDb2Rld29yZFN0YXJ0Q29sdW1uIiwiZ2V0TW9kdWxlQml0Q291bnQiLCJlbmRDb2x1bW4iLCJjb2Rld29yZEJpdENvdW50IiwidG1wQ291bnQiLCJjaGVja0NvZGV3b3JkU2tldyIsImdldENvZGV3b3JkQnVja2V0TnVtYmVyIiwiaW1hZ2VDb2x1bW4iLCJtb2R1bGVOdW1iZXIiLCJwcmV2aW91c1BpeGVsVmFsdWUiLCJjb2Rld29yZFN0YXJ0Q29sdW1uIiwiY29ycmVjdGVkU3RhcnRDb2x1bW4iLCJDT0RFV09SRF9TS0VXX1NJWkUiLCJjb3JyZWN0ZWRFcnJvcnNDb3VudCIsInZlcmlmeUNvZGV3b3JkQ291bnQiLCJNQVhfRVJST1JTIiwiTUFYX0VDX0NPREVXT1JEUyIsImVycm9yQ29ycmVjdGlvbiIsImdldEJpdENvdW50Rm9yQ29kZXdvcmQiLCJwcmV2aW91c1ZhbHVlIiwiZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXJfSW50MzJBcnJheSIsImdldENvZGV3b3JkQnVja2V0TnVtYmVyX251bWJlciIsImJhcmNvZGVWYWx1ZSIsIlBERjQxN1JlYWRlciIsImRlY29kZU11bHRpcGxlIiwiZ2V0TWluQ29kZXdvcmRXaWR0aCIsImdldE1heENvZGV3b3JkV2lkdGgiLCJQREZfNDE3IiwicGRmNDE3UmVzdWx0TWV0YWRhdGEiLCJQREY0MTdfRVhUUkFfTUVUQURBVEEiLCJnZXRNYXhXaWR0aCIsImdldE1pbldpZHRoIiwiUmVhZGVyRXhjZXB0aW9uIiwiTXVsdGlGb3JtYXRSZWFkZXIiLCJzZXRIaW50cyIsImRlY29kZUludGVybmFsIiwiZGVjb2RlV2l0aFN0YXRlIiwiZm9ybWF0cyIsImFkZE9uZURSZWFkZXIiLCJzb21lIiwiQ09EQUJBUiIsIkNPREVfOTMiLCJCcm93c2VyTXVsdGlGb3JtYXRSZWFkZXIiLCJCcm93c2VyUERGNDE3UmVhZGVyIiwiQnJvd3NlclFSQ29kZVJlYWRlciIsIkVuY29kZUhpbnRUeXBlIiwiRW5jb2RlSGludFR5cGUkMSIsIlJlZWRTb2xvbW9uRW5jb2RlciIsImNhY2hlZEdlbmVyYXRvcnMiLCJidWlsZEdlbmVyYXRvciIsImxhc3RHZW5lcmF0b3IiLCJuZXh0R2VuZXJhdG9yIiwidG9FbmNvZGUiLCJlY0J5dGVzIiwiZGF0YUJ5dGVzIiwiaW5mb0NvZWZmaWNpZW50cyIsIm51bVplcm9Db2VmZmljaWVudHMiLCJNYXNrVXRpbCIsImFwcGx5TWFza1BlbmFsdHlSdWxlMSIsImFwcGx5TWFza1BlbmFsdHlSdWxlMUludGVybmFsIiwiYXBwbHlNYXNrUGVuYWx0eVJ1bGUyIiwicGVuYWx0eSIsImdldEFycmF5IiwiYXJyYXlZIiwiTjIiLCJhcHBseU1hc2tQZW5hbHR5UnVsZTMiLCJudW1QZW5hbHRpZXMiLCJpc1doaXRlSG9yaXpvbnRhbCIsImlzV2hpdGVWZXJ0aWNhbCIsIk4zIiwiYXBwbHlNYXNrUGVuYWx0eVJ1bGU0IiwibnVtRGFya0NlbGxzIiwibnVtVG90YWxDZWxscyIsImZpdmVQZXJjZW50VmFyaWFuY2VzIiwiTjQiLCJnZXREYXRhTWFza0JpdCIsIm1hc2tQYXR0ZXJuIiwiaW50ZXJtZWRpYXRlIiwiaXNIb3Jpem9udGFsIiwiaUxpbWl0IiwiakxpbWl0IiwibnVtU2FtZUJpdENlbGxzIiwicHJldkJpdCIsIk4xIiwiQnl0ZU1hdHJpeCIsInNldE51bWJlciIsInNldEJvb2xlYW4iLCJhQnl0ZSIsImJ5dGVzWSIsIm90aGVyQnl0ZXNZIiwiUVJDb2RlIiwiZ2V0TW9kZSIsImdldE1hc2tQYXR0ZXJuIiwic2V0TW9kZSIsInNldEVDTGV2ZWwiLCJzZXRWZXJzaW9uIiwic2V0TWFza1BhdHRlcm4iLCJzZXRNYXRyaXgiLCJpc1ZhbGlkTWFza1BhdHRlcm4iLCJOVU1fTUFTS19QQVRURVJOUyIsIldyaXRlckV4Y2VwdGlvbiIsIk1hdHJpeFV0aWwiLCJjbGVhck1hdHJpeCIsImJ1aWxkTWF0cml4IiwiZGF0YUJpdHMiLCJlbWJlZEJhc2ljUGF0dGVybnMiLCJlbWJlZFR5cGVJbmZvIiwibWF5YmVFbWJlZFZlcnNpb25JbmZvIiwiZW1iZWREYXRhQml0cyIsImVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuc0FuZFNlcGFyYXRvcnMiLCJlbWJlZERhcmtEb3RBdExlZnRCb3R0b21Db3JuZXIiLCJtYXliZUVtYmVkUG9zaXRpb25BZGp1c3RtZW50UGF0dGVybnMiLCJlbWJlZFRpbWluZ1BhdHRlcm5zIiwidHlwZUluZm9CaXRzIiwibWFrZVR5cGVJbmZvQml0cyIsImNvb3JkaW5hdGVzIiwiVFlQRV9JTkZPX0NPT1JESU5BVEVTIiwidmVyc2lvbkluZm9CaXRzIiwibWFrZVZlcnNpb25JbmZvQml0cyIsImJpdEluZGV4IiwiZGlyZWN0aW9uIiwiaXNFbXB0eSIsImZpbmRNU0JTZXQiLCJjYWxjdWxhdGVCQ0hDb2RlIiwibXNiU2V0SW5Qb2x5IiwidHlwZUluZm8iLCJiY2hDb2RlIiwiVFlQRV9JTkZPX1BPTFkiLCJtYXNrQml0cyIsIlRZUEVfSU5GT19NQVNLX1BBVFRFUk4iLCJWRVJTSU9OX0lORk9fUE9MWSIsImVtYmVkSG9yaXpvbnRhbFNlcGFyYXRpb25QYXR0ZXJuIiwieFN0YXJ0IiwieVN0YXJ0IiwiZW1iZWRWZXJ0aWNhbFNlcGFyYXRpb25QYXR0ZXJuIiwiZW1iZWRQb3NpdGlvbkFkanVzdG1lbnRQYXR0ZXJuIiwicGF0dGVyblkiLCJQT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk4iLCJlbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybiIsIlBPU0lUSU9OX0RFVEVDVElPTl9QQVRURVJOIiwicGRwV2lkdGgiLCJoc3BXaWR0aCIsInZzcFNpemUiLCJQT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk5fQ09PUkRJTkFURV9UQUJMRSIsIkJsb2NrUGFpciIsImVycm9yQ29ycmVjdGlvbkJ5dGVzIiwiZ2V0RGF0YUJ5dGVzIiwiZ2V0RXJyb3JDb3JyZWN0aW9uQnl0ZXMiLCJFbmNvZGVyIiwiY2FsY3VsYXRlTWFza1BlbmFsdHkiLCJjb250ZW50IiwiREVGQVVMVF9CWVRFX01PREVfRU5DT0RJTkciLCJoYXNFbmNvZGluZ0hpbnQiLCJjaG9vc2VNb2RlIiwiaGVhZGVyQml0cyIsImVjaSIsImFwcGVuZEVDSSIsImFwcGVuZE1vZGVJbmZvIiwiYXBwZW5kQnl0ZXMiLCJRUl9WRVJTSU9OIiwiYml0c05lZWRlZCIsImNhbGN1bGF0ZUJpdHNOZWVkZWQiLCJ3aWxsRml0IiwicmVjb21tZW5kVmVyc2lvbiIsImhlYWRlckFuZERhdGFCaXRzIiwibnVtTGV0dGVycyIsImFwcGVuZExlbmd0aEluZm8iLCJudW1EYXRhQnl0ZXMiLCJ0ZXJtaW5hdGVCaXRzIiwiZmluYWxCaXRzIiwiaW50ZXJsZWF2ZVdpdGhFQ0J5dGVzIiwicXJDb2RlIiwiY2hvb3NlTWFza1BhdHRlcm4iLCJwcm92aXNpb25hbEJpdHNOZWVkZWQiLCJjaG9vc2VWZXJzaW9uIiwiZ2V0QWxwaGFudW1lcmljQ29kZSIsIkFMUEhBTlVNRVJJQ19UQUJMRSIsImlzT25seURvdWJsZUJ5dGVLYW5qaSIsImhhc051bWVyaWMiLCJoYXNBbHBoYW51bWVyaWMiLCJpc0RpZ2l0IiwiYnl0ZTEiLCJtaW5QZW5hbHR5IiwiYmVzdE1hc2tQYXR0ZXJuIiwibnVtSW5wdXRCaXRzIiwidmVyc2lvbk51bSIsIm51bUVjQnl0ZXMiLCJ0b3RhbElucHV0Qnl0ZXMiLCJjYXBhY2l0eSIsIm51bUJpdHNJbkxhc3RCeXRlIiwibnVtUGFkZGluZ0J5dGVzIiwiZ2V0TnVtRGF0YUJ5dGVzQW5kTnVtRUNCeXRlc0ZvckJsb2NrSUQiLCJudW1Ub3RhbEJ5dGVzIiwibnVtUlNCbG9ja3MiLCJibG9ja0lEIiwibnVtRGF0YUJ5dGVzSW5CbG9jayIsIm51bUVDQnl0ZXNJbkJsb2NrIiwibnVtUnNCbG9ja3NJbkdyb3VwMiIsIm51bVJzQmxvY2tzSW5Hcm91cDEiLCJudW1Ub3RhbEJ5dGVzSW5Hcm91cDEiLCJudW1Ub3RhbEJ5dGVzSW5Hcm91cDIiLCJudW1EYXRhQnl0ZXNJbkdyb3VwMSIsIm51bURhdGFCeXRlc0luR3JvdXAyIiwibnVtRWNCeXRlc0luR3JvdXAxIiwibnVtRWNCeXRlc0luR3JvdXAyIiwiZGF0YUJ5dGVzT2Zmc2V0IiwibWF4TnVtRGF0YUJ5dGVzIiwibWF4TnVtRWNCeXRlcyIsImJsb2NrcyIsIm51bUVjQnl0ZXNJbkJsb2NrIiwiZ2VuZXJhdGVFQ0J5dGVzIiwiYmxvY2siLCJhcHBlbmROdW1lcmljQnl0ZXMiLCJhcHBlbmRBbHBoYW51bWVyaWNCeXRlcyIsImFwcGVuZDhCaXRCeXRlcyIsImFwcGVuZEthbmppQnl0ZXMiLCJnZXREaWdpdCIsInNpbmdsZUNoYXJhY3RlciIsImNuIiwibnVtMSIsIm51bTIiLCJudW0zIiwiY29kZTEiLCJjb2RlMiIsImJ5dGUyIiwic3VidHJhY3RlZCIsIkJyb3dzZXJRUkNvZGVTdmdXcml0ZXIiLCJjb250ZW50cyIsInF1aWV0Wm9uZSIsIlFVSUVUX1pPTkVfU0laRSIsIkVSUk9SX0NPUlJFQ1RJT04iLCJNQVJHSU4iLCJyZW5kZXJSZXN1bHQiLCJ3cml0ZVRvRG9tIiwiY29udGFpbmVyRWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJzdmdFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJpbnB1dCIsImlucHV0V2lkdGgiLCJpbnB1dEhlaWdodCIsInFyV2lkdGgiLCJxckhlaWdodCIsIm91dHB1dFdpZHRoIiwib3V0cHV0SGVpZ2h0IiwibGVmdFBhZGRpbmciLCJ0b3BQYWRkaW5nIiwiY3JlYXRlU1ZHRWxlbWVudCIsImlucHV0WSIsIm91dHB1dFkiLCJpbnB1dFgiLCJvdXRwdXRYIiwic3ZnUmVjdEVsZW1lbnQiLCJjcmVhdGVTdmdSZWN0RWxlbWVudCIsInciLCJjcmVhdGVFbGVtZW50TlMiLCJTVkdfTlMiLCJzZXRBdHRyaWJ1dGVOUyIsInJlY3QiLCJRUkNvZGVXcml0ZXIiLCJvdXRwdXQiLCJNdWx0aUZvcm1hdFdyaXRlciIsIndyaXRlciIsIlBsYW5hcllVVkx1bWluYW5jZVNvdXJjZSIsInl1dkRhdGEiLCJkYXRhV2lkdGgiLCJkYXRhSGVpZ2h0IiwicmV2ZXJzZUhvcml6b250YWwiLCJhcmVhIiwiaW5wdXRPZmZzZXQiLCJvdXRwdXRPZmZzZXQiLCJyZW5kZXJUaHVtYm5haWwiLCJUSFVNQk5BSUxfU0NBTEVfRkFDVE9SIiwicGl4ZWxzIiwieXV2IiwiZ3JleSIsImdldFRodW1ibmFpbFdpZHRoIiwiZ2V0VGh1bWJuYWlsSGVpZ2h0Iiwicm93U3RhcnQiLCJSR0JMdW1pbmFuY2VTb3VyY2UiLCJCWVRFU19QRVJfRUxFTUVOVCIsImx1bWluYW5jZXNVaW50OEFycmF5IiwiZzIiLCJDaGFyc2V0IiwiZm9yTmFtZSIsIlN0YW5kYXJkQ2hhcnNldHMiLCJJU09fODg1OV8xIiwiQXp0ZWNDb2RlIiwic2V0Q29tcGFjdCIsInNldFNpemUiLCJnZXRMYXllcnMiLCJzZXRMYXllcnMiLCJnZXRDb2RlV29yZHMiLCJjb2RlV29yZHMiLCJzZXRDb2RlV29yZHMiLCJDb2xsZWN0aW9ucyIsInNpbmdsZXRvbkxpc3QiLCJpdGVtIiwiY29sbGVjdGlvbiIsIlRva2VuIiwiZ2V0UHJldmlvdXMiLCJTaW1wbGVUb2tlbiIsImFwcGVuZFRvIiwiYml0QXJyYXkiLCJhZGRCaW5hcnlTaGlmdCIsImJ5dGVDb3VudCIsIkJpbmFyeVNoaWZ0VG9rZW4iLCJiaW5hcnlTaGlmdFN0YXJ0IiwiYmluYXJ5U2hpZnRCeXRlQ291bnQiLCJ0b2tlbiIsIk1PREVfTkFNRVMiLCJNT0RFX1VQUEVSIiwiTU9ERV9MT1dFUiIsIk1PREVfRElHSVQiLCJNT0RFX01JWEVEIiwiTU9ERV9QVU5DVCIsIkVNUFRZX1RPS0VOIiwiTEFUQ0hfVEFCTEUiLCJzdGF0aWNfU0hJRlRfVEFCTEUiLCJTSElGVF9UQUJMRSIsIlN0YXRlIiwiYmluYXJ5Qnl0ZXMiLCJnZXRUb2tlbiIsImdldEJpbmFyeVNoaWZ0Qnl0ZUNvdW50IiwiZ2V0Qml0Q291bnQiLCJsYXRjaEFuZEFwcGVuZCIsImxhdGNoIiwibGF0Y2hNb2RlQml0Q291bnQiLCJzaGlmdEFuZEFwcGVuZCIsInRoaXNNb2RlQml0Q291bnQiLCJhZGRCaW5hcnlTaGlmdENoYXIiLCJkZWx0YUJpdENvdW50IiwiZW5kQmluYXJ5U2hpZnQiLCJpc0JldHRlclRoYW5PckVxdWFsVG8iLCJuZXdNb2RlQml0Q291bnQiLCJjYWxjdWxhdGVCaW5hcnlTaGlmdENvc3QiLCJ0b0JpdEFycmF5Iiwic3ltYm9scyIsIklOSVRJQUxfU1RBVEUiLCJzdGF0aWNfQ0hBUl9NQVAiLCJDSEFSX01BUCIsInNwYWNlQ2hhckNvZGUiLCJwb2ludENoYXJDb2RlIiwiY29tbWFDaGFyQ29kZSIsInpVcHBlckNoYXJDb2RlIiwiYVVwcGVyQ2hhckNvZGUiLCJ6TG93ZXJDaGFyQ29kZSIsImFMb3dlckNoYXJDb2RlIiwibmluZUNoYXJDb2RlIiwiemVyb0NoYXJDb2RlIiwibWl4ZWRUYWJsZSIsInB1bmN0VGFibGUiLCJIaWdoTGV2ZWxFbmNvZGVyIiwibGluZUJyZWFrQ2hhckNvZGUiLCJzdGF0ZXMiLCJwYWlyQ29kZSIsIm5leHRDaGFyIiwidXBkYXRlU3RhdGVMaXN0Rm9yUGFpciIsInVwZGF0ZVN0YXRlTGlzdEZvckNoYXIiLCJtaW5TdGF0ZSIsInVwZGF0ZVN0YXRlRm9yQ2hhciIsInNpbXBsaWZ5U3RhdGVzIiwiY2hhckluQ3VycmVudFRhYmxlIiwic3RhdGVOb0JpbmFyeSIsImNoYXJJbk1vZGUiLCJsYXRjaFN0YXRlIiwic2hpZnRTdGF0ZSIsImJpbmFyeVN0YXRlIiwidXBkYXRlU3RhdGVGb3JQYWlyIiwiZGlnaXRTdGF0ZSIsIm5ld1N0YXRlIiwib2xkU3RhdGUiLCJmaWx0ZXIiLCJFbmNvZGVyJDEiLCJlbmNvZGVCeXRlcyIsIkRFRkFVTFRfRUNfUEVSQ0VOVCIsIkRFRkFVTFRfQVpURUNfTEFZRVJTIiwibWluRUNDUGVyY2VudCIsInVzZXJTcGVjaWZpZWRMYXllcnMiLCJlY2NCaXRzIiwidG90YWxTaXplQml0cyIsIndvcmRTaXplIiwiTUFYX05CX0JJVFNfQ09NUEFDVCIsIk1BWF9OQl9CSVRTIiwiV09SRF9TSVpFIiwidXNhYmxlQml0c0luTGF5ZXJzIiwic3R1ZmZCaXRzIiwibWVzc2FnZUJpdHMiLCJnZW5lcmF0ZUNoZWNrV29yZHMiLCJtZXNzYWdlU2l6ZUluV29yZHMiLCJtb2RlTWVzc2FnZSIsImdlbmVyYXRlTW9kZU1lc3NhZ2UiLCJkcmF3TW9kZU1lc3NhZ2UiLCJkcmF3QnVsbHNFeWUiLCJhenRlYyIsInRvdGFsQml0cyIsImdldEdGIiwidG90YWxXb3JkcyIsIm1lc3NhZ2VXb3JkcyIsImJpdHNUb1dvcmRzIiwic3RhcnRQYWQiLCJtZXNzYWdlV29yZCIsIndvcmQiLCJBenRlY1dyaXRlciIsImVuY29kZVdpdGhIaW50cyIsImNoYXJzZXQiLCJlY2NQZXJjZW50IiwiQVpURUNfTEFZRVJTIiwiZW5jb2RlTGF5ZXJzIiwiQXp0ZWNDb2RlUmVhZGVyIiwiQXp0ZWNDb2RlV3JpdGVyIiwiQXp0ZWNEZWNvZGVyIiwiQXp0ZWNEZXRlY3RvciIsIkF6dGVjRW5jb2RlciIsIkF6dGVjSGlnaExldmVsRW5jb2RlciIsIkF6dGVjUG9pbnQiLCJEYXRhTWF0cml4RGVjb2RlZEJpdFN0cmVhbVBhcnNlciIsIlBERjQxN0RlY29kZWRCaXRTdHJlYW1QYXJzZXIiLCJQREY0MTdEZWNvZGVyRXJyb3JDb3JyZWN0aW9uIiwiUVJDb2RlQnl0ZU1hdHJpeCIsIlFSQ29kZURhdGFNYXNrIiwiUVJDb2RlRGVjb2RlZEJpdFN0cmVhbVBhcnNlciIsIlFSQ29kZURlY29kZXJFcnJvckNvcnJlY3Rpb25MZXZlbCIsIlFSQ29kZURlY29kZXJGb3JtYXRJbmZvcm1hdGlvbiIsIlFSQ29kZUVuY29kZXIiLCJRUkNvZGVFbmNvZGVyUVJDb2RlIiwiUVJDb2RlTWFza1V0aWwiLCJRUkNvZGVNYXRyaXhVdGlsIiwiUVJDb2RlTW9kZSIsIlFSQ29kZVZlcnNpb24iLCJaWGluZ0FycmF5cyIsIlpYaW5nQ2hhcnNldCIsIlpYaW5nSW50ZWdlciIsIlpYaW5nU3RhbmRhcmRDaGFyc2V0cyIsIlpYaW5nU3RyaW5nQnVpbGRlciIsIlpYaW5nU3RyaW5nRW5jb2RpbmciLCJaWGluZ1N5c3RlbSIsImNyZWF0ZUFic3RyYWN0RXhwYW5kZWREZWNvZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html5-qrcode/third_party/zxing-js.umd.js\n");

/***/ })

};
;