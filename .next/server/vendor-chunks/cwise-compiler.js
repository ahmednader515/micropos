"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cwise-compiler";
exports.ids = ["vendor-chunks/cwise-compiler"];
exports.modules = {

/***/ "(ssr)/./node_modules/cwise-compiler/compiler.js":
/*!*************************************************!*\
  !*** ./node_modules/cwise-compiler/compiler.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar createThunk = __webpack_require__(/*! ./lib/thunk.js */ \"(ssr)/./node_modules/cwise-compiler/lib/thunk.js\");\nfunction Procedure() {\n    this.argTypes = [];\n    this.shimArgs = [];\n    this.arrayArgs = [];\n    this.arrayBlockIndices = [];\n    this.scalarArgs = [];\n    this.offsetArgs = [];\n    this.offsetArgIndex = [];\n    this.indexArgs = [];\n    this.shapeArgs = [];\n    this.funcName = \"\";\n    this.pre = null;\n    this.body = null;\n    this.post = null;\n    this.debug = false;\n}\nfunction compileCwise(user_args) {\n    //Create procedure\n    var proc = new Procedure();\n    //Parse blocks\n    proc.pre = user_args.pre;\n    proc.body = user_args.body;\n    proc.post = user_args.post;\n    //Parse arguments\n    var proc_args = user_args.args.slice(0);\n    proc.argTypes = proc_args;\n    for(var i = 0; i < proc_args.length; ++i){\n        var arg_type = proc_args[i];\n        if (arg_type === \"array\" || typeof arg_type === \"object\" && arg_type.blockIndices) {\n            proc.argTypes[i] = \"array\";\n            proc.arrayArgs.push(i);\n            proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);\n            proc.shimArgs.push(\"array\" + i);\n            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {\n                throw new Error(\"cwise: pre() block may not reference array args\");\n            }\n            if (i < proc.post.args.length && proc.post.args[i].count > 0) {\n                throw new Error(\"cwise: post() block may not reference array args\");\n            }\n        } else if (arg_type === \"scalar\") {\n            proc.scalarArgs.push(i);\n            proc.shimArgs.push(\"scalar\" + i);\n        } else if (arg_type === \"index\") {\n            proc.indexArgs.push(i);\n            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {\n                throw new Error(\"cwise: pre() block may not reference array index\");\n            }\n            if (i < proc.body.args.length && proc.body.args[i].lvalue) {\n                throw new Error(\"cwise: body() block may not write to array index\");\n            }\n            if (i < proc.post.args.length && proc.post.args[i].count > 0) {\n                throw new Error(\"cwise: post() block may not reference array index\");\n            }\n        } else if (arg_type === \"shape\") {\n            proc.shapeArgs.push(i);\n            if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {\n                throw new Error(\"cwise: pre() block may not write to array shape\");\n            }\n            if (i < proc.body.args.length && proc.body.args[i].lvalue) {\n                throw new Error(\"cwise: body() block may not write to array shape\");\n            }\n            if (i < proc.post.args.length && proc.post.args[i].lvalue) {\n                throw new Error(\"cwise: post() block may not write to array shape\");\n            }\n        } else if (typeof arg_type === \"object\" && arg_type.offset) {\n            proc.argTypes[i] = \"offset\";\n            proc.offsetArgs.push({\n                array: arg_type.array,\n                offset: arg_type.offset\n            });\n            proc.offsetArgIndex.push(i);\n        } else {\n            throw new Error(\"cwise: Unknown argument type \" + proc_args[i]);\n        }\n    }\n    //Make sure at least one array argument was specified\n    if (proc.arrayArgs.length <= 0) {\n        throw new Error(\"cwise: No array arguments specified\");\n    }\n    //Make sure arguments are correct\n    if (proc.pre.args.length > proc_args.length) {\n        throw new Error(\"cwise: Too many arguments in pre() block\");\n    }\n    if (proc.body.args.length > proc_args.length) {\n        throw new Error(\"cwise: Too many arguments in body() block\");\n    }\n    if (proc.post.args.length > proc_args.length) {\n        throw new Error(\"cwise: Too many arguments in post() block\");\n    }\n    //Check debug flag\n    proc.debug = !!user_args.printCode || !!user_args.debug;\n    //Retrieve name\n    proc.funcName = user_args.funcName || \"cwise\";\n    //Read in block size\n    proc.blockSize = user_args.blockSize || 64;\n    return createThunk(proc);\n}\nmodule.exports = compileCwise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvY29tcGlsZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxjQUFjQyxtQkFBT0EsQ0FBQyx3RUFBZ0I7QUFFMUMsU0FBU0M7SUFDUCxJQUFJLENBQUNDLFFBQVEsR0FBRyxFQUFFO0lBQ2xCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLEVBQUU7SUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsRUFBRTtJQUNuQixJQUFJLENBQUNDLGlCQUFpQixHQUFHLEVBQUU7SUFDM0IsSUFBSSxDQUFDQyxVQUFVLEdBQUcsRUFBRTtJQUNwQixJQUFJLENBQUNDLFVBQVUsR0FBRyxFQUFFO0lBQ3BCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLEVBQUU7SUFDeEIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsRUFBRTtJQUNuQixJQUFJLENBQUNDLFNBQVMsR0FBRyxFQUFFO0lBQ25CLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ2hCLElBQUksQ0FBQ0MsR0FBRyxHQUFHO0lBQ1gsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDWixJQUFJLENBQUNDLElBQUksR0FBRztJQUNaLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0FBQ2Y7QUFFQSxTQUFTQyxhQUFhQyxTQUFTO0lBQzdCLGtCQUFrQjtJQUNsQixJQUFJQyxPQUFPLElBQUlqQjtJQUVmLGNBQWM7SUFDZGlCLEtBQUtOLEdBQUcsR0FBTUssVUFBVUwsR0FBRztJQUMzQk0sS0FBS0wsSUFBSSxHQUFLSSxVQUFVSixJQUFJO0lBQzVCSyxLQUFLSixJQUFJLEdBQUtHLFVBQVVILElBQUk7SUFFNUIsaUJBQWlCO0lBQ2pCLElBQUlLLFlBQVlGLFVBQVVHLElBQUksQ0FBQ0MsS0FBSyxDQUFDO0lBQ3JDSCxLQUFLaEIsUUFBUSxHQUFHaUI7SUFDaEIsSUFBSSxJQUFJRyxJQUFFLEdBQUdBLElBQUVILFVBQVVJLE1BQU0sRUFBRSxFQUFFRCxFQUFHO1FBQ3BDLElBQUlFLFdBQVdMLFNB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TUFBTSxJQUFJTSxNQUFNLGtDQUFrQ1QsU0FBUyxDQUFDRyxFQUFFO1FBQ2hFO0lBQ0Y7SUFFQSxxREFBcUQ7SUFDckQsSUFBR0osS0FBS2QsU0FBUyxDQUFDbUIsTUFBTSxJQUFJLEdBQUc7UUFDN0IsTUFBTSxJQUFJSyxNQUFNO0lBQ2xCO0lBRUEsaUNBQWlDO0lBQ2pDLElBQUdWLEtBQUtOLEdBQUcsQ0FBQ1EsSUFBSSxDQUFDRyxNQUFNLEdBQUdKLFVBQVVJLE1BQU0sRUFBRTtRQUMxQyxNQUFNLElBQUlLLE1BQU07SUFDbEI7SUFDQSxJQUFHVixLQUFLTCxJQUFJLENBQUNPLElBQUksQ0FBQ0csTUFBTSxHQUFHSixVQUFVSSxNQUFNLEVBQUU7UUFDM0MsTUFBTSxJQUFJSyxNQUFNO0lBQ2xCO0lBQ0EsSUFBR1YsS0FBS0osSUFBSSxDQUFDTSxJQUFJLENBQUNHLE1BQU0sR0FBR0osVUFBVUksTUFBTSxFQUFFO1FBQzNDLE1BQU0sSUFBSUssTUFBTTtJQUNsQjtJQUVBLGtCQUFrQjtJQUNsQlYsS0FBS0gsS0FBSyxHQUFHLENBQUMsQ0FBQ0UsVUFBVWUsU0FBUyxJQUFJLENBQUMsQ0FBQ2YsVUFBVUYsS0FBSztJQUV2RCxlQUFlO0lBQ2ZHLEtBQUtQLFFBQVEsR0FBR00sVUFBVU4sUUFBUSxJQUFJO0lBRXRDLG9CQUFvQjtJQUNwQk8sS0FBS2UsU0FBUyxHQUFHaEIsVUFBVWdCLFNBQVMsSUFBSTtJQUV4QyxPQUFPbEMsWUFBWW1CO0FBQ3JCO0FBRUFnQixPQUFPQyxPQUFPLEdBQUduQiIsInNvdXJjZXMiOlsid2VicGFjazovL21pY3JvcG9zLy4vbm9kZV9tb2R1bGVzL2N3aXNlLWNvbXBpbGVyL2NvbXBpbGVyLmpzP2Y2ZWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGNyZWF0ZVRodW5rID0gcmVxdWlyZShcIi4vbGliL3RodW5rLmpzXCIpXG5cbmZ1bmN0aW9uIFByb2NlZHVyZSgpIHtcbiAgdGhpcy5hcmdUeXBlcyA9IFtdXG4gIHRoaXMuc2hpbUFyZ3MgPSBbXVxuICB0aGlzLmFycmF5QXJncyA9IFtdXG4gIHRoaXMuYXJyYXlCbG9ja0luZGljZXMgPSBbXVxuICB0aGlzLnNjYWxhckFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ0luZGV4ID0gW11cbiAgdGhpcy5pbmRleEFyZ3MgPSBbXVxuICB0aGlzLnNoYXBlQXJncyA9IFtdXG4gIHRoaXMuZnVuY05hbWUgPSBcIlwiXG4gIHRoaXMucHJlID0gbnVsbFxuICB0aGlzLmJvZHkgPSBudWxsXG4gIHRoaXMucG9zdCA9IG51bGxcbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDd2lzZSh1c2VyX2FyZ3MpIHtcbiAgLy9DcmVhdGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jID0gbmV3IFByb2NlZHVyZSgpXG4gIFxuICAvL1BhcnNlIGJsb2Nrc1xuICBwcm9jLnByZSAgICA9IHVzZXJfYXJncy5wcmVcbiAgcHJvYy5ib2R5ICAgPSB1c2VyX2FyZ3MuYm9keVxuICBwcm9jLnBvc3QgICA9IHVzZXJfYXJncy5wb3N0XG5cbiAgLy9QYXJzZSBhcmd1bWVudHNcbiAgdmFyIHByb2NfYXJncyA9IHVzZXJfYXJncy5hcmdzLnNsaWNlKDApXG4gIHByb2MuYXJnVHlwZXMgPSBwcm9jX2FyZ3NcbiAgZm9yKHZhciBpPTA7IGk8cHJvY19hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGFyZ190eXBlID0gcHJvY19hcmdzW2ldXG4gICAgaWYoYXJnX3R5cGUgPT09IFwiYXJyYXlcIiB8fCAodHlwZW9mIGFyZ190eXBlID09PSBcIm9iamVjdFwiICYmIGFyZ190eXBlLmJsb2NrSW5kaWNlcykpIHtcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcImFycmF5XCJcbiAgICAgIHByb2MuYXJyYXlBcmdzLnB1c2goaSlcbiAgICAgIHByb2MuYXJyYXlCbG9ja0luZGljZXMucHVzaChhcmdfdHlwZS5ibG9ja0luZGljZXMgPyBhcmdfdHlwZS5ibG9ja0luZGljZXMgOiAwKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwiYXJyYXlcIiArIGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudD4wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5wb3N0LmFyZ3MubGVuZ3RoICYmIHByb2MucG9zdC5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcInNjYWxhclwiKSB7XG4gICAgICBwcm9jLnNjYWxhckFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwic2NhbGFyXCIgKyBpKVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJpbmRleFwiKSB7XG4gICAgICBwcm9jLmluZGV4QXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGluZGV4XCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2hhcGVcIikge1xuICAgICAgcHJvYy5zaGFwZUFyZ3MucHVzaChpKVxuICAgICAgaWYoaSA8IHByb2MucHJlLmFyZ3MubGVuZ3RoICYmIHByb2MucHJlLmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZih0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUub2Zmc2V0KSB7XG4gICAgICBwcm9jLmFyZ1R5cGVzW2ldID0gXCJvZmZzZXRcIlxuICAgICAgcHJvYy5vZmZzZXRBcmdzLnB1c2goeyBhcnJheTogYXJnX3R5cGUuYXJyYXksIG9mZnNldDphcmdfdHlwZS5vZmZzZXQgfSlcbiAgICAgIHByb2Mub2Zmc2V0QXJnSW5kZXgucHVzaChpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVW5rbm93biBhcmd1bWVudCB0eXBlIFwiICsgcHJvY19hcmdzW2ldKVxuICAgIH1cbiAgfVxuICBcbiAgLy9NYWtlIHN1cmUgYXQgbGVhc3Qgb25lIGFycmF5IGFyZ3VtZW50IHdhcyBzcGVjaWZpZWRcbiAgaWYocHJvYy5hcnJheUFyZ3MubGVuZ3RoIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogTm8gYXJyYXkgYXJndW1lbnRzIHNwZWNpZmllZFwiKVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhcmd1bWVudHMgYXJlIGNvcnJlY3RcbiAgaWYocHJvYy5wcmUuYXJncy5sZW5ndGggPiBwcm9jX2FyZ3MubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFRvbyBtYW55IGFyZ3VtZW50cyBpbiBwcmUoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MuYm9keS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIGJvZHkoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MucG9zdC5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHBvc3QoKSBibG9ja1wiKVxuICB9XG5cbiAgLy9DaGVjayBkZWJ1ZyBmbGFnXG4gIHByb2MuZGVidWcgPSAhIXVzZXJfYXJncy5wcmludENvZGUgfHwgISF1c2VyX2FyZ3MuZGVidWdcbiAgXG4gIC8vUmV0cmlldmUgbmFtZVxuICBwcm9jLmZ1bmNOYW1lID0gdXNlcl9hcmdzLmZ1bmNOYW1lIHx8IFwiY3dpc2VcIlxuICBcbiAgLy9SZWFkIGluIGJsb2NrIHNpemVcbiAgcHJvYy5ibG9ja1NpemUgPSB1c2VyX2FyZ3MuYmxvY2tTaXplIHx8IDY0XG5cbiAgcmV0dXJuIGNyZWF0ZVRodW5rKHByb2MpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZUN3aXNlXG4iXSwibmFtZXMiOlsiY3JlYXRlVGh1bmsiLCJyZXF1aXJlIiwiUHJvY2VkdXJlIiwiYXJnVHlwZXMiLCJzaGltQXJncyIsImFycmF5QXJncyIsImFycmF5QmxvY2tJbmRpY2VzIiwic2NhbGFyQXJncyIsIm9mZnNldEFyZ3MiLCJvZmZzZXRBcmdJbmRleCIsImluZGV4QXJncyIsInNoYXBlQXJncyIsImZ1bmNOYW1lIiwicHJlIiwiYm9keSIsInBvc3QiLCJkZWJ1ZyIsImNvbXBpbGVDd2lzZSIsInVzZXJfYXJncyIsInByb2MiLCJwcm9jX2FyZ3MiLCJhcmdzIiwic2xpY2UiLCJpIiwibGVuZ3RoIiwiYXJnX3R5cGUiLCJibG9ja0luZGljZXMiLCJwdXNoIiwiY291bnQiLCJFcnJvciIsImx2YWx1ZSIsIm9mZnNldCIsImFycmF5IiwicHJpbnRDb2RlIiwiYmxvY2tTaXplIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cwise-compiler/compiler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cwise-compiler/lib/compile.js":
/*!****************************************************!*\
  !*** ./node_modules/cwise-compiler/lib/compile.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar uniq = __webpack_require__(/*! uniq */ \"(ssr)/./node_modules/uniq/uniq.js\");\n// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)\n// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of \"pointers\" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.\nfunction innerFill(order, proc, body) {\n    var dimension = order.length, nargs = proc.arrayArgs.length, has_index = proc.indexArgs.length > 0, code = [], vars = [], idx = 0, pidx = 0, i, j;\n    for(i = 0; i < dimension; ++i){\n        vars.push([\n            \"i\",\n            i,\n            \"=0\"\n        ].join(\"\"));\n    }\n    //Compute scan deltas\n    for(j = 0; j < nargs; ++j){\n        for(i = 0; i < dimension; ++i){\n            pidx = idx;\n            idx = order[i];\n            if (i === 0) {\n                vars.push([\n                    \"d\",\n                    j,\n                    \"s\",\n                    i,\n                    \"=t\",\n                    j,\n                    \"p\",\n                    idx\n                ].join(\"\"));\n            } else {\n                vars.push([\n                    \"d\",\n                    j,\n                    \"s\",\n                    i,\n                    \"=(t\",\n                    j,\n                    \"p\",\n                    idx,\n                    \"-s\",\n                    pidx,\n                    \"*t\",\n                    j,\n                    \"p\",\n                    pidx,\n                    \")\"\n                ].join(\"\"));\n            }\n        }\n    }\n    if (vars.length > 0) {\n        code.push(\"var \" + vars.join(\",\"));\n    }\n    //Scan loop\n    for(i = dimension - 1; i >= 0; --i){\n        idx = order[i];\n        code.push([\n            \"for(i\",\n            i,\n            \"=0;i\",\n            i,\n            \"<s\",\n            idx,\n            \";++i\",\n            i,\n            \"){\"\n        ].join(\"\"));\n    }\n    //Push body of inner loop\n    code.push(body);\n    //Advance scan pointers\n    for(i = 0; i < dimension; ++i){\n        pidx = idx;\n        idx = order[i];\n        for(j = 0; j < nargs; ++j){\n            code.push([\n                \"p\",\n                j,\n                \"+=d\",\n                j,\n                \"s\",\n                i\n            ].join(\"\"));\n        }\n        if (has_index) {\n            if (i > 0) {\n                code.push([\n                    \"index[\",\n                    pidx,\n                    \"]-=s\",\n                    pidx\n                ].join(\"\"));\n            }\n            code.push([\n                \"++index[\",\n                idx,\n                \"]\"\n            ].join(\"\"));\n        }\n        code.push(\"}\");\n    }\n    return code.join(\"\\n\");\n}\n// Generate \"outer\" loops that loop over blocks of data, applying \"inner\" loops to the blocks by manipulating the local variables in such a way that the inner loop only \"sees\" the current block.\n// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.\n//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and \"shape\" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.\nfunction outerFill(matched, order, proc, body) {\n    var dimension = order.length, nargs = proc.arrayArgs.length, blockSize = proc.blockSize, has_index = proc.indexArgs.length > 0, code = [];\n    for(var i = 0; i < nargs; ++i){\n        code.push([\n            \"var offset\",\n            i,\n            \"=p\",\n            i\n        ].join(\"\"));\n    }\n    //Generate loops for unmatched dimensions\n    // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)\n    // TODO: It would be nice if the order in which these loops are placed would also be somehow \"optimal\" (at the very least we should check that it really doesn't hurt us if they're not).\n    for(var i = matched; i < dimension; ++i){\n        code.push([\n            \"for(var j\" + i + \"=SS[\",\n            order[i],\n            \"]|0;j\",\n            i,\n            \">0;){\"\n        ].join(\"\")) // Iterate back to front\n        ;\n        code.push([\n            \"if(j\",\n            i,\n            \"<\",\n            blockSize,\n            \"){\"\n        ].join(\"\")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).\n        ;\n        code.push([\n            \"s\",\n            order[i],\n            \"=j\",\n            i\n        ].join(\"\"));\n        code.push([\n            \"j\",\n            i,\n            \"=0\"\n        ].join(\"\"));\n        code.push([\n            \"}else{s\",\n            order[i],\n            \"=\",\n            blockSize\n        ].join(\"\"));\n        code.push([\n            \"j\",\n            i,\n            \"-=\",\n            blockSize,\n            \"}\"\n        ].join(\"\"));\n        if (has_index) {\n            code.push([\n                \"index[\",\n                order[i],\n                \"]=j\",\n                i\n            ].join(\"\"));\n        }\n    }\n    for(var i = 0; i < nargs; ++i){\n        var indexStr = [\n            \"offset\" + i\n        ];\n        for(var j = matched; j < dimension; ++j){\n            indexStr.push([\n                \"j\",\n                j,\n                \"*t\",\n                i,\n                \"p\",\n                order[j]\n            ].join(\"\"));\n        }\n        code.push([\n            \"p\",\n            i,\n            \"=(\",\n            indexStr.join(\"+\"),\n            \")\"\n        ].join(\"\"));\n    }\n    code.push(innerFill(order, proc, body));\n    for(var i = matched; i < dimension; ++i){\n        code.push(\"}\");\n    }\n    return code.join(\"\\n\");\n}\n//Count the number of compatible inner orders\n// This is the length of the longest common prefix of the arrays in orders.\n// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.\n// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.\nfunction countMatches(orders) {\n    var matched = 0, dimension = orders[0].length;\n    while(matched < dimension){\n        for(var j = 1; j < orders.length; ++j){\n            if (orders[j][matched] !== orders[0][matched]) {\n                return matched;\n            }\n        }\n        ++matched;\n    }\n    return matched;\n}\n//Processes a block according to the given data types\n// Replaces variable names by different ones, either \"local\" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.\nfunction processBlock(block, proc, dtypes) {\n    var code = block.body;\n    var pre = [];\n    var post = [];\n    for(var i = 0; i < block.args.length; ++i){\n        var carg = block.args[i];\n        if (carg.count <= 0) {\n            continue;\n        }\n        var re = new RegExp(carg.name, \"g\");\n        var ptrStr = \"\";\n        var arrNum = proc.arrayArgs.indexOf(i);\n        switch(proc.argTypes[i]){\n            case \"offset\":\n                var offArgIndex = proc.offsetArgIndex.indexOf(i);\n                var offArg = proc.offsetArgs[offArgIndex];\n                arrNum = offArg.array;\n                ptrStr = \"+q\" + offArgIndex // Adds offset to the \"pointer\" in the array\n                ;\n            case \"array\":\n                ptrStr = \"p\" + arrNum + ptrStr;\n                var localStr = \"l\" + i;\n                var arrStr = \"a\" + arrNum;\n                if (proc.arrayBlockIndices[arrNum] === 0) {\n                    if (carg.count === 1) {\n                        if (dtypes[arrNum] === \"generic\") {\n                            if (carg.lvalue) {\n                                pre.push([\n                                    \"var \",\n                                    localStr,\n                                    \"=\",\n                                    arrStr,\n                                    \".get(\",\n                                    ptrStr,\n                                    \")\"\n                                ].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\n                                ;\n                                code = code.replace(re, localStr);\n                                post.push([\n                                    arrStr,\n                                    \".set(\",\n                                    ptrStr,\n                                    \",\",\n                                    localStr,\n                                    \")\"\n                                ].join(\"\"));\n                            } else {\n                                code = code.replace(re, [\n                                    arrStr,\n                                    \".get(\",\n                                    ptrStr,\n                                    \")\"\n                                ].join(\"\"));\n                            }\n                        } else {\n                            code = code.replace(re, [\n                                arrStr,\n                                \"[\",\n                                ptrStr,\n                                \"]\"\n                            ].join(\"\"));\n                        }\n                    } else if (dtypes[arrNum] === \"generic\") {\n                        pre.push([\n                            \"var \",\n                            localStr,\n                            \"=\",\n                            arrStr,\n                            \".get(\",\n                            ptrStr,\n                            \")\"\n                        ].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\n                        ;\n                        code = code.replace(re, localStr);\n                        if (carg.lvalue) {\n                            post.push([\n                                arrStr,\n                                \".set(\",\n                                ptrStr,\n                                \",\",\n                                localStr,\n                                \")\"\n                            ].join(\"\"));\n                        }\n                    } else {\n                        pre.push([\n                            \"var \",\n                            localStr,\n                            \"=\",\n                            arrStr,\n                            \"[\",\n                            ptrStr,\n                            \"]\"\n                        ].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\n                        ;\n                        code = code.replace(re, localStr);\n                        if (carg.lvalue) {\n                            post.push([\n                                arrStr,\n                                \"[\",\n                                ptrStr,\n                                \"]=\",\n                                localStr\n                            ].join(\"\"));\n                        }\n                    }\n                } else {\n                    var reStrArr = [\n                        carg.name\n                    ], ptrStrArr = [\n                        ptrStr\n                    ];\n                    for(var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++){\n                        reStrArr.push(\"\\\\s*\\\\[([^\\\\]]+)\\\\]\");\n                        ptrStrArr.push(\"$\" + (j + 1) + \"*t\" + arrNum + \"b\" + j) // Matched index times stride\n                        ;\n                    }\n                    re = new RegExp(reStrArr.join(\"\"), \"g\");\n                    ptrStr = ptrStrArr.join(\"+\");\n                    if (dtypes[arrNum] === \"generic\") {\n                        /*if(carg.lvalue) {\n              pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\n              code = code.replace(re, localStr)\n              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n            } else {\n              code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n            }*/ throw new Error(\"cwise: Generic arrays not supported in combination with blocks!\");\n                    } else {\n                        // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.\n                        code = code.replace(re, [\n                            arrStr,\n                            \"[\",\n                            ptrStr,\n                            \"]\"\n                        ].join(\"\"));\n                    }\n                }\n                break;\n            case \"scalar\":\n                code = code.replace(re, \"Y\" + proc.scalarArgs.indexOf(i));\n                break;\n            case \"index\":\n                code = code.replace(re, \"index\");\n                break;\n            case \"shape\":\n                code = code.replace(re, \"shape\");\n                break;\n        }\n    }\n    return [\n        pre.join(\"\\n\"),\n        code,\n        post.join(\"\\n\")\n    ].join(\"\\n\").trim();\n}\nfunction typeSummary(dtypes) {\n    var summary = new Array(dtypes.length);\n    var allEqual = true;\n    for(var i = 0; i < dtypes.length; ++i){\n        var t = dtypes[i];\n        var digits = t.match(/\\d+/);\n        if (!digits) {\n            digits = \"\";\n        } else {\n            digits = digits[0];\n        }\n        if (t.charAt(0) === 0) {\n            summary[i] = \"u\" + t.charAt(1) + digits;\n        } else {\n            summary[i] = t.charAt(0) + digits;\n        }\n        if (i > 0) {\n            allEqual = allEqual && summary[i] === summary[i - 1];\n        }\n    }\n    if (allEqual) {\n        return summary[0];\n    }\n    return summary.join(\"\");\n}\n//Generates a cwise operator\nfunction generateCWiseOp(proc, typesig) {\n    //Compute dimension\n    // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.\n    var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;\n    var orders = new Array(proc.arrayArgs.length);\n    var dtypes = new Array(proc.arrayArgs.length);\n    for(var i = 0; i < proc.arrayArgs.length; ++i){\n        dtypes[i] = typesig[2 * i];\n        orders[i] = typesig[2 * i + 1];\n    }\n    //Determine where block and loop indices start and end\n    var blockBegin = [], blockEnd = [] // These indices are exposed as blocks\n    ;\n    var loopBegin = [], loopEnd = [] // These indices are iterated over\n    ;\n    var loopOrders = [] // orders restricted to the loop indices\n    ;\n    for(var i = 0; i < proc.arrayArgs.length; ++i){\n        if (proc.arrayBlockIndices[i] < 0) {\n            loopBegin.push(0);\n            loopEnd.push(dimension);\n            blockBegin.push(dimension);\n            blockEnd.push(dimension + proc.arrayBlockIndices[i]);\n        } else {\n            loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative\n            ;\n            loopEnd.push(proc.arrayBlockIndices[i] + dimension);\n            blockBegin.push(0);\n            blockEnd.push(proc.arrayBlockIndices[i]);\n        }\n        var newOrder = [];\n        for(var j = 0; j < orders[i].length; j++){\n            if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {\n                newOrder.push(orders[i][j] - loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.\n                ;\n            }\n        }\n        loopOrders.push(newOrder);\n    }\n    //First create arguments for procedure\n    var arglist = [\n        \"SS\"\n    ] // SS is the overall shape over which we iterate\n    ;\n    var code = [\n        \"'use strict'\"\n    ];\n    var vars = [];\n    for(var j = 0; j < dimension; ++j){\n        vars.push([\n            \"s\",\n            j,\n            \"=SS[\",\n            j,\n            \"]\"\n        ].join(\"\")) // The limits for each dimension.\n        ;\n    }\n    for(var i = 0; i < proc.arrayArgs.length; ++i){\n        arglist.push(\"a\" + i) // Actual data array\n        ;\n        arglist.push(\"t\" + i) // Strides\n        ;\n        arglist.push(\"p\" + i) // Offset in the array at which the data starts (also used for iterating over the data)\n        ;\n        for(var j = 0; j < dimension; ++j){\n            vars.push([\n                \"t\",\n                i,\n                \"p\",\n                j,\n                \"=t\",\n                i,\n                \"[\",\n                loopBegin[i] + j,\n                \"]\"\n            ].join(\"\"));\n        }\n        for(var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j){\n            vars.push([\n                \"t\",\n                i,\n                \"b\",\n                j,\n                \"=t\",\n                i,\n                \"[\",\n                blockBegin[i] + j,\n                \"]\"\n            ].join(\"\"));\n        }\n    }\n    for(var i = 0; i < proc.scalarArgs.length; ++i){\n        arglist.push(\"Y\" + i);\n    }\n    if (proc.shapeArgs.length > 0) {\n        vars.push(\"shape=SS.slice(0)\") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)\n        ;\n    }\n    if (proc.indexArgs.length > 0) {\n        // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.\n        var zeros = new Array(dimension);\n        for(var i = 0; i < dimension; ++i){\n            zeros[i] = \"0\";\n        }\n        vars.push([\n            \"index=[\",\n            zeros.join(\",\"),\n            \"]\"\n        ].join(\"\"));\n    }\n    for(var i = 0; i < proc.offsetArgs.length; ++i){\n        var off_arg = proc.offsetArgs[i];\n        var init_string = [];\n        for(var j = 0; j < off_arg.offset.length; ++j){\n            if (off_arg.offset[j] === 0) {\n                continue;\n            } else if (off_arg.offset[j] === 1) {\n                init_string.push([\n                    \"t\",\n                    off_arg.array,\n                    \"p\",\n                    j\n                ].join(\"\"));\n            } else {\n                init_string.push([\n                    off_arg.offset[j],\n                    \"*t\",\n                    off_arg.array,\n                    \"p\",\n                    j\n                ].join(\"\"));\n            }\n        }\n        if (init_string.length === 0) {\n            vars.push(\"q\" + i + \"=0\");\n        } else {\n            vars.push([\n                \"q\",\n                i,\n                \"=\",\n                init_string.join(\"+\")\n            ].join(\"\"));\n        }\n    }\n    //Prepare this variables\n    var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));\n    vars = vars.concat(thisVars);\n    if (vars.length > 0) {\n        code.push(\"var \" + vars.join(\",\"));\n    }\n    for(var i = 0; i < proc.arrayArgs.length; ++i){\n        code.push(\"p\" + i + \"|=0\");\n    }\n    //Inline prelude\n    if (proc.pre.body.length > 3) {\n        code.push(processBlock(proc.pre, proc, dtypes));\n    }\n    //Process body\n    var body = processBlock(proc.body, proc, dtypes);\n    var matched = countMatches(loopOrders);\n    if (matched < dimension) {\n        code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.\n        ;\n    } else {\n        code.push(innerFill(loopOrders[0], proc, body));\n    }\n    //Inline epilog\n    if (proc.post.body.length > 3) {\n        code.push(processBlock(proc.post, proc, dtypes));\n    }\n    if (proc.debug) {\n        console.log(\"-----Generated cwise routine for \", typesig, \":\\n\" + code.join(\"\\n\") + \"\\n----------\");\n    }\n    var loopName = [\n        proc.funcName || \"unnamed\",\n        \"_cwise_loop_\",\n        orders[0].join(\"s\"),\n        \"m\",\n        matched,\n        typeSummary(dtypes)\n    ].join(\"\");\n    var f = new Function([\n        \"function \",\n        loopName,\n        \"(\",\n        arglist.join(\",\"),\n        \"){\",\n        code.join(\"\\n\"),\n        \"} return \",\n        loopName\n    ].join(\"\"));\n    return f();\n}\nmodule.exports = generateCWiseOp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL2NvbXBpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxPQUFPQyxtQkFBT0EsQ0FBQywrQ0FBTTtBQUV6Qiw0TUFBNE07QUFDNU0saVdBQWlXO0FBQ2pXLFNBQVNDLFVBQVVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxJQUFJO0lBQ2xDLElBQUlDLFlBQVlILE1BQU1JLE1BQU0sRUFDeEJDLFFBQVFKLEtBQUtLLFNBQVMsQ0FBQ0YsTUFBTSxFQUM3QkcsWUFBWU4sS0FBS08sU0FBUyxDQUFDSixNQUFNLEdBQUMsR0FDbENLLE9BQU8sRUFBRSxFQUNUQyxPQUFPLEVBQUUsRUFDVEMsTUFBSSxHQUFHQyxPQUFLLEdBQUdDLEdBQUdDO0lBQ3RCLElBQUlELElBQUUsR0FBR0EsSUFBRVYsV0FBVyxFQUFFVSxFQUFHO1FBQ3pCSCxLQUFLSyxJQUFJLENBQUM7WUFBQztZQUFJRjtZQUFFO1NBQUssQ0FBQ0csSUFBSSxDQUFDO0lBQzlCO0lBQ0EscUJBQXFCO0lBQ3JCLElBQUlGLElBQUUsR0FBR0EsSUFBRVQsT0FBTyxFQUFFUyxFQUFHO1FBQ3JCLElBQUlELElBQUUsR0FBR0EsSUFBRVYsV0FBVyxFQUFFVSxFQUFHO1lBQ3pCRCxPQUFPRDtZQUNQQSxNQUFNWCxLQUFLLENBQUNhLEVBQUU7WUFDZCxJQUFHQSxNQUFNLEdBQUc7Z0JBQ1ZILEtBQUtLLElBQUksQ0FBQztvQkFBQztvQkFBSUQ7b0JBQUU7b0JBQUlEO29CQUFFO29CQUFLQztvQkFBRTtvQkFBSUg7aUJBQUksQ0FBQ0ssSUFBSSxDQUFDO1lBQzlDLE9BQU87Z0JBQ0xOLEtBQUtLLElBQUksQ0FBQztvQkFBQztvQkFBSUQ7b0JBQUU7b0JBQUlEO29CQUFFO29CQUFNQztvQkFBRTtvQkFBSUg7b0JBQUk7b0JBQUtDO29CQUFLO29CQUFLRTtvQkFBRTtvQkFBSUY7b0JBQUs7aUJBQUksQ0FBQ0ksSUFBSSxDQUFDO1lBQzdFO1FB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QU07UUFBYWtFO0tBQVMsQ0FBQ2xFLElBQUksQ0FBQztJQUNwSCxPQUFPb0U7QUFDVDtBQUNBRSxPQUFPQyxPQUFPLEdBQUd4QiIsInNvdXJjZXMiOlsid2VicGFjazovL21pY3JvcG9zLy4vbm9kZV9tb2R1bGVzL2N3aXNlLWNvbXBpbGVyL2xpYi9jb21waWxlLmpzPzA2YjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHVuaXEgPSByZXF1aXJlKFwidW5pcVwiKVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyB2ZXJ5IHNpbXBsZSBsb29wcyBhbmFsb2dvdXMgdG8gaG93IHlvdSB0eXBpY2FsbHkgdHJhdmVyc2UgYXJyYXlzICh0aGUgb3V0ZXJtb3N0IGxvb3AgY29ycmVzcG9uZHMgdG8gdGhlIHNsb3dlc3QgY2hhbmdpbmcgaW5kZXgsIHRoZSBpbm5lcm1vc3QgbG9vcCB0byB0aGUgZmFzdGVzdCBjaGFuZ2luZyBpbmRleClcbi8vIFRPRE86IElmIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBzdHJpZGVzIChhbmQgb2Zmc2V0cykgdGhlcmUgaXMgcG90ZW50aWFsIGZvciBkZWNyZWFzaW5nIHRoZSBudW1iZXIgb2YgXCJwb2ludGVyc1wiIGFuZCByZWxhdGVkIHZhcmlhYmxlcy4gVGhlIGRyYXdiYWNrIGlzIHRoYXQgdGhlIHR5cGUgc2lnbmF0dXJlIHdvdWxkIGJlY29tZSBtb3JlIHNwZWNpZmljIGFuZCB0aGF0IHRoZXJlIHdvdWxkIHRodXMgYmUgbGVzcyBwb3RlbnRpYWwgZm9yIGNhY2hpbmcsIGJ1dCBpdCBtaWdodCBzdGlsbCBiZSB3b3J0aCBpdCwgZXNwZWNpYWxseSB3aGVuIGRlYWxpbmcgd2l0aCBsYXJnZSBudW1iZXJzIG9mIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgaGFzX2luZGV4ID0gcHJvYy5pbmRleEFyZ3MubGVuZ3RoPjBcbiAgICAsIGNvZGUgPSBbXVxuICAgICwgdmFycyA9IFtdXG4gICAgLCBpZHg9MCwgcGlkeD0wLCBpLCBqXG4gIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHsgLy8gSXRlcmF0aW9uIHZhcmlhYmxlc1xuICAgIHZhcnMucHVzaChbXCJpXCIsaSxcIj0wXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9Db21wdXRlIHNjYW4gZGVsdGFzXG4gIGZvcihqPTA7IGo8bmFyZ3M7ICsraikge1xuICAgIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIHBpZHggPSBpZHhcbiAgICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgICBpZihpID09PSAwKSB7IC8vIFRoZSBpbm5lcm1vc3QvZmFzdGVzdCBkaW1lbnNpb24ncyBkZWx0YSBpcyBzaW1wbHkgaXRzIHN0cmlkZVxuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj10XCIsaixcInBcIixpZHhdLmpvaW4oXCJcIikpXG4gICAgICB9IGVsc2UgeyAvLyBGb3Igb3RoZXIgZGltZW5zaW9ucyB0aGUgZGVsdGEgaXMgYmFzaWNhbGx5IHRoZSBzdHJpZGUgbWludXMgc29tZXRoaW5nIHdoaWNoIGVzc2VudGlhbGx5IFwicmV3aW5kc1wiIHRoZSBwcmV2aW91cyAobW9yZSBpbm5lcikgZGltZW5zaW9uXG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPSh0XCIsaixcInBcIixpZHgsXCItc1wiLHBpZHgsXCIqdFwiLGosXCJwXCIscGlkeCxcIilcIl0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZhcnMubGVuZ3RoID4gMCkge1xuICAgIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIH0gIFxuICAvL1NjYW4gbG9vcFxuICBmb3IoaT1kaW1lbnNpb24tMTsgaT49MDsgLS1pKSB7IC8vIFN0YXJ0IGF0IGxhcmdlc3Qgc3RyaWRlIGFuZCB3b3JrIHlvdXIgd2F5IGlud2FyZHNcbiAgICBpZHggPSBvcmRlcltpXVxuICAgIGNvZGUucHVzaChbXCJmb3IoaVwiLGksXCI9MDtpXCIsaSxcIjxzXCIsaWR4LFwiOysraVwiLGksXCIpe1wiXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vUHVzaCBib2R5IG9mIGlubmVyIGxvb3BcbiAgY29kZS5wdXNoKGJvZHkpXG4gIC8vQWR2YW5jZSBzY2FuIHBvaW50ZXJzXG4gIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBwaWR4ID0gaWR4XG4gICAgaWR4ID0gb3JkZXJbaV1cbiAgICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcbiAgICAgIGNvZGUucHVzaChbXCJwXCIsaixcIis9ZFwiLGosXCJzXCIsaV0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgaWYoaGFzX2luZGV4KSB7XG4gICAgICBpZihpID4gMCkge1xuICAgICAgICBjb2RlLnB1c2goW1wiaW5kZXhbXCIscGlkeCxcIl0tPXNcIixwaWR4XS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFtcIisraW5kZXhbXCIsaWR4LFwiXVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgcmV0dXJuIGNvZGUuam9pbihcIlxcblwiKVxufVxuXG4vLyBHZW5lcmF0ZSBcIm91dGVyXCIgbG9vcHMgdGhhdCBsb29wIG92ZXIgYmxvY2tzIG9mIGRhdGEsIGFwcGx5aW5nIFwiaW5uZXJcIiBsb29wcyB0byB0aGUgYmxvY2tzIGJ5IG1hbmlwdWxhdGluZyB0aGUgbG9jYWwgdmFyaWFibGVzIGluIHN1Y2ggYSB3YXkgdGhhdCB0aGUgaW5uZXIgbG9vcCBvbmx5IFwic2Vlc1wiIHRoZSBjdXJyZW50IGJsb2NrLlxuLy8gVE9ETzogSWYgdGhpcyBpcyB1c2VkLCB0aGVuIHRoZSBwcmV2aW91cyBkZWNsYXJhdGlvbiAoZG9uZSBieSBnZW5lcmF0ZUN3aXNlT3ApIG9mIHMqIGlzIGVzc2VudGlhbGx5IHVubmVjZXNzYXJ5LlxuLy8gICAgICAgSSBiZWxpZXZlIHRoZSBzKiBhcmUgbm90IHVzZWQgZWxzZXdoZXJlIChpbiBwYXJ0aWN1bGFyLCBJIGRvbid0IHRoaW5rIHRoZXkncmUgdXNlZCBpbiB0aGUgcHJlL3Bvc3QgcGFydHMgYW5kIFwic2hhcGVcIiBpcyBkZWZpbmVkIGluZGVwZW5kZW50bHkpLCBzbyBpdCB3b3VsZCBiZSBwb3NzaWJsZSB0byBtYWtlIGRlZmluaW5nIHRoZSBzKiBkZXBlbmRlbnQgb24gd2hhdCBsb29wIG1ldGhvZCBpcyBiZWluZyB1c2VkLlxuZnVuY3Rpb24gb3V0ZXJGaWxsKG1hdGNoZWQsIG9yZGVyLCBwcm9jLCBib2R5KSB7XG4gIHZhciBkaW1lbnNpb24gPSBvcmRlci5sZW5ndGhcbiAgICAsIG5hcmdzID0gcHJvYy5hcnJheUFyZ3MubGVuZ3RoXG4gICAgLCBibG9ja1NpemUgPSBwcm9jLmJsb2NrU2l6ZVxuICAgICwgaGFzX2luZGV4ID0gcHJvYy5pbmRleEFyZ3MubGVuZ3RoID4gMFxuICAgICwgY29kZSA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPG5hcmdzOyArK2kpIHtcbiAgICBjb2RlLnB1c2goW1widmFyIG9mZnNldFwiLGksXCI9cFwiLGldLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9HZW5lcmF0ZSBsb29wcyBmb3IgdW5tYXRjaGVkIGRpbWVuc2lvbnNcbiAgLy8gVGhlIG9yZGVyIGluIHdoaWNoIHRoZXNlIGRpbWVuc2lvbnMgYXJlIHRyYXZlcnNlZCBpcyBmYWlybHkgYXJiaXRyYXJ5IChmcm9tIHNtYWxsIHN0cmlkZSB0byBsYXJnZSBzdHJpZGUsIGZvciB0aGUgZmlyc3QgYXJndW1lbnQpXG4gIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXNlIGxvb3BzIGFyZSBwbGFjZWQgd291bGQgYWxzbyBiZSBzb21laG93IFwib3B0aW1hbFwiIChhdCB0aGUgdmVyeSBsZWFzdCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpdCByZWFsbHkgZG9lc24ndCBodXJ0IHVzIGlmIHRoZXkncmUgbm90KS5cbiAgZm9yKHZhciBpPW1hdGNoZWQ7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goW1wiZm9yKHZhciBqXCIraStcIj1TU1tcIiwgb3JkZXJbaV0sIFwiXXwwO2pcIiwgaSwgXCI+MDspe1wiXS5qb2luKFwiXCIpKSAvLyBJdGVyYXRlIGJhY2sgdG8gZnJvbnRcbiAgICBjb2RlLnB1c2goW1wiaWYoalwiLGksXCI8XCIsYmxvY2tTaXplLFwiKXtcIl0uam9pbihcIlwiKSkgLy8gRWl0aGVyIGRlY3JlYXNlIGogYnkgYmxvY2tTaXplIChzID0gYmxvY2tTaXplKSwgb3Igc2V0IGl0IHRvIHplcm8gKGFmdGVyIHNldHRpbmcgcyA9IGopLlxuICAgIGNvZGUucHVzaChbXCJzXCIsb3JkZXJbaV0sXCI9alwiLGldLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcImpcIixpLFwiPTBcIl0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wifWVsc2V7c1wiLG9yZGVyW2ldLFwiPVwiLGJsb2NrU2l6ZV0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wialwiLGksXCItPVwiLGJsb2NrU2l6ZSxcIn1cIl0uam9pbihcIlwiKSlcbiAgICBpZihoYXNfaW5kZXgpIHtcbiAgICAgIGNvZGUucHVzaChbXCJpbmRleFtcIixvcmRlcltpXSxcIl09alwiLGldLmpvaW4oXCJcIikpXG4gICAgfVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPG5hcmdzOyArK2kpIHtcbiAgICB2YXIgaW5kZXhTdHIgPSBbXCJvZmZzZXRcIitpXVxuICAgIGZvcih2YXIgaj1tYXRjaGVkOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICBpbmRleFN0ci5wdXNoKFtcImpcIixqLFwiKnRcIixpLFwicFwiLG9yZGVyW2pdXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goW1wicFwiLGksXCI9KFwiLGluZGV4U3RyLmpvaW4oXCIrXCIpLFwiKVwiXS5qb2luKFwiXCIpKVxuICB9XG4gIGNvZGUucHVzaChpbm5lckZpbGwob3JkZXIsIHByb2MsIGJvZHkpKVxuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXG59XG5cbi8vQ291bnQgdGhlIG51bWJlciBvZiBjb21wYXRpYmxlIGlubmVyIG9yZGVyc1xuLy8gVGhpcyBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBsb25nZXN0IGNvbW1vbiBwcmVmaXggb2YgdGhlIGFycmF5cyBpbiBvcmRlcnMuXG4vLyBFYWNoIGFycmF5IGluIG9yZGVycyBsaXN0cyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgY29ycmVzcG9uZCBuZGFycmF5IGluIG9yZGVyIG9mIGluY3JlYXNpbmcgc3RyaWRlLlxuLy8gVGhpcyBpcyB0aHVzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkaW1lbnNpb25zIHRoYXQgY2FuIGJlIGVmZmljaWVudGx5IHRyYXZlcnNlZCBieSBzaW1wbGUgbmVzdGVkIGxvb3BzIGZvciBhbGwgYXJyYXlzLlxuZnVuY3Rpb24gY291bnRNYXRjaGVzKG9yZGVycykge1xuICB2YXIgbWF0Y2hlZCA9IDAsIGRpbWVuc2lvbiA9IG9yZGVyc1swXS5sZW5ndGhcbiAgd2hpbGUobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xuICAgIGZvcih2YXIgaj0xOyBqPG9yZGVycy5sZW5ndGg7ICsraikge1xuICAgICAgaWYob3JkZXJzW2pdW21hdGNoZWRdICE9PSBvcmRlcnNbMF1bbWF0Y2hlZF0pIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZWRcbiAgICAgIH1cbiAgICB9XG4gICAgKyttYXRjaGVkXG4gIH1cbiAgcmV0dXJuIG1hdGNoZWRcbn1cblxuLy9Qcm9jZXNzZXMgYSBibG9jayBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGRhdGEgdHlwZXNcbi8vIFJlcGxhY2VzIHZhcmlhYmxlIG5hbWVzIGJ5IGRpZmZlcmVudCBvbmVzLCBlaXRoZXIgXCJsb2NhbFwiIG9uZXMgKHRoYXQgYXJlIHRoZW4gZmVycmllZCBpbiBhbmQgb3V0IG9mIHRoZSBnaXZlbiBhcnJheSkgb3Igb25lcyBtYXRjaGluZyB0aGUgYXJndW1lbnRzIHRoYXQgdGhlIGZ1bmN0aW9uIHBlcmZvcm1pbmcgdGhlIHVsdGltYXRlIGxvb3Agd2lsbCBhY2NlcHQuXG5mdW5jdGlvbiBwcm9jZXNzQmxvY2soYmxvY2ssIHByb2MsIGR0eXBlcykge1xuICB2YXIgY29kZSA9IGJsb2NrLmJvZHlcbiAgdmFyIHByZSA9IFtdXG4gIHZhciBwb3N0ID0gW11cbiAgZm9yKHZhciBpPTA7IGk8YmxvY2suYXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjYXJnID0gYmxvY2suYXJnc1tpXVxuICAgIGlmKGNhcmcuY291bnQgPD0gMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cChjYXJnLm5hbWUsIFwiZ1wiKVxuICAgIHZhciBwdHJTdHIgPSBcIlwiXG4gICAgdmFyIGFyck51bSA9IHByb2MuYXJyYXlBcmdzLmluZGV4T2YoaSlcbiAgICBzd2l0Y2gocHJvYy5hcmdUeXBlc1tpXSkge1xuICAgICAgY2FzZSBcIm9mZnNldFwiOlxuICAgICAgICB2YXIgb2ZmQXJnSW5kZXggPSBwcm9jLm9mZnNldEFyZ0luZGV4LmluZGV4T2YoaSlcbiAgICAgICAgdmFyIG9mZkFyZyA9IHByb2Mub2Zmc2V0QXJnc1tvZmZBcmdJbmRleF1cbiAgICAgICAgYXJyTnVtID0gb2ZmQXJnLmFycmF5XG4gICAgICAgIHB0clN0ciA9IFwiK3FcIiArIG9mZkFyZ0luZGV4IC8vIEFkZHMgb2Zmc2V0IHRvIHRoZSBcInBvaW50ZXJcIiBpbiB0aGUgYXJyYXlcbiAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICBwdHJTdHIgPSBcInBcIiArIGFyck51bSArIHB0clN0clxuICAgICAgICB2YXIgbG9jYWxTdHIgPSBcImxcIiArIGlcbiAgICAgICAgdmFyIGFyclN0ciA9IFwiYVwiICsgYXJyTnVtXG4gICAgICAgIGlmIChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2Fyck51bV0gPT09IDApIHsgLy8gQXJndW1lbnQgdG8gYm9keSBpcyBqdXN0IGEgc2luZ2xlIHZhbHVlIGZyb20gdGhpcyBhcnJheVxuICAgICAgICAgIGlmKGNhcmcuY291bnQgPT09IDEpIHsgLy8gQXJndW1lbnQvYXJyYXkgdXNlZCBvbmx5IG9uY2UoPylcbiAgICAgICAgICAgIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSkgLy8gSXMgdGhpcyBuZWNlc3NhcnkgaWYgdGhlIGFyZ3VtZW50IGlzIE9OTFkgdXNlZCBhcyBhbiBsdmFsdWU/IChrZWVwIGluIG1pbmQgdGhhdCB3ZSBjYW4gaGF2ZSBhICs9IHNvbWV0aGluZywgc28gd2Ugd291bGQgYWN0dWFsbHkgbmVlZCB0byBjaGVjayBjYXJnLnJ2YWx1ZSlcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCIuc2V0KFwiLCBwdHJTdHIsIFwiLFwiLCBsb2NhbFN0cixcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSkgLy8gVE9ETzogQ291bGQgd2Ugb3B0aW1pemUgYnkgY2hlY2tpbmcgZm9yIGNhcmcucnZhbHVlP1xuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCIuc2V0KFwiLCBwdHJTdHIsIFwiLFwiLCBsb2NhbFN0cixcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdXCJdLmpvaW4oXCJcIikpIC8vIFRPRE86IENvdWxkIHdlIG9wdGltaXplIGJ5IGNoZWNraW5nIGZvciBjYXJnLnJ2YWx1ZT9cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXT1cIiwgbG9jYWxTdHJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBBcmd1bWVudCB0byBib2R5IGlzIGEgXCJibG9ja1wiXG4gICAgICAgICAgdmFyIHJlU3RyQXJyID0gW2NhcmcubmFtZV0sIHB0clN0ckFyciA9IFtwdHJTdHJdXG4gICAgICAgICAgZm9yKHZhciBqPTA7IGo8TWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1thcnJOdW1dKTsgaisrKSB7XG4gICAgICAgICAgICByZVN0ckFyci5wdXNoKFwiXFxcXHMqXFxcXFsoW15cXFxcXV0rKVxcXFxdXCIpXG4gICAgICAgICAgICBwdHJTdHJBcnIucHVzaChcIiRcIiArIChqKzEpICsgXCIqdFwiICsgYXJyTnVtICsgXCJiXCIgKyBqKSAvLyBNYXRjaGVkIGluZGV4IHRpbWVzIHN0cmlkZVxuICAgICAgICAgIH1cbiAgICAgICAgICByZSA9IG5ldyBSZWdFeHAocmVTdHJBcnIuam9pbihcIlwiKSwgXCJnXCIpXG4gICAgICAgICAgcHRyU3RyID0gcHRyU3RyQXJyLmpvaW4oXCIrXCIpXG4gICAgICAgICAgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICAvKmlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSkgLy8gSXMgdGhpcyBuZWNlc3NhcnkgaWYgdGhlIGFyZ3VtZW50IGlzIE9OTFkgdXNlZCBhcyBhbiBsdmFsdWU/IChrZWVwIGluIG1pbmQgdGhhdCB3ZSBjYW4gaGF2ZSBhICs9IHNvbWV0aGluZywgc28gd2Ugd291bGQgYWN0dWFsbHkgbmVlZCB0byBjaGVjayBjYXJnLnJ2YWx1ZSlcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogR2VuZXJpYyBhcnJheXMgbm90IHN1cHBvcnRlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGJsb2NrcyFcIilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBkb2VzIG5vdCBwcm9kdWNlIGFueSBsb2NhbCB2YXJpYWJsZXMsIGV2ZW4gaWYgdmFyaWFibGVzIGFyZSB1c2VkIG11bHRpcGxlIHRpbWVzLiBJdCB3b3VsZCBiZSBwb3NzaWJsZSB0byBkbyBzbywgYnV0IGl0IHdvdWxkIGNvbXBsaWNhdGUgdGhpbmdzIHF1aXRlIGEgYml0LlxuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBicmVha1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcIllcIiArIHByb2Muc2NhbGFyQXJncy5pbmRleE9mKGkpKVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJpbmRleFwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcImluZGV4XCIpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcInNoYXBlXCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwic2hhcGVcIilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiBbcHJlLmpvaW4oXCJcXG5cIiksIGNvZGUsIHBvc3Quam9pbihcIlxcblwiKV0uam9pbihcIlxcblwiKS50cmltKClcbn1cblxuZnVuY3Rpb24gdHlwZVN1bW1hcnkoZHR5cGVzKSB7XG4gIHZhciBzdW1tYXJ5ID0gbmV3IEFycmF5KGR0eXBlcy5sZW5ndGgpXG4gIHZhciBhbGxFcXVhbCA9IHRydWVcbiAgZm9yKHZhciBpPTA7IGk8ZHR5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHQgPSBkdHlwZXNbaV1cbiAgICB2YXIgZGlnaXRzID0gdC5tYXRjaCgvXFxkKy8pXG4gICAgaWYoIWRpZ2l0cykge1xuICAgICAgZGlnaXRzID0gXCJcIlxuICAgIH0gZWxzZSB7XG4gICAgICBkaWdpdHMgPSBkaWdpdHNbMF1cbiAgICB9XG4gICAgaWYodC5jaGFyQXQoMCkgPT09IDApIHtcbiAgICAgIHN1bW1hcnlbaV0gPSBcInVcIiArIHQuY2hhckF0KDEpICsgZGlnaXRzXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1bW1hcnlbaV0gPSB0LmNoYXJBdCgwKSArIGRpZ2l0c1xuICAgIH1cbiAgICBpZihpID4gMCkge1xuICAgICAgYWxsRXF1YWwgPSBhbGxFcXVhbCAmJiBzdW1tYXJ5W2ldID09PSBzdW1tYXJ5W2ktMV1cbiAgICB9XG4gIH1cbiAgaWYoYWxsRXF1YWwpIHtcbiAgICByZXR1cm4gc3VtbWFyeVswXVxuICB9XG4gIHJldHVybiBzdW1tYXJ5LmpvaW4oXCJcIilcbn1cblxuLy9HZW5lcmF0ZXMgYSBjd2lzZSBvcGVyYXRvclxuZnVuY3Rpb24gZ2VuZXJhdGVDV2lzZU9wKHByb2MsIHR5cGVzaWcpIHtcblxuICAvL0NvbXB1dGUgZGltZW5zaW9uXG4gIC8vIEFycmF5cyBnZXQgcHV0IGZpcnN0IGluIHR5cGVzaWcsIGFuZCB0aGVyZSBhcmUgdHdvIGVudHJpZXMgcGVyIGFycmF5IChkdHlwZSBhbmQgb3JkZXIpLCBzbyB0aGlzIGdldHMgdGhlIG51bWJlciBvZiBkaW1lbnNpb25zIGluIHRoZSBmaXJzdCBhcnJheSBhcmcuXG4gIHZhciBkaW1lbnNpb24gPSAodHlwZXNpZ1sxXS5sZW5ndGggLSBNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSl8MFxuICB2YXIgb3JkZXJzID0gbmV3IEFycmF5KHByb2MuYXJyYXlBcmdzLmxlbmd0aClcbiAgdmFyIGR0eXBlcyA9IG5ldyBBcnJheShwcm9jLmFycmF5QXJncy5sZW5ndGgpXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgZHR5cGVzW2ldID0gdHlwZXNpZ1syKmldXG4gICAgb3JkZXJzW2ldID0gdHlwZXNpZ1syKmkrMV1cbiAgfVxuICBcbiAgLy9EZXRlcm1pbmUgd2hlcmUgYmxvY2sgYW5kIGxvb3AgaW5kaWNlcyBzdGFydCBhbmQgZW5kXG4gIHZhciBibG9ja0JlZ2luID0gW10sIGJsb2NrRW5kID0gW10gLy8gVGhlc2UgaW5kaWNlcyBhcmUgZXhwb3NlZCBhcyBibG9ja3NcbiAgdmFyIGxvb3BCZWdpbiA9IFtdLCBsb29wRW5kID0gW10gLy8gVGhlc2UgaW5kaWNlcyBhcmUgaXRlcmF0ZWQgb3ZlclxuICB2YXIgbG9vcE9yZGVycyA9IFtdIC8vIG9yZGVycyByZXN0cmljdGVkIHRvIHRoZSBsb29wIGluZGljZXNcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXTwwKSB7XG4gICAgICBsb29wQmVnaW4ucHVzaCgwKVxuICAgICAgbG9vcEVuZC5wdXNoKGRpbWVuc2lvbilcbiAgICAgIGJsb2NrQmVnaW4ucHVzaChkaW1lbnNpb24pXG4gICAgICBibG9ja0VuZC5wdXNoKGRpbWVuc2lvbitwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKVxuICAgIH0gZWxzZSB7XG4gICAgICBsb29wQmVnaW4ucHVzaChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKSAvLyBOb24tbmVnYXRpdmVcbiAgICAgIGxvb3BFbmQucHVzaChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldK2RpbWVuc2lvbilcbiAgICAgIGJsb2NrQmVnaW4ucHVzaCgwKVxuICAgICAgYmxvY2tFbmQucHVzaChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKVxuICAgIH1cbiAgICB2YXIgbmV3T3JkZXIgPSBbXVxuICAgIGZvcih2YXIgaj0wOyBqPG9yZGVyc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGxvb3BCZWdpbltpXTw9b3JkZXJzW2ldW2pdICYmIG9yZGVyc1tpXVtqXTxsb29wRW5kW2ldKSB7XG4gICAgICAgIG5ld09yZGVyLnB1c2gob3JkZXJzW2ldW2pdLWxvb3BCZWdpbltpXSkgLy8gSWYgdGhpcyBpcyBhIGxvb3AgaW5kZXgsIHB1dCBpdCBpbiBuZXdPcmRlciwgc3VidHJhY3RpbmcgbG9vcEJlZ2luLCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgbG9vcE9yZGVycyBhcmUgdXNpbmcgYSBjb21tb24gc2V0IG9mIGluZGljZXMuXG4gICAgICB9XG4gICAgfVxuICAgIGxvb3BPcmRlcnMucHVzaChuZXdPcmRlcilcbiAgfVxuXG4gIC8vRmlyc3QgY3JlYXRlIGFyZ3VtZW50cyBmb3IgcHJvY2VkdXJlXG4gIHZhciBhcmdsaXN0ID0gW1wiU1NcIl0gLy8gU1MgaXMgdGhlIG92ZXJhbGwgc2hhcGUgb3ZlciB3aGljaCB3ZSBpdGVyYXRlXG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCJdXG4gIHZhciB2YXJzID0gW11cbiAgXG4gIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgdmFycy5wdXNoKFtcInNcIiwgaiwgXCI9U1NbXCIsIGosIFwiXVwiXS5qb2luKFwiXCIpKSAvLyBUaGUgbGltaXRzIGZvciBlYWNoIGRpbWVuc2lvbi5cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGFyZ2xpc3QucHVzaChcImFcIitpKSAvLyBBY3R1YWwgZGF0YSBhcnJheVxuICAgIGFyZ2xpc3QucHVzaChcInRcIitpKSAvLyBTdHJpZGVzXG4gICAgYXJnbGlzdC5wdXNoKFwicFwiK2kpIC8vIE9mZnNldCBpbiB0aGUgYXJyYXkgYXQgd2hpY2ggdGhlIGRhdGEgc3RhcnRzIChhbHNvIHVzZWQgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSBkYXRhKVxuICAgIFxuICAgIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7IC8vIFVucGFjayB0aGUgc3RyaWRlcyBpbnRvIHZhcnMgZm9yIGxvb3BpbmdcbiAgICAgIHZhcnMucHVzaChbXCJ0XCIsaSxcInBcIixqLFwiPXRcIixpLFwiW1wiLGxvb3BCZWdpbltpXStqLFwiXVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBcbiAgICBmb3IodmFyIGo9MDsgajxNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKTsgKytqKSB7IC8vIFVucGFjayB0aGUgc3RyaWRlcyBpbnRvIHZhcnMgZm9yIGJsb2NrIGl0ZXJhdGlvblxuICAgICAgdmFycy5wdXNoKFtcInRcIixpLFwiYlwiLGosXCI9dFwiLGksXCJbXCIsYmxvY2tCZWdpbltpXStqLFwiXVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLnNjYWxhckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdsaXN0LnB1c2goXCJZXCIgKyBpKVxuICB9XG4gIGlmKHByb2Muc2hhcGVBcmdzLmxlbmd0aCA+IDApIHtcbiAgICB2YXJzLnB1c2goXCJzaGFwZT1TUy5zbGljZSgwKVwiKSAvLyBNYWtlcyB0aGUgc2hhcGUgb3ZlciB3aGljaCB3ZSBpdGVyYXRlIGF2YWlsYWJsZSB0byB0aGUgdXNlciBkZWZpbmVkIGZ1bmN0aW9ucyAoc28geW91IGNhbiB1c2Ugd2lkdGgvaGVpZ2h0IGZvciBleGFtcGxlKVxuICB9XG4gIGlmKHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBQcmVwYXJlIGFuIGFycmF5IHRvIGtlZXAgdHJhY2sgb2YgdGhlIChsb2dpY2FsKSBpbmRpY2VzLCBpbml0aWFsaXplZCB0byBkaW1lbnNpb24gemVyb2VzLlxuICAgIHZhciB6ZXJvcyA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gICAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIHplcm9zW2ldID0gXCIwXCJcbiAgICB9XG4gICAgdmFycy5wdXNoKFtcImluZGV4PVtcIiwgemVyb3Muam9pbihcIixcIiksIFwiXVwiXS5qb2luKFwiXCIpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2Mub2Zmc2V0QXJncy5sZW5ndGg7ICsraSkgeyAvLyBPZmZzZXQgYXJndW1lbnRzIHVzZWQgZm9yIHN0ZW5jaWwgb3BlcmF0aW9uc1xuICAgIHZhciBvZmZfYXJnID0gcHJvYy5vZmZzZXRBcmdzW2ldXG4gICAgdmFyIGluaXRfc3RyaW5nID0gW11cbiAgICBmb3IodmFyIGo9MDsgajxvZmZfYXJnLm9mZnNldC5sZW5ndGg7ICsraikge1xuICAgICAgaWYob2ZmX2FyZy5vZmZzZXRbal0gPT09IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZihvZmZfYXJnLm9mZnNldFtqXSA9PT0gMSkge1xuICAgICAgICBpbml0X3N0cmluZy5wdXNoKFtcInRcIiwgb2ZmX2FyZy5hcnJheSwgXCJwXCIsIGpdLmpvaW4oXCJcIikpICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0X3N0cmluZy5wdXNoKFtvZmZfYXJnLm9mZnNldFtqXSwgXCIqdFwiLCBvZmZfYXJnLmFycmF5LCBcInBcIiwgal0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoaW5pdF9zdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXJzLnB1c2goXCJxXCIgKyBpICsgXCI9MFwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXJzLnB1c2goW1wicVwiLCBpLCBcIj1cIiwgaW5pdF9zdHJpbmcuam9pbihcIitcIildLmpvaW4oXCJcIikpXG4gICAgfVxuICB9XG5cbiAgLy9QcmVwYXJlIHRoaXMgdmFyaWFibGVzXG4gIHZhciB0aGlzVmFycyA9IHVuaXEoW10uY29uY2F0KHByb2MucHJlLnRoaXNWYXJzKVxuICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocHJvYy5ib2R5LnRoaXNWYXJzKVxuICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocHJvYy5wb3N0LnRoaXNWYXJzKSlcbiAgdmFycyA9IHZhcnMuY29uY2F0KHRoaXNWYXJzKVxuICBpZiAodmFycy5sZW5ndGggPiAwKSB7XG4gICAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGNvZGUucHVzaChcInBcIitpK1wifD0wXCIpXG4gIH1cbiAgXG4gIC8vSW5saW5lIHByZWx1ZGVcbiAgaWYocHJvYy5wcmUuYm9keS5sZW5ndGggPiAzKSB7XG4gICAgY29kZS5wdXNoKHByb2Nlc3NCbG9jayhwcm9jLnByZSwgcHJvYywgZHR5cGVzKSlcbiAgfVxuXG4gIC8vUHJvY2VzcyBib2R5XG4gIHZhciBib2R5ID0gcHJvY2Vzc0Jsb2NrKHByb2MuYm9keSwgcHJvYywgZHR5cGVzKVxuICB2YXIgbWF0Y2hlZCA9IGNvdW50TWF0Y2hlcyhsb29wT3JkZXJzKVxuICBpZihtYXRjaGVkIDwgZGltZW5zaW9uKSB7XG4gICAgY29kZS5wdXNoKG91dGVyRmlsbChtYXRjaGVkLCBsb29wT3JkZXJzWzBdLCBwcm9jLCBib2R5KSkgLy8gVE9ETzogUmF0aGVyIHRoYW4gcGFzc2luZyBsb29wT3JkZXJzWzBdLCBpdCBtaWdodCBiZSBpbnRlcmVzdGluZyB0byBsb29rIGF0IHBhc3NpbmcgYW4gb3JkZXIgdGhhdCByZXByZXNlbnRzIHRoZSBtYWpvcml0eSBvZiB0aGUgYXJndW1lbnRzIGZvciBleGFtcGxlLlxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChpbm5lckZpbGwobG9vcE9yZGVyc1swXSwgcHJvYywgYm9keSkpXG4gIH1cblxuICAvL0lubGluZSBlcGlsb2dcbiAgaWYocHJvYy5wb3N0LmJvZHkubGVuZ3RoID4gMykge1xuICAgIGNvZGUucHVzaChwcm9jZXNzQmxvY2socHJvYy5wb3N0LCBwcm9jLCBkdHlwZXMpKVxuICB9XG4gIFxuICBpZihwcm9jLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coXCItLS0tLUdlbmVyYXRlZCBjd2lzZSByb3V0aW5lIGZvciBcIiwgdHlwZXNpZywgXCI6XFxuXCIgKyBjb2RlLmpvaW4oXCJcXG5cIikgKyBcIlxcbi0tLS0tLS0tLS1cIilcbiAgfVxuICBcbiAgdmFyIGxvb3BOYW1lID0gWyhwcm9jLmZ1bmNOYW1lfHxcInVubmFtZWRcIiksIFwiX2N3aXNlX2xvb3BfXCIsIG9yZGVyc1swXS5qb2luKFwic1wiKSxcIm1cIixtYXRjaGVkLHR5cGVTdW1tYXJ5KGR0eXBlcyldLmpvaW4oXCJcIilcbiAgdmFyIGYgPSBuZXcgRnVuY3Rpb24oW1wiZnVuY3Rpb24gXCIsbG9vcE5hbWUsXCIoXCIsIGFyZ2xpc3Quam9pbihcIixcIiksXCIpe1wiLCBjb2RlLmpvaW4oXCJcXG5cIiksXCJ9IHJldHVybiBcIiwgbG9vcE5hbWVdLmpvaW4oXCJcIikpXG4gIHJldHVybiBmKClcbn1cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVDV2lzZU9wXG4iXSwibmFtZXMiOlsidW5pcSIsInJlcXVpcmUiLCJpbm5lckZpbGwiLCJvcmRlciIsInByb2MiLCJib2R5IiwiZGltZW5zaW9uIiwibGVuZ3RoIiwibmFyZ3MiLCJhcnJheUFyZ3MiLCJoYXNfaW5kZXgiLCJpbmRleEFyZ3MiLCJjb2RlIiwidmFycyIsImlkeCIsInBpZHgiLCJpIiwiaiIsInB1c2giLCJqb2luIiwib3V0ZXJGaWxsIiwibWF0Y2hlZCIsImJsb2NrU2l6ZSIsImluZGV4U3RyIiwiY291bnRNYXRjaGVzIiwib3JkZXJzIiwicHJvY2Vzc0Jsb2NrIiwiYmxvY2siLCJkdHlwZXMiLCJwcmUiLCJwb3N0IiwiYXJncyIsImNhcmciLCJjb3VudCIsInJlIiwiUmVnRXhwIiwibmFtZSIsInB0clN0ciIsImFyck51bSIsImluZGV4T2YiLCJhcmdUeXBlcyIsIm9mZkFyZ0luZGV4Iiwib2Zmc2V0QXJnSW5kZXgiLCJvZmZBcmciLCJvZmZzZXRBcmdzIiwiYXJyYXkiLCJsb2NhbFN0ciIsImFyclN0ciIsImFycmF5QmxvY2tJbmRpY2VzIiwibHZhbHVlIiwicmVwbGFjZSIsInJlU3RyQXJyIiwicHRyU3RyQXJyIiwiTWF0aCIsImFicyIsIkVycm9yIiwic2NhbGFyQXJncyIsInRyaW0iLCJ0eXBlU3VtbWFyeSIsInN1bW1hcnkiLCJBcnJheSIsImFsbEVxdWFsIiwidCIsImRpZ2l0cyIsIm1hdGNoIiwiY2hhckF0IiwiZ2VuZXJhdGVDV2lzZU9wIiwidHlwZXNpZyIsImJsb2NrQmVnaW4iLCJibG9ja0VuZCIsImxvb3BCZWdpbiIsImxvb3BFbmQiLCJsb29wT3JkZXJzIiwibmV3T3JkZXIiLCJhcmdsaXN0Iiwic2hhcGVBcmdzIiwiemVyb3MiLCJvZmZfYXJnIiwiaW5pdF9zdHJpbmciLCJvZmZzZXQiLCJ0aGlzVmFycyIsImNvbmNhdCIsImRlYnVnIiwiY29uc29sZSIsImxvZyIsImxvb3BOYW1lIiwiZnVuY05hbWUiLCJmIiwiRnVuY3Rpb24iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cwise-compiler/lib/compile.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cwise-compiler/lib/thunk.js":
/*!**************************************************!*\
  !*** ./node_modules/cwise-compiler/lib/thunk.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// The function below is called when constructing a cwise function object, and does the following:\n// A function object is constructed which accepts as argument a compilation function and returns another function.\n// It is this other function that is eventually returned by createThunk, and this function is the one that actually\n// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.\n// The compilation passed to the first function object is used for compiling new functions.\n// Once this function object is created, it is called with compile as argument, where the first argument of compile\n// is bound to \"proc\" (essentially containing a preprocessed version of the user arguments to cwise).\n// So createThunk roughly works like this:\n// function createThunk(proc) {\n//   var thunk = function(compileBound) {\n//     var CACHED = {}\n//     return function(arrays and scalars) {\n//       if (dtype and order of arrays in CACHED) {\n//         var func = CACHED[dtype and order of arrays]\n//       } else {\n//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)\n//       }\n//       return func(arrays and scalars)\n//     }\n//   }\n//   return thunk(compile.bind1(proc))\n// }\nvar compile = __webpack_require__(/*! ./compile.js */ \"(ssr)/./node_modules/cwise-compiler/lib/compile.js\");\nfunction createThunk(proc) {\n    var code = [\n        \"'use strict'\",\n        \"var CACHED={}\"\n    ];\n    var vars = [];\n    var thunkName = proc.funcName + \"_cwise_thunk\";\n    //Build thunk\n    code.push([\n        \"return function \",\n        thunkName,\n        \"(\",\n        proc.shimArgs.join(\",\"),\n        \"){\"\n    ].join(\"\"));\n    var typesig = [];\n    var string_typesig = [];\n    var proc_args = [\n        [\n            \"array\",\n            proc.arrayArgs[0],\n            \".shape.slice(\",\n            Math.max(0, proc.arrayBlockIndices[0]),\n            proc.arrayBlockIndices[0] < 0 ? \",\" + proc.arrayBlockIndices[0] + \")\" : \")\"\n        ].join(\"\")\n    ];\n    var shapeLengthConditions = [], shapeConditions = [];\n    // Process array arguments\n    for(var i = 0; i < proc.arrayArgs.length; ++i){\n        var j = proc.arrayArgs[i];\n        vars.push([\n            \"t\",\n            j,\n            \"=array\",\n            j,\n            \".dtype,\",\n            \"r\",\n            j,\n            \"=array\",\n            j,\n            \".order\"\n        ].join(\"\"));\n        typesig.push(\"t\" + j);\n        typesig.push(\"r\" + j);\n        string_typesig.push(\"t\" + j);\n        string_typesig.push(\"r\" + j + \".join()\");\n        proc_args.push(\"array\" + j + \".data\");\n        proc_args.push(\"array\" + j + \".stride\");\n        proc_args.push(\"array\" + j + \".offset|0\");\n        if (i > 0) {\n            shapeLengthConditions.push(\"array\" + proc.arrayArgs[0] + \".shape.length===array\" + j + \".shape.length+\" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));\n            shapeConditions.push(\"array\" + proc.arrayArgs[0] + \".shape[shapeIndex+\" + Math.max(0, proc.arrayBlockIndices[0]) + \"]===array\" + j + \".shape[shapeIndex+\" + Math.max(0, proc.arrayBlockIndices[i]) + \"]\");\n        }\n    }\n    // Check for shape equality\n    if (proc.arrayArgs.length > 1) {\n        code.push(\"if (!(\" + shapeLengthConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same dimensionality!')\");\n        code.push(\"for(var shapeIndex=array\" + proc.arrayArgs[0] + \".shape.length-\" + Math.abs(proc.arrayBlockIndices[0]) + \"; shapeIndex-->0;) {\");\n        code.push(\"if (!(\" + shapeConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same shape!')\");\n        code.push(\"}\");\n    }\n    // Process scalar arguments\n    for(var i = 0; i < proc.scalarArgs.length; ++i){\n        proc_args.push(\"scalar\" + proc.scalarArgs[i]);\n    }\n    // Check for cached function (and if not present, generate it)\n    vars.push([\n        \"type=[\",\n        string_typesig.join(\",\"),\n        \"].join()\"\n    ].join(\"\"));\n    vars.push(\"proc=CACHED[type]\");\n    code.push(\"var \" + vars.join(\",\"));\n    code.push([\n        \"if(!proc){\",\n        \"CACHED[type]=proc=compile([\",\n        typesig.join(\",\"),\n        \"])}\",\n        \"return proc(\",\n        proc_args.join(\",\"),\n        \")}\"\n    ].join(\"\"));\n    if (proc.debug) {\n        console.log(\"-----Generated thunk:\\n\" + code.join(\"\\n\") + \"\\n----------\");\n    }\n    //Compile thunk\n    var thunk = new Function(\"compile\", code.join(\"\\n\"));\n    return thunk(compile.bind(undefined, proc));\n}\nmodule.exports = createThunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL3RodW5rLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsa0dBQWtHO0FBQ2xHLGtIQUFrSDtBQUNsSCxtSEFBbUg7QUFDbkgsK0dBQStHO0FBQy9HLDJGQUEyRjtBQUMzRixtSEFBbUg7QUFDbkgscUdBQXFHO0FBQ3JHLDBDQUEwQztBQUMxQywrQkFBK0I7QUFDL0IseUNBQXlDO0FBQ3pDLHNCQUFzQjtBQUN0Qiw0Q0FBNEM7QUFDNUMsbURBQW1EO0FBQ25ELHVEQUF1RDtBQUN2RCxpQkFBaUI7QUFDakIsaUdBQWlHO0FBQ2pHLFVBQVU7QUFDVix3Q0FBd0M7QUFDeEMsUUFBUTtBQUNSLE1BQU07QUFDTixzQ0FBc0M7QUFDdEMsSUFBSTtBQUVKLElBQUlBLFVBQVVDLG1CQUFPQSxDQUFDLHdFQUFjO0FBRXBDLFNBQVNDLFlBQVlDLElBQUk7SUFDdkIsSUFBSUMsT0FBTztRQUFDO1FBQWdCO0tBQWdCO0lBQzVDLElBQUlDLE9BQU8sRUFBRTtJQUNiLElBQUlDLFlBQVlILEtBQUtJLFFBQVEsR0FBRztJQUVoQyxhQUFhO0lBQ2JILEtBQUtJLElBQUksQ0FBQztRQUFDO1FBQW9CRjtRQUFXO1FBQUtILEtBQUtNLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDO1FBQU07S0FBSyxDQUFDQSxJQUFJLENBQUM7SUFDbkYsSUFBSUMsVUFBVSxFQUFFO0lBQ2hCLElBQUlDLGlCQUFpQixFQUFFO0lBQ3ZCLElBQUlDLFlBQVk7UUFBQztZQUFDO1lBQVFWLEtBQUtXLFNBQVMsQ0FBQyxFQUFFO1lBQUM7WUFDMUJDLEtBQUtDLEdBQUcsQ0FBQyxHQUFFYixLQUFLYyxpQkFBaUIsQ0FBQyxFQUFFO1lBQUVkLEtBQUtjLGlCQUFpQixDQUFDLEVBQUUsR0FBQyxJQUFHLE1BQUlkLEtBQUtjLGlCQUFpQixDQUFDLEVBQUUsR0FBQyxNQUFLO1NBQUksQ0FBQ1AsSUFBSSxDQUFDO0tBQUk7SUFDdEksSUFBSVEsd0JBQXdCLEVB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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb3Bvcy8uL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvdGh1bmsuanM/NjY0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG4vLyBUaGUgZnVuY3Rpb24gYmVsb3cgaXMgY2FsbGVkIHdoZW4gY29uc3RydWN0aW5nIGEgY3dpc2UgZnVuY3Rpb24gb2JqZWN0LCBhbmQgZG9lcyB0aGUgZm9sbG93aW5nOlxuLy8gQSBmdW5jdGlvbiBvYmplY3QgaXMgY29uc3RydWN0ZWQgd2hpY2ggYWNjZXB0cyBhcyBhcmd1bWVudCBhIGNvbXBpbGF0aW9uIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGFub3RoZXIgZnVuY3Rpb24uXG4vLyBJdCBpcyB0aGlzIG90aGVyIGZ1bmN0aW9uIHRoYXQgaXMgZXZlbnR1YWxseSByZXR1cm5lZCBieSBjcmVhdGVUaHVuaywgYW5kIHRoaXMgZnVuY3Rpb24gaXMgdGhlIG9uZSB0aGF0IGFjdHVhbGx5XG4vLyBjaGVja3Mgd2hldGhlciBhIGNlcnRhaW4gcGF0dGVybiBvZiBhcmd1bWVudHMgaGFzIGFscmVhZHkgYmVlbiB1c2VkIGJlZm9yZSBhbmQgY29tcGlsZXMgbmV3IGxvb3BzIGFzIG5lZWRlZC5cbi8vIFRoZSBjb21waWxhdGlvbiBwYXNzZWQgdG8gdGhlIGZpcnN0IGZ1bmN0aW9uIG9iamVjdCBpcyB1c2VkIGZvciBjb21waWxpbmcgbmV3IGZ1bmN0aW9ucy5cbi8vIE9uY2UgdGhpcyBmdW5jdGlvbiBvYmplY3QgaXMgY3JlYXRlZCwgaXQgaXMgY2FsbGVkIHdpdGggY29tcGlsZSBhcyBhcmd1bWVudCwgd2hlcmUgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIGNvbXBpbGVcbi8vIGlzIGJvdW5kIHRvIFwicHJvY1wiIChlc3NlbnRpYWxseSBjb250YWluaW5nIGEgcHJlcHJvY2Vzc2VkIHZlcnNpb24gb2YgdGhlIHVzZXIgYXJndW1lbnRzIHRvIGN3aXNlKS5cbi8vIFNvIGNyZWF0ZVRodW5rIHJvdWdobHkgd29ya3MgbGlrZSB0aGlzOlxuLy8gZnVuY3Rpb24gY3JlYXRlVGh1bmsocHJvYykge1xuLy8gICB2YXIgdGh1bmsgPSBmdW5jdGlvbihjb21waWxlQm91bmQpIHtcbi8vICAgICB2YXIgQ0FDSEVEID0ge31cbi8vICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXlzIGFuZCBzY2FsYXJzKSB7XG4vLyAgICAgICBpZiAoZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5cyBpbiBDQUNIRUQpIHtcbi8vICAgICAgICAgdmFyIGZ1bmMgPSBDQUNIRURbZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5c11cbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIHZhciBmdW5jID0gQ0FDSEVEW2R0eXBlIGFuZCBvcmRlciBvZiBhcnJheXNdID0gY29tcGlsZUJvdW5kKGR0eXBlIGFuZCBvcmRlciBvZiBhcnJheXMpXG4vLyAgICAgICB9XG4vLyAgICAgICByZXR1cm4gZnVuYyhhcnJheXMgYW5kIHNjYWxhcnMpXG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIHJldHVybiB0aHVuayhjb21waWxlLmJpbmQxKHByb2MpKVxuLy8gfVxuXG52YXIgY29tcGlsZSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUuanNcIilcblxuZnVuY3Rpb24gY3JlYXRlVGh1bmsocHJvYykge1xuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiLCBcInZhciBDQUNIRUQ9e31cIl1cbiAgdmFyIHZhcnMgPSBbXVxuICB2YXIgdGh1bmtOYW1lID0gcHJvYy5mdW5jTmFtZSArIFwiX2N3aXNlX3RodW5rXCJcbiAgXG4gIC8vQnVpbGQgdGh1bmtcbiAgY29kZS5wdXNoKFtcInJldHVybiBmdW5jdGlvbiBcIiwgdGh1bmtOYW1lLCBcIihcIiwgcHJvYy5zaGltQXJncy5qb2luKFwiLFwiKSwgXCIpe1wiXS5qb2luKFwiXCIpKVxuICB2YXIgdHlwZXNpZyA9IFtdXG4gIHZhciBzdHJpbmdfdHlwZXNpZyA9IFtdXG4gIHZhciBwcm9jX2FyZ3MgPSBbW1wiYXJyYXlcIixwcm9jLmFycmF5QXJnc1swXSxcIi5zaGFwZS5zbGljZShcIiwgLy8gU2xpY2Ugc2hhcGUgc28gdGhhdCB3ZSBvbmx5IHJldGFpbiB0aGUgc2hhcGUgb3ZlciB3aGljaCB3ZSBpdGVyYXRlICh3aGljaCBnZXRzIHBhc3NlZCB0byB0aGUgY3dpc2Ugb3BlcmF0b3IgYXMgU1MpLlxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgwLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF08MD8oXCIsXCIrcHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXStcIilcIik6XCIpXCJdLmpvaW4oXCJcIildXG4gIHZhciBzaGFwZUxlbmd0aENvbmRpdGlvbnMgPSBbXSwgc2hhcGVDb25kaXRpb25zID0gW11cbiAgLy8gUHJvY2VzcyBhcnJheSBhcmd1bWVudHNcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaiA9IHByb2MuYXJyYXlBcmdzW2ldXG4gICAgdmFycy5wdXNoKFtcInRcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIuZHR5cGUsXCIsXG4gICAgICAgICAgICAgICBcInJcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIub3JkZXJcIl0uam9pbihcIlwiKSlcbiAgICB0eXBlc2lnLnB1c2goXCJ0XCIgKyBqKVxuICAgIHR5cGVzaWcucHVzaChcInJcIiArIGopXG4gICAgc3RyaW5nX3R5cGVzaWcucHVzaChcInRcIitqKVxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJyXCIraitcIi5qb2luKClcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuZGF0YVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5zdHJpZGVcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIub2Zmc2V0fDBcIilcbiAgICBpZiAoaT4wKSB7IC8vIEdhdGhlciBjb25kaXRpb25zIHRvIGNoZWNrIGZvciBzaGFwZSBlcXVhbGl0eSAoaWdub3JpbmcgYmxvY2sgaW5kaWNlcylcbiAgICAgIHNoYXBlTGVuZ3RoQ29uZGl0aW9ucy5wdXNoKFwiYXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGUubGVuZ3RoPT09YXJyYXlcIiArIGogKyBcIi5zaGFwZS5sZW5ndGgrXCIgKyAoTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSktTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkpKVxuICAgICAgc2hhcGVDb25kaXRpb25zLnB1c2goXCJhcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZVtzaGFwZUluZGV4K1wiICsgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSArIFwiXT09PWFycmF5XCIgKyBqICsgXCIuc2hhcGVbc2hhcGVJbmRleCtcIiArIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkgKyBcIl1cIilcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIHNoYXBlIGVxdWFsaXR5XG4gIGlmIChwcm9jLmFycmF5QXJncy5sZW5ndGggPiAxKSB7XG4gICAgY29kZS5wdXNoKFwiaWYgKCEoXCIgKyBzaGFwZUxlbmd0aENvbmRpdGlvbnMuam9pbihcIiAmJiBcIikgKyBcIikpIHRocm93IG5ldyBFcnJvcignY3dpc2U6IEFycmF5cyBkbyBub3QgYWxsIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uYWxpdHkhJylcIilcbiAgICBjb2RlLnB1c2goXCJmb3IodmFyIHNoYXBlSW5kZXg9YXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGUubGVuZ3RoLVwiICsgTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkgKyBcIjsgc2hhcGVJbmRleC0tPjA7KSB7XCIpXG4gICAgY29kZS5wdXNoKFwiaWYgKCEoXCIgKyBzaGFwZUNvbmRpdGlvbnMuam9pbihcIiAmJiBcIikgKyBcIikpIHRocm93IG5ldyBFcnJvcignY3dpc2U6IEFycmF5cyBkbyBub3QgYWxsIGhhdmUgdGhlIHNhbWUgc2hhcGUhJylcIilcbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgLy8gUHJvY2VzcyBzY2FsYXIgYXJndW1lbnRzXG4gIGZvcih2YXIgaT0wOyBpPHByb2Muc2NhbGFyQXJncy5sZW5ndGg7ICsraSkge1xuICAgIHByb2NfYXJncy5wdXNoKFwic2NhbGFyXCIgKyBwcm9jLnNjYWxhckFyZ3NbaV0pXG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNhY2hlZCBmdW5jdGlvbiAoYW5kIGlmIG5vdCBwcmVzZW50LCBnZW5lcmF0ZSBpdClcbiAgdmFycy5wdXNoKFtcInR5cGU9W1wiLCBzdHJpbmdfdHlwZXNpZy5qb2luKFwiLFwiKSwgXCJdLmpvaW4oKVwiXS5qb2luKFwiXCIpKVxuICB2YXJzLnB1c2goXCJwcm9jPUNBQ0hFRFt0eXBlXVwiKVxuICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICBcbiAgY29kZS5wdXNoKFtcImlmKCFwcm9jKXtcIixcbiAgICAgICAgICAgICBcIkNBQ0hFRFt0eXBlXT1wcm9jPWNvbXBpbGUoW1wiLCB0eXBlc2lnLmpvaW4oXCIsXCIpLCBcIl0pfVwiLFxuICAgICAgICAgICAgIFwicmV0dXJuIHByb2MoXCIsIHByb2NfYXJncy5qb2luKFwiLFwiKSwgXCIpfVwiXS5qb2luKFwiXCIpKVxuXG4gIGlmKHByb2MuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZyhcIi0tLS0tR2VuZXJhdGVkIHRodW5rOlxcblwiICsgY29kZS5qb2luKFwiXFxuXCIpICsgXCJcXG4tLS0tLS0tLS0tXCIpXG4gIH1cbiAgXG4gIC8vQ29tcGlsZSB0aHVua1xuICB2YXIgdGh1bmsgPSBuZXcgRnVuY3Rpb24oXCJjb21waWxlXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHRodW5rKGNvbXBpbGUuYmluZCh1bmRlZmluZWQsIHByb2MpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRodW5rXG4iXSwibmFtZXMiOlsiY29tcGlsZSIsInJlcXVpcmUiLCJjcmVhdGVUaHVuayIsInByb2MiLCJjb2RlIiwidmFycyIsInRodW5rTmFtZSIsImZ1bmNOYW1lIiwicHVzaCIsInNoaW1BcmdzIiwiam9pbiIsInR5cGVzaWciLCJzdHJpbmdfdHlwZXNpZyIsInByb2NfYXJncyIsImFycmF5QXJncyIsIk1hdGgiLCJtYXgiLCJhcnJheUJsb2NrSW5kaWNlcyIsInNoYXBlTGVuZ3RoQ29uZGl0aW9ucyIsInNoYXBlQ29uZGl0aW9ucyIsImkiLCJsZW5ndGgiLCJqIiwiYWJzIiwic2NhbGFyQXJncyIsImRlYnVnIiwiY29uc29sZSIsImxvZyIsInRodW5rIiwiRnVuY3Rpb24iLCJiaW5kIiwidW5kZWZpbmVkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cwise-compiler/lib/thunk.js\n");

/***/ })

};
;